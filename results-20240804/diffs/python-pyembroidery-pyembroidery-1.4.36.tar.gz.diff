Source package : python-pyembroidery
File name       : pyembroidery-1.4.36.tar.gz
Lookaside URL   : https://src.fedoraproject.org/repo/pkgs/python-pyembroidery/pyembroidery-1.4.36.tar.gz/sha512/7a4944a06c6b4d6f758da9185e78003b15b6aecb1f8a7b4d136e30c323c7d2900a1fb17bb5393ab68a27ab2d6a780a5f8e37b358f39852adc47f552eca28d7a4/pyembroidery-1.4.36.tar.gz
Source URL      : https://github.com/EmbroidePy/pyembroidery/archive/1.4.36/pyembroidery-1.4.36.tar.gz

source file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/source-pyembroidery-1.4.36.tar.gz: gzip compressed data, from Unix, original size modulo 2^32 624640
lookaside file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/lookaside-pyembroidery-1.4.36.tar.gz: gzip compressed data, was "dist\pyembroidery-1.4.36.tar", last modified: Tue Apr 26 13:52:55 2022, max compression, original size modulo 2^32 849920


Only in source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: LICENSE
Only in lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: PKG-INFO
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/EmbPattern.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/EmbPattern.py
1,1730c1,1730
< import os
< 
< import pyembroidery.A10oReader as A10oReader
< import pyembroidery.A100Reader as A100Reader
< 
< # import pyembroidery.ArtReader as ArtReader
< import pyembroidery.BroReader as BroReader
< import pyembroidery.ColReader as ColReader
< import pyembroidery.ColWriter as ColWriter
< import pyembroidery.CsvReader as CsvReader
< import pyembroidery.CsvWriter as CsvWriter
< import pyembroidery.DatReader as DatReader
< import pyembroidery.DsbReader as DsbReader
< import pyembroidery.DstReader as DstReader
< import pyembroidery.DstWriter as DstWriter
< import pyembroidery.DszReader as DszReader
< import pyembroidery.EdrReader as EdrReader
< import pyembroidery.EdrWriter as EdrWriter
< import pyembroidery.EmdReader as EmdReader
< import pyembroidery.ExpReader as ExpReader
< import pyembroidery.ExpWriter as ExpWriter
< import pyembroidery.ExyReader as ExyReader
< import pyembroidery.FxyReader as FxyReader
< import pyembroidery.GcodeReader as GcodeReader
< import pyembroidery.GcodeWriter as GcodeWriter
< import pyembroidery.GtReader as GtReader
< import pyembroidery.HusReader as HusReader
< import pyembroidery.InbReader as InbReader
< import pyembroidery.InfReader as InfReader
< import pyembroidery.InfWriter as InfWriter
< import pyembroidery.JefReader as JefReader
< import pyembroidery.JefWriter as JefWriter
< import pyembroidery.JpxReader as JpxReader
< import pyembroidery.JsonReader as JsonReader
< import pyembroidery.JsonWriter as JsonWriter
< import pyembroidery.KsmReader as KsmReader
< import pyembroidery.MaxReader as MaxReader
< import pyembroidery.MitReader as MitReader
< import pyembroidery.NewReader as NewReader
< import pyembroidery.PcdReader as PcdReader
< import pyembroidery.PcmReader as PcmReader
< import pyembroidery.PcqReader as PcqReader
< import pyembroidery.PcsReader as PcsReader
< import pyembroidery.PecReader as PecReader
< import pyembroidery.PecWriter as PecWriter
< import pyembroidery.PesReader as PesReader
< import pyembroidery.PesWriter as PesWriter
< import pyembroidery.PhbReader as PhbReader
< import pyembroidery.PhcReader as PhcReader
< import pyembroidery.PmvReader as PmvReader
< import pyembroidery.PmvWriter as PmvWriter
< import pyembroidery.PngWriter as PngWriter
< import pyembroidery.SewReader as SewReader
< import pyembroidery.ShvReader as ShvReader
< import pyembroidery.SpxReader as SpxReader
< import pyembroidery.StcReader as StcReader
< import pyembroidery.StxReader as StxReader
< import pyembroidery.SvgWriter as SvgWriter
< import pyembroidery.TapReader as TapReader
< import pyembroidery.TbfReader as TbfReader
< import pyembroidery.TxtWriter as TxtWriter
< import pyembroidery.U01Reader as U01Reader
< import pyembroidery.U01Writer as U01Writer
< import pyembroidery.Vp3Reader as Vp3Reader
< import pyembroidery.Vp3Writer as Vp3Writer
< import pyembroidery.XxxReader as XxxReader
< import pyembroidery.XxxWriter as XxxWriter
< 
< import pyembroidery.ZhsReader as ZhsReader
< import pyembroidery.ZxyReader as ZxyReader
< 
< from .EmbEncoder import Transcoder as Normalizer
< from .EmbFunctions import *
< from .EmbThread import EmbThread
< 
< 
< class EmbPattern:
<     def __init__(self, *args, **kwargs):
<         self.stitches = []  # type: list
<         self.threadlist = []  # type: list
<         self.extras = {}  # type: dict
<         # filename, name, category, author, keywords, comments, are typical
<         self._previousX = 0  # type: float
<         self._previousY = 0  # type: float
<         len_args = len(args)
<         if len_args >= 1:
<             arg0 = args[0]
<             if isinstance(arg0, EmbPattern):
<                 self.stitches = arg0.stitches[:]
<                 self.threadlist = arg0.threadlist[:]
<                 self.extras.update(arg0.extras)
<                 self._previousX = arg0._previousX
<                 self._previousY = arg0._previousY
<                 return
<             if len(args) >= 2:
<                 settings = args[1]
<             elif "settings" in kwargs:
<                 settings = kwargs["settings"]
<             else:
<                 settings = kwargs
<             if isinstance(arg0, str):
<                 EmbPattern.static_read(arg0, settings=settings, pattern=self)
< 
<     def __ne__(self, other):
<         return not self.__eq__(other)
< 
<     def __eq__(self, other):
<         if not isinstance(other, EmbPattern):
<             return False
<         if self.stitches != other.stitches:
<             return False
<         if self.threadlist != other.threadlist:
<             return False
<         if self.extras != other.extras:
<             return False
<         return True
< 
<     def __str__(self):
<         if "name" in self.extras:
<             return "EmbPattern %s (commands: %3d, threads: %3d)" % (
<                 self.extras["name"],
<                 len(self.stitches),
<                 len(self.threadlist),
<             )
<         return "EmbPattern (commands: %3d, threads: %3d)" % (
<             len(self.stitches),
<             len(self.threadlist),
<         )
< 
<     def __len__(self):
<         return len(self.stitches)
< 
<     def __getitem__(self, item):
<         if isinstance(item, str):
<             return self.extras[item]
<         return self.stitches[item]
< 
<     def __setitem__(self, key, value):
<         if isinstance(key, str):
<             self.extras[key] = value
<         else:
<             self.stitches[key] = value
< 
<     def __copy__(self):
<         return self.copy()
< 
<     def __deepcopy__(self):
<         return self.copy()
< 
<     def __iadd__(self, other):
<         if isinstance(other, EmbPattern):
<             self.add_pattern(other)
<         elif isinstance(other, EmbThread) or isinstance(other, str):
<             self.add_thread(other)
<             for i in range(0, len(self.stitches)):
<                 data = self.stitches[i][2] & COMMAND_MASK
<                 if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
<                     self.color_change()
<                     break  # Only add color change if stitching exists.
<         elif isinstance(other, int):
<             self.add_command(other)
<         elif isinstance(other, list) or isinstance(other, tuple):  # tuple or list
<             if len(other) == 0:
<                 return
<             v = other[0]
<             if isinstance(v, list) or isinstance(
<                 v, tuple
<             ):  # tuple or list of tuple or lists
<                 for v in other:
<                     x = v[0]
<                     y = v[1]
<                     try:
<                         cmd = v[2]
<                     except IndexError:
<                         cmd = STITCH
<                     self.add_stitch_absolute(cmd, x, y)
<             elif isinstance(v, complex):  # tuple or list of complex
<                 for v in other:
<                     x = v.real
<                     y = v.imag
<                     self.add_stitch_absolute(STITCH, x, y)
<             elif isinstance(v, int) or isinstance(
<                 v, float
<             ):  # tuple or list of numbers.
<                 i = 0
<                 ie = len(other)
<                 while i < ie:
<                     self.add_stitch_absolute(STITCH, other[i], other[i + 1])
<                     i += 2
<             elif isinstance(v, str):
<                 self.extras[v] = other[1]
<         else:
<             raise ValueError()
<         return self
< 
<     def __add__(self, other):
<         p = self.copy()
<         p.add_pattern(other)
<         return p
< 
<     def __radd__(self, other):
<         p = other.copy()
<         p.add_pattern(self)
<         return p
< 
<     def copy(self):
<         emb_pattern = EmbPattern()
<         emb_pattern.stitches = self.stitches[:]
<         emb_pattern.threadlist = self.threadlist[:]
<         emb_pattern.extras.update(self.extras)
<         emb_pattern._previousX = self._previousX
<         emb_pattern._previousY = self._previousY
<         return emb_pattern
< 
<     def clear(self):
<         self.stitches = []
<         self.threadlist = []
<         self.extras = {}
<         self._previousX = 0
<         self._previousY = 0
< 
<     def read(self, filename, **settings):
<         EmbPattern.static_read(filename, settings=settings, pattern=self)
< 
<     def write(self, filename, **settings):
<         EmbPattern.static_write(self, filename, settings=settings)
< 
<     def move(self, dx=0, dy=0, position=None):
<         """Move dx, dy"""
<         if position is None:
<             self.add_stitch_relative(JUMP, dx, dy)
<         else:
<             self.insert_stitch_relative(position, JUMP, dx, dy)
< 
<     def move_abs(self, x, y, position=None):
<         """Move absolute x, y"""
<         if position is None:
<             self.add_stitch_absolute(JUMP, x, y)
<         else:
<             self.insert(position, JUMP, x, y)
< 
<     def stitch(self, dx=0, dy=0, position=None):
<         """Stitch dx, dy"""
<         if position is None:
<             self.add_stitch_relative(STITCH, dx, dy)
<         else:
<             self.insert_stitch_relative(position, STITCH, dx, dy)
< 
<     def stitch_abs(self, x, y, position=None):
<         """Stitch absolute x, y"""
<         if position is None:
<             self.add_stitch_absolute(STITCH, x, y)
<         else:
<             self.insert(position, STITCH, x, y)
< 
<     def stop(self, dx=0, dy=0, position=None):
<         """Stop dx, dy"""
<         if position is None:
<             self.add_stitch_relative(STOP, dx, dy)
<         else:
<             self.insert_stitch_relative(position, STOP, dx, dy)
< 
<     def trim(self, dx=0, dy=0, position=None):
<         """Trim dx, dy"""
<         if position is None:
<             self.add_stitch_relative(TRIM, dx, dy)
<         else:
<             self.insert_stitch_relative(position, TRIM, dx, dy)
< 
<     def color_change(self, dx=0, dy=0, position=None):
<         """Color Change dx, dy"""
<         if position is None:
<             self.add_stitch_relative(COLOR_CHANGE, dx, dy)
<         else:
<             self.insert_stitch_relative(position, COLOR_CHANGE, dx, dy)
< 
<     def needle_change(self, needle=0, dx=0, dy=0, position=None):
<         """Needle change, needle, dx, dy"""
<         cmd = encode_thread_change(NEEDLE_SET, None, needle)
<         if position is None:
<             self.add_stitch_relative(cmd, dx, dy)
<         else:
<             self.insert_stitch_relative(position, cmd, dx, dy)
< 
<     def sequin_eject(self, dx=0, dy=0, position=None):
<         """Eject Sequin dx, dy"""
<         if position is None:
<             self.add_stitch_relative(SEQUIN_EJECT, dx, dy)
<         else:
<             self.insert_stitch_relative(position, SEQUIN_EJECT, dx, dy)
< 
<     def sequin_mode(self, dx=0, dy=0, position=None):
<         """Eject Sequin dx, dy"""
<         if position is None:
<             self.add_stitch_relative(SEQUIN_MODE, dx, dy)
<         else:
<             self.insert_stitch_relative(position, SEQUIN_MODE, dx, dy)
< 
<     def end(self, dx=0, dy=0, position=None):
<         """End Design dx, dy"""
<         if position is None:
<             self.add_stitch_relative(END, dx, dy)
<         else:
<             self.insert_stitch_relative(position, END, dx, dy)
< 
<     def add_thread(self, thread):
<         """Adds thread to design.
<         Note: this has no effect on stitching and can be done at any point."""
<         if isinstance(thread, EmbThread):
<             self.threadlist.append(thread)
<         else:
<             thread_object = EmbThread()
<             thread_object.set(thread)
<             self.threadlist.append(thread_object)
< 
<     def metadata(self, name, data):
<         """Adds select metadata to design.
<         Note: this has no effect on stitching and can be done at any point."""
<         self.extras[name] = data
< 
<     def get_metadata(self, name, default=None):
<         return self.extras.get(name, default)
< 
<     def bounds(self):
<         """Returns the bounds of the stitch data:
<         min_x, min_y, max_x, max_y"""
<         min_x = float("inf")
<         min_y = float("inf")
<         max_x = -float("inf")
<         max_y = -float("inf")
< 
<         for stitch in self.stitches:
<             if stitch[0] > max_x:
<                 max_x = stitch[0]
<             if stitch[0] < min_x:
<                 min_x = stitch[0]
<             if stitch[1] > max_y:
<                 max_y = stitch[1]
<             if stitch[1] < min_y:
<                 min_y = stitch[1]
<         return min_x, min_y, max_x, max_y
< 
<     extends = bounds
<     extents = bounds
< 
<     def count_stitch_commands(self, command):
<         count = 0
<         for stitch in self.stitches:
<             flags = stitch[2] & COMMAND_MASK
<             if flags == command:
<                 count += 1
<         return count
< 
<     def count_color_changes(self):
<         return self.count_stitch_commands(COLOR_CHANGE)
< 
<     def count_needle_sets(self):
<         return self.count_stitch_commands(NEEDLE_SET)
< 
<     def count_stitches(self):
<         return len(self.stitches)
< 
<     def count_threads(self):
<         return len(self.threadlist)
< 
<     @staticmethod
<     def get_random_thread():
<         thread = EmbThread()
<         thread.set("random")
<         thread.description = "Random"
<         return thread
< 
<     def get_thread_or_filler(self, index):
<         if len(self.threadlist) <= index:
<             return self.get_random_thread()
<         else:
<             return self.threadlist[index]
< 
<     def get_thread(self, index):
<         return self.threadlist[index]
< 
<     def get_match_commands(self, command):
<         for stitch in self.stitches:
<             flags = stitch[2] & COMMAND_MASK
<             if flags == command:
<                 yield stitch
< 
<     def get_as_stitchblock(self):
<         stitchblock = []
<         thread = self.get_thread_or_filler(0)
<         thread_index = 1
<         for stitch in self.stitches:
<             flags = stitch[2] & COMMAND_MASK
<             if flags == STITCH:
<                 stitchblock.append(stitch)
<             else:
<                 if len(stitchblock) > 0:
<                     yield (stitchblock, thread)
<                     stitchblock = []
<                 if flags == COLOR_CHANGE:
<                     thread = self.get_thread_or_filler(thread_index)
<                     thread_index += 1
<         if len(stitchblock) > 0:
<             yield (stitchblock, thread)
< 
<     def get_as_command_blocks(self):
<         last_pos = 0
<         last_command = NO_COMMAND
<         for pos, stitch in enumerate(self.stitches):
<             command = stitch[2] & COMMAND_MASK
<             if command == last_command or last_command == NO_COMMAND:
<                 last_command = command
<                 continue
<             last_command = command
<             yield self.stitches[last_pos:pos]
<             last_pos = pos
<         yield self.stitches[last_pos:]
< 
<     def get_as_colorblocks(self):
<         """
<         Returns a generator for colorblocks. Color blocks defined with color_breaks will have
<         the command omitted whereas color blocks delimited with color_change will end with the
<         color_change command, and if delimited with needle_set, the blocks will begin the new
<         color block with the needle_set.
<         """
<         thread_index = 0
<         colorblock_start = 0
< 
<         for pos, stitch in enumerate(self.stitches):
<             command = stitch[2] & COMMAND_MASK
<             if command == COLOR_BREAK:
<                 if colorblock_start != pos:
<                     thread = self.get_thread_or_filler(thread_index)
<                     thread_index += 1
<                     yield self.stitches[colorblock_start:pos], thread
<                 colorblock_start = pos + 1
<                 continue
<             if command == COLOR_CHANGE:
<                 thread = self.get_thread_or_filler(thread_index)
<                 thread_index += 1
<                 yield self.stitches[colorblock_start : pos + 1], thread
<                 colorblock_start = pos + 1
<                 continue
<             if command == NEEDLE_SET and colorblock_start != pos:
<                 thread = self.get_thread_or_filler(thread_index)
<                 thread_index += 1
<                 yield self.stitches[colorblock_start:pos], thread
<                 colorblock_start = pos
<                 continue
< 
<         if colorblock_start != len(self.stitches):
<             thread = self.get_thread_or_filler(thread_index)
<             yield self.stitches[colorblock_start:], thread
< 
<     def get_as_stitches(self):
<         """pos, x, y, command, v1, v2, v3"""
<         for pos, stitch in enumerate(self.stitches):
<             decode = decode_embroidery_command(stitch[2])
<             command = decode[0]
<             thread = decode[1]
<             needle = decode[2]
<             order = decode[3]
<             yield pos, stitch[0], stitch[1], command, thread, needle, order
< 
<     def get_unique_threadlist(self):
<         return set(self.threadlist)
< 
<     def get_singleton_threadlist(self):
<         singleton = []
<         last_thread = None
<         for thread in self.threadlist:
<             if thread != last_thread:
<                 singleton.append(thread)
<             last_thread = thread
<         return singleton
< 
<     def move_center_to_origin(self):
<         extends = self.bounds()
<         cx = round((extends[2] - extends[0]) / 2.0)
<         cy = round((extends[3] - extends[1]) / 2.0)
<         self.translate(-cx, -cy)
< 
<     def translate(self, dx, dy):
<         for stitch in self.stitches:
<             stitch[0] += dx
<             stitch[1] += dy
< 
<     def transform(self, matrix):
<         for stitch in self.stitches:
<             matrix.apply(stitch)
< 
<     def fix_color_count(self):
<         """Ensure that there are threads for all color blocks."""
<         thread_index = 0
<         init_color = True
<         for stitch in self.stitches:
<             data = stitch[2] & COMMAND_MASK
<             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
<                 if init_color:
<                     thread_index += 1
<                     init_color = False
<             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
<                 init_color = True
<         while len(self.threadlist) < thread_index:
<             self.add_thread(self.get_thread_or_filler(len(self.threadlist)))
< 
<     def add_stitch_absolute(self, cmd, x=0, y=0):
<         """Add a command at the absolute location: x, y"""
<         self.stitches.append([x, y, cmd])
<         self._previousX = x
<         self._previousY = y
< 
<     def add_stitch_relative(self, cmd, dx=0, dy=0):
<         """Add a command relative to the previous location"""
<         x = self._previousX + dx
<         y = self._previousY + dy
<         self.add_stitch_absolute(cmd, x, y)
< 
<     def insert_stitch_relative(self, position, cmd, dx=0, dy=0):
<         """Insert a relative stitch into the pattern. The stitch is relative to the stitch before it.
<         If inserting at position 0, it's relative to 0,0. If appending, add is called, updating the positioning.
<         """
<         if position < 0:
<             position += len(self.stitches)  # I need positive positions.
<         if position == 0:
<             self.stitches.insert(0, [dx, dy, cmd])  # started (0,0)
<         elif (
<             position == len(self.stitches) or position is None
<         ):  # This is properly just an add.
<             self.add_stitch_relative(cmd, dx, dy)
<         elif 0 < position < len(self.stitches):
<             p = self.stitches[position - 1]
<             x = p[0] + dx
<             y = p[1] + dy
<             self.stitches.insert(position, [x, y, cmd])
< 
<     def insert(self, position, cmd, x=0, y=0):
<         """Insert a stitch or command"""
<         self.stitches.insert(position, [x, y, cmd])
< 
<     def prepend_command(self, cmd, x=0, y=0):
<         """Prepend a command, without treating parameters as locations"""
<         self.stitches.insert(0, [x, y, cmd])
< 
<     def add_command(self, cmd, x=0, y=0):
<         """Add a command, without treating parameters as locations
<         that require an update"""
<         self.stitches.append([x, y, cmd])
< 
<     def add_block(self, block, thread=None):
<         if thread is not None:
<             self.add_thread(thread)
<         if block is None:
<             return
< 
<         if isinstance(block, list) or isinstance(block, tuple):
<             if len(block) == 0:
<                 return
<             v = block[0]
<             if isinstance(v, list) or isinstance(v, tuple):
<                 for v in block:
<                     x = v[0]
<                     y = v[1]
<                     try:
<                         cmd = v[2]
<                     except IndexError:
<                         cmd = STITCH
<                     self.add_stitch_absolute(cmd, x, y)
<             elif isinstance(v, complex):
<                 for v in block:
<                     x = v.real
<                     y = v.imag
<                     self.add_stitch_absolute(STITCH, x, y)
<             elif isinstance(v, int) or isinstance(v, float):
<                 i = 0
<                 ie = len(block)
<                 while i < ie:
<                     self.add_stitch_absolute(STITCH, block[i], block[i + 1])
<                     i += 2
<         self.add_command(COLOR_BREAK)
< 
<     def add_stitchblock(self, stitchblock):
<         threadlist = self.threadlist
<         block = stitchblock[0]
<         thread = stitchblock[1]
<         if len(threadlist) == 0 or thread is not threadlist[-1]:
<             threadlist.append(thread)
<             self.add_stitch_relative(COLOR_BREAK)
<         else:
<             self.add_stitch_relative(SEQUENCE_BREAK)
< 
<         for stitch in block:
<             try:
<                 self.add_stitch_absolute(stitch.command, stitch.x, stitch.y)
<             except AttributeError:
<                 self.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
< 
<     def add_pattern(self, pattern, dx=None, dy=None, sx=None, sy=None, rotate=None):
<         """
<         add_pattern merges the given pattern with the current pattern. It accounts for some edge conditions but
<         not all of them.
< 
<         If there is an end command on the current pattern, that is removed.
<         If the color ending the current pattern is equal to the color starting the next those color blocks are merged.
<         Any prepended thread change command to the merging pattern is suppressed.
< 
<         :param pattern: pattern to add to current pattern
<         :param dx: position change of the added pattern x
<         :param dy: position change of the added pattern y
<         :param sx: scale of the added pattern x
<         :param sy: scale of the added pattern y
<         :param rotate: rotation of the added pattern
<         :return:
<         """
<         if isinstance(pattern, str):
<             pattern = EmbPattern(pattern)
<         if self.stitches[-1][2] == END:
<             self.stitches = self.stitches[:-1]  # Remove END, if exists
<         if dx is not None or dy is not None:
<             if dx is None:
<                 dx = 0
<             if dy is None:
<                 dy = 0
<             self.add_command(MATRIX_TRANSLATE, dx, dy)
<         if sx is not None or sx is not None:
<             if sx is None:
<                 sx = sy
<             if sy is None:
<                 sy = sx
<             self.add_command(MATRIX_SCALE, sx, sy)
<         if rotate is not None:
<             self.add_command(MATRIX_ROTATE, rotate)
<         # Add the new thread only if it's different from the last one
<         self.fix_color_count()
< 
<         if len(pattern.threadlist) > 0:
<             if pattern.threadlist[0] == self.threadlist[-1]:
<                 self.threadlist.extend(pattern.threadlist[1:])
<             else:
<                 self.threadlist.extend(pattern.threadlist)
<                 self.color_change()
<         join_position = len(self.stitches)
<         self.stitches.extend(pattern.stitches)
< 
<         for i in range(join_position, len(self.stitches)):
<             data = self.stitches[i][2] & COMMAND_MASK
<             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
<                 break
<             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
<                 self.stitches[i][2] = NO_COMMAND
<         self.extras.update(pattern.extras)
< 
<     def interpolate_duplicate_color_as_stop(self):
<         """Processes a pattern replacing any duplicate colors in the threadlist as a stop."""
<         thread_index = 0
<         init_color = True
<         last_change = None
<         for position, stitch in enumerate(self.stitches):
<             data = stitch[2] & COMMAND_MASK
<             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
<                 if init_color:
<                     try:
<                         if (
<                             last_change is not None
<                             and thread_index != 0
<                             and self.threadlist[thread_index - 1]
<                             == self.threadlist[thread_index]
<                         ):
<                             del self.threadlist[thread_index]
<                             self.stitches[last_change][2] = STOP
<                         else:
<                             thread_index += 1
<                     except IndexError:  # Non-existant threads cannot double
<                         return
<                     init_color = False
<             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
<                 init_color = True
<                 last_change = position
< 
<     def interpolate_stop_as_duplicate_color(self, thread_change_command=COLOR_CHANGE):
<         """Processes a pattern replacing any stop as a duplicate color, and color_change
<         or another specified thread_change_command"""
<         thread_index = 0
<         for position, stitch in enumerate(self.stitches):
<             data = stitch[2] & COMMAND_MASK
<             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
<                 continue
<             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
<                 thread_index += 1
<             elif data == STOP:
<                 try:
<                     self.threadlist.insert(thread_index, self.threadlist[thread_index])
<                     self.stitches[position][2] = thread_change_command
<                     thread_index += 1
<                 except IndexError:  # There are no colors to duplicate
<                     return
< 
<     def interpolate_frame_eject(self):
<         """Processes a pattern replacing jump-stop-jump/jump-stop-end sequences with FRAME_EJECT."""
<         mode = 0
<         stop_x = None
<         stop_y = None
<         sequence_start_position = None
<         position = 0
<         ie = len(self.stitches)
<         while position < ie:
<             stitch = self.stitches[position]
<             data = stitch[2] & COMMAND_MASK
<             if (
<                 data == STITCH
<                 or data == SEW_TO
<                 or data == NEEDLE_AT
<                 or data == COLOR_CHANGE
<                 or data == COLOR_BREAK
<                 or data == NEEDLE_SET
<             ):
<                 if mode == 3:
<                     del self.stitches[sequence_start_position:position]
<                     position = sequence_start_position
<                     self.stitches.insert(position, [stop_x, stop_y, FRAME_EJECT])
<                     ie = len(self.stitches)
<                 mode = 0
<             elif data == JUMP:
<                 if mode == 2:
<                     mode = 3
<                 if mode == 0:
<                     sequence_start_position = position
<                     mode = 1
<             elif data == STOP:
<                 if mode == 1:
<                     mode = 2
<                     stop_x = stitch[0]
<                     stop_y = stitch[1]
<             position += 1
<         if mode >= 2:  # Frame_eject at end.
<             del self.stitches[sequence_start_position:position]
<             position = sequence_start_position
<             self.stitches.insert(position, [stop_x, stop_y, FRAME_EJECT])
< 
<     def interpolate_trims(
<         self, jumps_to_require_trim=None, distance_to_require_trim=None, clipping=True
<     ):
<         """Processes a pattern adding trims according to the given criteria."""
<         i = -1
<         ie = len(self.stitches) - 1
< 
<         x = 0
<         y = 0
<         jump_count = 0
<         jump_start = 0
<         jump_dx = 0
<         jump_dy = 0
<         jumping = False
<         trimmed = True
<         while i < ie:
<             i += 1
<             stitch = self.stitches[i]
<             dx = stitch[0] - x
<             dy = stitch[1] - y
<             x = stitch[0]
<             y = stitch[1]
<             command = stitch[2] & COMMAND_MASK
<             if command == STITCH or command == SEQUIN_EJECT:
<                 trimmed = False
<                 jumping = False
<             elif command == COLOR_CHANGE or command == NEEDLE_SET or command == TRIM:
<                 trimmed = True
<                 jumping = False
<             if command == JUMP:
<                 if not jumping:
<                     jump_dx = 0
<                     jump_dy = 0
<                     jump_count = 0
<                     jump_start = i
<                     jumping = True
<                 jump_count += 1
<                 jump_dx += dx
<                 jump_dy += dy
<                 if not trimmed:
<                     if (
<                         jump_count == jumps_to_require_trim
<                         or distance_to_require_trim is not None
<                         and (
<                             abs(jump_dy) > distance_to_require_trim
<                             or abs(jump_dx) > distance_to_require_trim
<                         )
<                     ):
<                         self.trim(position=jump_start)
<                         jump_start += 1  # We inserted a position, start jump has moved.
<                         i += 1
<                         ie += 1
<                         trimmed = True
<                 if (
<                     clipping and jump_dx == 0 and jump_dy == 0
<                 ):  # jump displacement is 0, clip trim command.
<                     del self.stitches[jump_start : i + 1]
<                     i = jump_start - 1
<                     ie = len(self.stitches) - 1
< 
<     def get_pattern_interpolate_trim(self, jumps_to_require_trim):
<         """Gets a processed pattern with untrimmed jumps merged
<         and trims added if merged jumps are beyond the given value.
<         The expectation is that it has core commands and not
<         middle-level commands"""
<         new_pattern = EmbPattern()
<         i = -1
<         ie = len(self.stitches) - 1
<         count = 0
<         trimmed = True
<         while i < ie:
<             i += 1
<             stitch = self.stitches[i]
<             command = stitch[2] & COMMAND_MASK
<             if command == STITCH or command == SEQUIN_EJECT:
<                 trimmed = False
<             elif command == COLOR_CHANGE or command == NEEDLE_SET or command == TRIM:
<                 trimmed = True
<             if trimmed or stitch[2] != JUMP:
<                 new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
<                 continue
<             while i < ie and command == JUMP:
<                 i += 1
<                 stitch = self.stitches[i]
<                 command = stitch[2]
<                 count += 1
<             if command != JUMP:
<                 i -= 1
<             stitch = self.stitches[i]
<             if count >= jumps_to_require_trim:
<                 new_pattern.trim()
<             count = 0
<             new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
<         new_pattern.threadlist.extend(self.threadlist)
<         new_pattern.extras.update(self.extras)
<         return new_pattern
< 
<     def get_pattern_merge_jumps(self):
<         """Returns a pattern with all multiple jumps merged."""
<         new_pattern = EmbPattern()
<         i = -1
<         ie = len(self.stitches) - 1
<         stitch_break = False
<         while i < ie:
<             i += 1
<             stitch = self.stitches[i]
<             command = stitch[2] & COMMAND_MASK
<             if command == JUMP:
<                 if stitch_break:
<                     continue
<                 new_pattern.add_command(STITCH_BREAK)
<                 stitch_break = True
<                 continue
<             new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
<         new_pattern.threadlist.extend(self.threadlist)
<         new_pattern.extras.update(self.extras)
<         return new_pattern
< 
<     def get_stable_pattern(self):
<         """Gets a stabilized version of the pattern."""
<         stable_pattern = EmbPattern()
<         for stitchblock in self.get_as_stitchblock():
<             stable_pattern.add_stitchblock(stitchblock)
<         stable_pattern.extras.update(self.extras)
<         return stable_pattern
< 
<     def get_normalized_pattern(self, encode_settings=None):
<         """Encodes pattern typically for saving."""
<         normal_pattern = EmbPattern()
<         transcoder = Normalizer(encode_settings)
<         transcoder.transcode(self, normal_pattern)
<         return normal_pattern
< 
<     def append_translation(self, x, y):
<         """Appends translation to the pattern.
<         All commands will be translated by the given amount,
<         including absolute location commands."""
<         self.add_stitch_relative(MATRIX_TRANSLATE, x, y)
< 
<     @staticmethod
<     def supported_formats():
<         """Generates dictionary entries for supported formats. Each entry will
<         always have description, extension, mimetype, and category. Reader
<         will provide the reader, if one exists, writer will provide the writer,
<         if one exists.
< 
<         Metadata gives a list of metadata read and/or written by that type.
< 
<         Options provides accepted options by the format and their accepted values.
<         """
<         # yield ({
<         #     "description": "Art Embroidery Format",
<         #     "extension": "art",
<         #     "extensions": ("art",),
<         #     "mimetype": "application/x-art",
<         #     "category": "embroidery",
<         #     "reader": ArtReader,
<         #     "metadata": ("name")
<         # })
<         yield (
<             {
<                 "description": "Brother Embroidery Format",
<                 "extension": "pec",
<                 "extensions": ("pec",),
<                 "mimetype": "application/x-pec",
<                 "category": "embroidery",
<                 "reader": PecReader,
<                 "writer": PecWriter,
<                 "metadata": ("name"),
<             }
<         )
<         yield (
<             {
<                 "description": "Brother Embroidery Format",
<                 "extension": "pes",
<                 "extensions": ("pes",),
<                 "mimetype": "application/x-pes",
<                 "category": "embroidery",
<                 "reader": PesReader,
<                 "writer": PesWriter,
<                 "versions": ("1", "6", "1t", "6t"),
<                 "metadata": ("name", "author", "category", "keywords", "comments"),
<             }
<         )
<         yield (
<             {
<                 "description": "Melco Expanded Embroidery Format",
<                 "extension": "exp",
<                 "extensions": ("exp",),
<                 "mimetype": "application/x-exp",
<                 "category": "embroidery",
<                 "reader": ExpReader,
<                 "writer": ExpWriter,
<             }
<         )
<         # yield (
<         #     {
<         #         "description": "Melco Condensed Embroidery Format",
<         #         "extension": "cnd",
<         #         "extensions": ("cnd",),
<         #         "mimetype": "application/x-cnd",
<         #         "category": "embroidery",
<         #         "reader": CndReader,
<         #     }
<         # )
<         yield (
<             {
<                 "description": "Tajima Embroidery Format",
<                 "extension": "dst",
<                 "extensions": ("dst",),
<                 "mimetype": "application/x-dst",
<                 "category": "embroidery",
<                 "reader": DstReader,
<                 "writer": DstWriter,
<                 "read_options": {
<                     "trim_distance": (None, 3.0, 50.0),
<                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
<                     "clipping": (True, False),
<                 },
<                 "write_options": {"trim_at": (2, 3, 4, 5, 6, 7, 8)},
<                 "versions": ("default", "extended"),
<                 "metadata": ("name", "author", "copyright"),
<             }
<         )
<         yield (
<             {
<                 "description": "Janome Embroidery Format",
<                 "extension": "jef",
<                 "extensions": ("jef",),
<                 "mimetype": "application/x-jef",
<                 "category": "embroidery",
<                 "reader": JefReader,
<                 "writer": JefWriter,
<                 "read_options": {
<                     "trim_distance": (None, 3.0, 50.0),
<                     "trims": (True, False),
<                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
<                     "clipping": (True, False),
<                 },
<                 "write_options": {
<                     "trims": (True, False),
<                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
<                 },
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "vp3",
<                 "extensions": ("vp3",),
<                 "mimetype": "application/x-vp3",
<                 "category": "embroidery",
<                 "reader": Vp3Reader,
<                 "writer": Vp3Writer,
<             }
<         )
<         yield (
<             {
<                 "description": "Scalable Vector Graphics",
<                 "extension": "svg",
<                 "extensions": ("svg", "svgz"),
<                 "mimetype": "image/svg+xml",
<                 "category": "vector",
<                 "writer": SvgWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "Comma-separated values",
<                 "extension": "csv",
<                 "extensions": ("csv",),
<                 "mimetype": "text/csv",
<                 "category": "debug",
<                 "reader": CsvReader,
<                 "writer": CsvWriter,
<                 "versions": ("default", "delta", "full"),
<             }
<         )
<         yield (
<             {
<                 "description": "Singer Embroidery Format",
<                 "extension": "xxx",
<                 "extensions": ("xxx",),
<                 "mimetype": "application/x-xxx",
<                 "category": "embroidery",
<                 "reader": XxxReader,
<                 "writer": XxxWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "Janome Embroidery Format",
<                 "extension": "sew",
<                 "extensions": ("sew",),
<                 "mimetype": "application/x-sew",
<                 "category": "embroidery",
<                 "reader": SewReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Barudan Embroidery Format",
<                 "extension": "u01",
<                 "extensions": ("u00", "u01", "u02"),
<                 "mimetype": "application/x-u01",
<                 "category": "embroidery",
<                 "reader": U01Reader,
<                 "writer": U01Writer,
<             }
<         )
<         yield (
<             {
<                 "description": "Husqvarna Viking Embroidery Format",
<                 "extension": "shv",
<                 "extensions": ("shv",),
<                 "mimetype": "application/x-shv",
<                 "category": "embroidery",
<                 "reader": ShvReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Toyota Embroidery Format",
<                 "extension": "10o",
<                 "extensions": ("10o",),
<                 "mimetype": "application/x-10o",
<                 "category": "embroidery",
<                 "reader": A10oReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Toyota Embroidery Format",
<                 "extension": "100",
<                 "extensions": ("100",),
<                 "mimetype": "application/x-100",
<                 "category": "embroidery",
<                 "reader": A100Reader,
<             }
<         )
<         yield (
<             {
<                 "description": "Bits & Volts Embroidery Format",
<                 "extension": "bro",
<                 "extensions": ("bro",),
<                 "mimetype": "application/x-Bro",
<                 "category": "embroidery",
<                 "reader": BroReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Sunstar or Barudan Embroidery Format",
<                 "extension": "dat",
<                 "extensions": ("dat",),
<                 "mimetype": "application/x-dat",
<                 "category": "embroidery",
<                 "reader": DatReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Tajima(Barudan) Embroidery Format",
<                 "extension": "dsb",
<                 "extensions": ("dsb",),
<                 "mimetype": "application/x-dsb",
<                 "category": "embroidery",
<                 "reader": DsbReader,
<             }
<         )
<         yield (
<             {
<                 "description": "ZSK USA Embroidery Format",
<                 "extension": "dsz",
<                 "extensions": ("dsz",),
<                 "mimetype": "application/x-dsz",
<                 "category": "embroidery",
<                 "reader": DszReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Elna Embroidery Format",
<                 "extension": "emd",
<                 "extensions": ("emd",),
<                 "mimetype": "application/x-emd",
<                 "category": "embroidery",
<                 "reader": EmdReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Eltac Embroidery Format",
<                 "extension": "exy",  # e??, e01
<                 "extensions": ("e00", "e01", "e02"),
<                 "mimetype": "application/x-exy",
<                 "category": "embroidery",
<                 "reader": ExyReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Fortron Embroidery Format",
<                 "extension": "fxy",  # f??, f01
<                 "extensions": ("f00", "f01", "f02"),
<                 "mimetype": "application/x-fxy",
<                 "category": "embroidery",
<                 "reader": FxyReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Gold Thread Embroidery Format",
<                 "extension": "gt",
<                 "extensions": ("gt",),
<                 "mimetype": "application/x-exy",
<                 "category": "embroidery",
<                 "reader": GtReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Inbro Embroidery Format",
<                 "extension": "inb",
<                 "extensions": ("inb",),
<                 "mimetype": "application/x-inb",
<                 "category": "embroidery",
<                 "reader": InbReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Tajima Embroidery Format",
<                 "extension": "tbf",
<                 "extensions": ("tbf",),
<                 "mimetype": "application/x-tbf",
<                 "category": "embroidery",
<                 "reader": TbfReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "ksm",
<                 "extensions": ("ksm",),
<                 "mimetype": "application/x-ksm",
<                 "category": "embroidery",
<                 "reader": KsmReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Happy Embroidery Format",
<                 "extension": "tap",
<                 "extensions": ("tap",),
<                 "mimetype": "application/x-tap",
<                 "category": "embroidery",
<                 "reader": TapReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "spx",
<                 "extensions": ("spx"),
<                 "mimetype": "application/x-spx",
<                 "category": "embroidery",
<                 "reader": SpxReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Data Stitch Embroidery Format",
<                 "extension": "stx",
<                 "extensions": ("stx",),
<                 "mimetype": "application/x-stx",
<                 "category": "embroidery",
<                 "reader": StxReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Brother Embroidery Format",
<                 "extension": "phb",
<                 "extensions": ("phb",),
<                 "mimetype": "application/x-phb",
<                 "category": "embroidery",
<                 "reader": PhbReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Brother Embroidery Format",
<                 "extension": "phc",
<                 "extensions": ("phc",),
<                 "mimetype": "application/x-phc",
<                 "category": "embroidery",
<                 "reader": PhcReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Ameco Embroidery Format",
<                 "extension": "new",
<                 "extensions": ("new",),
<                 "mimetype": "application/x-new",
<                 "category": "embroidery",
<                 "reader": NewReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "max",
<                 "extensions": ("max",),
<                 "mimetype": "application/x-max",
<                 "category": "embroidery",
<                 "reader": MaxReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Mitsubishi Embroidery Format",
<                 "extension": "mit",
<                 "extensions": ("mit",),
<                 "mimetype": "application/x-mit",
<                 "category": "embroidery",
<                 "reader": MitReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "pcd",
<                 "extensions": ("pcd",),
<                 "mimetype": "application/x-pcd",
<                 "category": "embroidery",
<                 "reader": PcdReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "pcq",
<                 "extensions": ("pcq",),
<                 "mimetype": "application/x-pcq",
<                 "category": "embroidery",
<                 "reader": PcqReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "pcm",
<                 "extensions": ("pcm",),
<                 "mimetype": "application/x-pcm",
<                 "category": "embroidery",
<                 "reader": PcmReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Pfaff Embroidery Format",
<                 "extension": "pcs",
<                 "extensions": ("pcs",),
<                 "mimetype": "application/x-pcs",
<                 "category": "embroidery",
<                 "reader": PcsReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Janome Embroidery Format",
<                 "extension": "jpx",
<                 "extensions": ("jpx",),
<                 "mimetype": "application/x-jpx",
<                 "category": "embroidery",
<                 "reader": JpxReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Gunold Embroidery Format",
<                 "extension": "stc",
<                 "extensions": ("stc",),
<                 "mimetype": "application/x-stc",
<                 "category": "embroidery",
<                 "reader": StcReader,
<             }
<         )
<         yield ({
<             "description": "Zeng Hsing Embroidery Format",
<             "extension": "zhs",
<             "extensions": ("zhs",),
<             "mimetype": "application/x-zhs",
<             "category": "embroidery",
<             "reader": ZhsReader
<         })
<         yield (
<             {
<                 "description": "ZSK TC Embroidery Format",
<                 "extension": "zxy",
<                 "extensions": ("z00", "z01", "z02"),
<                 "mimetype": "application/x-zxy",
<                 "category": "embroidery",
<                 "reader": ZxyReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Brother Stitch Format",
<                 "extension": "pmv",
<                 "extensions": ("pmv",),
<                 "mimetype": "application/x-pmv",
<                 "category": "stitch",
<                 "reader": PmvReader,
<                 "writer": PmvWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "PNG Format, Portable Network Graphics",
<                 "extension": "png",
<                 "extensions": ("png",),
<                 "mimetype": "image/png",
<                 "category": "image",
<                 "writer": PngWriter,
<                 "write_options": {
<                     "background": (0x000000, 0xFFFFFF),
<                     "linewidth": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
<                 },
<             }
<         )
<         yield (
<             {
<                 "description": "txt Format, Text File",
<                 "extension": "txt",
<                 "extensions": ("txt",),
<                 "mimetype": "text/plain",
<                 "category": "debug",
<                 "writer": TxtWriter,
<                 "versions": ("default", "embroidermodder"),
<             }
<         )
<         yield (
<             {
<                 "description": "gcode Format, Text File",
<                 "extension": "gcode",
<                 "extensions": ("gcode", "g-code", "ngc", "nc", ".g"),
<                 "mimetype": "text/plain",
<                 "category": "embroidery",
<                 "reader": GcodeReader,
<                 "writer": GcodeWriter,
<                 "write_options": {
<                     "stitch_z_travel": (5.0, 10.0),
<                 },
<             }
<         )
<         yield (
<             {
<                 "description": "Husqvarna Embroidery Format",
<                 "extension": "hus",
<                 "extensions": ("hus",),
<                 "mimetype": "application/x-hus",
<                 "category": "embroidery",
<                 "reader": HusReader,
<             }
<         )
<         yield (
<             {
<                 "description": "Edr Color Format",
<                 "extension": "edr",
<                 "extensions": ("edr",),
<                 "mimetype": "application/x-edr",
<                 "category": "color",
<                 "reader": EdrReader,
<                 "writer": EdrWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "Col Color Format",
<                 "extension": "col",
<                 "extensions": ("col",),
<                 "mimetype": "application/x-col",
<                 "category": "color",
<                 "reader": ColReader,
<                 "writer": ColWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "Inf Color Format",
<                 "extension": "inf",
<                 "extensions": ("inf",),
<                 "mimetype": "application/x-inf",
<                 "category": "color",
<                 "reader": InfReader,
<                 "writer": InfWriter,
<             }
<         )
<         yield (
<             {
<                 "description": "Json Export",
<                 "extension": "json",
<                 "extensions": ("json",),
<                 "mimetype": "application/json",
<                 "category": "debug",
<                 "reader": JsonReader,
<                 "writer": JsonWriter,
<             }
<         )
< 
<     @staticmethod
<     def convert(filename_from, filename_to, settings=None):
<         pattern = EmbPattern.static_read(filename_from, settings)
<         if pattern is None:
<             return
<         EmbPattern.static_write(pattern, filename_to, settings)
< 
<     @staticmethod
<     def get_extension_by_filename(filename):
<         """extracts the extension from a filename"""
<         return os.path.splitext(filename)[1][1:]
< 
<     @staticmethod
<     def read_embroidery(reader, f, settings=None, pattern=None):
<         """Reads fileobject or filename with reader."""
<         if reader is None:
<             return None
<         if pattern is None:
<             pattern = EmbPattern()
< 
<         if EmbPattern.is_str(f):
<             text_mode = False
<             try:
<                 text_mode = reader.READ_FILE_IN_TEXT_MODE
<             except AttributeError:
<                 pass
<             if text_mode:
<                 try:
<                     with open(f, "r") as stream:
<                         reader.read(stream, pattern, settings)
<                         stream.close()
<                 except IOError:
<                     pass
<             else:
<                 try:
<                     with open(f, "rb") as stream:
<                         reader.read(stream, pattern, settings)
<                         stream.close()
<                 except IOError:
<                     pass
<         else:
<             reader.read(f, pattern, settings)
<         return pattern
< 
<     @staticmethod
<     def read_dst(f, settings=None, pattern=None):
<         """Reads fileobject as DST file"""
<         return EmbPattern.read_embroidery(DstReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_pec(f, settings=None, pattern=None):
<         """Reads fileobject as PEC file"""
<         return EmbPattern.read_embroidery(PecReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_pes(f, settings=None, pattern=None):
<         """Reads fileobject as PES file"""
<         return EmbPattern.read_embroidery(PesReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_exp(f, settings=None, pattern=None):
<         """Reads fileobject as EXP file"""
<         return EmbPattern.read_embroidery(ExpReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_vp3(f, settings=None, pattern=None):
<         """Reads fileobject as VP3 file"""
<         return EmbPattern.read_embroidery(Vp3Reader, f, settings, pattern)
< 
<     @staticmethod
<     def read_jef(f, settings=None, pattern=None):
<         """Reads fileobject as JEF file"""
<         return EmbPattern.read_embroidery(JefReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_u01(f, settings=None, pattern=None):
<         """Reads fileobject as U01 file"""
<         return EmbPattern.read_embroidery(U01Reader, f, settings, pattern)
< 
<     @staticmethod
<     def read_csv(f, settings=None, pattern=None):
<         """Reads fileobject as CSV file"""
<         return EmbPattern.read_embroidery(CsvReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_gcode(f, settings=None, pattern=None):
<         """Reads fileobject as GCode file"""
<         return EmbPattern.read_embroidery(GcodeReader, f, settings, pattern)
< 
<     @staticmethod
<     def read_xxx(f, settings=None, pattern=None):
<         """Reads fileobject as XXX file"""
<         return EmbPattern.read_embroidery(XxxReader, f, settings, pattern)
< 
<     @staticmethod
<     def static_read(filename, settings=None, pattern=None):
<         """Reads file, assuming type by extension"""
<         extension = EmbPattern.get_extension_by_filename(filename)
<         extension = extension.lower()
<         for file_type in EmbPattern.supported_formats():
<             if file_type["extension"] != extension:
<                 continue
<             reader = file_type.get("reader", None)
<             return EmbPattern.read_embroidery(reader, filename, settings, pattern)
<         return None
< 
<     @staticmethod
<     def write_embroidery(writer, pattern, stream, settings=None):
<         if pattern is None:
<             return
<         if settings is None:
<             settings = {}
<         else:
<             settings = settings.copy()
<         try:
<             encode = writer.ENCODE
<         except AttributeError:
<             encode = True
< 
<         if settings.get("encode", encode):
<             if not ("max_jump" in settings):
<                 try:
<                     settings["max_jump"] = writer.MAX_JUMP_DISTANCE
<                 except AttributeError:
<                     pass
<             if not ("max_stitch" in settings):
<                 try:
<                     settings["max_stitch"] = writer.MAX_STITCH_DISTANCE
<                 except AttributeError:
<                     pass
<             if not ("full_jump" in settings):
<                 try:
<                     settings["full_jump"] = writer.FULL_JUMP
<                 except AttributeError:
<                     pass
<             if not ("round" in settings):
<                 try:
<                     settings["round"] = writer.ROUND
<                 except AttributeError:
<                     pass
<             if not ("writes_speeds" in settings):
<                 try:
<                     settings["writes_speeds"] = writer.WRITES_SPEEDS
<                 except AttributeError:
<                     pass
<             if not ("sequin_contingency" in settings):
<                 try:
<                     settings["sequin_contingency"] = writer.SEQUIN_CONTINGENCY
<                 except AttributeError:
<                     pass
<             if not ("thread_change_command" in settings):
<                 try:
<                     settings["thread_change_command"] = writer.THREAD_CHANGE_COMMAND
<                 except AttributeError:
<                     pass
<             if not ("translate" in settings):
<                 try:
<                     settings["translate"] = writer.TRANSLATE
<                 except AttributeError:
<                     pass
<             if not ("scale" in settings):
<                 try:
<                     settings["scale"] = writer.SCALE
<                 except AttributeError:
<                     pass
<             if not ("rotate" in settings):
<                 try:
<                     settings["rotate"] = writer.ROTATE
<                 except AttributeError:
<                     pass
<             pattern = pattern.get_normalized_pattern(settings)
< 
<         if EmbPattern.is_str(stream):
<             text_mode = False
<             try:
<                 text_mode = writer.WRITE_FILE_IN_TEXT_MODE
<             except AttributeError:
<                 pass
<             if text_mode:
<                 try:
<                     with open(stream, "w") as stream:
<                         writer.write(pattern, stream, settings)
<                 except IOError:
<                     pass
<             else:
<                 try:
<                     with open(stream, "wb") as stream:
<                         writer.write(pattern, stream, settings)
<                 except IOError:
<                     pass
<         else:
<             writer.write(pattern, stream, settings)
< 
<     @staticmethod
<     def write_dst(pattern, stream, settings=None):
<         """Writes fileobject as DST file"""
<         EmbPattern.write_embroidery(DstWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_pec(pattern, stream, settings=None):
<         """Writes fileobject as PEC file"""
<         EmbPattern.write_embroidery(PecWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_pes(pattern, stream, settings=None):
<         """Writes fileobject as PES file"""
<         EmbPattern.write_embroidery(PesWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_exp(pattern, stream, settings=None):
<         """Writes fileobject as EXP file"""
<         EmbPattern.write_embroidery(ExpWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_vp3(pattern, stream, settings=None):
<         """Writes fileobject as Vp3 file"""
<         EmbPattern.write_embroidery(Vp3Writer, pattern, stream, settings)
< 
<     @staticmethod
<     def write_jef(pattern, stream, settings=None):
<         """Writes fileobject as JEF file"""
<         EmbPattern.write_embroidery(JefWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_u01(pattern, stream, settings=None):
<         """Writes fileobject as U01 file"""
<         EmbPattern.write_embroidery(U01Writer, pattern, stream, settings)
< 
<     @staticmethod
<     def write_csv(pattern, stream, settings=None):
<         """Writes fileobject as CSV file"""
<         EmbPattern.write_embroidery(CsvWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_txt(pattern, stream, settings=None):
<         """Writes fileobject as CSV file"""
<         EmbPattern.write_embroidery(TxtWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_gcode(pattern, stream, settings=None):
<         """Writes fileobject as Gcode file"""
<         EmbPattern.write_embroidery(GcodeWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_xxx(pattern, stream, settings=None):
<         """Writes fileobject as XXX file"""
<         EmbPattern.write_embroidery(XxxWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_svg(pattern, stream, settings=None):
<         """Writes fileobject as DST file"""
<         EmbPattern.write_embroidery(SvgWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def write_png(pattern, stream, settings=None):
<         """Writes fileobject as PNG file"""
<         EmbPattern.write_embroidery(PngWriter, pattern, stream, settings)
< 
<     @staticmethod
<     def static_write(pattern, filename, settings=None):
<         """Writes file, assuming type by extension"""
<         extension = EmbPattern.get_extension_by_filename(filename)
<         extension = extension.lower()
< 
<         for file_type in EmbPattern.supported_formats():
<             if file_type["extension"] != extension:
<                 continue
<             writer = file_type.get("writer", None)
<             if writer is None:
<                 continue
<             EmbPattern.write_embroidery(writer, pattern, filename, settings)
< 
<     @staticmethod
<     def is_str(obj):
<         try:
<             return isinstance(obj, basestring)
<         except NameError:
<             return isinstance(obj, str)
---
> import os
> 
> import pyembroidery.A10oReader as A10oReader
> import pyembroidery.A100Reader as A100Reader
> 
> # import pyembroidery.ArtReader as ArtReader
> import pyembroidery.BroReader as BroReader
> import pyembroidery.ColReader as ColReader
> import pyembroidery.ColWriter as ColWriter
> import pyembroidery.CsvReader as CsvReader
> import pyembroidery.CsvWriter as CsvWriter
> import pyembroidery.DatReader as DatReader
> import pyembroidery.DsbReader as DsbReader
> import pyembroidery.DstReader as DstReader
> import pyembroidery.DstWriter as DstWriter
> import pyembroidery.DszReader as DszReader
> import pyembroidery.EdrReader as EdrReader
> import pyembroidery.EdrWriter as EdrWriter
> import pyembroidery.EmdReader as EmdReader
> import pyembroidery.ExpReader as ExpReader
> import pyembroidery.ExpWriter as ExpWriter
> import pyembroidery.ExyReader as ExyReader
> import pyembroidery.FxyReader as FxyReader
> import pyembroidery.GcodeReader as GcodeReader
> import pyembroidery.GcodeWriter as GcodeWriter
> import pyembroidery.GtReader as GtReader
> import pyembroidery.HusReader as HusReader
> import pyembroidery.InbReader as InbReader
> import pyembroidery.InfReader as InfReader
> import pyembroidery.InfWriter as InfWriter
> import pyembroidery.JefReader as JefReader
> import pyembroidery.JefWriter as JefWriter
> import pyembroidery.JpxReader as JpxReader
> import pyembroidery.JsonReader as JsonReader
> import pyembroidery.JsonWriter as JsonWriter
> import pyembroidery.KsmReader as KsmReader
> import pyembroidery.MaxReader as MaxReader
> import pyembroidery.MitReader as MitReader
> import pyembroidery.NewReader as NewReader
> import pyembroidery.PcdReader as PcdReader
> import pyembroidery.PcmReader as PcmReader
> import pyembroidery.PcqReader as PcqReader
> import pyembroidery.PcsReader as PcsReader
> import pyembroidery.PecReader as PecReader
> import pyembroidery.PecWriter as PecWriter
> import pyembroidery.PesReader as PesReader
> import pyembroidery.PesWriter as PesWriter
> import pyembroidery.PhbReader as PhbReader
> import pyembroidery.PhcReader as PhcReader
> import pyembroidery.PmvReader as PmvReader
> import pyembroidery.PmvWriter as PmvWriter
> import pyembroidery.PngWriter as PngWriter
> import pyembroidery.SewReader as SewReader
> import pyembroidery.ShvReader as ShvReader
> import pyembroidery.SpxReader as SpxReader
> import pyembroidery.StcReader as StcReader
> import pyembroidery.StxReader as StxReader
> import pyembroidery.SvgWriter as SvgWriter
> import pyembroidery.TapReader as TapReader
> import pyembroidery.TbfReader as TbfReader
> import pyembroidery.TxtWriter as TxtWriter
> import pyembroidery.U01Reader as U01Reader
> import pyembroidery.U01Writer as U01Writer
> import pyembroidery.Vp3Reader as Vp3Reader
> import pyembroidery.Vp3Writer as Vp3Writer
> import pyembroidery.XxxReader as XxxReader
> import pyembroidery.XxxWriter as XxxWriter
> 
> import pyembroidery.ZhsReader as ZhsReader
> import pyembroidery.ZxyReader as ZxyReader
> 
> from .EmbEncoder import Transcoder as Normalizer
> from .EmbFunctions import *
> from .EmbThread import EmbThread
> 
> 
> class EmbPattern:
>     def __init__(self, *args, **kwargs):
>         self.stitches = []  # type: list
>         self.threadlist = []  # type: list
>         self.extras = {}  # type: dict
>         # filename, name, category, author, keywords, comments, are typical
>         self._previousX = 0  # type: float
>         self._previousY = 0  # type: float
>         len_args = len(args)
>         if len_args >= 1:
>             arg0 = args[0]
>             if isinstance(arg0, EmbPattern):
>                 self.stitches = arg0.stitches[:]
>                 self.threadlist = arg0.threadlist[:]
>                 self.extras.update(arg0.extras)
>                 self._previousX = arg0._previousX
>                 self._previousY = arg0._previousY
>                 return
>             if len(args) >= 2:
>                 settings = args[1]
>             elif "settings" in kwargs:
>                 settings = kwargs["settings"]
>             else:
>                 settings = kwargs
>             if isinstance(arg0, str):
>                 EmbPattern.static_read(arg0, settings=settings, pattern=self)
> 
>     def __ne__(self, other):
>         return not self.__eq__(other)
> 
>     def __eq__(self, other):
>         if not isinstance(other, EmbPattern):
>             return False
>         if self.stitches != other.stitches:
>             return False
>         if self.threadlist != other.threadlist:
>             return False
>         if self.extras != other.extras:
>             return False
>         return True
> 
>     def __str__(self):
>         if "name" in self.extras:
>             return "EmbPattern %s (commands: %3d, threads: %3d)" % (
>                 self.extras["name"],
>                 len(self.stitches),
>                 len(self.threadlist),
>             )
>         return "EmbPattern (commands: %3d, threads: %3d)" % (
>             len(self.stitches),
>             len(self.threadlist),
>         )
> 
>     def __len__(self):
>         return len(self.stitches)
> 
>     def __getitem__(self, item):
>         if isinstance(item, str):
>             return self.extras[item]
>         return self.stitches[item]
> 
>     def __setitem__(self, key, value):
>         if isinstance(key, str):
>             self.extras[key] = value
>         else:
>             self.stitches[key] = value
> 
>     def __copy__(self):
>         return self.copy()
> 
>     def __deepcopy__(self):
>         return self.copy()
> 
>     def __iadd__(self, other):
>         if isinstance(other, EmbPattern):
>             self.add_pattern(other)
>         elif isinstance(other, EmbThread) or isinstance(other, str):
>             self.add_thread(other)
>             for i in range(0, len(self.stitches)):
>                 data = self.stitches[i][2] & COMMAND_MASK
>                 if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
>                     self.color_change()
>                     break  # Only add color change if stitching exists.
>         elif isinstance(other, int):
>             self.add_command(other)
>         elif isinstance(other, list) or isinstance(other, tuple):  # tuple or list
>             if len(other) == 0:
>                 return
>             v = other[0]
>             if isinstance(v, list) or isinstance(
>                 v, tuple
>             ):  # tuple or list of tuple or lists
>                 for v in other:
>                     x = v[0]
>                     y = v[1]
>                     try:
>                         cmd = v[2]
>                     except IndexError:
>                         cmd = STITCH
>                     self.add_stitch_absolute(cmd, x, y)
>             elif isinstance(v, complex):  # tuple or list of complex
>                 for v in other:
>                     x = v.real
>                     y = v.imag
>                     self.add_stitch_absolute(STITCH, x, y)
>             elif isinstance(v, int) or isinstance(
>                 v, float
>             ):  # tuple or list of numbers.
>                 i = 0
>                 ie = len(other)
>                 while i < ie:
>                     self.add_stitch_absolute(STITCH, other[i], other[i + 1])
>                     i += 2
>             elif isinstance(v, str):
>                 self.extras[v] = other[1]
>         else:
>             raise ValueError()
>         return self
> 
>     def __add__(self, other):
>         p = self.copy()
>         p.add_pattern(other)
>         return p
> 
>     def __radd__(self, other):
>         p = other.copy()
>         p.add_pattern(self)
>         return p
> 
>     def copy(self):
>         emb_pattern = EmbPattern()
>         emb_pattern.stitches = self.stitches[:]
>         emb_pattern.threadlist = self.threadlist[:]
>         emb_pattern.extras.update(self.extras)
>         emb_pattern._previousX = self._previousX
>         emb_pattern._previousY = self._previousY
>         return emb_pattern
> 
>     def clear(self):
>         self.stitches = []
>         self.threadlist = []
>         self.extras = {}
>         self._previousX = 0
>         self._previousY = 0
> 
>     def read(self, filename, **settings):
>         EmbPattern.static_read(filename, settings=settings, pattern=self)
> 
>     def write(self, filename, **settings):
>         EmbPattern.static_write(self, filename, settings=settings)
> 
>     def move(self, dx=0, dy=0, position=None):
>         """Move dx, dy"""
>         if position is None:
>             self.add_stitch_relative(JUMP, dx, dy)
>         else:
>             self.insert_stitch_relative(position, JUMP, dx, dy)
> 
>     def move_abs(self, x, y, position=None):
>         """Move absolute x, y"""
>         if position is None:
>             self.add_stitch_absolute(JUMP, x, y)
>         else:
>             self.insert(position, JUMP, x, y)
> 
>     def stitch(self, dx=0, dy=0, position=None):
>         """Stitch dx, dy"""
>         if position is None:
>             self.add_stitch_relative(STITCH, dx, dy)
>         else:
>             self.insert_stitch_relative(position, STITCH, dx, dy)
> 
>     def stitch_abs(self, x, y, position=None):
>         """Stitch absolute x, y"""
>         if position is None:
>             self.add_stitch_absolute(STITCH, x, y)
>         else:
>             self.insert(position, STITCH, x, y)
> 
>     def stop(self, dx=0, dy=0, position=None):
>         """Stop dx, dy"""
>         if position is None:
>             self.add_stitch_relative(STOP, dx, dy)
>         else:
>             self.insert_stitch_relative(position, STOP, dx, dy)
> 
>     def trim(self, dx=0, dy=0, position=None):
>         """Trim dx, dy"""
>         if position is None:
>             self.add_stitch_relative(TRIM, dx, dy)
>         else:
>             self.insert_stitch_relative(position, TRIM, dx, dy)
> 
>     def color_change(self, dx=0, dy=0, position=None):
>         """Color Change dx, dy"""
>         if position is None:
>             self.add_stitch_relative(COLOR_CHANGE, dx, dy)
>         else:
>             self.insert_stitch_relative(position, COLOR_CHANGE, dx, dy)
> 
>     def needle_change(self, needle=0, dx=0, dy=0, position=None):
>         """Needle change, needle, dx, dy"""
>         cmd = encode_thread_change(NEEDLE_SET, None, needle)
>         if position is None:
>             self.add_stitch_relative(cmd, dx, dy)
>         else:
>             self.insert_stitch_relative(position, cmd, dx, dy)
> 
>     def sequin_eject(self, dx=0, dy=0, position=None):
>         """Eject Sequin dx, dy"""
>         if position is None:
>             self.add_stitch_relative(SEQUIN_EJECT, dx, dy)
>         else:
>             self.insert_stitch_relative(position, SEQUIN_EJECT, dx, dy)
> 
>     def sequin_mode(self, dx=0, dy=0, position=None):
>         """Eject Sequin dx, dy"""
>         if position is None:
>             self.add_stitch_relative(SEQUIN_MODE, dx, dy)
>         else:
>             self.insert_stitch_relative(position, SEQUIN_MODE, dx, dy)
> 
>     def end(self, dx=0, dy=0, position=None):
>         """End Design dx, dy"""
>         if position is None:
>             self.add_stitch_relative(END, dx, dy)
>         else:
>             self.insert_stitch_relative(position, END, dx, dy)
> 
>     def add_thread(self, thread):
>         """Adds thread to design.
>         Note: this has no effect on stitching and can be done at any point."""
>         if isinstance(thread, EmbThread):
>             self.threadlist.append(thread)
>         else:
>             thread_object = EmbThread()
>             thread_object.set(thread)
>             self.threadlist.append(thread_object)
> 
>     def metadata(self, name, data):
>         """Adds select metadata to design.
>         Note: this has no effect on stitching and can be done at any point."""
>         self.extras[name] = data
> 
>     def get_metadata(self, name, default=None):
>         return self.extras.get(name, default)
> 
>     def bounds(self):
>         """Returns the bounds of the stitch data:
>         min_x, min_y, max_x, max_y"""
>         min_x = float("inf")
>         min_y = float("inf")
>         max_x = -float("inf")
>         max_y = -float("inf")
> 
>         for stitch in self.stitches:
>             if stitch[0] > max_x:
>                 max_x = stitch[0]
>             if stitch[0] < min_x:
>                 min_x = stitch[0]
>             if stitch[1] > max_y:
>                 max_y = stitch[1]
>             if stitch[1] < min_y:
>                 min_y = stitch[1]
>         return min_x, min_y, max_x, max_y
> 
>     extends = bounds
>     extents = bounds
> 
>     def count_stitch_commands(self, command):
>         count = 0
>         for stitch in self.stitches:
>             flags = stitch[2] & COMMAND_MASK
>             if flags == command:
>                 count += 1
>         return count
> 
>     def count_color_changes(self):
>         return self.count_stitch_commands(COLOR_CHANGE)
> 
>     def count_needle_sets(self):
>         return self.count_stitch_commands(NEEDLE_SET)
> 
>     def count_stitches(self):
>         return len(self.stitches)
> 
>     def count_threads(self):
>         return len(self.threadlist)
> 
>     @staticmethod
>     def get_random_thread():
>         thread = EmbThread()
>         thread.set("random")
>         thread.description = "Random"
>         return thread
> 
>     def get_thread_or_filler(self, index):
>         if len(self.threadlist) <= index:
>             return self.get_random_thread()
>         else:
>             return self.threadlist[index]
> 
>     def get_thread(self, index):
>         return self.threadlist[index]
> 
>     def get_match_commands(self, command):
>         for stitch in self.stitches:
>             flags = stitch[2] & COMMAND_MASK
>             if flags == command:
>                 yield stitch
> 
>     def get_as_stitchblock(self):
>         stitchblock = []
>         thread = self.get_thread_or_filler(0)
>         thread_index = 1
>         for stitch in self.stitches:
>             flags = stitch[2] & COMMAND_MASK
>             if flags == STITCH:
>                 stitchblock.append(stitch)
>             else:
>                 if len(stitchblock) > 0:
>                     yield (stitchblock, thread)
>                     stitchblock = []
>                 if flags == COLOR_CHANGE:
>                     thread = self.get_thread_or_filler(thread_index)
>                     thread_index += 1
>         if len(stitchblock) > 0:
>             yield (stitchblock, thread)
> 
>     def get_as_command_blocks(self):
>         last_pos = 0
>         last_command = NO_COMMAND
>         for pos, stitch in enumerate(self.stitches):
>             command = stitch[2] & COMMAND_MASK
>             if command == last_command or last_command == NO_COMMAND:
>                 last_command = command
>                 continue
>             last_command = command
>             yield self.stitches[last_pos:pos]
>             last_pos = pos
>         yield self.stitches[last_pos:]
> 
>     def get_as_colorblocks(self):
>         """
>         Returns a generator for colorblocks. Color blocks defined with color_breaks will have
>         the command omitted whereas color blocks delimited with color_change will end with the
>         color_change command, and if delimited with needle_set, the blocks will begin the new
>         color block with the needle_set.
>         """
>         thread_index = 0
>         colorblock_start = 0
> 
>         for pos, stitch in enumerate(self.stitches):
>             command = stitch[2] & COMMAND_MASK
>             if command == COLOR_BREAK:
>                 if colorblock_start != pos:
>                     thread = self.get_thread_or_filler(thread_index)
>                     thread_index += 1
>                     yield self.stitches[colorblock_start:pos], thread
>                 colorblock_start = pos + 1
>                 continue
>             if command == COLOR_CHANGE:
>                 thread = self.get_thread_or_filler(thread_index)
>                 thread_index += 1
>                 yield self.stitches[colorblock_start : pos + 1], thread
>                 colorblock_start = pos + 1
>                 continue
>             if command == NEEDLE_SET and colorblock_start != pos:
>                 thread = self.get_thread_or_filler(thread_index)
>                 thread_index += 1
>                 yield self.stitches[colorblock_start:pos], thread
>                 colorblock_start = pos
>                 continue
> 
>         if colorblock_start != len(self.stitches):
>             thread = self.get_thread_or_filler(thread_index)
>             yield self.stitches[colorblock_start:], thread
> 
>     def get_as_stitches(self):
>         """pos, x, y, command, v1, v2, v3"""
>         for pos, stitch in enumerate(self.stitches):
>             decode = decode_embroidery_command(stitch[2])
>             command = decode[0]
>             thread = decode[1]
>             needle = decode[2]
>             order = decode[3]
>             yield pos, stitch[0], stitch[1], command, thread, needle, order
> 
>     def get_unique_threadlist(self):
>         return set(self.threadlist)
> 
>     def get_singleton_threadlist(self):
>         singleton = []
>         last_thread = None
>         for thread in self.threadlist:
>             if thread != last_thread:
>                 singleton.append(thread)
>             last_thread = thread
>         return singleton
> 
>     def move_center_to_origin(self):
>         extends = self.bounds()
>         cx = round((extends[2] - extends[0]) / 2.0)
>         cy = round((extends[3] - extends[1]) / 2.0)
>         self.translate(-cx, -cy)
> 
>     def translate(self, dx, dy):
>         for stitch in self.stitches:
>             stitch[0] += dx
>             stitch[1] += dy
> 
>     def transform(self, matrix):
>         for stitch in self.stitches:
>             matrix.apply(stitch)
> 
>     def fix_color_count(self):
>         """Ensure that there are threads for all color blocks."""
>         thread_index = 0
>         init_color = True
>         for stitch in self.stitches:
>             data = stitch[2] & COMMAND_MASK
>             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
>                 if init_color:
>                     thread_index += 1
>                     init_color = False
>             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
>                 init_color = True
>         while len(self.threadlist) < thread_index:
>             self.add_thread(self.get_thread_or_filler(len(self.threadlist)))
> 
>     def add_stitch_absolute(self, cmd, x=0, y=0):
>         """Add a command at the absolute location: x, y"""
>         self.stitches.append([x, y, cmd])
>         self._previousX = x
>         self._previousY = y
> 
>     def add_stitch_relative(self, cmd, dx=0, dy=0):
>         """Add a command relative to the previous location"""
>         x = self._previousX + dx
>         y = self._previousY + dy
>         self.add_stitch_absolute(cmd, x, y)
> 
>     def insert_stitch_relative(self, position, cmd, dx=0, dy=0):
>         """Insert a relative stitch into the pattern. The stitch is relative to the stitch before it.
>         If inserting at position 0, it's relative to 0,0. If appending, add is called, updating the positioning.
>         """
>         if position < 0:
>             position += len(self.stitches)  # I need positive positions.
>         if position == 0:
>             self.stitches.insert(0, [dx, dy, cmd])  # started (0,0)
>         elif (
>             position == len(self.stitches) or position is None
>         ):  # This is properly just an add.
>             self.add_stitch_relative(cmd, dx, dy)
>         elif 0 < position < len(self.stitches):
>             p = self.stitches[position - 1]
>             x = p[0] + dx
>             y = p[1] + dy
>             self.stitches.insert(position, [x, y, cmd])
> 
>     def insert(self, position, cmd, x=0, y=0):
>         """Insert a stitch or command"""
>         self.stitches.insert(position, [x, y, cmd])
> 
>     def prepend_command(self, cmd, x=0, y=0):
>         """Prepend a command, without treating parameters as locations"""
>         self.stitches.insert(0, [x, y, cmd])
> 
>     def add_command(self, cmd, x=0, y=0):
>         """Add a command, without treating parameters as locations
>         that require an update"""
>         self.stitches.append([x, y, cmd])
> 
>     def add_block(self, block, thread=None):
>         if thread is not None:
>             self.add_thread(thread)
>         if block is None:
>             return
> 
>         if isinstance(block, list) or isinstance(block, tuple):
>             if len(block) == 0:
>                 return
>             v = block[0]
>             if isinstance(v, list) or isinstance(v, tuple):
>                 for v in block:
>                     x = v[0]
>                     y = v[1]
>                     try:
>                         cmd = v[2]
>                     except IndexError:
>                         cmd = STITCH
>                     self.add_stitch_absolute(cmd, x, y)
>             elif isinstance(v, complex):
>                 for v in block:
>                     x = v.real
>                     y = v.imag
>                     self.add_stitch_absolute(STITCH, x, y)
>             elif isinstance(v, int) or isinstance(v, float):
>                 i = 0
>                 ie = len(block)
>                 while i < ie:
>                     self.add_stitch_absolute(STITCH, block[i], block[i + 1])
>                     i += 2
>         self.add_command(COLOR_BREAK)
> 
>     def add_stitchblock(self, stitchblock):
>         threadlist = self.threadlist
>         block = stitchblock[0]
>         thread = stitchblock[1]
>         if len(threadlist) == 0 or thread is not threadlist[-1]:
>             threadlist.append(thread)
>             self.add_stitch_relative(COLOR_BREAK)
>         else:
>             self.add_stitch_relative(SEQUENCE_BREAK)
> 
>         for stitch in block:
>             try:
>                 self.add_stitch_absolute(stitch.command, stitch.x, stitch.y)
>             except AttributeError:
>                 self.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
> 
>     def add_pattern(self, pattern, dx=None, dy=None, sx=None, sy=None, rotate=None):
>         """
>         add_pattern merges the given pattern with the current pattern. It accounts for some edge conditions but
>         not all of them.
> 
>         If there is an end command on the current pattern, that is removed.
>         If the color ending the current pattern is equal to the color starting the next those color blocks are merged.
>         Any prepended thread change command to the merging pattern is suppressed.
> 
>         :param pattern: pattern to add to current pattern
>         :param dx: position change of the added pattern x
>         :param dy: position change of the added pattern y
>         :param sx: scale of the added pattern x
>         :param sy: scale of the added pattern y
>         :param rotate: rotation of the added pattern
>         :return:
>         """
>         if isinstance(pattern, str):
>             pattern = EmbPattern(pattern)
>         if self.stitches[-1][2] == END:
>             self.stitches = self.stitches[:-1]  # Remove END, if exists
>         if dx is not None or dy is not None:
>             if dx is None:
>                 dx = 0
>             if dy is None:
>                 dy = 0
>             self.add_command(MATRIX_TRANSLATE, dx, dy)
>         if sx is not None or sx is not None:
>             if sx is None:
>                 sx = sy
>             if sy is None:
>                 sy = sx
>             self.add_command(MATRIX_SCALE, sx, sy)
>         if rotate is not None:
>             self.add_command(MATRIX_ROTATE, rotate)
>         # Add the new thread only if it's different from the last one
>         self.fix_color_count()
> 
>         if len(pattern.threadlist) > 0:
>             if pattern.threadlist[0] == self.threadlist[-1]:
>                 self.threadlist.extend(pattern.threadlist[1:])
>             else:
>                 self.threadlist.extend(pattern.threadlist)
>                 self.color_change()
>         join_position = len(self.stitches)
>         self.stitches.extend(pattern.stitches)
> 
>         for i in range(join_position, len(self.stitches)):
>             data = self.stitches[i][2] & COMMAND_MASK
>             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
>                 break
>             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
>                 self.stitches[i][2] = NO_COMMAND
>         self.extras.update(pattern.extras)
> 
>     def interpolate_duplicate_color_as_stop(self):
>         """Processes a pattern replacing any duplicate colors in the threadlist as a stop."""
>         thread_index = 0
>         init_color = True
>         last_change = None
>         for position, stitch in enumerate(self.stitches):
>             data = stitch[2] & COMMAND_MASK
>             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
>                 if init_color:
>                     try:
>                         if (
>                             last_change is not None
>                             and thread_index != 0
>                             and self.threadlist[thread_index - 1]
>                             == self.threadlist[thread_index]
>                         ):
>                             del self.threadlist[thread_index]
>                             self.stitches[last_change][2] = STOP
>                         else:
>                             thread_index += 1
>                     except IndexError:  # Non-existant threads cannot double
>                         return
>                     init_color = False
>             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
>                 init_color = True
>                 last_change = position
> 
>     def interpolate_stop_as_duplicate_color(self, thread_change_command=COLOR_CHANGE):
>         """Processes a pattern replacing any stop as a duplicate color, and color_change
>         or another specified thread_change_command"""
>         thread_index = 0
>         for position, stitch in enumerate(self.stitches):
>             data = stitch[2] & COMMAND_MASK
>             if data == STITCH or data == SEW_TO or data == NEEDLE_AT:
>                 continue
>             elif data == COLOR_CHANGE or data == COLOR_BREAK or data == NEEDLE_SET:
>                 thread_index += 1
>             elif data == STOP:
>                 try:
>                     self.threadlist.insert(thread_index, self.threadlist[thread_index])
>                     self.stitches[position][2] = thread_change_command
>                     thread_index += 1
>                 except IndexError:  # There are no colors to duplicate
>                     return
> 
>     def interpolate_frame_eject(self):
>         """Processes a pattern replacing jump-stop-jump/jump-stop-end sequences with FRAME_EJECT."""
>         mode = 0
>         stop_x = None
>         stop_y = None
>         sequence_start_position = None
>         position = 0
>         ie = len(self.stitches)
>         while position < ie:
>             stitch = self.stitches[position]
>             data = stitch[2] & COMMAND_MASK
>             if (
>                 data == STITCH
>                 or data == SEW_TO
>                 or data == NEEDLE_AT
>                 or data == COLOR_CHANGE
>                 or data == COLOR_BREAK
>                 or data == NEEDLE_SET
>             ):
>                 if mode == 3:
>                     del self.stitches[sequence_start_position:position]
>                     position = sequence_start_position
>                     self.stitches.insert(position, [stop_x, stop_y, FRAME_EJECT])
>                     ie = len(self.stitches)
>                 mode = 0
>             elif data == JUMP:
>                 if mode == 2:
>                     mode = 3
>                 if mode == 0:
>                     sequence_start_position = position
>                     mode = 1
>             elif data == STOP:
>                 if mode == 1:
>                     mode = 2
>                     stop_x = stitch[0]
>                     stop_y = stitch[1]
>             position += 1
>         if mode >= 2:  # Frame_eject at end.
>             del self.stitches[sequence_start_position:position]
>             position = sequence_start_position
>             self.stitches.insert(position, [stop_x, stop_y, FRAME_EJECT])
> 
>     def interpolate_trims(
>         self, jumps_to_require_trim=None, distance_to_require_trim=None, clipping=True
>     ):
>         """Processes a pattern adding trims according to the given criteria."""
>         i = -1
>         ie = len(self.stitches) - 1
> 
>         x = 0
>         y = 0
>         jump_count = 0
>         jump_start = 0
>         jump_dx = 0
>         jump_dy = 0
>         jumping = False
>         trimmed = True
>         while i < ie:
>             i += 1
>             stitch = self.stitches[i]
>             dx = stitch[0] - x
>             dy = stitch[1] - y
>             x = stitch[0]
>             y = stitch[1]
>             command = stitch[2] & COMMAND_MASK
>             if command == STITCH or command == SEQUIN_EJECT:
>                 trimmed = False
>                 jumping = False
>             elif command == COLOR_CHANGE or command == NEEDLE_SET or command == TRIM:
>                 trimmed = True
>                 jumping = False
>             if command == JUMP:
>                 if not jumping:
>                     jump_dx = 0
>                     jump_dy = 0
>                     jump_count = 0
>                     jump_start = i
>                     jumping = True
>                 jump_count += 1
>                 jump_dx += dx
>                 jump_dy += dy
>                 if not trimmed:
>                     if (
>                         jump_count == jumps_to_require_trim
>                         or distance_to_require_trim is not None
>                         and (
>                             abs(jump_dy) > distance_to_require_trim
>                             or abs(jump_dx) > distance_to_require_trim
>                         )
>                     ):
>                         self.trim(position=jump_start)
>                         jump_start += 1  # We inserted a position, start jump has moved.
>                         i += 1
>                         ie += 1
>                         trimmed = True
>                 if (
>                     clipping and jump_dx == 0 and jump_dy == 0
>                 ):  # jump displacement is 0, clip trim command.
>                     del self.stitches[jump_start : i + 1]
>                     i = jump_start - 1
>                     ie = len(self.stitches) - 1
> 
>     def get_pattern_interpolate_trim(self, jumps_to_require_trim):
>         """Gets a processed pattern with untrimmed jumps merged
>         and trims added if merged jumps are beyond the given value.
>         The expectation is that it has core commands and not
>         middle-level commands"""
>         new_pattern = EmbPattern()
>         i = -1
>         ie = len(self.stitches) - 1
>         count = 0
>         trimmed = True
>         while i < ie:
>             i += 1
>             stitch = self.stitches[i]
>             command = stitch[2] & COMMAND_MASK
>             if command == STITCH or command == SEQUIN_EJECT:
>                 trimmed = False
>             elif command == COLOR_CHANGE or command == NEEDLE_SET or command == TRIM:
>                 trimmed = True
>             if trimmed or stitch[2] != JUMP:
>                 new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
>                 continue
>             while i < ie and command == JUMP:
>                 i += 1
>                 stitch = self.stitches[i]
>                 command = stitch[2]
>                 count += 1
>             if command != JUMP:
>                 i -= 1
>             stitch = self.stitches[i]
>             if count >= jumps_to_require_trim:
>                 new_pattern.trim()
>             count = 0
>             new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
>         new_pattern.threadlist.extend(self.threadlist)
>         new_pattern.extras.update(self.extras)
>         return new_pattern
> 
>     def get_pattern_merge_jumps(self):
>         """Returns a pattern with all multiple jumps merged."""
>         new_pattern = EmbPattern()
>         i = -1
>         ie = len(self.stitches) - 1
>         stitch_break = False
>         while i < ie:
>             i += 1
>             stitch = self.stitches[i]
>             command = stitch[2] & COMMAND_MASK
>             if command == JUMP:
>                 if stitch_break:
>                     continue
>                 new_pattern.add_command(STITCH_BREAK)
>                 stitch_break = True
>                 continue
>             new_pattern.add_stitch_absolute(stitch[2], stitch[0], stitch[1])
>         new_pattern.threadlist.extend(self.threadlist)
>         new_pattern.extras.update(self.extras)
>         return new_pattern
> 
>     def get_stable_pattern(self):
>         """Gets a stabilized version of the pattern."""
>         stable_pattern = EmbPattern()
>         for stitchblock in self.get_as_stitchblock():
>             stable_pattern.add_stitchblock(stitchblock)
>         stable_pattern.extras.update(self.extras)
>         return stable_pattern
> 
>     def get_normalized_pattern(self, encode_settings=None):
>         """Encodes pattern typically for saving."""
>         normal_pattern = EmbPattern()
>         transcoder = Normalizer(encode_settings)
>         transcoder.transcode(self, normal_pattern)
>         return normal_pattern
> 
>     def append_translation(self, x, y):
>         """Appends translation to the pattern.
>         All commands will be translated by the given amount,
>         including absolute location commands."""
>         self.add_stitch_relative(MATRIX_TRANSLATE, x, y)
> 
>     @staticmethod
>     def supported_formats():
>         """Generates dictionary entries for supported formats. Each entry will
>         always have description, extension, mimetype, and category. Reader
>         will provide the reader, if one exists, writer will provide the writer,
>         if one exists.
> 
>         Metadata gives a list of metadata read and/or written by that type.
> 
>         Options provides accepted options by the format and their accepted values.
>         """
>         # yield ({
>         #     "description": "Art Embroidery Format",
>         #     "extension": "art",
>         #     "extensions": ("art",),
>         #     "mimetype": "application/x-art",
>         #     "category": "embroidery",
>         #     "reader": ArtReader,
>         #     "metadata": ("name")
>         # })
>         yield (
>             {
>                 "description": "Brother Embroidery Format",
>                 "extension": "pec",
>                 "extensions": ("pec",),
>                 "mimetype": "application/x-pec",
>                 "category": "embroidery",
>                 "reader": PecReader,
>                 "writer": PecWriter,
>                 "metadata": ("name"),
>             }
>         )
>         yield (
>             {
>                 "description": "Brother Embroidery Format",
>                 "extension": "pes",
>                 "extensions": ("pes",),
>                 "mimetype": "application/x-pes",
>                 "category": "embroidery",
>                 "reader": PesReader,
>                 "writer": PesWriter,
>                 "versions": ("1", "6", "1t", "6t"),
>                 "metadata": ("name", "author", "category", "keywords", "comments"),
>             }
>         )
>         yield (
>             {
>                 "description": "Melco Expanded Embroidery Format",
>                 "extension": "exp",
>                 "extensions": ("exp",),
>                 "mimetype": "application/x-exp",
>                 "category": "embroidery",
>                 "reader": ExpReader,
>                 "writer": ExpWriter,
>             }
>         )
>         # yield (
>         #     {
>         #         "description": "Melco Condensed Embroidery Format",
>         #         "extension": "cnd",
>         #         "extensions": ("cnd",),
>         #         "mimetype": "application/x-cnd",
>         #         "category": "embroidery",
>         #         "reader": CndReader,
>         #     }
>         # )
>         yield (
>             {
>                 "description": "Tajima Embroidery Format",
>                 "extension": "dst",
>                 "extensions": ("dst",),
>                 "mimetype": "application/x-dst",
>                 "category": "embroidery",
>                 "reader": DstReader,
>                 "writer": DstWriter,
>                 "read_options": {
>                     "trim_distance": (None, 3.0, 50.0),
>                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
>                     "clipping": (True, False),
>                 },
>                 "write_options": {"trim_at": (2, 3, 4, 5, 6, 7, 8)},
>                 "versions": ("default", "extended"),
>                 "metadata": ("name", "author", "copyright"),
>             }
>         )
>         yield (
>             {
>                 "description": "Janome Embroidery Format",
>                 "extension": "jef",
>                 "extensions": ("jef",),
>                 "mimetype": "application/x-jef",
>                 "category": "embroidery",
>                 "reader": JefReader,
>                 "writer": JefWriter,
>                 "read_options": {
>                     "trim_distance": (None, 3.0, 50.0),
>                     "trims": (True, False),
>                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
>                     "clipping": (True, False),
>                 },
>                 "write_options": {
>                     "trims": (True, False),
>                     "trim_at": (2, 3, 4, 5, 6, 7, 8),
>                 },
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "vp3",
>                 "extensions": ("vp3",),
>                 "mimetype": "application/x-vp3",
>                 "category": "embroidery",
>                 "reader": Vp3Reader,
>                 "writer": Vp3Writer,
>             }
>         )
>         yield (
>             {
>                 "description": "Scalable Vector Graphics",
>                 "extension": "svg",
>                 "extensions": ("svg", "svgz"),
>                 "mimetype": "image/svg+xml",
>                 "category": "vector",
>                 "writer": SvgWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "Comma-separated values",
>                 "extension": "csv",
>                 "extensions": ("csv",),
>                 "mimetype": "text/csv",
>                 "category": "debug",
>                 "reader": CsvReader,
>                 "writer": CsvWriter,
>                 "versions": ("default", "delta", "full"),
>             }
>         )
>         yield (
>             {
>                 "description": "Singer Embroidery Format",
>                 "extension": "xxx",
>                 "extensions": ("xxx",),
>                 "mimetype": "application/x-xxx",
>                 "category": "embroidery",
>                 "reader": XxxReader,
>                 "writer": XxxWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "Janome Embroidery Format",
>                 "extension": "sew",
>                 "extensions": ("sew",),
>                 "mimetype": "application/x-sew",
>                 "category": "embroidery",
>                 "reader": SewReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Barudan Embroidery Format",
>                 "extension": "u01",
>                 "extensions": ("u00", "u01", "u02"),
>                 "mimetype": "application/x-u01",
>                 "category": "embroidery",
>                 "reader": U01Reader,
>                 "writer": U01Writer,
>             }
>         )
>         yield (
>             {
>                 "description": "Husqvarna Viking Embroidery Format",
>                 "extension": "shv",
>                 "extensions": ("shv",),
>                 "mimetype": "application/x-shv",
>                 "category": "embroidery",
>                 "reader": ShvReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Toyota Embroidery Format",
>                 "extension": "10o",
>                 "extensions": ("10o",),
>                 "mimetype": "application/x-10o",
>                 "category": "embroidery",
>                 "reader": A10oReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Toyota Embroidery Format",
>                 "extension": "100",
>                 "extensions": ("100",),
>                 "mimetype": "application/x-100",
>                 "category": "embroidery",
>                 "reader": A100Reader,
>             }
>         )
>         yield (
>             {
>                 "description": "Bits & Volts Embroidery Format",
>                 "extension": "bro",
>                 "extensions": ("bro",),
>                 "mimetype": "application/x-Bro",
>                 "category": "embroidery",
>                 "reader": BroReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Sunstar or Barudan Embroidery Format",
>                 "extension": "dat",
>                 "extensions": ("dat",),
>                 "mimetype": "application/x-dat",
>                 "category": "embroidery",
>                 "reader": DatReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Tajima(Barudan) Embroidery Format",
>                 "extension": "dsb",
>                 "extensions": ("dsb",),
>                 "mimetype": "application/x-dsb",
>                 "category": "embroidery",
>                 "reader": DsbReader,
>             }
>         )
>         yield (
>             {
>                 "description": "ZSK USA Embroidery Format",
>                 "extension": "dsz",
>                 "extensions": ("dsz",),
>                 "mimetype": "application/x-dsz",
>                 "category": "embroidery",
>                 "reader": DszReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Elna Embroidery Format",
>                 "extension": "emd",
>                 "extensions": ("emd",),
>                 "mimetype": "application/x-emd",
>                 "category": "embroidery",
>                 "reader": EmdReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Eltac Embroidery Format",
>                 "extension": "exy",  # e??, e01
>                 "extensions": ("e00", "e01", "e02"),
>                 "mimetype": "application/x-exy",
>                 "category": "embroidery",
>                 "reader": ExyReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Fortron Embroidery Format",
>                 "extension": "fxy",  # f??, f01
>                 "extensions": ("f00", "f01", "f02"),
>                 "mimetype": "application/x-fxy",
>                 "category": "embroidery",
>                 "reader": FxyReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Gold Thread Embroidery Format",
>                 "extension": "gt",
>                 "extensions": ("gt",),
>                 "mimetype": "application/x-exy",
>                 "category": "embroidery",
>                 "reader": GtReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Inbro Embroidery Format",
>                 "extension": "inb",
>                 "extensions": ("inb",),
>                 "mimetype": "application/x-inb",
>                 "category": "embroidery",
>                 "reader": InbReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Tajima Embroidery Format",
>                 "extension": "tbf",
>                 "extensions": ("tbf",),
>                 "mimetype": "application/x-tbf",
>                 "category": "embroidery",
>                 "reader": TbfReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "ksm",
>                 "extensions": ("ksm",),
>                 "mimetype": "application/x-ksm",
>                 "category": "embroidery",
>                 "reader": KsmReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Happy Embroidery Format",
>                 "extension": "tap",
>                 "extensions": ("tap",),
>                 "mimetype": "application/x-tap",
>                 "category": "embroidery",
>                 "reader": TapReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "spx",
>                 "extensions": ("spx"),
>                 "mimetype": "application/x-spx",
>                 "category": "embroidery",
>                 "reader": SpxReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Data Stitch Embroidery Format",
>                 "extension": "stx",
>                 "extensions": ("stx",),
>                 "mimetype": "application/x-stx",
>                 "category": "embroidery",
>                 "reader": StxReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Brother Embroidery Format",
>                 "extension": "phb",
>                 "extensions": ("phb",),
>                 "mimetype": "application/x-phb",
>                 "category": "embroidery",
>                 "reader": PhbReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Brother Embroidery Format",
>                 "extension": "phc",
>                 "extensions": ("phc",),
>                 "mimetype": "application/x-phc",
>                 "category": "embroidery",
>                 "reader": PhcReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Ameco Embroidery Format",
>                 "extension": "new",
>                 "extensions": ("new",),
>                 "mimetype": "application/x-new",
>                 "category": "embroidery",
>                 "reader": NewReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "max",
>                 "extensions": ("max",),
>                 "mimetype": "application/x-max",
>                 "category": "embroidery",
>                 "reader": MaxReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Mitsubishi Embroidery Format",
>                 "extension": "mit",
>                 "extensions": ("mit",),
>                 "mimetype": "application/x-mit",
>                 "category": "embroidery",
>                 "reader": MitReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "pcd",
>                 "extensions": ("pcd",),
>                 "mimetype": "application/x-pcd",
>                 "category": "embroidery",
>                 "reader": PcdReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "pcq",
>                 "extensions": ("pcq",),
>                 "mimetype": "application/x-pcq",
>                 "category": "embroidery",
>                 "reader": PcqReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "pcm",
>                 "extensions": ("pcm",),
>                 "mimetype": "application/x-pcm",
>                 "category": "embroidery",
>                 "reader": PcmReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Pfaff Embroidery Format",
>                 "extension": "pcs",
>                 "extensions": ("pcs",),
>                 "mimetype": "application/x-pcs",
>                 "category": "embroidery",
>                 "reader": PcsReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Janome Embroidery Format",
>                 "extension": "jpx",
>                 "extensions": ("jpx",),
>                 "mimetype": "application/x-jpx",
>                 "category": "embroidery",
>                 "reader": JpxReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Gunold Embroidery Format",
>                 "extension": "stc",
>                 "extensions": ("stc",),
>                 "mimetype": "application/x-stc",
>                 "category": "embroidery",
>                 "reader": StcReader,
>             }
>         )
>         yield ({
>             "description": "Zeng Hsing Embroidery Format",
>             "extension": "zhs",
>             "extensions": ("zhs",),
>             "mimetype": "application/x-zhs",
>             "category": "embroidery",
>             "reader": ZhsReader
>         })
>         yield (
>             {
>                 "description": "ZSK TC Embroidery Format",
>                 "extension": "zxy",
>                 "extensions": ("z00", "z01", "z02"),
>                 "mimetype": "application/x-zxy",
>                 "category": "embroidery",
>                 "reader": ZxyReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Brother Stitch Format",
>                 "extension": "pmv",
>                 "extensions": ("pmv",),
>                 "mimetype": "application/x-pmv",
>                 "category": "stitch",
>                 "reader": PmvReader,
>                 "writer": PmvWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "PNG Format, Portable Network Graphics",
>                 "extension": "png",
>                 "extensions": ("png",),
>                 "mimetype": "image/png",
>                 "category": "image",
>                 "writer": PngWriter,
>                 "write_options": {
>                     "background": (0x000000, 0xFFFFFF),
>                     "linewidth": (1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
>                 },
>             }
>         )
>         yield (
>             {
>                 "description": "txt Format, Text File",
>                 "extension": "txt",
>                 "extensions": ("txt",),
>                 "mimetype": "text/plain",
>                 "category": "debug",
>                 "writer": TxtWriter,
>                 "versions": ("default", "embroidermodder"),
>             }
>         )
>         yield (
>             {
>                 "description": "gcode Format, Text File",
>                 "extension": "gcode",
>                 "extensions": ("gcode", "g-code", "ngc", "nc", ".g"),
>                 "mimetype": "text/plain",
>                 "category": "embroidery",
>                 "reader": GcodeReader,
>                 "writer": GcodeWriter,
>                 "write_options": {
>                     "stitch_z_travel": (5.0, 10.0),
>                 },
>             }
>         )
>         yield (
>             {
>                 "description": "Husqvarna Embroidery Format",
>                 "extension": "hus",
>                 "extensions": ("hus",),
>                 "mimetype": "application/x-hus",
>                 "category": "embroidery",
>                 "reader": HusReader,
>             }
>         )
>         yield (
>             {
>                 "description": "Edr Color Format",
>                 "extension": "edr",
>                 "extensions": ("edr",),
>                 "mimetype": "application/x-edr",
>                 "category": "color",
>                 "reader": EdrReader,
>                 "writer": EdrWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "Col Color Format",
>                 "extension": "col",
>                 "extensions": ("col",),
>                 "mimetype": "application/x-col",
>                 "category": "color",
>                 "reader": ColReader,
>                 "writer": ColWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "Inf Color Format",
>                 "extension": "inf",
>                 "extensions": ("inf",),
>                 "mimetype": "application/x-inf",
>                 "category": "color",
>                 "reader": InfReader,
>                 "writer": InfWriter,
>             }
>         )
>         yield (
>             {
>                 "description": "Json Export",
>                 "extension": "json",
>                 "extensions": ("json",),
>                 "mimetype": "application/json",
>                 "category": "debug",
>                 "reader": JsonReader,
>                 "writer": JsonWriter,
>             }
>         )
> 
>     @staticmethod
>     def convert(filename_from, filename_to, settings=None):
>         pattern = EmbPattern.static_read(filename_from, settings)
>         if pattern is None:
>             return
>         EmbPattern.static_write(pattern, filename_to, settings)
> 
>     @staticmethod
>     def get_extension_by_filename(filename):
>         """extracts the extension from a filename"""
>         return os.path.splitext(filename)[1][1:]
> 
>     @staticmethod
>     def read_embroidery(reader, f, settings=None, pattern=None):
>         """Reads fileobject or filename with reader."""
>         if reader is None:
>             return None
>         if pattern is None:
>             pattern = EmbPattern()
> 
>         if EmbPattern.is_str(f):
>             text_mode = False
>             try:
>                 text_mode = reader.READ_FILE_IN_TEXT_MODE
>             except AttributeError:
>                 pass
>             if text_mode:
>                 try:
>                     with open(f, "r") as stream:
>                         reader.read(stream, pattern, settings)
>                         stream.close()
>                 except IOError:
>                     pass
>             else:
>                 try:
>                     with open(f, "rb") as stream:
>                         reader.read(stream, pattern, settings)
>                         stream.close()
>                 except IOError:
>                     pass
>         else:
>             reader.read(f, pattern, settings)
>         return pattern
> 
>     @staticmethod
>     def read_dst(f, settings=None, pattern=None):
>         """Reads fileobject as DST file"""
>         return EmbPattern.read_embroidery(DstReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_pec(f, settings=None, pattern=None):
>         """Reads fileobject as PEC file"""
>         return EmbPattern.read_embroidery(PecReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_pes(f, settings=None, pattern=None):
>         """Reads fileobject as PES file"""
>         return EmbPattern.read_embroidery(PesReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_exp(f, settings=None, pattern=None):
>         """Reads fileobject as EXP file"""
>         return EmbPattern.read_embroidery(ExpReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_vp3(f, settings=None, pattern=None):
>         """Reads fileobject as VP3 file"""
>         return EmbPattern.read_embroidery(Vp3Reader, f, settings, pattern)
> 
>     @staticmethod
>     def read_jef(f, settings=None, pattern=None):
>         """Reads fileobject as JEF file"""
>         return EmbPattern.read_embroidery(JefReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_u01(f, settings=None, pattern=None):
>         """Reads fileobject as U01 file"""
>         return EmbPattern.read_embroidery(U01Reader, f, settings, pattern)
> 
>     @staticmethod
>     def read_csv(f, settings=None, pattern=None):
>         """Reads fileobject as CSV file"""
>         return EmbPattern.read_embroidery(CsvReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_gcode(f, settings=None, pattern=None):
>         """Reads fileobject as GCode file"""
>         return EmbPattern.read_embroidery(GcodeReader, f, settings, pattern)
> 
>     @staticmethod
>     def read_xxx(f, settings=None, pattern=None):
>         """Reads fileobject as XXX file"""
>         return EmbPattern.read_embroidery(XxxReader, f, settings, pattern)
> 
>     @staticmethod
>     def static_read(filename, settings=None, pattern=None):
>         """Reads file, assuming type by extension"""
>         extension = EmbPattern.get_extension_by_filename(filename)
>         extension = extension.lower()
>         for file_type in EmbPattern.supported_formats():
>             if file_type["extension"] != extension:
>                 continue
>             reader = file_type.get("reader", None)
>             return EmbPattern.read_embroidery(reader, filename, settings, pattern)
>         return None
> 
>     @staticmethod
>     def write_embroidery(writer, pattern, stream, settings=None):
>         if pattern is None:
>             return
>         if settings is None:
>             settings = {}
>         else:
>             settings = settings.copy()
>         try:
>             encode = writer.ENCODE
>         except AttributeError:
>             encode = True
> 
>         if settings.get("encode", encode):
>             if not ("max_jump" in settings):
>                 try:
>                     settings["max_jump"] = writer.MAX_JUMP_DISTANCE
>                 except AttributeError:
>                     pass
>             if not ("max_stitch" in settings):
>                 try:
>                     settings["max_stitch"] = writer.MAX_STITCH_DISTANCE
>                 except AttributeError:
>                     pass
>             if not ("full_jump" in settings):
>                 try:
>                     settings["full_jump"] = writer.FULL_JUMP
>                 except AttributeError:
>                     pass
>             if not ("round" in settings):
>                 try:
>                     settings["round"] = writer.ROUND
>                 except AttributeError:
>                     pass
>             if not ("writes_speeds" in settings):
>                 try:
>                     settings["writes_speeds"] = writer.WRITES_SPEEDS
>                 except AttributeError:
>                     pass
>             if not ("sequin_contingency" in settings):
>                 try:
>                     settings["sequin_contingency"] = writer.SEQUIN_CONTINGENCY
>                 except AttributeError:
>                     pass
>             if not ("thread_change_command" in settings):
>                 try:
>                     settings["thread_change_command"] = writer.THREAD_CHANGE_COMMAND
>                 except AttributeError:
>                     pass
>             if not ("translate" in settings):
>                 try:
>                     settings["translate"] = writer.TRANSLATE
>                 except AttributeError:
>                     pass
>             if not ("scale" in settings):
>                 try:
>                     settings["scale"] = writer.SCALE
>                 except AttributeError:
>                     pass
>             if not ("rotate" in settings):
>                 try:
>                     settings["rotate"] = writer.ROTATE
>                 except AttributeError:
>                     pass
>             pattern = pattern.get_normalized_pattern(settings)
> 
>         if EmbPattern.is_str(stream):
>             text_mode = False
>             try:
>                 text_mode = writer.WRITE_FILE_IN_TEXT_MODE
>             except AttributeError:
>                 pass
>             if text_mode:
>                 try:
>                     with open(stream, "w") as stream:
>                         writer.write(pattern, stream, settings)
>                 except IOError:
>                     pass
>             else:
>                 try:
>                     with open(stream, "wb") as stream:
>                         writer.write(pattern, stream, settings)
>                 except IOError:
>                     pass
>         else:
>             writer.write(pattern, stream, settings)
> 
>     @staticmethod
>     def write_dst(pattern, stream, settings=None):
>         """Writes fileobject as DST file"""
>         EmbPattern.write_embroidery(DstWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_pec(pattern, stream, settings=None):
>         """Writes fileobject as PEC file"""
>         EmbPattern.write_embroidery(PecWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_pes(pattern, stream, settings=None):
>         """Writes fileobject as PES file"""
>         EmbPattern.write_embroidery(PesWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_exp(pattern, stream, settings=None):
>         """Writes fileobject as EXP file"""
>         EmbPattern.write_embroidery(ExpWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_vp3(pattern, stream, settings=None):
>         """Writes fileobject as Vp3 file"""
>         EmbPattern.write_embroidery(Vp3Writer, pattern, stream, settings)
> 
>     @staticmethod
>     def write_jef(pattern, stream, settings=None):
>         """Writes fileobject as JEF file"""
>         EmbPattern.write_embroidery(JefWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_u01(pattern, stream, settings=None):
>         """Writes fileobject as U01 file"""
>         EmbPattern.write_embroidery(U01Writer, pattern, stream, settings)
> 
>     @staticmethod
>     def write_csv(pattern, stream, settings=None):
>         """Writes fileobject as CSV file"""
>         EmbPattern.write_embroidery(CsvWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_txt(pattern, stream, settings=None):
>         """Writes fileobject as CSV file"""
>         EmbPattern.write_embroidery(TxtWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_gcode(pattern, stream, settings=None):
>         """Writes fileobject as Gcode file"""
>         EmbPattern.write_embroidery(GcodeWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_xxx(pattern, stream, settings=None):
>         """Writes fileobject as XXX file"""
>         EmbPattern.write_embroidery(XxxWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_svg(pattern, stream, settings=None):
>         """Writes fileobject as DST file"""
>         EmbPattern.write_embroidery(SvgWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def write_png(pattern, stream, settings=None):
>         """Writes fileobject as PNG file"""
>         EmbPattern.write_embroidery(PngWriter, pattern, stream, settings)
> 
>     @staticmethod
>     def static_write(pattern, filename, settings=None):
>         """Writes file, assuming type by extension"""
>         extension = EmbPattern.get_extension_by_filename(filename)
>         extension = extension.lower()
> 
>         for file_type in EmbPattern.supported_formats():
>             if file_type["extension"] != extension:
>                 continue
>             writer = file_type.get("writer", None)
>             if writer is None:
>                 continue
>             EmbPattern.write_embroidery(writer, pattern, filename, settings)
> 
>     @staticmethod
>     def is_str(obj):
>         try:
>             return isinstance(obj, basestring)
>         except NameError:
>             return isinstance(obj, str)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/GenericWriter.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/GenericWriter.py
1,574c1,574
< import pyembroidery
< from pyembroidery import (
<     CONTINGENCY_SEQUIN_UTILIZE,
<     decode_embroidery_command,
<     STITCH,
<     COLOR_CHANGE,
<     NEEDLE_SET,
<     TRIM,
<     JUMP,
<     SEQUIN_MODE,
<     SEQUIN_EJECT,
<     STOP,
<     SLOW,
<     FAST,
<     END,
<     get_common_name_dictionary,
<     COMMAND_MASK,
< )
< from pyembroidery.WriteHelper import write_string_utf8
< 
< WRITES_SPEEDS = True
< SEQUIN_CONTINGENCY = CONTINGENCY_SEQUIN_UTILIZE
< 
< 
< def write(pattern, f, settings=None):
<     writer = GenericWriter(pattern, f, settings)
<     writer.write()
< 
< 
< class GenericWriter:
<     """
<     Generic Writer will write generic data fit to a formatted set of strings.
< 
<     Blocks are established by the first segment.
<     Colors are established by the first segment or the first segment after a color change or by a needle_set.
<     Documents are established by the first segment, or the first segment after an end.
< 
<     Segment is the default for any-command. Specific commands override segment.
< 
<     stitch is the default stitch.
<     stitch_first overrides stitch for the first stitch in a block.
<     stitch_last overrides stitch for the last stitch in a block.
< 
<     trims and jumps occurring before a color change belong to the previous color.
<     trims and jumps occurring after a color change belong to the next color.
< 
<     Missing segments are treated as if they never existed. Value properties will differ if segments are excluded.
<     """
< 
<     def __init__(self, pattern, f, settings):
<         self.pattern = pattern
<         self.f = f
<         self.settings = settings
<         self.metadata_entry = settings.get("metadata_entry", None)
<         self.thread_entry = settings.get("thread_entry", None)
<         self.pattern_start = settings.get("pattern_start", None)
<         self.pattern_end = settings.get("pattern_end", None)
<         self.document_start = settings.get("document_start", None)
<         self.document_end = settings.get("document_end", None)
<         self.color_start = settings.get("color_start", None)
<         self.color_end = settings.get("color_end", None)
<         self.color_join = settings.get("color_join", None)
<         self.block_start = settings.get("block_start", None)
<         self.block_end = settings.get("block_end", None)
<         self.block_join = settings.get("block_join", None)
<         self.segment_start = settings.get("segment_start", None)
<         self.segment = settings.get("segment", None)
<         self.segment_end = settings.get("segment_end", None)
<         self.segment_join = settings.get("segment_join", None)
<         self.stitch_first = settings.get("stitch_first", None)
<         self.stitch_last = settings.get("stitch_last", None)
<         self.stitch = settings.get("stitch", None)
<         self.stop = settings.get("stop", None)
<         self.jump = settings.get("jump", None)
<         self.trim = settings.get("trim", None)
<         self.needle_set = settings.get("needle_set", None)
<         self.color_change = settings.get("color_change", None)
<         self.sequin = settings.get("sequin", None)
<         self.sequin_mode = settings.get("sequin_mode", None)
<         self.slow = settings.get("slow", None)
<         self.fast = settings.get("fast", None)
<         self.end = settings.get("end", None)
< 
<         self.format_dictionary = {}
<         self.pattern_established = False
<         self.document_established = False
<         self.color_established = False
<         self.block_established = False
<         self.document_index = -1
<         self.thread = None
<         self.thread_index = -1
<         self.stitch_index = -1
<         self.color_index = -1
<         self.block_index = -1
<         self.dx = 0
<         self.dy = 0
<         self.xx = 0
<         self.yy = 0
<         self.last_x = 0
<         self.last_y = 0
<         self.z = 0.0
<         self.z_increment = settings.get("stitch_z_travel", 10.0)
<         self.command_index = 0
< 
<         self.current_stitch = None
<         self.x = None
<         self.y = None
<         self.command = None
<         self.cmd = None
<         self.thread = None
<         self.needle = None
<         self.order = None
<         self.cmd_str = None
< 
<         self.block_closing = False
<         self.color_closing = False
<         self.document_closing = False
< 
<         self.block_opening = False
<         self.color_opening = False
<         self.document_opening = False
< 
<     def write_opens(self):
<         if self.document_opening:
<             self.document_opening = False
<             if self.document_start is not None:
<                 write_string_utf8(self.f, self.document_start.format_map(self.format_dictionary))
<         if self.color_opening:
<             self.color_opening = False
<             if self.color_join is not None and self.color_index != 0:
<                 write_string_utf8(self.f, self.color_join.format_map(self.format_dictionary))
<             if self.color_start is not None:
<                 write_string_utf8(self.f, self.color_start.format_map(self.format_dictionary))
<         if self.block_opening:
<             self.block_opening = False
<             if self.block_join is not None and self.block_index != 0:
<                 write_string_utf8(self.f, self.block_join.format_map(self.format_dictionary))
<             if self.block_start is not None:
<                 write_string_utf8(self.f, self.block_start.format_map(self.format_dictionary))
< 
<     def write_closes(self):
<         if self.block_closing:
<             self.block_closing = False
<             if self.block_end is not None:
<                 write_string_utf8(self.f, self.block_end.format_map(self.format_dictionary))
<         if self.color_closing:
<             self.color_closing = False
<             if self.color_end is not None:
<                 write_string_utf8(self.f, self.color_end.format_map(self.format_dictionary))
<         if self.document_closing:
<             self.document_closing = False
<             if self.document_end is not None:
<                 write_string_utf8(self.f, self.document_end.format_map(self.format_dictionary))
< 
<     def get_write_segment(self, cmd):
<         # SEQUIN_MODE
<         if cmd == SEQUIN_MODE and self.sequin_mode is not None:
<             return self.sequin_mode
< 
<         # SEQUIN
<         if cmd == SEQUIN_EJECT and self.sequin is not None:
<             return self.sequin
< 
<         # STITCH
<         if cmd == STITCH and self.stitch is not None:
<             return self.stitch
< 
<         # TRIM
<         if cmd == TRIM and self.trim is not None:
<             return self.trim
< 
<         # JUMP
<         if cmd == JUMP and self.jump is not None:
<             return self.jump
< 
<         # COLOR CHANGE
<         if cmd == COLOR_CHANGE and self.color_change is not None:
<             return self.color_change
< 
<         # NEEDLE SET
<         if cmd == NEEDLE_SET and self.needle_set is not None:
<             return self.needle_set
< 
<         # STOP COMMAND
<         if cmd == STOP and self.stop is not None:
<             return self.stop
< 
<         # SLOW COMMAND
<         if cmd == SLOW and self.slow is not None:
<             return self.slow
< 
<         # FAST COMMAND
<         if cmd == FAST and self.fast is not None:
<             return self.fast
< 
<         # END COMMAND
<         if cmd == END and self.end is not None:
<             return self.end
< 
<         # GENERIC SEGMENT
<         return self.segment
< 
<     def set_document_statistics(self):
<         pattern = self.pattern
<         self.format_dictionary.update(pattern.extras)
< 
<         bounds = pattern.bounds()  # convert to mm.
<         width = bounds[2] - bounds[0]
<         height = bounds[3] - bounds[1]
< 
<         stitch_counts = {}
<         for s in pattern.stitches:
<             command = s[2] & COMMAND_MASK
<             if command in stitch_counts:
<                 stitch_counts[command] += 1
<             else:
<                 stitch_counts[command] = 1
< 
<         names = get_common_name_dictionary()
<         for name in names:
<             value = names[name].lower()
<             self.format_dictionary[value + "_count"] = stitch_counts.get(name,0)
<         self.format_dictionary.update(
<             {
<                 "stitch_total": pattern.count_stitches(),
<                 "thread_total": pattern.count_threads(),
<                 "extents_left": bounds[0],
<                 "extends_top": bounds[1],
<                 "extends_right": bounds[2],
<                 "extends_bottom": bounds[3],
<                 "extends_width": width,
<                 "extends_height": height,
<                 "extents_left_mm": bounds[0] / 10.0,
<                 "extends_top_mm": bounds[1] / 10.0,
<                 "extends_right_mm": bounds[2] / 10.0,
<                 "extends_bottom_mm": bounds[3] / 10.0,
<                 "extends_width_mm": width / 10.0,
<                 "extends_height_mm": height / 10.0,
<             }
<         )
< 
<     def update_positions(self, x, y, cmd):
<         self.dx = x - self.last_x
<         self.dy = y - self.last_y
<         idx = int(round(x - self.xx))
<         idy = int(round(y - self.yy))
<         self.xx += idx
<         self.yy += idy
<         self.format_dictionary.update(
<             {
<                 "x": x,
<                 "y": y,
<                 "z": self.z,
<                 "_x": -x,
<                 "_y": -y,
<                 "dx": self.dx,
<                 "dy": self.dy,
<                 "idx": idx,
<                 "idy": idy,
<                 "_idx": -idx,
<                 "_idy": -idy,
<                 "ix": self.xx,
<                 "iy": self.yy,
<                 "_ix": -self.xx,
<                 "_iy": -self.yy,
<                 "last_x": self.last_x,
<                 "last_y": self.last_y,
<                 "_last_x": -self.last_x,
<                 "_last_y": -self.last_y,
<             }
<         )
<         if cmd == STITCH:
<             self.z += self.z_increment
<         self.last_x = x
<         self.last_y = y
< 
<     def update_command(self):
<         try:
<             self.current_stitch = self.pattern.stitches[self.command_index]
< 
<             self.x, self.y, self.command = self.current_stitch
<             self.cmd, self.thread, self.needle, self.order = decode_embroidery_command(
<                 self.command
<             )
<             self.cmd_str = pyembroidery.get_common_name_dictionary()[self.cmd]
<         except IndexError:
<             self.current_stitch = None
<             self.x = None
<             self.y = None
<             self.command = None
<             self.cmd = None
<             self.thread = None
<             self.needle = None
<             self.order = None
<             self.cmd_str = None
<         self.format_dictionary.update(
<             {
<                 "index": self.command_index,
<                 "command": self.command,
<                 "cmd_str": self.cmd_str,
<                 "cmd": self.cmd,
<                 "cmd_thread": self.thread,
<                 "cmd_needle": self.needle,
<                 "cmd_order": self.order,
<             }
<         )
< 
<     def open_pattern(self):
<         if not self.pattern_established:
<             self.pattern_established = True
<             if self.pattern_start is not None:
<                 write_string_utf8(
<                     self.f, self.pattern_start.format_map(self.format_dictionary)
<                 )
< 
<     def open_document(self):
<         # DOCUMENT START
<         if not self.document_established:
<             self.document_established = True
<             self.document_index += 1
<             self.document_opening = True
<             self.color_index = 0
< 
<             self.format_dictionary.update(
<                 {
<                     "document_index": self.document_index,
<                     "document_index1": self.document_index + 1,
<                     "color_index": self.color_index,
<                     "color_index1": self.color_index + 1,
<                     "block_index": self.block_index,
<                     "block_index1": self.block_index + 1,
<                 }
<             )
< 
<     def open_color(self):
<         # COLOR START
<         if not self.color_established:
<             self.color_established = True
<             self.thread_index += 1
<             self.color_opening = True
< 
<             self.thread = self.pattern.get_thread_or_filler(self.thread_index)
<             self.block_index = 0
<             self.color_index += 1
<             self.format_dictionary.update(
<                 {
<                     "document_index": self.document_index,
<                     "document_index1": self.document_index + 1,
<                     "color_index": self.color_index,
<                     "color_index1": self.color_index + 1,
<                     "block_index": self.block_index,
<                     "block_index1": self.block_index + 1,
<                 }
<             )
< 
<     def open_block(self):
<         # BLOCK START
<         if not self.block_established:
<             self.block_established = True
<             self.block_index += 1
<             self.block_opening = True
<             self.format_dictionary.update(
<                 {
<                     "document_index": self.document_index,
<                     "document_index1": self.document_index + 1,
<                     "color_index": self.color_index,
<                     "color_index1": self.color_index + 1,
<                     "block_index": self.block_index,
<                     "block_index1": self.block_index + 1,
<                 }
<             )
< 
<     def write_segment(self, segment):
<         # SEGMENT
<         if self.segment_start is not None:
<             write_string_utf8(self.f, self.segment_start.format_map(self.format_dictionary))
< 
<         write_string_utf8(self.f, segment.format_map(self.format_dictionary))
< 
<         # SEGMENT JOIN
<         if self.segment_join is not None:
<             write_string_utf8(self.f, self.segment_join.format_map(self.format_dictionary))
< 
<         # SEGMENT_END
<         if self.segment_end is not None:
<             write_string_utf8(self.f, self.segment_end.format_map(self.format_dictionary))
< 
<     def close_pattern(self):
<         if self.pattern_established:
<             self.pattern_established = False
<             if self.pattern_end is not None:
<                 write_string_utf8(
<                     self.f, self.pattern_end.format_map(self.format_dictionary)
<                 )
< 
<     def close_document(self):
<         # DOCUMENT END
<         if self.document_established:
<             self.document_established = False
<             self.document_closing = True
< 
<     def close_color(self):
<         # COLOR END
<         if self.color_established:
<             self.color_established = False
<             self.color_closing = True
< 
<     def close_block(self):
<         # BLOCK END
<         if self.block_established:
<             self.block_established = False
<             self.block_closing = True
< 
<     def write(self):
<         # DOCUMENT STATISTICS
<         self.set_document_statistics()
< 
<         self.open_pattern()
<         if self.metadata_entry is not None:
<             for i, key in enumerate(self.pattern.extras):
<                 value = self.pattern.extras[key]
<                 self.format_dictionary.update({
<                     "metadata_index": i,
<                     "metadata_key": str(key),
<                     "metadata_value": str(value),
<                 })
<                 write_string_utf8(
<                     self.f, self.metadata_entry.format_map(self.format_dictionary)
<                 )
< 
<         if self.thread_entry is not None:
<             for i, thread in enumerate(self.pattern.threadlist):
<                 self.format_dictionary.update({
<                     "thread_index": i,
<                     "thread_color": thread.hex_color(),
<                     "thread_description": thread.description,
<                     "thread_brand": thread.brand,
<                     "thread_catalog_number": thread.catalog_number,
<                     "thread_chart": thread.chart,
<                     "thread_details": thread.details,
<                     "thread_weight": thread.weight,
<                     "thread_red": thread.get_red(),
<                     "thread_green": thread.get_green(),
<                     "thread_blue": thread.get_blue(),
<                 })
<                 write_string_utf8(
<                     self.f, self.thread_entry.format_map(self.format_dictionary)
<                 )
<         for self.command_index in range(0, len(self.pattern.stitches)):
<             self.update_command()
<             write_segment = self.get_write_segment(self.cmd)
< 
<             # MAIN CODE, there is something to write.
<             if write_segment is not None:
<                 if isinstance(write_segment, dict):
<                     key, default = write_segment[None]
<                     key = key.format_map(self.format_dictionary)
<                     write_segment = write_segment.get(key, default)
<                 self.update_positions(self.x, self.y, self.cmd)
<                 if self.cmd == SEQUIN_MODE:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # SEQUIN
<                 if self.cmd == SEQUIN_EJECT:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # STITCH
<                 if self.cmd == STITCH:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # TRIM
<                 if self.cmd == TRIM:
<                     self.open_document()
<                     self.open_color()
< 
<                 # JUMP
<                 if self.cmd == JUMP:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # COLOR CHANGE
<                 if self.cmd == COLOR_CHANGE:
<                     self.open_document()
< 
<                 # NEEDLE SET
<                 if self.cmd == NEEDLE_SET:
<                     self.open_document()
<                     self.open_color()
< 
<                 # STOP COMMAND
<                 if self.cmd == STOP:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # SLOW COMMAND
<                 if self.cmd == SLOW:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # FAST COMMAND
<                 if self.cmd == FAST:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 # END COMMAND
<                 if self.cmd == END:
<                     self.open_document()
<                     self.open_color()
<                     self.open_block()
< 
<                 self.write_opens()
<                 self.write_segment(write_segment)
< 
<                 if self.cmd == SEQUIN_MODE:
<                     pass
< 
<                 # SEQUIN
<                 if self.cmd == SEQUIN_EJECT:
<                     pass
< 
<                 # STITCH
<                 if self.cmd == STITCH:
<                     pass
< 
<                 # TRIM
<                 if self.cmd == TRIM:
<                     self.close_block()
< 
<                 # JUMP
<                 if self.cmd == JUMP:
<                     pass
< 
<                 # COLOR CHANGE
<                 if self.cmd == COLOR_CHANGE:
<                     self.close_block()
<                     self.close_color()
< 
<                 # NEEDLE SET
<                 if self.cmd == NEEDLE_SET:
<                     pass
< 
<                 # STOP COMMAND
<                 if self.cmd == STOP:
<                     pass
< 
<                 # SLOW COMMAND
<                 if self.cmd == SLOW:
<                     pass
< 
<                 # FAST COMMAND
<                 if self.cmd == FAST:
<                     pass
< 
<                 # END COMMAND
<                 if self.cmd == END:
<                     self.close_block()
<                     self.close_color()
<                     self.close_document()
<                 self.write_closes()
< 
<         self.close_block()
<         self.close_color()
<         self.close_document()
<         self.close_pattern()
---
> import pyembroidery
> from pyembroidery import (
>     CONTINGENCY_SEQUIN_UTILIZE,
>     decode_embroidery_command,
>     STITCH,
>     COLOR_CHANGE,
>     NEEDLE_SET,
>     TRIM,
>     JUMP,
>     SEQUIN_MODE,
>     SEQUIN_EJECT,
>     STOP,
>     SLOW,
>     FAST,
>     END,
>     get_common_name_dictionary,
>     COMMAND_MASK,
> )
> from pyembroidery.WriteHelper import write_string_utf8
> 
> WRITES_SPEEDS = True
> SEQUIN_CONTINGENCY = CONTINGENCY_SEQUIN_UTILIZE
> 
> 
> def write(pattern, f, settings=None):
>     writer = GenericWriter(pattern, f, settings)
>     writer.write()
> 
> 
> class GenericWriter:
>     """
>     Generic Writer will write generic data fit to a formatted set of strings.
> 
>     Blocks are established by the first segment.
>     Colors are established by the first segment or the first segment after a color change or by a needle_set.
>     Documents are established by the first segment, or the first segment after an end.
> 
>     Segment is the default for any-command. Specific commands override segment.
> 
>     stitch is the default stitch.
>     stitch_first overrides stitch for the first stitch in a block.
>     stitch_last overrides stitch for the last stitch in a block.
> 
>     trims and jumps occurring before a color change belong to the previous color.
>     trims and jumps occurring after a color change belong to the next color.
> 
>     Missing segments are treated as if they never existed. Value properties will differ if segments are excluded.
>     """
> 
>     def __init__(self, pattern, f, settings):
>         self.pattern = pattern
>         self.f = f
>         self.settings = settings
>         self.metadata_entry = settings.get("metadata_entry", None)
>         self.thread_entry = settings.get("thread_entry", None)
>         self.pattern_start = settings.get("pattern_start", None)
>         self.pattern_end = settings.get("pattern_end", None)
>         self.document_start = settings.get("document_start", None)
>         self.document_end = settings.get("document_end", None)
>         self.color_start = settings.get("color_start", None)
>         self.color_end = settings.get("color_end", None)
>         self.color_join = settings.get("color_join", None)
>         self.block_start = settings.get("block_start", None)
>         self.block_end = settings.get("block_end", None)
>         self.block_join = settings.get("block_join", None)
>         self.segment_start = settings.get("segment_start", None)
>         self.segment = settings.get("segment", None)
>         self.segment_end = settings.get("segment_end", None)
>         self.segment_join = settings.get("segment_join", None)
>         self.stitch_first = settings.get("stitch_first", None)
>         self.stitch_last = settings.get("stitch_last", None)
>         self.stitch = settings.get("stitch", None)
>         self.stop = settings.get("stop", None)
>         self.jump = settings.get("jump", None)
>         self.trim = settings.get("trim", None)
>         self.needle_set = settings.get("needle_set", None)
>         self.color_change = settings.get("color_change", None)
>         self.sequin = settings.get("sequin", None)
>         self.sequin_mode = settings.get("sequin_mode", None)
>         self.slow = settings.get("slow", None)
>         self.fast = settings.get("fast", None)
>         self.end = settings.get("end", None)
> 
>         self.format_dictionary = {}
>         self.pattern_established = False
>         self.document_established = False
>         self.color_established = False
>         self.block_established = False
>         self.document_index = -1
>         self.thread = None
>         self.thread_index = -1
>         self.stitch_index = -1
>         self.color_index = -1
>         self.block_index = -1
>         self.dx = 0
>         self.dy = 0
>         self.xx = 0
>         self.yy = 0
>         self.last_x = 0
>         self.last_y = 0
>         self.z = 0.0
>         self.z_increment = settings.get("stitch_z_travel", 10.0)
>         self.command_index = 0
> 
>         self.current_stitch = None
>         self.x = None
>         self.y = None
>         self.command = None
>         self.cmd = None
>         self.thread = None
>         self.needle = None
>         self.order = None
>         self.cmd_str = None
> 
>         self.block_closing = False
>         self.color_closing = False
>         self.document_closing = False
> 
>         self.block_opening = False
>         self.color_opening = False
>         self.document_opening = False
> 
>     def write_opens(self):
>         if self.document_opening:
>             self.document_opening = False
>             if self.document_start is not None:
>                 write_string_utf8(self.f, self.document_start.format_map(self.format_dictionary))
>         if self.color_opening:
>             self.color_opening = False
>             if self.color_join is not None and self.color_index != 0:
>                 write_string_utf8(self.f, self.color_join.format_map(self.format_dictionary))
>             if self.color_start is not None:
>                 write_string_utf8(self.f, self.color_start.format_map(self.format_dictionary))
>         if self.block_opening:
>             self.block_opening = False
>             if self.block_join is not None and self.block_index != 0:
>                 write_string_utf8(self.f, self.block_join.format_map(self.format_dictionary))
>             if self.block_start is not None:
>                 write_string_utf8(self.f, self.block_start.format_map(self.format_dictionary))
> 
>     def write_closes(self):
>         if self.block_closing:
>             self.block_closing = False
>             if self.block_end is not None:
>                 write_string_utf8(self.f, self.block_end.format_map(self.format_dictionary))
>         if self.color_closing:
>             self.color_closing = False
>             if self.color_end is not None:
>                 write_string_utf8(self.f, self.color_end.format_map(self.format_dictionary))
>         if self.document_closing:
>             self.document_closing = False
>             if self.document_end is not None:
>                 write_string_utf8(self.f, self.document_end.format_map(self.format_dictionary))
> 
>     def get_write_segment(self, cmd):
>         # SEQUIN_MODE
>         if cmd == SEQUIN_MODE and self.sequin_mode is not None:
>             return self.sequin_mode
> 
>         # SEQUIN
>         if cmd == SEQUIN_EJECT and self.sequin is not None:
>             return self.sequin
> 
>         # STITCH
>         if cmd == STITCH and self.stitch is not None:
>             return self.stitch
> 
>         # TRIM
>         if cmd == TRIM and self.trim is not None:
>             return self.trim
> 
>         # JUMP
>         if cmd == JUMP and self.jump is not None:
>             return self.jump
> 
>         # COLOR CHANGE
>         if cmd == COLOR_CHANGE and self.color_change is not None:
>             return self.color_change
> 
>         # NEEDLE SET
>         if cmd == NEEDLE_SET and self.needle_set is not None:
>             return self.needle_set
> 
>         # STOP COMMAND
>         if cmd == STOP and self.stop is not None:
>             return self.stop
> 
>         # SLOW COMMAND
>         if cmd == SLOW and self.slow is not None:
>             return self.slow
> 
>         # FAST COMMAND
>         if cmd == FAST and self.fast is not None:
>             return self.fast
> 
>         # END COMMAND
>         if cmd == END and self.end is not None:
>             return self.end
> 
>         # GENERIC SEGMENT
>         return self.segment
> 
>     def set_document_statistics(self):
>         pattern = self.pattern
>         self.format_dictionary.update(pattern.extras)
> 
>         bounds = pattern.bounds()  # convert to mm.
>         width = bounds[2] - bounds[0]
>         height = bounds[3] - bounds[1]
> 
>         stitch_counts = {}
>         for s in pattern.stitches:
>             command = s[2] & COMMAND_MASK
>             if command in stitch_counts:
>                 stitch_counts[command] += 1
>             else:
>                 stitch_counts[command] = 1
> 
>         names = get_common_name_dictionary()
>         for name in names:
>             value = names[name].lower()
>             self.format_dictionary[value + "_count"] = stitch_counts.get(name,0)
>         self.format_dictionary.update(
>             {
>                 "stitch_total": pattern.count_stitches(),
>                 "thread_total": pattern.count_threads(),
>                 "extents_left": bounds[0],
>                 "extends_top": bounds[1],
>                 "extends_right": bounds[2],
>                 "extends_bottom": bounds[3],
>                 "extends_width": width,
>                 "extends_height": height,
>                 "extents_left_mm": bounds[0] / 10.0,
>                 "extends_top_mm": bounds[1] / 10.0,
>                 "extends_right_mm": bounds[2] / 10.0,
>                 "extends_bottom_mm": bounds[3] / 10.0,
>                 "extends_width_mm": width / 10.0,
>                 "extends_height_mm": height / 10.0,
>             }
>         )
> 
>     def update_positions(self, x, y, cmd):
>         self.dx = x - self.last_x
>         self.dy = y - self.last_y
>         idx = int(round(x - self.xx))
>         idy = int(round(y - self.yy))
>         self.xx += idx
>         self.yy += idy
>         self.format_dictionary.update(
>             {
>                 "x": x,
>                 "y": y,
>                 "z": self.z,
>                 "_x": -x,
>                 "_y": -y,
>                 "dx": self.dx,
>                 "dy": self.dy,
>                 "idx": idx,
>                 "idy": idy,
>                 "_idx": -idx,
>                 "_idy": -idy,
>                 "ix": self.xx,
>                 "iy": self.yy,
>                 "_ix": -self.xx,
>                 "_iy": -self.yy,
>                 "last_x": self.last_x,
>                 "last_y": self.last_y,
>                 "_last_x": -self.last_x,
>                 "_last_y": -self.last_y,
>             }
>         )
>         if cmd == STITCH:
>             self.z += self.z_increment
>         self.last_x = x
>         self.last_y = y
> 
>     def update_command(self):
>         try:
>             self.current_stitch = self.pattern.stitches[self.command_index]
> 
>             self.x, self.y, self.command = self.current_stitch
>             self.cmd, self.thread, self.needle, self.order = decode_embroidery_command(
>                 self.command
>             )
>             self.cmd_str = pyembroidery.get_common_name_dictionary()[self.cmd]
>         except IndexError:
>             self.current_stitch = None
>             self.x = None
>             self.y = None
>             self.command = None
>             self.cmd = None
>             self.thread = None
>             self.needle = None
>             self.order = None
>             self.cmd_str = None
>         self.format_dictionary.update(
>             {
>                 "index": self.command_index,
>                 "command": self.command,
>                 "cmd_str": self.cmd_str,
>                 "cmd": self.cmd,
>                 "cmd_thread": self.thread,
>                 "cmd_needle": self.needle,
>                 "cmd_order": self.order,
>             }
>         )
> 
>     def open_pattern(self):
>         if not self.pattern_established:
>             self.pattern_established = True
>             if self.pattern_start is not None:
>                 write_string_utf8(
>                     self.f, self.pattern_start.format_map(self.format_dictionary)
>                 )
> 
>     def open_document(self):
>         # DOCUMENT START
>         if not self.document_established:
>             self.document_established = True
>             self.document_index += 1
>             self.document_opening = True
>             self.color_index = 0
> 
>             self.format_dictionary.update(
>                 {
>                     "document_index": self.document_index,
>                     "document_index1": self.document_index + 1,
>                     "color_index": self.color_index,
>                     "color_index1": self.color_index + 1,
>                     "block_index": self.block_index,
>                     "block_index1": self.block_index + 1,
>                 }
>             )
> 
>     def open_color(self):
>         # COLOR START
>         if not self.color_established:
>             self.color_established = True
>             self.thread_index += 1
>             self.color_opening = True
> 
>             self.thread = self.pattern.get_thread_or_filler(self.thread_index)
>             self.block_index = 0
>             self.color_index += 1
>             self.format_dictionary.update(
>                 {
>                     "document_index": self.document_index,
>                     "document_index1": self.document_index + 1,
>                     "color_index": self.color_index,
>                     "color_index1": self.color_index + 1,
>                     "block_index": self.block_index,
>                     "block_index1": self.block_index + 1,
>                 }
>             )
> 
>     def open_block(self):
>         # BLOCK START
>         if not self.block_established:
>             self.block_established = True
>             self.block_index += 1
>             self.block_opening = True
>             self.format_dictionary.update(
>                 {
>                     "document_index": self.document_index,
>                     "document_index1": self.document_index + 1,
>                     "color_index": self.color_index,
>                     "color_index1": self.color_index + 1,
>                     "block_index": self.block_index,
>                     "block_index1": self.block_index + 1,
>                 }
>             )
> 
>     def write_segment(self, segment):
>         # SEGMENT
>         if self.segment_start is not None:
>             write_string_utf8(self.f, self.segment_start.format_map(self.format_dictionary))
> 
>         write_string_utf8(self.f, segment.format_map(self.format_dictionary))
> 
>         # SEGMENT JOIN
>         if self.segment_join is not None:
>             write_string_utf8(self.f, self.segment_join.format_map(self.format_dictionary))
> 
>         # SEGMENT_END
>         if self.segment_end is not None:
>             write_string_utf8(self.f, self.segment_end.format_map(self.format_dictionary))
> 
>     def close_pattern(self):
>         if self.pattern_established:
>             self.pattern_established = False
>             if self.pattern_end is not None:
>                 write_string_utf8(
>                     self.f, self.pattern_end.format_map(self.format_dictionary)
>                 )
> 
>     def close_document(self):
>         # DOCUMENT END
>         if self.document_established:
>             self.document_established = False
>             self.document_closing = True
> 
>     def close_color(self):
>         # COLOR END
>         if self.color_established:
>             self.color_established = False
>             self.color_closing = True
> 
>     def close_block(self):
>         # BLOCK END
>         if self.block_established:
>             self.block_established = False
>             self.block_closing = True
> 
>     def write(self):
>         # DOCUMENT STATISTICS
>         self.set_document_statistics()
> 
>         self.open_pattern()
>         if self.metadata_entry is not None:
>             for i, key in enumerate(self.pattern.extras):
>                 value = self.pattern.extras[key]
>                 self.format_dictionary.update({
>                     "metadata_index": i,
>                     "metadata_key": str(key),
>                     "metadata_value": str(value),
>                 })
>                 write_string_utf8(
>                     self.f, self.metadata_entry.format_map(self.format_dictionary)
>                 )
> 
>         if self.thread_entry is not None:
>             for i, thread in enumerate(self.pattern.threadlist):
>                 self.format_dictionary.update({
>                     "thread_index": i,
>                     "thread_color": thread.hex_color(),
>                     "thread_description": thread.description,
>                     "thread_brand": thread.brand,
>                     "thread_catalog_number": thread.catalog_number,
>                     "thread_chart": thread.chart,
>                     "thread_details": thread.details,
>                     "thread_weight": thread.weight,
>                     "thread_red": thread.get_red(),
>                     "thread_green": thread.get_green(),
>                     "thread_blue": thread.get_blue(),
>                 })
>                 write_string_utf8(
>                     self.f, self.thread_entry.format_map(self.format_dictionary)
>                 )
>         for self.command_index in range(0, len(self.pattern.stitches)):
>             self.update_command()
>             write_segment = self.get_write_segment(self.cmd)
> 
>             # MAIN CODE, there is something to write.
>             if write_segment is not None:
>                 if isinstance(write_segment, dict):
>                     key, default = write_segment[None]
>                     key = key.format_map(self.format_dictionary)
>                     write_segment = write_segment.get(key, default)
>                 self.update_positions(self.x, self.y, self.cmd)
>                 if self.cmd == SEQUIN_MODE:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # SEQUIN
>                 if self.cmd == SEQUIN_EJECT:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # STITCH
>                 if self.cmd == STITCH:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # TRIM
>                 if self.cmd == TRIM:
>                     self.open_document()
>                     self.open_color()
> 
>                 # JUMP
>                 if self.cmd == JUMP:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # COLOR CHANGE
>                 if self.cmd == COLOR_CHANGE:
>                     self.open_document()
> 
>                 # NEEDLE SET
>                 if self.cmd == NEEDLE_SET:
>                     self.open_document()
>                     self.open_color()
> 
>                 # STOP COMMAND
>                 if self.cmd == STOP:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # SLOW COMMAND
>                 if self.cmd == SLOW:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # FAST COMMAND
>                 if self.cmd == FAST:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 # END COMMAND
>                 if self.cmd == END:
>                     self.open_document()
>                     self.open_color()
>                     self.open_block()
> 
>                 self.write_opens()
>                 self.write_segment(write_segment)
> 
>                 if self.cmd == SEQUIN_MODE:
>                     pass
> 
>                 # SEQUIN
>                 if self.cmd == SEQUIN_EJECT:
>                     pass
> 
>                 # STITCH
>                 if self.cmd == STITCH:
>                     pass
> 
>                 # TRIM
>                 if self.cmd == TRIM:
>                     self.close_block()
> 
>                 # JUMP
>                 if self.cmd == JUMP:
>                     pass
> 
>                 # COLOR CHANGE
>                 if self.cmd == COLOR_CHANGE:
>                     self.close_block()
>                     self.close_color()
> 
>                 # NEEDLE SET
>                 if self.cmd == NEEDLE_SET:
>                     pass
> 
>                 # STOP COMMAND
>                 if self.cmd == STOP:
>                     pass
> 
>                 # SLOW COMMAND
>                 if self.cmd == SLOW:
>                     pass
> 
>                 # FAST COMMAND
>                 if self.cmd == FAST:
>                     pass
> 
>                 # END COMMAND
>                 if self.cmd == END:
>                     self.close_block()
>                     self.close_color()
>                     self.close_document()
>                 self.write_closes()
> 
>         self.close_block()
>         self.close_color()
>         self.close_document()
>         self.close_pattern()
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/__init__.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/pyembroidery/__init__.py
1,14c1,14
< name = "pyembroidery"
< 
< # items available at the top level (e.g. pyembroidery.read)
< from .EmbConstant import *
< from .EmbFunctions import *
< from .EmbMatrix import EmbMatrix
< from .EmbPattern import EmbPattern
< from .EmbThread import EmbThread
< from .EmbCompress import compress, expand
< import pyembroidery.GenericWriter as GenericWriter
< 
< # items available in a sub-heirarchy (e.g. pyembroidery.PecGraphics.get_graphic_as_string)
< from .PecGraphics import get_graphic_as_string
< from .PyEmbroidery import *
---
> name = "pyembroidery"
> 
> # items available at the top level (e.g. pyembroidery.read)
> from .EmbConstant import *
> from .EmbFunctions import *
> from .EmbMatrix import EmbMatrix
> from .EmbPattern import EmbPattern
> from .EmbThread import EmbThread
> from .EmbCompress import compress, expand
> import pyembroidery.GenericWriter as GenericWriter
> 
> # items available in a sub-heirarchy (e.g. pyembroidery.PecGraphics.get_graphic_as_string)
> from .PecGraphics import get_graphic_as_string
> from .PyEmbroidery import *
Only in lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: pyembroidery.egg-info
Only in source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: requirements.txt
Only in lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: setup.cfg
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_catalog.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_catalog.py
1,14c1,14
< from __future__ import print_function
< 
< import unittest
< from test.pattern_for_tests import *
< 
< 
< class TestDataCatalog(unittest.TestCase):
< 
<     def test_catalog_files(self):
<         for f in EmbPattern.supported_formats():
<             self.assertIn("extensions", f)
<             self.assertIn("extension", f)
<             self.assertIn("description", f)
<             self.assertIn("category", f)
---
> from __future__ import print_function
> 
> import unittest
> from test.pattern_for_tests import *
> 
> 
> class TestDataCatalog(unittest.TestCase):
> 
>     def test_catalog_files(self):
>         for f in EmbPattern.supported_formats():
>             self.assertIn("extensions", f)
>             self.assertIn("extension", f)
>             self.assertIn("description", f)
>             self.assertIn("category", f)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_color_fileformats.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_color_fileformats.py
1,102c1,102
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestColorFormats(unittest.TestCase):
< 
<     def test_write_read_col(self):
<         file1 = "color.col"
<         for m in range(0,50):
<             pattern = EmbPattern()
<             for i in range(4, 20):
<                 pattern.add_thread(EmbThread("random"))
<             write(pattern, file1)
<             w_pattern = read(file1)
<             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<             for q in range(0,len(pattern.threadlist)):
<                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_read_edr(self):
<         file1 = "color.edr"
<         for m in range(0, 50):
<             pattern = EmbPattern()
<             for i in range(4, 20):
<                 pattern.add_thread(EmbThread("random"))
<             write(pattern, file1)
<             w_pattern = read(file1)
<             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<             for q in range(0, len(pattern.threadlist)):
<                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_read_inf(self):
<         file1 = "color.inf"
<         for m in range(0, 50):
<             pattern = EmbPattern()
<             for i in range(4, 20):
<                 pattern.add_thread(EmbThread("random"))
<             write(pattern, file1)
<             w_pattern = read(file1)
<             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<             for q in range(0, len(pattern.threadlist)):
<                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_edr_dst(self):
<         pattern = get_shift_pattern()
<         file1 = "color.edr"
<         file2 = "color.dst"
<         write(pattern, file1)
<         write(pattern, file2)
<         w_pattern = read(file1)
<         w_pattern = read(file2, pattern=w_pattern)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_write_dst_edr(self):
<         pattern = get_shift_pattern()
<         file1 = "color.dst"
<         file2 = "color.edr"
<         write(pattern, file1)
<         write(pattern, file2)
<         w_pattern = read(file1)
<         w_pattern = read(file2, pattern=w_pattern)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_write_dst_col(self):
<         pattern = get_shift_pattern()
<         file1 = "color.dst"
<         file2 = "color.col"
<         write(pattern, file1)
<         write(pattern, file2)
<         w_pattern = read(file1)
<         w_pattern = read(file2, pattern=w_pattern)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_write_dst_inf(self):
<         pattern = get_shift_pattern()
<         file1 = "color.dst"
<         file2 = "color.inf"
<         write(pattern, file1)
<         write(pattern, file2)
<         w_pattern = read(file1)
<         w_pattern = read(file2, pattern=w_pattern)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestColorFormats(unittest.TestCase):
> 
>     def test_write_read_col(self):
>         file1 = "color.col"
>         for m in range(0,50):
>             pattern = EmbPattern()
>             for i in range(4, 20):
>                 pattern.add_thread(EmbThread("random"))
>             write(pattern, file1)
>             w_pattern = read(file1)
>             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>             for q in range(0,len(pattern.threadlist)):
>                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_read_edr(self):
>         file1 = "color.edr"
>         for m in range(0, 50):
>             pattern = EmbPattern()
>             for i in range(4, 20):
>                 pattern.add_thread(EmbThread("random"))
>             write(pattern, file1)
>             w_pattern = read(file1)
>             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>             for q in range(0, len(pattern.threadlist)):
>                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_read_inf(self):
>         file1 = "color.inf"
>         for m in range(0, 50):
>             pattern = EmbPattern()
>             for i in range(4, 20):
>                 pattern.add_thread(EmbThread("random"))
>             write(pattern, file1)
>             w_pattern = read(file1)
>             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>             for q in range(0, len(pattern.threadlist)):
>                 self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_edr_dst(self):
>         pattern = get_shift_pattern()
>         file1 = "color.edr"
>         file2 = "color.dst"
>         write(pattern, file1)
>         write(pattern, file2)
>         w_pattern = read(file1)
>         w_pattern = read(file2, pattern=w_pattern)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_write_dst_edr(self):
>         pattern = get_shift_pattern()
>         file1 = "color.dst"
>         file2 = "color.edr"
>         write(pattern, file1)
>         write(pattern, file2)
>         w_pattern = read(file1)
>         w_pattern = read(file2, pattern=w_pattern)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_write_dst_col(self):
>         pattern = get_shift_pattern()
>         file1 = "color.dst"
>         file2 = "color.col"
>         write(pattern, file1)
>         write(pattern, file2)
>         w_pattern = read(file1)
>         w_pattern = read(file2, pattern=w_pattern)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_write_dst_inf(self):
>         pattern = get_shift_pattern()
>         file1 = "color.dst"
>         file2 = "color.inf"
>         write(pattern, file1)
>         write(pattern, file2)
>         w_pattern = read(file1)
>         w_pattern = read(file2, pattern=w_pattern)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q].color, w_pattern.threadlist[q].color)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_csv.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_csv.py
1,170c1,170
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_csv_to_u01(self):
<         file1 = "convert_u01.csv"
<         file2 = "converted_csv.u01"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_csv(self):
<         file1 = "convert_csv.csv"
<         file2 = "converted_csv.csv"
<         write_csv(get_big_pattern(), file1, {"encode": True})
<         f_pattern = read_csv(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_exp(self):
<         file1 = "convert_exp.csv"
<         file2 = "converted_csv.exp"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_pes(self):
<         file1 = "convert_pes.csv"
<         file2 = "converted_csv.pes"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_jef(self):
<         file1 = "convert_jef.csv"
<         file2 = "converted_csv.jef"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_pec(self):
<         file1 = "convert_pec.csv"
<         file2 = "converted_csv.pec"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_vp3(self):
<         file1 = "convert_vp3.csv"
<         file2 = "converted_csv.vp3"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_dst(self):
<         file1 = "convert_dst.csv"
<         file2 = "converted_csv.dst"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_gcode(self):
<         file1 = "convert_gcode.csv"
<         file2 = "converted_csv.gcode"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_csv_to_xxx(self):
<         file1 = "convert_xxx.csv"
<         file2 = "converted_csv.xxx"
<         write_csv(get_big_pattern(), file1)
<         f_pattern = read_csv(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("csv->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_csv_to_u01(self):
>         file1 = "convert_u01.csv"
>         file2 = "converted_csv.u01"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_csv(self):
>         file1 = "convert_csv.csv"
>         file2 = "converted_csv.csv"
>         write_csv(get_big_pattern(), file1, {"encode": True})
>         f_pattern = read_csv(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_exp(self):
>         file1 = "convert_exp.csv"
>         file2 = "converted_csv.exp"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_pes(self):
>         file1 = "convert_pes.csv"
>         file2 = "converted_csv.pes"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_jef(self):
>         file1 = "convert_jef.csv"
>         file2 = "converted_csv.jef"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_pec(self):
>         file1 = "convert_pec.csv"
>         file2 = "converted_csv.pec"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_vp3(self):
>         file1 = "convert_vp3.csv"
>         file2 = "converted_csv.vp3"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_dst(self):
>         file1 = "convert_dst.csv"
>         file2 = "converted_csv.dst"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_gcode(self):
>         file1 = "convert_gcode.csv"
>         file2 = "converted_csv.gcode"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_csv_to_xxx(self):
>         file1 = "convert_xxx.csv"
>         file2 = "converted_csv.xxx"
>         write_csv(get_big_pattern(), file1)
>         f_pattern = read_csv(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("csv->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_dst.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_dst.py
1,170c1,170
< from __future__ import print_function
< 
< import unittest
< from pyembroidery import *
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_dst_to_u01(self):
<         file1 = "convert_u01.dst"
<         file2 = "converted_dst.u01"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_csv(self):
<         file1 = "convert_csv.dst"
<         file2 = "converted_dst.csv"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_exp(self):
<         file1 = "convert_exp.dst"
<         file2 = "converted_dst.exp"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_pes(self):
<         file1 = "convert_pes.dst"
<         file2 = "converted_dst.pes"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_jef(self):
<         file1 = "convert_jef.dst"
<         file2 = "converted_dst.jef"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_pec(self):
<         file1 = "convert_pec.dst"
<         file2 = "converted_dst.pec"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_vp3(self):
<         file1 = "convert_vp3.dst"
<         file2 = "converted_dst.vp3"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_dst(self):
<         file1 = "convert_dst.dst"
<         file2 = "converted_dst.dst"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_dst_to_gcode(self):
<         file1 = "convert_gcode.dst"
<         file2 = "converted_dst.gcode"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_dst_to_xxx(self):
<         file1 = "convert_xxx.dst"
<         file2 = "converted_dst.xxx"
<         write_dst(get_big_pattern(), file1)
<         f_pattern = read_dst(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("dst->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> from pyembroidery import *
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_dst_to_u01(self):
>         file1 = "convert_u01.dst"
>         file2 = "converted_dst.u01"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_csv(self):
>         file1 = "convert_csv.dst"
>         file2 = "converted_dst.csv"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_exp(self):
>         file1 = "convert_exp.dst"
>         file2 = "converted_dst.exp"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_pes(self):
>         file1 = "convert_pes.dst"
>         file2 = "converted_dst.pes"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_jef(self):
>         file1 = "convert_jef.dst"
>         file2 = "converted_dst.jef"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_pec(self):
>         file1 = "convert_pec.dst"
>         file2 = "converted_dst.pec"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_vp3(self):
>         file1 = "convert_vp3.dst"
>         file2 = "converted_dst.vp3"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_dst(self):
>         file1 = "convert_dst.dst"
>         file2 = "converted_dst.dst"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_dst_to_gcode(self):
>         file1 = "convert_gcode.dst"
>         file2 = "converted_dst.gcode"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_dst_to_xxx(self):
>         file1 = "convert_xxx.dst"
>         file2 = "converted_dst.xxx"
>         write_dst(get_big_pattern(), file1)
>         f_pattern = read_dst(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("dst->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_exp.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_exp.py
1,170c1,170
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_exp_to_u01(self):
<         file1 = "convert_u01.exp"
<         file2 = "converted_exp.u01"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_csv(self):
<         file1 = "convert_csv.exp"
<         file2 = "converted_exp.csv"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_exp(self):
<         file1 = "convert_exp.exp"
<         file2 = "converted_exp.exp"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_pes(self):
<         file1 = "convert_pes.exp"
<         file2 = "converted_exp.pes"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_jef(self):
<         file1 = "convert_jef.exp"
<         file2 = "converted_exp.jef"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_pec(self):
<         file1 = "convert_pec.exp"
<         file2 = "converted_exp.pec"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_vp3(self):
<         file1 = "convert_vp3.exp"
<         file2 = "converted_exp.vp3"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_dst(self):
<         file1 = "convert_dst.exp"
<         file2 = "converted_exp.dst"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_exp_to_gcode(self):
<         file1 = "convert_gcode.exp"
<         file2 = "converted_exp.gcode"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_exp_to_xxx(self):
<         file1 = "convert_xxx.exp"
<         file2 = "converted_exp.xxx"
<         write_exp(get_big_pattern(), file1)
<         f_pattern = read_exp(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("exp->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_exp_to_u01(self):
>         file1 = "convert_u01.exp"
>         file2 = "converted_exp.u01"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_csv(self):
>         file1 = "convert_csv.exp"
>         file2 = "converted_exp.csv"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_exp(self):
>         file1 = "convert_exp.exp"
>         file2 = "converted_exp.exp"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_pes(self):
>         file1 = "convert_pes.exp"
>         file2 = "converted_exp.pes"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_jef(self):
>         file1 = "convert_jef.exp"
>         file2 = "converted_exp.jef"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_pec(self):
>         file1 = "convert_pec.exp"
>         file2 = "converted_exp.pec"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_vp3(self):
>         file1 = "convert_vp3.exp"
>         file2 = "converted_exp.vp3"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_dst(self):
>         file1 = "convert_dst.exp"
>         file2 = "converted_exp.dst"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_exp_to_gcode(self):
>         file1 = "convert_gcode.exp"
>         file2 = "converted_exp.gcode"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_exp_to_xxx(self):
>         file1 = "convert_xxx.exp"
>         file2 = "converted_exp.xxx"
>         write_exp(get_big_pattern(), file1)
>         f_pattern = read_exp(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("exp->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_gcode.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_gcode.py
1,170c1,170
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_gcode_to_u01(self):
<         file1 = "convert_u01.gcode"
<         file2 = "converted_gcode.u01"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_csv(self):
<         file1 = "convert_csv.gcode"
<         file2 = "converted_gcode.csv"
<         write_gcode(get_big_pattern(), file1, {"encode": True})
<         f_pattern = read_gcode(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_exp(self):
<         file1 = "convert_exp.gcode"
<         file2 = "converted_gcode.exp"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_pes(self):
<         file1 = "convert_pes.gcode"
<         file2 = "converted_gcode.pes"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_jef(self):
<         file1 = "convert_jef.gcode"
<         file2 = "converted_gcode.jef"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_pec(self):
<         file1 = "convert_pec.gcode"
<         file2 = "converted_gcode.pec"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_vp3(self):
<         file1 = "convert_vp3.gcode"
<         file2 = "converted_gcode.vp3"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_dst(self):
<         file1 = "convert_dst.gcode"
<         file2 = "converted_gcode.dst"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_gcode_to_gcode(self):
<         file1 = "convert_gcode.gcode"
<         file2 = "converted_gcode.gcode"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_gcode_to_xxx(self):
<         file1 = "convert_xxx.gcode"
<         file2 = "converted_gcode.xxx"
<         write_gcode(get_big_pattern(), file1)
<         f_pattern = read_gcode(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("gcode->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_gcode_to_u01(self):
>         file1 = "convert_u01.gcode"
>         file2 = "converted_gcode.u01"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_csv(self):
>         file1 = "convert_csv.gcode"
>         file2 = "converted_gcode.csv"
>         write_gcode(get_big_pattern(), file1, {"encode": True})
>         f_pattern = read_gcode(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_exp(self):
>         file1 = "convert_exp.gcode"
>         file2 = "converted_gcode.exp"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_pes(self):
>         file1 = "convert_pes.gcode"
>         file2 = "converted_gcode.pes"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_jef(self):
>         file1 = "convert_jef.gcode"
>         file2 = "converted_gcode.jef"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_pec(self):
>         file1 = "convert_pec.gcode"
>         file2 = "converted_gcode.pec"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_vp3(self):
>         file1 = "convert_vp3.gcode"
>         file2 = "converted_gcode.vp3"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_dst(self):
>         file1 = "convert_dst.gcode"
>         file2 = "converted_gcode.dst"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_gcode_to_gcode(self):
>         file1 = "convert_gcode.gcode"
>         file2 = "converted_gcode.gcode"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_gcode_to_xxx(self):
>         file1 = "convert_xxx.gcode"
>         file2 = "converted_gcode.xxx"
>         write_gcode(get_big_pattern(), file1)
>         f_pattern = read_gcode(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("gcode->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_jef.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_jef.py
1,200c1,200
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_jef_to_u01(self):
<         file1 = "convert_u01.jef"
<         file2 = "converted_jef.u01"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_csv(self):
<         file1 = "convert_csv.jef"
<         file2 = "converted_jef.csv"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_exp(self):
<         file1 = "convert_exp.jef"
<         file2 = "converted_jef.exp"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_pes(self):
<         file1 = "convert_pes.jef"
<         file2 = "converted_jef.pes"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_jef(self):
<         file1 = "convert_jef.jef"
<         file2 = "converted_jef.jef"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_pec(self):
<         file1 = "convert_pec.jef"
<         file2 = "converted_jef.pec"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_vp3(self):
<         file1 = "convert_vp3.jef"
<         file2 = "converted_jef.vp3"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_dst(self):
<         file1 = "convert_dst.jef"
<         file2 = "converted_jef.dst"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_jef_to_gcode(self):
<         file1 = "convert_gcode.jef"
<         file2 = "converted_jef.gcode"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_jef_to_xxx(self):
<         file1 = "convert_xxx.jef"
<         file2 = "converted_jef.xxx"
<         write_jef(get_big_pattern(), file1)
<         f_pattern = read_jef(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("jef->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_jef_stop_write_simple(self):
<         file = "stop.jef"
<         write_jef(get_simple_stop(), file)
<         s_pattern = read_jef(file)
<         self.assertEqual(s_pattern.count_stitch_commands(STOP), 1)
<         self.assertEqual(s_pattern.count_color_changes(), 0)
<         self.addCleanup(os.remove, file)
< 
<     def test_jef_stop_write_large(self):
<         file = "stop2.jef"
<         pattern = get_shift_stop_pattern()
<         n_pattern = pattern.get_normalized_pattern()
<         self.assertEqual(n_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(n_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.assertEqual(n_pattern.count_stitch_commands(STOP), 5)
< 
<         write_jef(pattern, file)
<         f_pattern = read_jef(file)
<         self.assertIsNotNone(f_pattern)
< 
<         with open(file, "rb") as f:
<             f.seek(0x18)
<             colors = f.read(1)
<             self.assertEqual(ord(colors), f_pattern.count_color_changes() + f_pattern.count_stitch_commands(STOP) + 1)
< 
<         self.assertEqual(f_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(f_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.assertEqual(f_pattern.count_stitch_commands(STOP), 5)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_jef_to_u01(self):
>         file1 = "convert_u01.jef"
>         file2 = "converted_jef.u01"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_csv(self):
>         file1 = "convert_csv.jef"
>         file2 = "converted_jef.csv"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_exp(self):
>         file1 = "convert_exp.jef"
>         file2 = "converted_jef.exp"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_pes(self):
>         file1 = "convert_pes.jef"
>         file2 = "converted_jef.pes"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_jef(self):
>         file1 = "convert_jef.jef"
>         file2 = "converted_jef.jef"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_pec(self):
>         file1 = "convert_pec.jef"
>         file2 = "converted_jef.pec"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_vp3(self):
>         file1 = "convert_vp3.jef"
>         file2 = "converted_jef.vp3"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_dst(self):
>         file1 = "convert_dst.jef"
>         file2 = "converted_jef.dst"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_jef_to_gcode(self):
>         file1 = "convert_gcode.jef"
>         file2 = "converted_jef.gcode"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_jef_to_xxx(self):
>         file1 = "convert_xxx.jef"
>         file2 = "converted_jef.xxx"
>         write_jef(get_big_pattern(), file1)
>         f_pattern = read_jef(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("jef->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_jef_stop_write_simple(self):
>         file = "stop.jef"
>         write_jef(get_simple_stop(), file)
>         s_pattern = read_jef(file)
>         self.assertEqual(s_pattern.count_stitch_commands(STOP), 1)
>         self.assertEqual(s_pattern.count_color_changes(), 0)
>         self.addCleanup(os.remove, file)
> 
>     def test_jef_stop_write_large(self):
>         file = "stop2.jef"
>         pattern = get_shift_stop_pattern()
>         n_pattern = pattern.get_normalized_pattern()
>         self.assertEqual(n_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(n_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.assertEqual(n_pattern.count_stitch_commands(STOP), 5)
> 
>         write_jef(pattern, file)
>         f_pattern = read_jef(file)
>         self.assertIsNotNone(f_pattern)
> 
>         with open(file, "rb") as f:
>             f.seek(0x18)
>             colors = f.read(1)
>             self.assertEqual(ord(colors), f_pattern.count_color_changes() + f_pattern.count_stitch_commands(STOP) + 1)
> 
>         self.assertEqual(f_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(f_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.assertEqual(f_pattern.count_stitch_commands(STOP), 5)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_pec.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_pec.py
1,170c1,170
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_pec_to_u01(self):
<         file1 = "convert_u01.pec"
<         file2 = "converted_pec.u01"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_csv(self):
<         file1 = "convert_csv.pec"
<         file2 = "converted_pec.csv"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_exp(self):
<         file1 = "convert_exp.pec"
<         file2 = "converted_pec.exp"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_pes(self):
<         file1 = "convert_pes.pec"
<         file2 = "converted_pec.pes"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_jef(self):
<         file1 = "convert_jef.pec"
<         file2 = "converted_pec.jef"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_pec(self):
<         file1 = "convert_pec.pec"
<         file2 = "converted_pec.pec"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_vp3(self):
<         file1 = "convert_vp3.pec"
<         file2 = "converted_pec.vp3"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_dst(self):
<         file1 = "convert_dst.pec"
<         file2 = "converted_pec.dst"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pec_to_gcode(self):
<         file1 = "convert_gcode.pec"
<         file2 = "converted_pec.gcode"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_pec_to_xxx(self):
<         file1 = "convert_xxx.pec"
<         file2 = "converted_pec.xxx"
<         write_pec(get_big_pattern(), file1)
<         f_pattern = read_pec(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pec->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_pec_to_u01(self):
>         file1 = "convert_u01.pec"
>         file2 = "converted_pec.u01"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_csv(self):
>         file1 = "convert_csv.pec"
>         file2 = "converted_pec.csv"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_exp(self):
>         file1 = "convert_exp.pec"
>         file2 = "converted_pec.exp"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_pes(self):
>         file1 = "convert_pes.pec"
>         file2 = "converted_pec.pes"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_jef(self):
>         file1 = "convert_jef.pec"
>         file2 = "converted_pec.jef"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_pec(self):
>         file1 = "convert_pec.pec"
>         file2 = "converted_pec.pec"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_vp3(self):
>         file1 = "convert_vp3.pec"
>         file2 = "converted_pec.vp3"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_dst(self):
>         file1 = "convert_dst.pec"
>         file2 = "converted_pec.dst"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pec_to_gcode(self):
>         file1 = "convert_gcode.pec"
>         file2 = "converted_pec.gcode"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_pec_to_xxx(self):
>         file1 = "convert_xxx.pec"
>         file2 = "converted_pec.xxx"
>         write_pec(get_big_pattern(), file1)
>         f_pattern = read_pec(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pec->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_pes.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_pes.py
1,176c1,176
< from __future__ import print_function
< 
< import unittest
< from pyembroidery import *
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_pes_to_u01(self):
<         file1 = "convert_u01.pes"
<         file2 = "converted_pes.u01"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_csv(self):
<         file1 = "convert_csv.pes"
<         file2 = "converted_pes.csv"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_exp(self):
<         file1 = "convert_exp.pes"
<         file2 = "converted_pes.exp"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_pes(self):
<         file1 = "convert_pes.pes"
<         file2 = "converted_pes.pes"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_jef(self):
<         file1 = "convert_jef.pes"
<         file2 = "converted_pes.jef"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_pec(self):
<         file1 = "convert_pec.pes"
<         file2 = "converted_pes.pec"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_vp3(self):
<         file1 = "convert_vp3.pes"
<         file2 = "converted_pes.vp3"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_dst(self):
<         file1 = "convert_dst.pes"
<         file2 = "converted_pes.dst"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_pes_to_gcode(self):
<         file1 = "convert_gcode.pes"
<         file2 = "converted_pes.gcode"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_pes_to_xxx(self):
<         file1 = "convert_xxx.pes"
<         file2 = "converted_pes.xxx"
<         write_pes(get_big_pattern(), file1)
<         f_pattern = read_pes(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("pes->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_write_pes_long(self):
<         file1 = "long.pes"
<         write_pes(get_long_jump(), file1)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> from pyembroidery import *
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_pes_to_u01(self):
>         file1 = "convert_u01.pes"
>         file2 = "converted_pes.u01"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_csv(self):
>         file1 = "convert_csv.pes"
>         file2 = "converted_pes.csv"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_exp(self):
>         file1 = "convert_exp.pes"
>         file2 = "converted_pes.exp"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_pes(self):
>         file1 = "convert_pes.pes"
>         file2 = "converted_pes.pes"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_jef(self):
>         file1 = "convert_jef.pes"
>         file2 = "converted_pes.jef"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_pec(self):
>         file1 = "convert_pec.pes"
>         file2 = "converted_pes.pec"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_vp3(self):
>         file1 = "convert_vp3.pes"
>         file2 = "converted_pes.vp3"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_dst(self):
>         file1 = "convert_dst.pes"
>         file2 = "converted_pes.dst"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_pes_to_gcode(self):
>         file1 = "convert_gcode.pes"
>         file2 = "converted_pes.gcode"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_pes_to_xxx(self):
>         file1 = "convert_xxx.pes"
>         file2 = "converted_pes.xxx"
>         write_pes(get_big_pattern(), file1)
>         f_pattern = read_pes(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("pes->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_write_pes_long(self):
>         file1 = "long.pes"
>         write_pes(get_long_jump(), file1)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_u01.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_u01.py
1,169c1,169
< from __future__ import print_function
< 
< import unittest
< from pyembroidery import *
< from test.pattern_for_tests import *
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_u01_to_u01(self):
<         file1 = "convert_u01.u01"
<         file2 = "converted_u01.u01"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_csv(self):
<         file1 = "convert_csv.u01"
<         file2 = "converted_u01.csv"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_exp(self):
<         file1 = "convert_exp.u01"
<         file2 = "converted_u01.exp"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_pes(self):
<         file1 = "convert_pes.u01"
<         file2 = "converted_u01.pes"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_jef(self):
<         file1 = "convert_jef.u01"
<         file2 = "converted_u01.jef"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_pec(self):
<         file1 = "convert_pec.u01"
<         file2 = "converted_u01.pec"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_vp3(self):
<         file1 = "convert_vp3.u01"
<         file2 = "converted_u01.vp3"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_dst(self):
<         file1 = "convert_dst.u01"
<         file2 = "converted_u01.dst"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_u01_to_gcode(self):
<         file1 = "convert_gcode.u01"
<         file2 = "converted_u01.gcode"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_u01_to_xxx(self):
<         file1 = "convert_xxx.u01"
<         file2 = "converted_u01.xxx"
<         write_u01(get_big_pattern(), file1)
<         f_pattern = read_u01(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("u01->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> from pyembroidery import *
> from test.pattern_for_tests import *
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_u01_to_u01(self):
>         file1 = "convert_u01.u01"
>         file2 = "converted_u01.u01"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_csv(self):
>         file1 = "convert_csv.u01"
>         file2 = "converted_u01.csv"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_exp(self):
>         file1 = "convert_exp.u01"
>         file2 = "converted_u01.exp"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_pes(self):
>         file1 = "convert_pes.u01"
>         file2 = "converted_u01.pes"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_jef(self):
>         file1 = "convert_jef.u01"
>         file2 = "converted_u01.jef"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_pec(self):
>         file1 = "convert_pec.u01"
>         file2 = "converted_u01.pec"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_vp3(self):
>         file1 = "convert_vp3.u01"
>         file2 = "converted_u01.vp3"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_dst(self):
>         file1 = "convert_dst.u01"
>         file2 = "converted_u01.dst"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_u01_to_gcode(self):
>         file1 = "convert_gcode.u01"
>         file2 = "converted_u01.gcode"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_u01_to_xxx(self):
>         file1 = "convert_xxx.u01"
>         file2 = "converted_u01.xxx"
>         write_u01(get_big_pattern(), file1)
>         f_pattern = read_u01(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("u01->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_vp3.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_vp3.py
1,171c1,171
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_vp3_to_u01(self):
<         file1 = "convert_u01.vp3"
<         file2 = "converted_vp3.u01"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_csv(self):
<         file1 = "convert_csv.vp3"
<         file2 = "converted_vp3.csv"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_exp(self):
<         file1 = "convert_exp.vp3"
<         file2 = "converted_vp3.exp"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
< 
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_pes(self):
<         file1 = "convert_pes.vp3"
<         file2 = "converted_vp3.pes"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_jef(self):
<         file1 = "convert_jef.vp3"
<         file2 = "converted_vp3.jef"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_pec(self):
<         file1 = "convert_pec.vp3"
<         file2 = "converted_vp3.pec"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_vp3(self):
<         file1 = "convert_vp3.vp3"
<         file2 = "converted_vp3.vp3"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_dst(self):
<         file1 = "convert_dst.vp3"
<         file2 = "converted_vp3.dst"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_vp3_to_gcode(self):
<         file1 = "convert_gcode.vp3"
<         file2 = "converted_vp3.gcode"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         
<     def test_convert_vp3_to_xxx(self):
<         file1 = "convert_xxx.vp3"
<         file2 = "converted_vp3.xxx"
<         write_vp3(get_big_pattern(), file1)
<         f_pattern = read_vp3(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("vp3->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_vp3_to_u01(self):
>         file1 = "convert_u01.vp3"
>         file2 = "converted_vp3.u01"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_csv(self):
>         file1 = "convert_csv.vp3"
>         file2 = "converted_vp3.csv"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_exp(self):
>         file1 = "convert_exp.vp3"
>         file2 = "converted_vp3.exp"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
> 
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_pes(self):
>         file1 = "convert_pes.vp3"
>         file2 = "converted_vp3.pes"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_jef(self):
>         file1 = "convert_jef.vp3"
>         file2 = "converted_vp3.jef"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_pec(self):
>         file1 = "convert_pec.vp3"
>         file2 = "converted_vp3.pec"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_vp3(self):
>         file1 = "convert_vp3.vp3"
>         file2 = "converted_vp3.vp3"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_dst(self):
>         file1 = "convert_dst.vp3"
>         file2 = "converted_vp3.dst"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_vp3_to_gcode(self):
>         file1 = "convert_gcode.vp3"
>         file2 = "converted_vp3.gcode"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         
>     def test_convert_vp3_to_xxx(self):
>         file1 = "convert_xxx.vp3"
>         file2 = "converted_vp3.xxx"
>         write_vp3(get_big_pattern(), file1)
>         f_pattern = read_vp3(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("vp3->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_xxx.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_convert_xxx.py
1,171c1,171
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestConverts(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_convert_xxx_to_u01(self):
<         file1 = "convert_u01.xxx"
<         file2 = "converted_xxx.u01"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_u01(f_pattern, file2)
<         t_pattern = read_u01(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->u01: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_csv(self):
<         file1 = "convert_csv.xxx"
<         file2 = "converted_xxx.csv"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_csv(f_pattern, file2)
<         t_pattern = read_csv(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->csv: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_exp(self):
<         file1 = "convert_exp.xxx"
<         file2 = "converted_xxx.exp"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_exp(f_pattern, file2)
<         t_pattern = read_exp(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->exp: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_vp3(self):
<         file1 = "convert_vp3.xxx"
<         file2 = "converted_xxx.vp3"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_vp3(f_pattern, file2)
<         t_pattern = read_vp3(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->vp3: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_jef(self):
<         file1 = "convert_jef.xxx"
<         file2 = "converted_xxx.jef"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_jef(f_pattern, file2)
<         t_pattern = read_jef(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->jef: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_pec(self):
<         file1 = "convert_pec.xxx"
<         file2 = "converted_xxx.pec"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_pec(f_pattern, file2)
<         t_pattern = read_pec(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->pec: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_xxx(self):
<         file1 = "convert_xxx.xxx"
<         file2 = "converted_xxx.xxx"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_xxx(f_pattern, file2)
<         t_pattern = read_xxx(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->xxx: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_dst(self):
<         file1 = "convert_dst.xxx"
<         file2 = "converted_xxx.dst"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_dst(f_pattern, file2)
<         t_pattern = read_dst(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->dst: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_gcode(self):
<         file1 = "convert_gcode.xxx"
<         file2 = "converted_xxx.gcode"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_gcode(f_pattern, file2)
<         t_pattern = read_gcode(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->gcode: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
< 
<     def test_convert_xxx_to_pes(self):
<         file1 = "convert_pes.xxx"
<         file2 = "converted_xxx.pes"
<         write_xxx(get_big_pattern(), file1)
<         f_pattern = read_xxx(file1)
<         write_pes(f_pattern, file2)
<         t_pattern = read_pes(file2)
< 
<         self.assertIsNotNone(t_pattern)
<         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
<         self.position_equals(t_pattern.stitches, 0, -1)
<         print("xxx->pes: ", t_pattern.stitches)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestConverts(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_convert_xxx_to_u01(self):
>         file1 = "convert_u01.xxx"
>         file2 = "converted_xxx.u01"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_u01(f_pattern, file2)
>         t_pattern = read_u01(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->u01: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_csv(self):
>         file1 = "convert_csv.xxx"
>         file2 = "converted_xxx.csv"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_csv(f_pattern, file2)
>         t_pattern = read_csv(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->csv: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_exp(self):
>         file1 = "convert_exp.xxx"
>         file2 = "converted_xxx.exp"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_exp(f_pattern, file2)
>         t_pattern = read_exp(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->exp: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_vp3(self):
>         file1 = "convert_vp3.xxx"
>         file2 = "converted_xxx.vp3"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_vp3(f_pattern, file2)
>         t_pattern = read_vp3(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->vp3: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_jef(self):
>         file1 = "convert_jef.xxx"
>         file2 = "converted_xxx.jef"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_jef(f_pattern, file2)
>         t_pattern = read_jef(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->jef: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_pec(self):
>         file1 = "convert_pec.xxx"
>         file2 = "converted_xxx.pec"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_pec(f_pattern, file2)
>         t_pattern = read_pec(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->pec: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_xxx(self):
>         file1 = "convert_xxx.xxx"
>         file2 = "converted_xxx.xxx"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_xxx(f_pattern, file2)
>         t_pattern = read_xxx(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->xxx: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_dst(self):
>         file1 = "convert_dst.xxx"
>         file2 = "converted_xxx.dst"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_dst(f_pattern, file2)
>         t_pattern = read_dst(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->dst: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_gcode(self):
>         file1 = "convert_gcode.xxx"
>         file2 = "converted_xxx.gcode"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_gcode(f_pattern, file2)
>         t_pattern = read_gcode(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->gcode: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
> 
>     def test_convert_xxx_to_pes(self):
>         file1 = "convert_pes.xxx"
>         file2 = "converted_xxx.pes"
>         write_xxx(get_big_pattern(), file1)
>         f_pattern = read_xxx(file1)
>         write_pes(f_pattern, file2)
>         t_pattern = read_pes(file2)
> 
>         self.assertIsNotNone(t_pattern)
>         self.assertEqual(t_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(t_pattern.count_stitch_commands(STITCH), 16 * 5)
>         self.position_equals(t_pattern.stitches, 0, -1)
>         print("xxx->pes: ", t_pattern.stitches)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_datapreservation.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_datapreservation.py
1,17c1,17
< from __future__ import print_function
< 
< import unittest
< from test.pattern_for_tests import *
< 
< 
< class TestDataPreservation(unittest.TestCase):
< 
<     def test_preserve_u01_needles(self):
<         file1 = "file.u01"
<         pattern = get_big_pattern()
<         pattern.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 6, 0))
<         write_u01(pattern, file1)
<         read_pattern = read_u01(file1)
<         for cmd in read_pattern.get_match_commands(NEEDLE_SET):
<             print(decode_embroidery_command(cmd[2]))
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> from test.pattern_for_tests import *
> 
> 
> class TestDataPreservation(unittest.TestCase):
> 
>     def test_preserve_u01_needles(self):
>         file1 = "file.u01"
>         pattern = get_big_pattern()
>         pattern.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 6, 0))
>         write_u01(pattern, file1)
>         read_pattern = read_u01(file1)
>         for cmd in read_pattern.get_match_commands(NEEDLE_SET):
>             print(decode_embroidery_command(cmd[2]))
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_embpattern.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_embpattern.py
1,432c1,432
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestEmbpattern(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_thread_reorder(self):
<         test_file = "reorder.pes"
<         shift = get_shift_pattern()
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, thread=1, order=0))
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 0, None, 1))
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 1, None, 0))
<         self.assertEqual(0xFFFFFF & shift.threadlist[0].color, 0xFF0000)
<         self.assertEqual(0xFFFFFF & shift.threadlist[1].color, 0x0000FF)
<         write_pes(shift, test_file, {"pes version": 6})
<         read_pattern = read_pes(test_file)
<         for thread in read_pattern.threadlist:
<             print(0xFFFFFF & thread.color)
<         self.assertEqual((0xFFFFFF & read_pattern.threadlist[0].color), 0x0000FF)
<         self.assertEqual((0xFFFFFF & read_pattern.threadlist[1].color), 0xFF0000)
<         self.addCleanup(os.remove, test_file)
< 
<     def test_needle_count_limited_set(self):
<         needle_file = "needle-ls.u01"
<         shift = get_shift_pattern()
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 6, 0))
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 4, 6, 7))
<         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 3, 0))
<         write_u01(shift, needle_file, {"needle_count": 7})
<         needle_pattern = read_u01(needle_file)
<         self.assertEqual(needle_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         first = True
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             print(cmd)
<             if first:
<                 # self.assertEqual(cmd[2], 3)
<                 first = False
<             self.assertLessEqual(cmd[2], 7)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit1(self):
<         needle_file = "needle-1.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 1})
<         needle_pattern = read_u01(needle_file)
<         self.assertEqual(needle_pattern.count_stitch_commands(STOP), 16)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLess(cmd[2], 1)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit2(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 2})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 2)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit3(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 3})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 3)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit4(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 4})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 4)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit5(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 5})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 5)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit6(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 6})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 6)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit7(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 7})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 7)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit8(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 8})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 8)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit9(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 9})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 9)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_needle_count_limit10(self):
<         needle_file = "needle.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 10)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_u01_tie_on(self):
<         needle_file = "tie_on.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10, "tie_on": CONTINGENCY_TIE_ON_THREE_SMALL})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 10)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.assertEqual(needle_pattern.count_stitch_commands(STITCH), 16 * (5 + 4))
<         # 5 for the actual stitch pattern. 3 small, and 1 extra tieon, start.
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_u01_tie_off(self):
<         needle_file = "tie_on.u01"
<         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10, "tie_off": CONTINGENCY_TIE_OFF_THREE_SMALL})
<         needle_pattern = read_u01(needle_file)
<         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
<             cmd = decode_embroidery_command(stitch[2])
<             self.assertLessEqual(cmd[2], 10)
<         self.assertEqual(needle_pattern.count_needle_sets(), 16)
<         self.assertEqual(needle_pattern.count_stitch_commands(STITCH), 16 * (5 + 4))
<         # 5 for the actual stitch pattern. 3 small, and 1 extra tieoff, end.
<         self.addCleanup(os.remove, needle_file)
< 
<     def test_write_dst_read_dst_long_jump(self):
<         file1 = "file3.dst"
<         pattern = EmbPattern()
<         pattern.add_block([(0, 0), (0, 200)], "red")
< 
<         write_dst(pattern, file1)
<         dst_pattern = read_dst(file1)
<         self.assertIsNotNone(dst_pattern)
<         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 2)
<         self.assertEqual(dst_pattern.stitches[1][1], 100)
<         print("dst: ", dst_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_dst_read_dst_random_stitch(self):
<         file1 = "fsmall.dst"
<         for i in range(0, 12):
<             max = (i * 10) + 1
<             write_dst(get_random_pattern_small_halfs(), file1,
<                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO, "max_stitch": max})
<             dst_pattern = read_dst(file1)
<             xx = 0
<             yy = 0
<             command = NO_COMMAND
<             for stitch in dst_pattern.stitches:
<                 dx = stitch[0] - xx
<                 dy = stitch[1] - yy
<                 xx += dx
<                 yy += dy
<                 last_command = command
<                 command = stitch[2] & COMMAND_MASK
<                 if command == STITCH and last_command == STITCH:
<                     self.assertLessEqual(dx, max)
<                     self.assertLessEqual(dy, max)
<             self.assertIsNotNone(dst_pattern)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_dst_read_dst_long_jump_random_small(self):
<         file1 = "file3small.dst"
< 
<         for i in range(0, 1000):
<             write_dst(get_random_pattern_small_halfs(), file1,
<                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
<             dst_pattern = read_dst(file1)
<             self.assertIsNotNone(dst_pattern)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_dst_read_dst_long_jump_random_large(self):
<         file1 = "file3large.dst"
<         for i in range(0, 5):
<             write_dst(get_random_pattern_large(), file1,
<                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
<             dst_pattern = read_dst(file1)
<             self.assertIsNotNone(dst_pattern)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_dst_read_dst_divide(self):
<         file1 = "file3.dst"
<         pattern = EmbPattern()
<         pattern.add_block([(0, 0), (0, 2)], "red")
< 
<         write_dst(pattern, file1, {"scale": 100, "long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
<         dst_pattern = read_dst(file1)
<         self.assertIsNotNone(dst_pattern)
<         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 3)
<         self.assertEqual(dst_pattern.stitches[1][1], 100)
<         print("dst: ", dst_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_csv_read_csv_raw(self):
<         file1 = "file.csv"
<         write_csv(get_simple_pattern(), file1)
<         csv_pattern = read_csv(file1)
<         self.assertIsNotNone(csv_pattern)
<         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_BREAK), 3)
<         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
<         self.position_equals(csv_pattern.stitches, 0, -1)
<         print("csv: ", csv_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_csv_read_csv_needle(self):
<         file1 = "file2.csv"
<         write_csv(get_simple_pattern(), "file2.csv", {"thread_change_command": NEEDLE_SET, "encode": True})
<         csv_pattern = read_csv(file1)
<         self.assertIsNotNone(csv_pattern)
<         self.assertEqual(csv_pattern.count_stitch_commands(NEEDLE_SET), 3)
<         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
<         print("csv: ", csv_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_csv_read_csv_color(self):
<         file1 = "file3.csv"
<         write_csv(get_simple_pattern(), "file3.csv", {"thread_change_command": COLOR_CHANGE, "encode": True})
<         csv_pattern = read_csv(file1)
<         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_CHANGE), 2)
<         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
<         self.position_equals(csv_pattern.stitches, 0, -1)
<         print("csv: ", csv_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_csv_read_csv_encoded_command(self):
<         file1 = "file-encoded.csv"
<         pattern = EmbPattern()
<         encoded_command = encode_thread_change(SET_CHANGE_SEQUENCE, 3, 4, 1)
<         pattern.add_command(encoded_command)
<         write_csv(pattern, file1)
<         csv_pattern = read_csv(file1)
<         self.assertIsNotNone(csv_pattern)
<         print("csv-encoded: ", csv_pattern.stitches)
<         self.assertEqual(encoded_command, csv_pattern.stitches[-1][2])
<         self.addCleanup(os.remove, file1)
< 
<     def test_issue_87(self):
<         """
<         Initial test raised by issue 87.
<         """
<         pattern = EmbPattern()
<         stitches_1 = [[0, 1], [2, 3]]
<         stitches_2 = [[4, 5], [6, 7]]
<         pattern.add_block(stitches_1, 0xFF0000)
<         pattern.add_block(stitches_2, 0x0000FF)
<         blocks = list(pattern.get_as_colorblocks())
<         for q in blocks:
<             print(q)
<         self.assertEqual(len(blocks), 2)
<         self.assertEqual(len(blocks[0][0]), 2)  # 0,1 and 2,3
<         self.assertEqual(len(blocks[1][0]), 2)  # 4,5 and 6,7
< 
<     def test_issue_87_2(self):
<         """
<         Tests a pattern arbitrarily starting with a color change.
<         With two predefined blocks. The blocks should maintain their blockness.
<         The color change should isolate 0 stitches, of an unknown color.
<         :return:
<         """
<         pattern = EmbPattern()
<         stitches_1 = [[0, 1], [2, 3]]
<         stitches_2 = [[4, 5], [6, 7]]
< 
<         pattern.color_change()
<         pattern.add_thread('random')
<         pattern.add_block(stitches_1, 0xFF0000)
<         pattern.add_block(stitches_2, 0x0000FF)
<         blocks = list(pattern.get_as_colorblocks())
<         # for q in blocks:
<         #     print(q)
<         self.assertEqual(blocks[1][1].color, 0xFF0000)
<         self.assertEqual(blocks[2][1].color, 0x0000FF)
<         self.assertEqual(len(blocks), 3)
<         self.assertEqual(len(blocks[0][0]), 1)
<         self.assertEqual(len(blocks[1][0]), 2)
<         self.assertEqual(len(blocks[2][0]), 2)
< 
<         for block in blocks:
<             stitch_block = block[0]
<             for stitch in stitch_block:
<                 self.assertNotEqual(stitch[2], COLOR_BREAK)
< 
<         pattern = EmbPattern()
<         pattern.add_thread('random')
<         pattern.color_change()  # end block 1, empty
<         pattern.add_thread(0xFF0000)
<         pattern += stitches_1
<         pattern.color_change()  # end block 2
<         pattern.add_thread(0x0000FF)
<         pattern += stitches_2
<         blocks = list(pattern.get_as_colorblocks())
<         # end block 3, no explicit end.
<         # for q in blocks:
<         #     print(q)
<         self.assertEqual(blocks[0][0][-1][2], COLOR_CHANGE)  # Color change ends the block.
<         self.assertEqual(blocks[1][0][-1][2], COLOR_CHANGE)  # Color change ends the block.
<         self.assertEqual(blocks[1][1].color, 0xFF0000)
<         self.assertEqual(blocks[2][1].color, 0x0000FF)
<         self.assertEqual(len(blocks), 3)
<         self.assertEqual(len(blocks[0][0]), 1)
<         self.assertEqual(len(blocks[1][0]), 3)
<         self.assertEqual(len(blocks[2][0]), 2)  # Final color change is part of no block.
<         pattern.color_change()  # end block 3
<         blocks = list(pattern.get_as_colorblocks())
<         self.assertEqual(len(blocks[2][0]), 3) # Final block with colorchange.
< 
<     def test_issue_87_3(self):
<         """
<         Tests a pattern arbitrarily starting with a needle_set.
<         With two predefined blocks. The blocks should maintain their blockness.
<         The needle set should not contribute a block. Initial needle_set, only
<         define a starting needle.
<         :return:
<         """
<         pattern = EmbPattern()
<         pattern.needle_change()
<         stitches_1 = [[0, 1], [2, 3]]
<         stitches_2 = [[4, 5], [6, 7]]
<         pattern.add_block(stitches_1, 0xFF0000)
<         pattern.add_block(stitches_2, 0x0000FF)
<         blocks = list(pattern.get_as_colorblocks())
<         # for q in blocks:
<         #     print(q)
<         self.assertEqual(blocks[0][1], 0xFF0000)
<         self.assertEqual(blocks[1][1], 0x0000FF)
<         self.assertEqual(len(blocks), 2)
<         for block in blocks:
<             stitch_block = block[0]
<             for stitch in stitch_block:
<                 self.assertNotEqual(stitch[2], COLOR_BREAK)
< 
<         pattern = EmbPattern()
< 
<         pattern.needle_change()  # start block 0
<         pattern += stitches_1
<         pattern.add_thread(EmbThread(0xFF0000))
< 
<         pattern.needle_change()  # start block 1
<         pattern += stitches_1
<         pattern.add_thread(EmbThread(0x0000FF))
< 
<         pattern.needle_change()  # start block 2
<         pattern.add_thread(EmbThread('random'))
< 
<         blocks = list(pattern.get_as_colorblocks())
<         for q in blocks:
<             print(q)
<         # Mask is required here since needle_set automatically appends extended data.
<         self.assertEqual(blocks[0][0][0][2] & COMMAND_MASK, NEEDLE_SET)  # Needle_set starts the block.
<         self.assertEqual(blocks[1][0][0][2] & COMMAND_MASK, NEEDLE_SET)  # Needle_set starts the block.
<         self.assertEqual(blocks[0][1], 0xFF0000)
<         self.assertEqual(blocks[1][1], 0x0000FF)
<         self.assertEqual(len(blocks), 3)
<         self.assertEqual(len(blocks[0][0]), 3)
<         self.assertEqual(len(blocks[1][0]), 3)
<         self.assertEqual(len(blocks[2][0]), 1)
< 
<     def test_issue_87_4(self):
<         """
<         Tests a pattern arbitrarily starting with a color break.
<         With two predefined blocks. The blocks should maintain their blockness.
<         And ending with another arbitrary color break. This should give exactly
<         2 blocks which were defined as prepended colorbreaks postpended color breaks
<         are not to have an impact.
<         :return:
<         """
<         pattern = EmbPattern()
<         pattern += COLOR_BREAK
<         stitches_1 = [[0, 1], [2, 3]]
<         stitches_2 = [[4, 5], [6, 7]]
<         pattern.add_block(stitches_1, 0xFF0000)
<         pattern.add_block(stitches_2, 0x0000FF)
<         pattern += COLOR_BREAK
<         blocks = list(pattern.get_as_colorblocks())
<         for q in blocks:
<             print(q)
< 
<         for block in blocks:
<             stitch_block = block[0]
<             for stitch in stitch_block:
<                 self.assertNotEqual(stitch[2], COLOR_BREAK)
<         self.assertEqual(blocks[0][1], 0xFF0000)
<         self.assertEqual(blocks[1][1], 0x0000FF)
<         self.assertEqual(len(blocks), 2)
<         self.assertEqual(len(blocks[0][0]), 2)
<         self.assertEqual(len(blocks[1][0]), 2)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestEmbpattern(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_thread_reorder(self):
>         test_file = "reorder.pes"
>         shift = get_shift_pattern()
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, thread=1, order=0))
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 0, None, 1))
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 1, None, 0))
>         self.assertEqual(0xFFFFFF & shift.threadlist[0].color, 0xFF0000)
>         self.assertEqual(0xFFFFFF & shift.threadlist[1].color, 0x0000FF)
>         write_pes(shift, test_file, {"pes version": 6})
>         read_pattern = read_pes(test_file)
>         for thread in read_pattern.threadlist:
>             print(0xFFFFFF & thread.color)
>         self.assertEqual((0xFFFFFF & read_pattern.threadlist[0].color), 0x0000FF)
>         self.assertEqual((0xFFFFFF & read_pattern.threadlist[1].color), 0xFF0000)
>         self.addCleanup(os.remove, test_file)
> 
>     def test_needle_count_limited_set(self):
>         needle_file = "needle-ls.u01"
>         shift = get_shift_pattern()
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 6, 0))
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, 4, 6, 7))
>         shift.add_command(encode_thread_change(SET_CHANGE_SEQUENCE, None, 3, 0))
>         write_u01(shift, needle_file, {"needle_count": 7})
>         needle_pattern = read_u01(needle_file)
>         self.assertEqual(needle_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         first = True
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             print(cmd)
>             if first:
>                 # self.assertEqual(cmd[2], 3)
>                 first = False
>             self.assertLessEqual(cmd[2], 7)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit1(self):
>         needle_file = "needle-1.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 1})
>         needle_pattern = read_u01(needle_file)
>         self.assertEqual(needle_pattern.count_stitch_commands(STOP), 16)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLess(cmd[2], 1)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit2(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 2})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 2)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit3(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 3})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 3)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit4(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 4})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 4)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit5(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 5})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 5)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit6(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 6})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 6)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit7(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 7})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 7)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit8(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 8})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 8)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit9(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 9})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 9)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_needle_count_limit10(self):
>         needle_file = "needle.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 10)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_u01_tie_on(self):
>         needle_file = "tie_on.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10, "tie_on": CONTINGENCY_TIE_ON_THREE_SMALL})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 10)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.assertEqual(needle_pattern.count_stitch_commands(STITCH), 16 * (5 + 4))
>         # 5 for the actual stitch pattern. 3 small, and 1 extra tieon, start.
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_u01_tie_off(self):
>         needle_file = "tie_on.u01"
>         write_u01(get_shift_pattern(), needle_file, {"needle_count": 10, "tie_off": CONTINGENCY_TIE_OFF_THREE_SMALL})
>         needle_pattern = read_u01(needle_file)
>         for stitch in needle_pattern.get_match_commands(NEEDLE_SET):
>             cmd = decode_embroidery_command(stitch[2])
>             self.assertLessEqual(cmd[2], 10)
>         self.assertEqual(needle_pattern.count_needle_sets(), 16)
>         self.assertEqual(needle_pattern.count_stitch_commands(STITCH), 16 * (5 + 4))
>         # 5 for the actual stitch pattern. 3 small, and 1 extra tieoff, end.
>         self.addCleanup(os.remove, needle_file)
> 
>     def test_write_dst_read_dst_long_jump(self):
>         file1 = "file3.dst"
>         pattern = EmbPattern()
>         pattern.add_block([(0, 0), (0, 200)], "red")
> 
>         write_dst(pattern, file1)
>         dst_pattern = read_dst(file1)
>         self.assertIsNotNone(dst_pattern)
>         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 2)
>         self.assertEqual(dst_pattern.stitches[1][1], 100)
>         print("dst: ", dst_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_dst_read_dst_random_stitch(self):
>         file1 = "fsmall.dst"
>         for i in range(0, 12):
>             max = (i * 10) + 1
>             write_dst(get_random_pattern_small_halfs(), file1,
>                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO, "max_stitch": max})
>             dst_pattern = read_dst(file1)
>             xx = 0
>             yy = 0
>             command = NO_COMMAND
>             for stitch in dst_pattern.stitches:
>                 dx = stitch[0] - xx
>                 dy = stitch[1] - yy
>                 xx += dx
>                 yy += dy
>                 last_command = command
>                 command = stitch[2] & COMMAND_MASK
>                 if command == STITCH and last_command == STITCH:
>                     self.assertLessEqual(dx, max)
>                     self.assertLessEqual(dy, max)
>             self.assertIsNotNone(dst_pattern)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_dst_read_dst_long_jump_random_small(self):
>         file1 = "file3small.dst"
> 
>         for i in range(0, 1000):
>             write_dst(get_random_pattern_small_halfs(), file1,
>                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
>             dst_pattern = read_dst(file1)
>             self.assertIsNotNone(dst_pattern)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_dst_read_dst_long_jump_random_large(self):
>         file1 = "file3large.dst"
>         for i in range(0, 5):
>             write_dst(get_random_pattern_large(), file1,
>                       {"long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
>             dst_pattern = read_dst(file1)
>             self.assertIsNotNone(dst_pattern)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_dst_read_dst_divide(self):
>         file1 = "file3.dst"
>         pattern = EmbPattern()
>         pattern.add_block([(0, 0), (0, 2)], "red")
> 
>         write_dst(pattern, file1, {"scale": 100, "long_stitch_contingency": CONTINGENCY_LONG_STITCH_SEW_TO})
>         dst_pattern = read_dst(file1)
>         self.assertIsNotNone(dst_pattern)
>         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 3)
>         self.assertEqual(dst_pattern.stitches[1][1], 100)
>         print("dst: ", dst_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_csv_read_csv_raw(self):
>         file1 = "file.csv"
>         write_csv(get_simple_pattern(), file1)
>         csv_pattern = read_csv(file1)
>         self.assertIsNotNone(csv_pattern)
>         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_BREAK), 3)
>         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
>         self.position_equals(csv_pattern.stitches, 0, -1)
>         print("csv: ", csv_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_csv_read_csv_needle(self):
>         file1 = "file2.csv"
>         write_csv(get_simple_pattern(), "file2.csv", {"thread_change_command": NEEDLE_SET, "encode": True})
>         csv_pattern = read_csv(file1)
>         self.assertIsNotNone(csv_pattern)
>         self.assertEqual(csv_pattern.count_stitch_commands(NEEDLE_SET), 3)
>         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
>         print("csv: ", csv_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_csv_read_csv_color(self):
>         file1 = "file3.csv"
>         write_csv(get_simple_pattern(), "file3.csv", {"thread_change_command": COLOR_CHANGE, "encode": True})
>         csv_pattern = read_csv(file1)
>         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_CHANGE), 2)
>         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 15)
>         self.position_equals(csv_pattern.stitches, 0, -1)
>         print("csv: ", csv_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_csv_read_csv_encoded_command(self):
>         file1 = "file-encoded.csv"
>         pattern = EmbPattern()
>         encoded_command = encode_thread_change(SET_CHANGE_SEQUENCE, 3, 4, 1)
>         pattern.add_command(encoded_command)
>         write_csv(pattern, file1)
>         csv_pattern = read_csv(file1)
>         self.assertIsNotNone(csv_pattern)
>         print("csv-encoded: ", csv_pattern.stitches)
>         self.assertEqual(encoded_command, csv_pattern.stitches[-1][2])
>         self.addCleanup(os.remove, file1)
> 
>     def test_issue_87(self):
>         """
>         Initial test raised by issue 87.
>         """
>         pattern = EmbPattern()
>         stitches_1 = [[0, 1], [2, 3]]
>         stitches_2 = [[4, 5], [6, 7]]
>         pattern.add_block(stitches_1, 0xFF0000)
>         pattern.add_block(stitches_2, 0x0000FF)
>         blocks = list(pattern.get_as_colorblocks())
>         for q in blocks:
>             print(q)
>         self.assertEqual(len(blocks), 2)
>         self.assertEqual(len(blocks[0][0]), 2)  # 0,1 and 2,3
>         self.assertEqual(len(blocks[1][0]), 2)  # 4,5 and 6,7
> 
>     def test_issue_87_2(self):
>         """
>         Tests a pattern arbitrarily starting with a color change.
>         With two predefined blocks. The blocks should maintain their blockness.
>         The color change should isolate 0 stitches, of an unknown color.
>         :return:
>         """
>         pattern = EmbPattern()
>         stitches_1 = [[0, 1], [2, 3]]
>         stitches_2 = [[4, 5], [6, 7]]
> 
>         pattern.color_change()
>         pattern.add_thread('random')
>         pattern.add_block(stitches_1, 0xFF0000)
>         pattern.add_block(stitches_2, 0x0000FF)
>         blocks = list(pattern.get_as_colorblocks())
>         # for q in blocks:
>         #     print(q)
>         self.assertEqual(blocks[1][1].color, 0xFF0000)
>         self.assertEqual(blocks[2][1].color, 0x0000FF)
>         self.assertEqual(len(blocks), 3)
>         self.assertEqual(len(blocks[0][0]), 1)
>         self.assertEqual(len(blocks[1][0]), 2)
>         self.assertEqual(len(blocks[2][0]), 2)
> 
>         for block in blocks:
>             stitch_block = block[0]
>             for stitch in stitch_block:
>                 self.assertNotEqual(stitch[2], COLOR_BREAK)
> 
>         pattern = EmbPattern()
>         pattern.add_thread('random')
>         pattern.color_change()  # end block 1, empty
>         pattern.add_thread(0xFF0000)
>         pattern += stitches_1
>         pattern.color_change()  # end block 2
>         pattern.add_thread(0x0000FF)
>         pattern += stitches_2
>         blocks = list(pattern.get_as_colorblocks())
>         # end block 3, no explicit end.
>         # for q in blocks:
>         #     print(q)
>         self.assertEqual(blocks[0][0][-1][2], COLOR_CHANGE)  # Color change ends the block.
>         self.assertEqual(blocks[1][0][-1][2], COLOR_CHANGE)  # Color change ends the block.
>         self.assertEqual(blocks[1][1].color, 0xFF0000)
>         self.assertEqual(blocks[2][1].color, 0x0000FF)
>         self.assertEqual(len(blocks), 3)
>         self.assertEqual(len(blocks[0][0]), 1)
>         self.assertEqual(len(blocks[1][0]), 3)
>         self.assertEqual(len(blocks[2][0]), 2)  # Final color change is part of no block.
>         pattern.color_change()  # end block 3
>         blocks = list(pattern.get_as_colorblocks())
>         self.assertEqual(len(blocks[2][0]), 3) # Final block with colorchange.
> 
>     def test_issue_87_3(self):
>         """
>         Tests a pattern arbitrarily starting with a needle_set.
>         With two predefined blocks. The blocks should maintain their blockness.
>         The needle set should not contribute a block. Initial needle_set, only
>         define a starting needle.
>         :return:
>         """
>         pattern = EmbPattern()
>         pattern.needle_change()
>         stitches_1 = [[0, 1], [2, 3]]
>         stitches_2 = [[4, 5], [6, 7]]
>         pattern.add_block(stitches_1, 0xFF0000)
>         pattern.add_block(stitches_2, 0x0000FF)
>         blocks = list(pattern.get_as_colorblocks())
>         # for q in blocks:
>         #     print(q)
>         self.assertEqual(blocks[0][1], 0xFF0000)
>         self.assertEqual(blocks[1][1], 0x0000FF)
>         self.assertEqual(len(blocks), 2)
>         for block in blocks:
>             stitch_block = block[0]
>             for stitch in stitch_block:
>                 self.assertNotEqual(stitch[2], COLOR_BREAK)
> 
>         pattern = EmbPattern()
> 
>         pattern.needle_change()  # start block 0
>         pattern += stitches_1
>         pattern.add_thread(EmbThread(0xFF0000))
> 
>         pattern.needle_change()  # start block 1
>         pattern += stitches_1
>         pattern.add_thread(EmbThread(0x0000FF))
> 
>         pattern.needle_change()  # start block 2
>         pattern.add_thread(EmbThread('random'))
> 
>         blocks = list(pattern.get_as_colorblocks())
>         for q in blocks:
>             print(q)
>         # Mask is required here since needle_set automatically appends extended data.
>         self.assertEqual(blocks[0][0][0][2] & COMMAND_MASK, NEEDLE_SET)  # Needle_set starts the block.
>         self.assertEqual(blocks[1][0][0][2] & COMMAND_MASK, NEEDLE_SET)  # Needle_set starts the block.
>         self.assertEqual(blocks[0][1], 0xFF0000)
>         self.assertEqual(blocks[1][1], 0x0000FF)
>         self.assertEqual(len(blocks), 3)
>         self.assertEqual(len(blocks[0][0]), 3)
>         self.assertEqual(len(blocks[1][0]), 3)
>         self.assertEqual(len(blocks[2][0]), 1)
> 
>     def test_issue_87_4(self):
>         """
>         Tests a pattern arbitrarily starting with a color break.
>         With two predefined blocks. The blocks should maintain their blockness.
>         And ending with another arbitrary color break. This should give exactly
>         2 blocks which were defined as prepended colorbreaks postpended color breaks
>         are not to have an impact.
>         :return:
>         """
>         pattern = EmbPattern()
>         pattern += COLOR_BREAK
>         stitches_1 = [[0, 1], [2, 3]]
>         stitches_2 = [[4, 5], [6, 7]]
>         pattern.add_block(stitches_1, 0xFF0000)
>         pattern.add_block(stitches_2, 0x0000FF)
>         pattern += COLOR_BREAK
>         blocks = list(pattern.get_as_colorblocks())
>         for q in blocks:
>             print(q)
> 
>         for block in blocks:
>             stitch_block = block[0]
>             for stitch in stitch_block:
>                 self.assertNotEqual(stitch[2], COLOR_BREAK)
>         self.assertEqual(blocks[0][1], 0xFF0000)
>         self.assertEqual(blocks[1][1], 0x0000FF)
>         self.assertEqual(len(blocks), 2)
>         self.assertEqual(len(blocks[0][0]), 2)
>         self.assertEqual(len(blocks[1][0]), 2)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_encoder.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_encoder.py
1,113c1,113
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestEmbpattern(unittest.TestCase):
< 
<     def test_encoder_bookend_color_break(self):
<         pattern = EmbPattern()
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("red")
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern = pattern.get_normalized_pattern()
<         self.assertEqual(len(pattern.threadlist), 1)
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 0)
< 
<     def test_encoder_multiple_internal_breaks(self):
<         pattern = EmbPattern()
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("red")
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("green")
<         pattern.add_command(COLOR_BREAK)
<         pattern = pattern.get_normalized_pattern()
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 4)
<         self.assertEqual(len(pattern.threadlist), 5)
< 
<     def test_encoder_colorchange(self):
<         pattern = EmbPattern()
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("red")
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("green")
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("blue")
<         pattern.add_command(COLOR_BREAK)
<         pattern = pattern.get_normalized_pattern()
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE) + 1, len(pattern.threadlist))
< 
<     def test_encoder_needleset(self):
<         pattern = EmbPattern()
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("red")
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("green")
<         pattern.add_command(COLOR_BREAK)
<         pattern.stitch_abs(0, 0)
<         pattern.stitch_abs(0, 100)
<         pattern.stitch_abs(100, 100)
<         pattern.stitch_abs(100, 0)
<         pattern.stitch_abs(0, 0)
<         pattern.add_thread("blue")
<         pattern.add_command(COLOR_BREAK)
<         pattern = pattern.get_normalized_pattern({"thread_change_command": NEEDLE_SET})
<         self.assertEqual(pattern.count_stitch_commands(NEEDLE_SET), len(pattern.threadlist))
< 
<     def test_transcode_to_self(self):
<         pattern = get_shift_pattern()
<         from pyembroidery.EmbEncoder import Transcoder
<         encoder = Transcoder()
<         encoder.transcode(pattern, pattern)
<         self.assertNotEqual(len(pattern.stitches), 0)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestEmbpattern(unittest.TestCase):
> 
>     def test_encoder_bookend_color_break(self):
>         pattern = EmbPattern()
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("red")
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern = pattern.get_normalized_pattern()
>         self.assertEqual(len(pattern.threadlist), 1)
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 0)
> 
>     def test_encoder_multiple_internal_breaks(self):
>         pattern = EmbPattern()
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("red")
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("green")
>         pattern.add_command(COLOR_BREAK)
>         pattern = pattern.get_normalized_pattern()
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 4)
>         self.assertEqual(len(pattern.threadlist), 5)
> 
>     def test_encoder_colorchange(self):
>         pattern = EmbPattern()
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("red")
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("green")
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("blue")
>         pattern.add_command(COLOR_BREAK)
>         pattern = pattern.get_normalized_pattern()
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE) + 1, len(pattern.threadlist))
> 
>     def test_encoder_needleset(self):
>         pattern = EmbPattern()
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("red")
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("green")
>         pattern.add_command(COLOR_BREAK)
>         pattern.stitch_abs(0, 0)
>         pattern.stitch_abs(0, 100)
>         pattern.stitch_abs(100, 100)
>         pattern.stitch_abs(100, 0)
>         pattern.stitch_abs(0, 0)
>         pattern.add_thread("blue")
>         pattern.add_command(COLOR_BREAK)
>         pattern = pattern.get_normalized_pattern({"thread_change_command": NEEDLE_SET})
>         self.assertEqual(pattern.count_stitch_commands(NEEDLE_SET), len(pattern.threadlist))
> 
>     def test_transcode_to_self(self):
>         pattern = get_shift_pattern()
>         from pyembroidery.EmbEncoder import Transcoder
>         encoder = Transcoder()
>         encoder.transcode(pattern, pattern)
>         self.assertNotEqual(len(pattern.stitches), 0)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_generic.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_generic.py
1,78c1,78
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< from pyembroidery import GenericWriter
< 
< 
< class TestConverts(unittest.TestCase):
<     def test_generic_write_stitch(self):
<         file1 = "convert.dst"
<         file2 = "convert.txt"
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
<         pattern = get_fractal_pattern()
<         pattern.write(file1)
< 
<         pattern = EmbPattern(file1)
< 
<         EmbPattern.write_embroidery(
<             GenericWriter,
<             pattern,
<             file2,
<             {
<                 "segment_start": "\t\t",
<                 "segment_end": "\n",
<                 "segment": "{cmd_str} {x},{y}",
<                 "stitch": "Stitch: {x},{y}",
<                 "jump": "Jump {x},{y}",
<                 "trim": "Trim: {x},{y}",
<                 "color_change": "Color-Change: {x},{y}",
<                 "block_start": "\t{{\n",
<                 "block_end": "\t}}\n",
<                 "color_start": "[\n",
<                 "color_end": "]\n",
<             },
<         )
<         print("write generic: ", file1)
< 
<     def test_generic_write_gcode(self):
<         gcode_writer_dict = {
<             "scale": (-0.1, -0.1),
<             "pattern_start": "(STITCH_COUNT: {stitch_total})\n"
<             "(THREAD_COUNT: {color_change_count})\n"
<             "(EXTENTS_LEFT: {extents_left:.3f})\n"
<             "(EXTENTS_TOP: {extends_top:.3f})\n"
<             "(EXTENTS_RIGHT: {extends_right:.3f})\n"
<             "(EXTENTS_BOTTOM: {extends_bottom:.3f})\n"
<             "(EXTENTS_WIDTH: {extends_width:.3f})\n"
<             "(EXTENTS_HEIGHT: {extends_height:.3f})\n"
<             "(COMMAND_STITCH: {stitch_count})\n"
<             "(COMMAND_COLOR_CHANGE: {color_change_count})\n"
<             "(COMMAND_TRIM: {trim_count})\n"
<             "(COMMAND_STOP: {stop_count})\n"
<             "(COMMAND_END: {end_count})\n",
<             "metadata_entry": "({metadata_key}: {metadata_value})\n",
<             "thread_entry": "(Thread{thread_index}: {thread_color} {thread_description} {thread_brand} {thread_catalog_number})\n",
<             "stitch": "G00 X{x:.3f} Y{y:.3f}\nG00 Z{z:.1f}\n",
<             "color_change": "M00\n",
<             "stop": "M00\n",
<             "end": "M30\n",
<         }
<         file1 = "file-gcode.gcode"
<         file2 = "file-generic.gcode"
<         pattern = get_fractal_pattern()
<         pattern.fix_color_count()
<         EmbPattern.write_embroidery(
<             GenericWriter,
<             pattern,
<             file2,
<             gcode_writer_dict,
<         )
<         pattern.write(file1)
<         f1 = open(file1, "rb").read()
<         f2 = open(file2, "rb").read()
<         self.assertEqual(f1, f2)
<         self.addCleanup(os.remove, file1)
<         self.addCleanup(os.remove, file2)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> from pyembroidery import GenericWriter
> 
> 
> class TestConverts(unittest.TestCase):
>     def test_generic_write_stitch(self):
>         file1 = "convert.dst"
>         file2 = "convert.txt"
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
>         pattern = get_fractal_pattern()
>         pattern.write(file1)
> 
>         pattern = EmbPattern(file1)
> 
>         EmbPattern.write_embroidery(
>             GenericWriter,
>             pattern,
>             file2,
>             {
>                 "segment_start": "\t\t",
>                 "segment_end": "\n",
>                 "segment": "{cmd_str} {x},{y}",
>                 "stitch": "Stitch: {x},{y}",
>                 "jump": "Jump {x},{y}",
>                 "trim": "Trim: {x},{y}",
>                 "color_change": "Color-Change: {x},{y}",
>                 "block_start": "\t{{\n",
>                 "block_end": "\t}}\n",
>                 "color_start": "[\n",
>                 "color_end": "]\n",
>             },
>         )
>         print("write generic: ", file1)
> 
>     def test_generic_write_gcode(self):
>         gcode_writer_dict = {
>             "scale": (-0.1, -0.1),
>             "pattern_start": "(STITCH_COUNT: {stitch_total})\n"
>             "(THREAD_COUNT: {color_change_count})\n"
>             "(EXTENTS_LEFT: {extents_left:.3f})\n"
>             "(EXTENTS_TOP: {extends_top:.3f})\n"
>             "(EXTENTS_RIGHT: {extends_right:.3f})\n"
>             "(EXTENTS_BOTTOM: {extends_bottom:.3f})\n"
>             "(EXTENTS_WIDTH: {extends_width:.3f})\n"
>             "(EXTENTS_HEIGHT: {extends_height:.3f})\n"
>             "(COMMAND_STITCH: {stitch_count})\n"
>             "(COMMAND_COLOR_CHANGE: {color_change_count})\n"
>             "(COMMAND_TRIM: {trim_count})\n"
>             "(COMMAND_STOP: {stop_count})\n"
>             "(COMMAND_END: {end_count})\n",
>             "metadata_entry": "({metadata_key}: {metadata_value})\n",
>             "thread_entry": "(Thread{thread_index}: {thread_color} {thread_description} {thread_brand} {thread_catalog_number})\n",
>             "stitch": "G00 X{x:.3f} Y{y:.3f}\nG00 Z{z:.1f}\n",
>             "color_change": "M00\n",
>             "stop": "M00\n",
>             "end": "M30\n",
>         }
>         file1 = "file-gcode.gcode"
>         file2 = "file-generic.gcode"
>         pattern = get_fractal_pattern()
>         pattern.fix_color_count()
>         EmbPattern.write_embroidery(
>             GenericWriter,
>             pattern,
>             file2,
>             gcode_writer_dict,
>         )
>         pattern.write(file1)
>         f1 = open(file1, "rb").read()
>         f2 = open(file2, "rb").read()
>         self.assertEqual(f1, f2)
>         self.addCleanup(os.remove, file1)
>         self.addCleanup(os.remove, file2)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_interpolate.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_interpolate.py
1,213c1,213
< from __future__ import print_function
< 
< import unittest
< 
< from pyembroidery import *
< from test.pattern_for_tests import *
< 
< 
< class TestInterpolate(unittest.TestCase):
< 
<     def test_interpolate_color_stop(self):
<         """Full circle STOP/color conversion"""
<         pattern = get_fractal_pattern()
<         pattern.fix_color_count()
<         p2 = pattern.copy()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
<         pattern.interpolate_stop_as_duplicate_color()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
< 
<         self.assertEqual(pattern, p2)
< 
<     def test_interpolate_to_stop(self):
<         """Duplicate color to STOP"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "red"
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
< 
<     def test_interpolate_to_stop_multi(self):
<         """Multiple duplicate color to multiple STOP"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "red"
<         pattern += (100, 0), (0, 100)
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "red"
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
< 
<     def test_interpolate_to_stop_interleave(self):
<         """interleaved colors do not become STOP"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "blue"
<         pattern += (100, 0), (0, 100)
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "blue"
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
< 
<     def test_interpolate_to_stop_mismatch(self):
<         """if the threadlist and color_changes are mismatched"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += "red"
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += COLOR_CHANGE
<         pattern += (100, 0), (0, 100)
<         pattern += COLOR_CHANGE
<         pattern += (0, 0), (100, 100)
<         pattern += COLOR_CHANGE
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 1)
< 
<     def test_interpolate_stop_no_threads(self):
<         """No threads, cannot duplicate."""
<         pattern = EmbPattern()
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         pattern += STOP
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
<         pattern.interpolate_stop_as_duplicate_color()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
< 
<     def test_interpolate_to_stop_intermix(self):
<         """intermixed colors become intermixed STOP"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += "red"
<         pattern += (100, 0), (0, 100)
<         pattern += "blue"
<         pattern += (0, 0), (100, 100)
<         pattern += "blue"
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         pattern.interpolate_duplicate_color_as_stop()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
< 
<     def test_interpolate_stop_intermix(self):
<         """intermixed STOP become intermixed colors"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         pattern += "blue"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
<         pattern.interpolate_stop_as_duplicate_color()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         self.assertEqual(len(pattern.threadlist),4)
<         self.assertEqual(pattern.threadlist[0], pattern.threadlist[1])
<         self.assertNotEqual(pattern.threadlist[1], pattern.threadlist[2])
<         self.assertEqual(pattern.threadlist[2], pattern.threadlist[3])
< 
<     def test_interpolate_stop_duplicate(self):
<         """multiple STOP become multiple duplicate"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += STOP
<         pattern += STOP
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 4)
<         pattern.interpolate_stop_as_duplicate_color()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         self.assertEqual(len(pattern.threadlist), 5)
< 
<     def test_interpolate_stop_duplicate_break(self):
<         """changing colors, in a stop series works"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += STOP
<         pattern += "blue"
<         pattern += STOP
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 4)
<         pattern.interpolate_stop_as_duplicate_color()
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
<         self.assertEqual(len(pattern.threadlist), 6)
<         self.assertEqual(pattern.threadlist[0], pattern.threadlist[1])
<         self.assertEqual(pattern.threadlist[1], pattern.threadlist[2])
<         self.assertNotEqual(pattern.threadlist[2], pattern.threadlist[3])
<         self.assertEqual(pattern.threadlist[3], pattern.threadlist[4])
<         self.assertEqual(pattern.threadlist[4], pattern.threadlist[5])
< 
<     def test_interpolate_frame_eject(self):
<         """FRAME_EJECTs are interpolated"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern.move_abs(200, 0)
<         pattern.stop()
<         pattern.move_abs(100, 100)
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
<         pattern.interpolate_frame_eject()
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
< 
<     def test_interpolate_frame_eject_multijums(self):
<         """FRAME_EJECTs are interpolated"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern.move_abs(100, 0)
<         pattern.move_abs(200, 0)
<         pattern.stop()
<         pattern.move_abs(100, 0)
<         pattern.move_abs(101, 0)
<         pattern.move_abs(100, 100)
<         pattern += (100, 0), (0, 100)
<         self.assertEqual(pattern.count_stitch_commands(JUMP), 5)
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
<         pattern.interpolate_frame_eject()
<         self.assertEqual(pattern.count_stitch_commands(JUMP), 0)
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
< 
<     def test_interpolate_frame_eject_end(self):
<         """FRAME_EJECTs are interpolated"""
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern.move_abs(200, 0)
<         pattern.stop()
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
<         pattern.interpolate_frame_eject()
<         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
---
> from __future__ import print_function
> 
> import unittest
> 
> from pyembroidery import *
> from test.pattern_for_tests import *
> 
> 
> class TestInterpolate(unittest.TestCase):
> 
>     def test_interpolate_color_stop(self):
>         """Full circle STOP/color conversion"""
>         pattern = get_fractal_pattern()
>         pattern.fix_color_count()
>         p2 = pattern.copy()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
>         pattern.interpolate_stop_as_duplicate_color()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
> 
>         self.assertEqual(pattern, p2)
> 
>     def test_interpolate_to_stop(self):
>         """Duplicate color to STOP"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "red"
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
> 
>     def test_interpolate_to_stop_multi(self):
>         """Multiple duplicate color to multiple STOP"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "red"
>         pattern += (100, 0), (0, 100)
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "red"
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
> 
>     def test_interpolate_to_stop_interleave(self):
>         """interleaved colors do not become STOP"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "blue"
>         pattern += (100, 0), (0, 100)
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "blue"
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
> 
>     def test_interpolate_to_stop_mismatch(self):
>         """if the threadlist and color_changes are mismatched"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += "red"
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += COLOR_CHANGE
>         pattern += (100, 0), (0, 100)
>         pattern += COLOR_CHANGE
>         pattern += (0, 0), (100, 100)
>         pattern += COLOR_CHANGE
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 1)
> 
>     def test_interpolate_stop_no_threads(self):
>         """No threads, cannot duplicate."""
>         pattern = EmbPattern()
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         pattern += STOP
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
>         pattern.interpolate_stop_as_duplicate_color()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 3)
> 
>     def test_interpolate_to_stop_intermix(self):
>         """intermixed colors become intermixed STOP"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += "red"
>         pattern += (100, 0), (0, 100)
>         pattern += "blue"
>         pattern += (0, 0), (100, 100)
>         pattern += "blue"
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         pattern.interpolate_duplicate_color_as_stop()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
> 
>     def test_interpolate_stop_intermix(self):
>         """intermixed STOP become intermixed colors"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         pattern += "blue"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
>         pattern.interpolate_stop_as_duplicate_color()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         self.assertEqual(len(pattern.threadlist),4)
>         self.assertEqual(pattern.threadlist[0], pattern.threadlist[1])
>         self.assertNotEqual(pattern.threadlist[1], pattern.threadlist[2])
>         self.assertEqual(pattern.threadlist[2], pattern.threadlist[3])
> 
>     def test_interpolate_stop_duplicate(self):
>         """multiple STOP become multiple duplicate"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += STOP
>         pattern += STOP
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 4)
>         pattern.interpolate_stop_as_duplicate_color()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         self.assertEqual(len(pattern.threadlist), 5)
> 
>     def test_interpolate_stop_duplicate_break(self):
>         """changing colors, in a stop series works"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += STOP
>         pattern += "blue"
>         pattern += STOP
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 4)
>         pattern.interpolate_stop_as_duplicate_color()
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
>         self.assertEqual(len(pattern.threadlist), 6)
>         self.assertEqual(pattern.threadlist[0], pattern.threadlist[1])
>         self.assertEqual(pattern.threadlist[1], pattern.threadlist[2])
>         self.assertNotEqual(pattern.threadlist[2], pattern.threadlist[3])
>         self.assertEqual(pattern.threadlist[3], pattern.threadlist[4])
>         self.assertEqual(pattern.threadlist[4], pattern.threadlist[5])
> 
>     def test_interpolate_frame_eject(self):
>         """FRAME_EJECTs are interpolated"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern.move_abs(200, 0)
>         pattern.stop()
>         pattern.move_abs(100, 100)
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
>         pattern.interpolate_frame_eject()
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
> 
>     def test_interpolate_frame_eject_multijums(self):
>         """FRAME_EJECTs are interpolated"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern.move_abs(100, 0)
>         pattern.move_abs(200, 0)
>         pattern.stop()
>         pattern.move_abs(100, 0)
>         pattern.move_abs(101, 0)
>         pattern.move_abs(100, 100)
>         pattern += (100, 0), (0, 100)
>         self.assertEqual(pattern.count_stitch_commands(JUMP), 5)
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
>         pattern.interpolate_frame_eject()
>         self.assertEqual(pattern.count_stitch_commands(JUMP), 0)
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
> 
>     def test_interpolate_frame_eject_end(self):
>         """FRAME_EJECTs are interpolated"""
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern.move_abs(200, 0)
>         pattern.stop()
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 0)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 1)
>         pattern.interpolate_frame_eject()
>         self.assertEqual(pattern.count_stitch_commands(FRAME_EJECT), 1)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 0)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_json.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_json.py
1,53c1,53
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestJson(unittest.TestCase):
< 
<     def test_metadata_write_read_json(self):
<         file1 = "metadata.json"
<         pattern = EmbPattern()
<         for i in range(4, 20):
<             pattern.add_thread(EmbThread("random"))
<         pattern.extras['name'] = "My Embroidery."
<         pattern.extras['bytes'] = b'\00these are bytes'
<         pattern.extras['bytes2'] = bytearray(b'this is bytearray')
<         pattern.extras['value'] = 208
<         write(pattern, file1)
<         w_pattern = read(file1)
<         self.assertEqual(w_pattern.extras['name'], "My Embroidery.")
<         self.assertEqual(w_pattern.extras['value'], 208)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
< 
<         self.addCleanup(os.remove, file1)
< 
< 
<     def test_colors_write_read_json(self):
<         file1 = "color.json"
<         for m in range(0, 50):
<             pattern = EmbPattern()
<             for i in range(4, 20):
<                 pattern.add_thread(EmbThread("random"))
<             write(pattern, file1)
<             w_pattern = read(file1)
<             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<             for q in range(0, len(pattern.threadlist)):
<                 self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_read_json(self):
<         file1 = "test.json"
<         pattern = get_shift_pattern()
<         write(pattern, file1)
<         w_pattern = read(file1)
<         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
<         for q in range(0, len(pattern.threadlist)):
<             self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
<         for q in range(0, len(pattern.stitches)):
<             self.assertEqual(pattern.stitches[q], w_pattern.stitches[q])
<         self.addCleanup(os.remove, file1)
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestJson(unittest.TestCase):
> 
>     def test_metadata_write_read_json(self):
>         file1 = "metadata.json"
>         pattern = EmbPattern()
>         for i in range(4, 20):
>             pattern.add_thread(EmbThread("random"))
>         pattern.extras['name'] = "My Embroidery."
>         pattern.extras['bytes'] = b'\00these are bytes'
>         pattern.extras['bytes2'] = bytearray(b'this is bytearray')
>         pattern.extras['value'] = 208
>         write(pattern, file1)
>         w_pattern = read(file1)
>         self.assertEqual(w_pattern.extras['name'], "My Embroidery.")
>         self.assertEqual(w_pattern.extras['value'], 208)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
> 
>         self.addCleanup(os.remove, file1)
> 
> 
>     def test_colors_write_read_json(self):
>         file1 = "color.json"
>         for m in range(0, 50):
>             pattern = EmbPattern()
>             for i in range(4, 20):
>                 pattern.add_thread(EmbThread("random"))
>             write(pattern, file1)
>             w_pattern = read(file1)
>             self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>             for q in range(0, len(pattern.threadlist)):
>                 self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_read_json(self):
>         file1 = "test.json"
>         pattern = get_shift_pattern()
>         write(pattern, file1)
>         w_pattern = read(file1)
>         self.assertEqual(len(pattern.threadlist), len(w_pattern.threadlist))
>         for q in range(0, len(pattern.threadlist)):
>             self.assertEqual(pattern.threadlist[q], w_pattern.threadlist[q])
>         for q in range(0, len(pattern.stitches)):
>             self.assertEqual(pattern.stitches[q], w_pattern.stitches[q])
>         self.addCleanup(os.remove, file1)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_overloads.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_overloads.py
1,92c1,92
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< 
< 
< class TestOverloads(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_pattern_equal(self):
<         shift0 = get_shift_pattern()
<         shift1 = get_shift_pattern()
<         self.assertIsNot(shift0, shift1)
<         self.assertEqual(shift0, shift1)
< 
<     def test_pattern_merge(self):
<         shift0 = get_shift_pattern()
<         shift1 = get_shift_pattern()
<         shift0.add_command(END)
<         last_pos = len(shift0) - 1
<         self.assertEqual(shift0[last_pos][2], END)
<         shift0 += shift1
<         self.assertNotEqual(shift0[last_pos][2], END)
< 
<         shift2 = get_shift_pattern()
<         shift3 = get_shift_pattern()
<         shift2 += shift3
< 
<         self.assertEqual(shift0, shift2)
< 
<         shift4 = get_shift_pattern()
< 
<         self.assertEqual(shift4, shift3)
<         self.assertEqual(shift4, shift1)
<         shift1["name"] = "shifty"
< 
<         self.assertNotEqual(shift4, shift1)
< 
<     def test_pattern_merge_color(self):
<         p0 = EmbPattern()
<         p0 += "blue"
<         p0 += ((0, 0), (1, 1), (2, 2))
<         p0 += "red"
<         p0 += ((4, 4))
< 
<         p1 = EmbPattern()
<         p1 += "red"
<         p1 += ((0, 0), (1, 1), (2, 2)) * 10
<         p1 += "yellow"
<         p1 += ((4, 4))
< 
<         p0 += p1
<         self.assertEqual(p0.count_color_changes(), 2)
< 
<     def test_pattern_merge_color2(self):
<         p0 = EmbPattern()
<         p0 += COLOR_BREAK
<         p0 += "blue"
<         p0 += ((0, 0), (1, 1), (2, 2))
<         p0 += "red"
<         p0 += ((4, 4))
< 
<         p1 = EmbPattern()
<         p1 += COLOR_BREAK
<         p1 += "red"
<         p1 += ((0, 0), (1, 1), (2, 2))
<         p1 += "yellow"
<         p1 += ((4, 4))
< 
<         p0 += p1
<         self.assertEqual(p0.count_color_changes(), 2)
< 
<     def test_thread_equal(self):
<         t0 = EmbThread("red")
<         t1 = EmbThread("#F00")
<         self.assertEqual(t0, t1)
< 
<     def test_matrix(self):
<         m0 = EmbMatrix()
<         m1 = EmbMatrix()
<         m0.post_scale(2)
<         m1.post_rotate(30)
<         catted = m0.__matmul__(m1)  # might run in 2.7
<         m2 = EmbMatrix()
<         m2.post_scale(2)
<         m2.post_rotate(30)
<         self.assertEqual(catted, m2)
< 
< 
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> 
> 
> class TestOverloads(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_pattern_equal(self):
>         shift0 = get_shift_pattern()
>         shift1 = get_shift_pattern()
>         self.assertIsNot(shift0, shift1)
>         self.assertEqual(shift0, shift1)
> 
>     def test_pattern_merge(self):
>         shift0 = get_shift_pattern()
>         shift1 = get_shift_pattern()
>         shift0.add_command(END)
>         last_pos = len(shift0) - 1
>         self.assertEqual(shift0[last_pos][2], END)
>         shift0 += shift1
>         self.assertNotEqual(shift0[last_pos][2], END)
> 
>         shift2 = get_shift_pattern()
>         shift3 = get_shift_pattern()
>         shift2 += shift3
> 
>         self.assertEqual(shift0, shift2)
> 
>         shift4 = get_shift_pattern()
> 
>         self.assertEqual(shift4, shift3)
>         self.assertEqual(shift4, shift1)
>         shift1["name"] = "shifty"
> 
>         self.assertNotEqual(shift4, shift1)
> 
>     def test_pattern_merge_color(self):
>         p0 = EmbPattern()
>         p0 += "blue"
>         p0 += ((0, 0), (1, 1), (2, 2))
>         p0 += "red"
>         p0 += ((4, 4))
> 
>         p1 = EmbPattern()
>         p1 += "red"
>         p1 += ((0, 0), (1, 1), (2, 2)) * 10
>         p1 += "yellow"
>         p1 += ((4, 4))
> 
>         p0 += p1
>         self.assertEqual(p0.count_color_changes(), 2)
> 
>     def test_pattern_merge_color2(self):
>         p0 = EmbPattern()
>         p0 += COLOR_BREAK
>         p0 += "blue"
>         p0 += ((0, 0), (1, 1), (2, 2))
>         p0 += "red"
>         p0 += ((4, 4))
> 
>         p1 = EmbPattern()
>         p1 += COLOR_BREAK
>         p1 += "red"
>         p1 += ((0, 0), (1, 1), (2, 2))
>         p1 += "yellow"
>         p1 += ((4, 4))
> 
>         p0 += p1
>         self.assertEqual(p0.count_color_changes(), 2)
> 
>     def test_thread_equal(self):
>         t0 = EmbThread("red")
>         t1 = EmbThread("#F00")
>         self.assertEqual(t0, t1)
> 
>     def test_matrix(self):
>         m0 = EmbMatrix()
>         m1 = EmbMatrix()
>         m0.post_scale(2)
>         m1.post_rotate(30)
>         catted = m0.__matmul__(m1)  # might run in 2.7
>         m2 = EmbMatrix()
>         m2.post_scale(2)
>         m2.post_rotate(30)
>         self.assertEqual(catted, m2)
> 
> 
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_palette.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_palette.py
1,105c1,105
< from __future__ import print_function
< 
< import unittest
< 
< from pyembroidery import *
< from pyembroidery.EmbThreadPec import *
< from pyembroidery.EmbThread import build_unique_palette, build_nonrepeat_palette, build_palette
< 
< 
< class TestPalettes(unittest.TestCase):
< 
<     def test_unique_palette(self):
<         """Similar elements should not plot to the same palette index"""
<         pattern = EmbPattern()
<         pattern += "#FF0001"
<         pattern += "Blue"
<         pattern += "Blue"
<         pattern += "Red"
<         threadset = get_thread_set()
<         palette = build_unique_palette(threadset,pattern.threadlist)
<         self.assertNotEqual(palette[0],palette[3])  # Red and altered Red
<         self.assertEqual(palette[1], palette[2])  # Blue and Blue
< 
<     def test_unique_palette_large(self):
<         """Excessive palette entries that all map, should be mapped"""
<         pattern = EmbPattern()
<         for x in range(0, 100):
<             pattern += "black"
<         threadset = get_thread_set()
<         palette = build_unique_palette(threadset, pattern.threadlist)
<         self.assertEqual(palette[0], palette[1])
< 
<     def test_unique_palette_unmap(self):
<         """Excessive palette entries can't all map, should map what it can and repeat"""
<         pattern = EmbPattern()
<         for i in range(0, 100):
<             thread = EmbThread()
<             thread.set_color(i, i, i)
<             pattern += thread
<         threadset = get_thread_set()
<         palette = build_unique_palette(threadset, pattern.threadlist)
<         palette.sort()
< 
<     def test_unique_palette_max(self):
<         """If the entries equal the list they should all map."""
<         pattern = EmbPattern()
<         threadset = get_thread_set()
<         for i in range(0, len(threadset)-2):
<             thread = EmbThread()
<             thread.set_color(i, i, i)
<             pattern += thread
<         palette = build_unique_palette(threadset, pattern.threadlist)
<         palette.sort()
<         for i in range(1,len(palette)):
<             self.assertNotEqual(palette[i-1], palette[i])
< 
<     def test_nonrepeat_palette_moving(self):
<         """The almost same color should not get plotted to the same palette index"""
<         pattern = EmbPattern()
<         pattern += "Red"
<         pattern += "Blue"
<         pattern += "#0100FF"
<         pattern += "Red"
<         threadset = get_thread_set()
<         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
<         self.assertEqual(palette[0],palette[3]) # Red and Red
<         self.assertNotEqual(palette[1], palette[2])  # Blue and altered Blue
< 
<     def test_nonrepeat_palette_stay_moved(self):
<         """An almost same moved, only temporary"""
<         pattern = EmbPattern()
<         pattern += "Red"
<         pattern += "Blue"
<         pattern += "#0100FF"
<         pattern += "Red"
<         pattern += "#0100FF"
<         threadset = get_thread_set()
<         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
<         self.assertEqual(palette[0],palette[3]) # Red and Red
<         self.assertNotEqual(palette[1], palette[2])  # Blue and altered Blue
<         self.assertNotEqual(palette[2], palette[4])  # same color, but color was moved
< 
<     def test_nonrepeat_palette_same(self):
<         """The same exact same color if repeated should remain"""
<         pattern = EmbPattern()
<         pattern += "Red"
<         pattern += "Blue"
<         pattern += "#0000FF"  # actual blue
<         pattern += "Red"
<         threadset = get_thread_set()
<         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
<         self.assertEqual(palette[0],palette[3]) # Red and Red
<         self.assertEqual(palette[1], palette[2])  # Blue and Blue
< 
<     def test_palette(self):
<         """Similar colors map to the same index"""
<         pattern = EmbPattern()
<         pattern += "#FF0001"
<         pattern += "Blue"
<         pattern += "Blue"
<         pattern += "Red"
<         threadset = get_thread_set()
<         palette = build_palette(threadset,pattern.threadlist)
<         self.assertEqual(palette[0],palette[3])  # Red and altered Red
<         self.assertEqual(palette[1], palette[2])  # Blue and Blue
---
> from __future__ import print_function
> 
> import unittest
> 
> from pyembroidery import *
> from pyembroidery.EmbThreadPec import *
> from pyembroidery.EmbThread import build_unique_palette, build_nonrepeat_palette, build_palette
> 
> 
> class TestPalettes(unittest.TestCase):
> 
>     def test_unique_palette(self):
>         """Similar elements should not plot to the same palette index"""
>         pattern = EmbPattern()
>         pattern += "#FF0001"
>         pattern += "Blue"
>         pattern += "Blue"
>         pattern += "Red"
>         threadset = get_thread_set()
>         palette = build_unique_palette(threadset,pattern.threadlist)
>         self.assertNotEqual(palette[0],palette[3])  # Red and altered Red
>         self.assertEqual(palette[1], palette[2])  # Blue and Blue
> 
>     def test_unique_palette_large(self):
>         """Excessive palette entries that all map, should be mapped"""
>         pattern = EmbPattern()
>         for x in range(0, 100):
>             pattern += "black"
>         threadset = get_thread_set()
>         palette = build_unique_palette(threadset, pattern.threadlist)
>         self.assertEqual(palette[0], palette[1])
> 
>     def test_unique_palette_unmap(self):
>         """Excessive palette entries can't all map, should map what it can and repeat"""
>         pattern = EmbPattern()
>         for i in range(0, 100):
>             thread = EmbThread()
>             thread.set_color(i, i, i)
>             pattern += thread
>         threadset = get_thread_set()
>         palette = build_unique_palette(threadset, pattern.threadlist)
>         palette.sort()
> 
>     def test_unique_palette_max(self):
>         """If the entries equal the list they should all map."""
>         pattern = EmbPattern()
>         threadset = get_thread_set()
>         for i in range(0, len(threadset)-2):
>             thread = EmbThread()
>             thread.set_color(i, i, i)
>             pattern += thread
>         palette = build_unique_palette(threadset, pattern.threadlist)
>         palette.sort()
>         for i in range(1,len(palette)):
>             self.assertNotEqual(palette[i-1], palette[i])
> 
>     def test_nonrepeat_palette_moving(self):
>         """The almost same color should not get plotted to the same palette index"""
>         pattern = EmbPattern()
>         pattern += "Red"
>         pattern += "Blue"
>         pattern += "#0100FF"
>         pattern += "Red"
>         threadset = get_thread_set()
>         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
>         self.assertEqual(palette[0],palette[3]) # Red and Red
>         self.assertNotEqual(palette[1], palette[2])  # Blue and altered Blue
> 
>     def test_nonrepeat_palette_stay_moved(self):
>         """An almost same moved, only temporary"""
>         pattern = EmbPattern()
>         pattern += "Red"
>         pattern += "Blue"
>         pattern += "#0100FF"
>         pattern += "Red"
>         pattern += "#0100FF"
>         threadset = get_thread_set()
>         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
>         self.assertEqual(palette[0],palette[3]) # Red and Red
>         self.assertNotEqual(palette[1], palette[2])  # Blue and altered Blue
>         self.assertNotEqual(palette[2], palette[4])  # same color, but color was moved
> 
>     def test_nonrepeat_palette_same(self):
>         """The same exact same color if repeated should remain"""
>         pattern = EmbPattern()
>         pattern += "Red"
>         pattern += "Blue"
>         pattern += "#0000FF"  # actual blue
>         pattern += "Red"
>         threadset = get_thread_set()
>         palette = build_nonrepeat_palette(threadset,pattern.threadlist)
>         self.assertEqual(palette[0],palette[3]) # Red and Red
>         self.assertEqual(palette[1], palette[2])  # Blue and Blue
> 
>     def test_palette(self):
>         """Similar colors map to the same index"""
>         pattern = EmbPattern()
>         pattern += "#FF0001"
>         pattern += "Blue"
>         pattern += "Blue"
>         pattern += "Red"
>         threadset = get_thread_set()
>         palette = build_palette(threadset,pattern.threadlist)
>         self.assertEqual(palette[0],palette[3])  # Red and altered Red
>         self.assertEqual(palette[1], palette[2])  # Blue and Blue
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_trims_dst_jef.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_trims_dst_jef.py
1,73c1,73
< from __future__ import print_function
< 
< import unittest
< 
< from pyembroidery import *
< from test.pattern_for_tests import *
< 
< 
< class TestTrims(unittest.TestCase):
< 
<     def test_dst_trims(self):
<         file0 = "trim.dst"
<         pattern = get_fractal_pattern()
<         write_dst(pattern, file0)
<         loaded_pattern = read_dst(file0)
<         self.assertIsNotNone(loaded_pattern)
<         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         self.addCleanup(os.remove, file0)
< 
<     def test_dst_trims_fail(self):
<         file0 = "trim.dst"
<         pattern = get_fractal_pattern()
<         write_dst(pattern, file0)
<         loaded_pattern = read_dst(file0, {"trim_at": 50})  # Lines beyond 50 jumps get a trim.
<         self.assertIsNotNone(loaded_pattern)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         self.addCleanup(os.remove, file0)
< 
<     def test_dst_trims_success(self):
<         file0 = "trim.dst"
<         pattern = get_fractal_pattern()
<         write_dst(pattern, file0, {"trim_at": 50})  # We make trim jumps big enough.
<         loaded_pattern = read_dst(file0, {"trim_at": 50, "clipping": False})  # Lines beyond 50 jumps get a trim.
<         self.assertIsNotNone(loaded_pattern)
<         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         self.addCleanup(os.remove, file0)
< 
<     def test_jef_trims(self):
<         file0 = "trim.jef"
<         pattern = get_fractal_pattern()
<         write_jef(pattern, file0)
<         loaded_pattern = read_jef(file0)
<         self.assertIsNotNone(loaded_pattern)
<         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         self.addCleanup(os.remove, file0)
< 
<     def test_jef_trims_off(self):
<         file0 = "trim.jef"
<         pattern = get_fractal_pattern()
<         write_jef(pattern, file0)
<         loaded_pattern = read_jef(file0, {"trim_distance": None})
<         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
<         self.assertIsNotNone(loaded_pattern)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         self.addCleanup(os.remove, file0)
< 
<     def test_jef_trims_commands(self):
<         file0 = "trim.jef"
<         pattern = get_fractal_pattern()
<         write_jef(pattern, file0, {"trims": True})
<         loaded_pattern = read_jef(file0, {"trim_distance": None})
<         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         loaded_pattern = read_jef(file0, {"trim_distance": None, "clipping": False})
<         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 21)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
<         loaded_pattern = read_jef(file0, {"trim_distance": None, "clipping": False, "trims": True, })
<         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 21)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 2)
<         loaded_pattern = read_jef(file0, {"trim_distance": None, "trims": True})
<         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
<         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 2)
<         self.addCleanup(os.remove, file0)
---
> from __future__ import print_function
> 
> import unittest
> 
> from pyembroidery import *
> from test.pattern_for_tests import *
> 
> 
> class TestTrims(unittest.TestCase):
> 
>     def test_dst_trims(self):
>         file0 = "trim.dst"
>         pattern = get_fractal_pattern()
>         write_dst(pattern, file0)
>         loaded_pattern = read_dst(file0)
>         self.assertIsNotNone(loaded_pattern)
>         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         self.addCleanup(os.remove, file0)
> 
>     def test_dst_trims_fail(self):
>         file0 = "trim.dst"
>         pattern = get_fractal_pattern()
>         write_dst(pattern, file0)
>         loaded_pattern = read_dst(file0, {"trim_at": 50})  # Lines beyond 50 jumps get a trim.
>         self.assertIsNotNone(loaded_pattern)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         self.addCleanup(os.remove, file0)
> 
>     def test_dst_trims_success(self):
>         file0 = "trim.dst"
>         pattern = get_fractal_pattern()
>         write_dst(pattern, file0, {"trim_at": 50})  # We make trim jumps big enough.
>         loaded_pattern = read_dst(file0, {"trim_at": 50, "clipping": False})  # Lines beyond 50 jumps get a trim.
>         self.assertIsNotNone(loaded_pattern)
>         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         self.addCleanup(os.remove, file0)
> 
>     def test_jef_trims(self):
>         file0 = "trim.jef"
>         pattern = get_fractal_pattern()
>         write_jef(pattern, file0)
>         loaded_pattern = read_jef(file0)
>         self.assertIsNotNone(loaded_pattern)
>         self.assertNotEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         self.addCleanup(os.remove, file0)
> 
>     def test_jef_trims_off(self):
>         file0 = "trim.jef"
>         pattern = get_fractal_pattern()
>         write_jef(pattern, file0)
>         loaded_pattern = read_jef(file0, {"trim_distance": None})
>         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
>         self.assertIsNotNone(loaded_pattern)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         self.addCleanup(os.remove, file0)
> 
>     def test_jef_trims_commands(self):
>         file0 = "trim.jef"
>         pattern = get_fractal_pattern()
>         write_jef(pattern, file0, {"trims": True})
>         loaded_pattern = read_jef(file0, {"trim_distance": None})
>         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         loaded_pattern = read_jef(file0, {"trim_distance": None, "clipping": False})
>         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 21)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 0)
>         loaded_pattern = read_jef(file0, {"trim_distance": None, "clipping": False, "trims": True, })
>         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 21)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 2)
>         loaded_pattern = read_jef(file0, {"trim_distance": None, "trims": True})
>         self.assertEqual(loaded_pattern.count_stitch_commands(JUMP), 15)
>         self.assertEqual(loaded_pattern.count_stitch_commands(TRIM), 2)
>         self.addCleanup(os.remove, file0)
diff -r source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_writes.py lookaside-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36/test/test_writes.py
1,187c1,187
< from __future__ import print_function
< 
< import unittest
< 
< from test.pattern_for_tests import *
< from pyembroidery import *
< 
< 
< class TestWrites(unittest.TestCase):
< 
<     def position_equals(self, stitches, j, k):
<         self.assertEqual(stitches[j][:1], stitches[k][:1])
< 
<     def test_write_png(self):
<         file1 = "file.png"
<         write_png(get_shift_pattern(), file1, {"background": "#F00", "linewidth": 5})
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_dst_read_dst(self):
<         file1 = "file.dst"
<         write_dst(get_big_pattern(), file1)
<         dst_pattern = read_dst(file1)
<         self.assertEqual(len(dst_pattern.threadlist), 0)
<         self.assertEqual(dst_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(dst_pattern)
<         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(dst_pattern.stitches, 0, -1)
<         print("dst: ", dst_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_exp_read_exp(self):
<         file1 = "file.exp"
<         write_exp(get_big_pattern(), file1)
<         exp_pattern = read_exp(file1)
<         self.assertEqual(len(exp_pattern.threadlist), 0)
<         self.assertEqual(exp_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(exp_pattern)
<         self.assertEqual(exp_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(exp_pattern.stitches, 0, -1)
<         print("exp: ", exp_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_vp3_read_vp3(self):
<         file1 = "file.vp3"
<         write_vp3(get_big_pattern(), file1)
<         vp3_pattern = read_vp3(file1)
<         self.assertEqual(len(vp3_pattern.threadlist), vp3_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(vp3_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(vp3_pattern)
<         self.assertEqual(vp3_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(vp3_pattern.stitches, 0, -1)
<         print("vp3: ", vp3_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_jef_read_jef(self):
<         file1 = "file.jef"
<         write_jef(get_big_pattern(), file1)
<         jef_pattern = read_jef(file1)
<         self.assertEqual(len(jef_pattern.threadlist), jef_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(jef_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(jef_pattern)
<         self.assertEqual(jef_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(jef_pattern.stitches, 0, -1)
<         print("jef: ", jef_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_pec_read_pec(self):
<         file1 = "file.pec"
<         write_pec(get_big_pattern(), file1)
<         pec_pattern = read_pec(file1)
<         self.assertEqual(len(pec_pattern.threadlist), pec_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(pec_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(pec_pattern)
<         self.assertEqual(pec_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(pec_pattern.stitches, 0, -1)
<         print("pec: ", pec_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_pes_read_pes(self):
<         file1 = "file.pes"
<         write_pes(get_big_pattern(), file1)
<         pes_pattern = read_pes(file1)
<         self.assertEqual(len(pes_pattern.threadlist), pes_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(pes_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(pes_pattern)
<         self.assertEqual(pes_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(pes_pattern.stitches, 0, -1)
<         print("pes: ", pes_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_xxx_read_xxx(self):
<         file1 = "file.xxx"
<         write_xxx(get_big_pattern(), file1)
<         pattern = read_xxx(file1)
<         self.assertEqual(len(pattern.threadlist), pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertIsNotNone(pattern)
<         self.assertEqual(pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(pattern.stitches, 0, -1)
<         print("xxx: ", pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_u01_read_u01(self):
<         file1 = "file.u01"
<         write_u01(get_big_pattern(), file1)
<         u01_pattern = read_u01(file1)
<         self.assertEqual(len(u01_pattern.threadlist), 0)
<         self.assertEqual(u01_pattern.count_stitch_commands(NEEDLE_SET), 16)
<         self.assertIsNotNone(u01_pattern)
<         self.assertEqual(u01_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(u01_pattern.stitches, 0, -1)
<         print("u01: ", u01_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_csv_read_csv(self):
<         file1 = "file.csv"
<         write_csv(get_big_pattern(), file1, {"encode": True})
<         csv_pattern = read_csv(file1)
<         self.assertIsNotNone(csv_pattern)
<         self.assertEqual(len(csv_pattern.threadlist), csv_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
<         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(csv_pattern.stitches, 0, -1)
<         print("csv: ", csv_pattern.stitches)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_gcode_read_gcode(self):
<         file1 = "file.gcode"
<         write_gcode(get_big_pattern(), file1)
<         gcode_pattern = read_gcode(file1)
<         self.assertIsNotNone(gcode_pattern)
<         thread_count = len(gcode_pattern.threadlist)
<         change_count = gcode_pattern.count_stitch_commands(COLOR_CHANGE) + 1
<         print(thread_count)
<         print(change_count)
< 
<         self.assertEqual(thread_count, change_count)
<         self.assertEqual(gcode_pattern.count_stitch_commands(COLOR_CHANGE), 15)
<         self.assertEqual(gcode_pattern.count_stitch_commands(STITCH), 5 * 16)
<         self.position_equals(gcode_pattern.stitches, 0, -1)
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_txt(self):
<         file1 = "file.txt"
<         write_txt(get_big_pattern(), file1)
<         write_txt(get_big_pattern(), file1, {"mimic": True})
<         self.addCleanup(os.remove, file1)
< 
<     def test_write_pes_mismatched(self):
<         file1 = "file.pes"
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += "red"
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += COLOR_CHANGE
<         pattern += (100, 0), (0, 100)
<         pattern += COLOR_CHANGE
<         pattern += (0, 0), (100, 100)
<         pattern += COLOR_CHANGE
<         pattern += (100, 0), (0, 100)
<         write_pes(pattern, file1, {"version": "6t"})
<         write_pes(pattern, file1)
<         self.addCleanup(os.remove, file1)
< 
<     def test_pes_writes_stop(self):
<         """Test if pes can read/write a stop command."""
<         file1 = "file.pes"
<         pattern = EmbPattern()
<         pattern += "red"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         pattern += "blue"
<         pattern += (0, 0), (100, 100)
<         pattern += STOP
<         pattern += (100, 0), (0, 100)
<         write_pes(pattern, file1, {"version": "6t"})
<         loaded = read_pes(file1)
<         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
<         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 1)
<         self.assertEqual(pattern.count_threads(), 2)
<         self.assertEqual(loaded.count_stitch_commands(STOP), 2)
<         self.assertEqual(loaded.count_stitch_commands(COLOR_CHANGE), 1)
<         self.assertEqual(loaded.count_threads(), 2)
<         self.addCleanup(os.remove, file1)
< 
---
> from __future__ import print_function
> 
> import unittest
> 
> from test.pattern_for_tests import *
> from pyembroidery import *
> 
> 
> class TestWrites(unittest.TestCase):
> 
>     def position_equals(self, stitches, j, k):
>         self.assertEqual(stitches[j][:1], stitches[k][:1])
> 
>     def test_write_png(self):
>         file1 = "file.png"
>         write_png(get_shift_pattern(), file1, {"background": "#F00", "linewidth": 5})
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_dst_read_dst(self):
>         file1 = "file.dst"
>         write_dst(get_big_pattern(), file1)
>         dst_pattern = read_dst(file1)
>         self.assertEqual(len(dst_pattern.threadlist), 0)
>         self.assertEqual(dst_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(dst_pattern)
>         self.assertEqual(dst_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(dst_pattern.stitches, 0, -1)
>         print("dst: ", dst_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_exp_read_exp(self):
>         file1 = "file.exp"
>         write_exp(get_big_pattern(), file1)
>         exp_pattern = read_exp(file1)
>         self.assertEqual(len(exp_pattern.threadlist), 0)
>         self.assertEqual(exp_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(exp_pattern)
>         self.assertEqual(exp_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(exp_pattern.stitches, 0, -1)
>         print("exp: ", exp_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_vp3_read_vp3(self):
>         file1 = "file.vp3"
>         write_vp3(get_big_pattern(), file1)
>         vp3_pattern = read_vp3(file1)
>         self.assertEqual(len(vp3_pattern.threadlist), vp3_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(vp3_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(vp3_pattern)
>         self.assertEqual(vp3_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(vp3_pattern.stitches, 0, -1)
>         print("vp3: ", vp3_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_jef_read_jef(self):
>         file1 = "file.jef"
>         write_jef(get_big_pattern(), file1)
>         jef_pattern = read_jef(file1)
>         self.assertEqual(len(jef_pattern.threadlist), jef_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(jef_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(jef_pattern)
>         self.assertEqual(jef_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(jef_pattern.stitches, 0, -1)
>         print("jef: ", jef_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_pec_read_pec(self):
>         file1 = "file.pec"
>         write_pec(get_big_pattern(), file1)
>         pec_pattern = read_pec(file1)
>         self.assertEqual(len(pec_pattern.threadlist), pec_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(pec_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(pec_pattern)
>         self.assertEqual(pec_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(pec_pattern.stitches, 0, -1)
>         print("pec: ", pec_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_pes_read_pes(self):
>         file1 = "file.pes"
>         write_pes(get_big_pattern(), file1)
>         pes_pattern = read_pes(file1)
>         self.assertEqual(len(pes_pattern.threadlist), pes_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(pes_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(pes_pattern)
>         self.assertEqual(pes_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(pes_pattern.stitches, 0, -1)
>         print("pes: ", pes_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_xxx_read_xxx(self):
>         file1 = "file.xxx"
>         write_xxx(get_big_pattern(), file1)
>         pattern = read_xxx(file1)
>         self.assertEqual(len(pattern.threadlist), pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertIsNotNone(pattern)
>         self.assertEqual(pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(pattern.stitches, 0, -1)
>         print("xxx: ", pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_u01_read_u01(self):
>         file1 = "file.u01"
>         write_u01(get_big_pattern(), file1)
>         u01_pattern = read_u01(file1)
>         self.assertEqual(len(u01_pattern.threadlist), 0)
>         self.assertEqual(u01_pattern.count_stitch_commands(NEEDLE_SET), 16)
>         self.assertIsNotNone(u01_pattern)
>         self.assertEqual(u01_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(u01_pattern.stitches, 0, -1)
>         print("u01: ", u01_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_csv_read_csv(self):
>         file1 = "file.csv"
>         write_csv(get_big_pattern(), file1, {"encode": True})
>         csv_pattern = read_csv(file1)
>         self.assertIsNotNone(csv_pattern)
>         self.assertEqual(len(csv_pattern.threadlist), csv_pattern.count_stitch_commands(COLOR_CHANGE) + 1)
>         self.assertEqual(csv_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(csv_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(csv_pattern.stitches, 0, -1)
>         print("csv: ", csv_pattern.stitches)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_gcode_read_gcode(self):
>         file1 = "file.gcode"
>         write_gcode(get_big_pattern(), file1)
>         gcode_pattern = read_gcode(file1)
>         self.assertIsNotNone(gcode_pattern)
>         thread_count = len(gcode_pattern.threadlist)
>         change_count = gcode_pattern.count_stitch_commands(COLOR_CHANGE) + 1
>         print(thread_count)
>         print(change_count)
> 
>         self.assertEqual(thread_count, change_count)
>         self.assertEqual(gcode_pattern.count_stitch_commands(COLOR_CHANGE), 15)
>         self.assertEqual(gcode_pattern.count_stitch_commands(STITCH), 5 * 16)
>         self.position_equals(gcode_pattern.stitches, 0, -1)
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_txt(self):
>         file1 = "file.txt"
>         write_txt(get_big_pattern(), file1)
>         write_txt(get_big_pattern(), file1, {"mimic": True})
>         self.addCleanup(os.remove, file1)
> 
>     def test_write_pes_mismatched(self):
>         file1 = "file.pes"
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += "red"
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += COLOR_CHANGE
>         pattern += (100, 0), (0, 100)
>         pattern += COLOR_CHANGE
>         pattern += (0, 0), (100, 100)
>         pattern += COLOR_CHANGE
>         pattern += (100, 0), (0, 100)
>         write_pes(pattern, file1, {"version": "6t"})
>         write_pes(pattern, file1)
>         self.addCleanup(os.remove, file1)
> 
>     def test_pes_writes_stop(self):
>         """Test if pes can read/write a stop command."""
>         file1 = "file.pes"
>         pattern = EmbPattern()
>         pattern += "red"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         pattern += "blue"
>         pattern += (0, 0), (100, 100)
>         pattern += STOP
>         pattern += (100, 0), (0, 100)
>         write_pes(pattern, file1, {"version": "6t"})
>         loaded = read_pes(file1)
>         self.assertEqual(pattern.count_stitch_commands(STOP), 2)
>         self.assertEqual(pattern.count_stitch_commands(COLOR_CHANGE), 1)
>         self.assertEqual(pattern.count_threads(), 2)
>         self.assertEqual(loaded.count_stitch_commands(STOP), 2)
>         self.assertEqual(loaded.count_stitch_commands(COLOR_CHANGE), 1)
>         self.assertEqual(loaded.count_threads(), 2)
>         self.addCleanup(os.remove, file1)
> 
Only in source-pyembroidery-1.4.36.tar.gz-extracted/pyembroidery-1.4.36: .travis.yml
