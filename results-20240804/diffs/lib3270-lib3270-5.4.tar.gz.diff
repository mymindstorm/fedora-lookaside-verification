Source package : lib3270
File name       : lib3270-5.4.tar.gz
Lookaside URL   : https://src.fedoraproject.org/repo/pkgs/lib3270/lib3270-5.4.tar.gz/sha512/b96567a681a086f265eeba96db6336ad1bc2d52ece4dd24297280adb661bcb2faf07373b73ef7b06a4096e74b54aadb507e42e61dfa9a0280414c0b179c24227/lib3270-5.4.tar.gz
Source URL      : https://github.com/PerryWerneck/lib3270/archive/5.4/lib3270-5.4.tar.gz

source file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/source-lib3270-5.4.tar.gz: gzip compressed data, from Unix, original size modulo 2^32 1884160
lookaside file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/lookaside-lib3270-5.4.tar.gz: gzip compressed data, from Unix, original size modulo 2^32 1822720


diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/arch/PKGBUILD lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/arch/PKGBUILD
5c5
< pkgver=5.4+git20240817
---
> pkgver=5.3
8c8
< url="https://github.com/PerryWerneck/lib3270"
---
> url="https://github.com/PerryWerneck/lib3270/"
11,12c11,12
< depends=(openssl)
< makedepends=(autoconf automake make openssl libtool gzip)
---
> depends=()
> makedepends=(autoconf automake make openssl)
20c20
< provides=($pkgname) 
---
> provides=($pkgname)
25,26d24
<   mkdir -p scripts
<   touch scripts/config.rpath
28c26
<   ./configure --prefix=/usr --disable-static
---
>   ./configure --prefix=/usr
40d37
< 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/autogen.sh lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/autogen.sh
3,4d2
< builddir=${PWD}
< 
7a6
> olddir=`pwd`
10,27d8
< mkdir -p scripts
< mkdir -p m4
< 
< LIBTOOLIZE=$(which libtoolize)
< if [ -z ${LIBTOOLIZE} ]; then
< 	LIBTOOLIZE=$(which glibtoolize)
< fi
< if [ -z ${LIBTOOLIZE} ]; then
< 	echo "Can't find libtoolize"
< 	exit -1
< fi
< 
< ${LIBTOOLIZE} --force
< if test $? != 0 ; then
< 	echo "libtoolize failed."
< 	exit -1
< fi
< 
34,40c15
< #autoheader --force
< #if test $? != 0 ; then
< #	echo "autoheader failed."
< #	exit -1
< #fi
< 
< autoconf --force
---
> autoconf
45a21
> mkdir -p scripts
48,52c24,25
< autopoint
< 
< cd "${builddir}"
< 
< test -n "$NOCONFIGURE" || "$srcdir/configure" --srcdir=${srcdir} $@
---
> cd "$olddir"
> test -n "$NOCONFIGURE" || "$srcdir/configure" "$@"
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4: CHANGELOG
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/configure.ac lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/configure.ac
42,46d41
< AC_CONFIG_MACRO_DIRS([m4])
< 
< dnl Initialize libtool.
< LT_INIT
< 
48c43
< AC_CONFIG_HEADERS([src/include/config.h])
---
> AC_CONFIG_HEADER([src/include/config.h])
56,58d50
< dnl Set gettext version
< AM_GNU_GETTEXT_VERSION([0.14])
< 
88,91d79
< AC_SUBST(CFLAGS)
< AC_SUBST(LDFLAGS)
< AC_SUBST(LIBS)
< 
126c114
< 		DLLEXT=".dylib"
---
> 		DLLEXT=".so"
129c117
< 		INSTALL_PACKAGES="macos-lib ${INSTALL_PACKAGES}"
---
> 		INSTALL_PACKAGES="linux-lib ${INSTALL_PACKAGES}"
146,148d133
< 		AC_CONFIG_FILES(debian/control)
< 		AC_CONFIG_FILES(debian/shlibs)
< 
170,183d154
< 
< dnl ---------------------------------------------------------------------------
< dnl Compatibility definitions
< dnl ---------------------------------------------------------------------------
< 
< AC_DEFINE(UNLOCK_MS, 350, [The delay, in miliseconds, between the host unlocking the keyboard and lib3270 actually performing the unlock])
< 
< AC_DEFINE(X3270_TN3270E,[],[X3270 compatibility])
< AC_DEFINE(X3270_ANSI,[],[X3270 compatibility])
< AC_DEFINE(X3270_APL,[],[X3270 compatibility])
< 
< AC_DEFINE(X3270_TRACE,[],[X3270 compatibility])
< AC_DEFINE(X3270_FT,[],[X3270 compatibility])
< 
199c170
< AC_DEFINE_UNQUOTED(PRODUCT_NAME, $app_cv_product, [The product name])
---
> AC_DEFINE_UNQUOTED(PRODUCT_NAME, $app_cv_product)
207,208c178,179
< AC_DEFINE_UNQUOTED(PACKAGE_MAJOR_VERSION, $app_vrs_major, [The library major version])
< AC_DEFINE_UNQUOTED(PACKAGE_MINOR_VERSION, $app_vrs_minor, [The library minor version])
---
> AC_DEFINE_UNQUOTED(PACKAGE_MAJOR_VERSION, $app_vrs_major)
> AC_DEFINE_UNQUOTED(PACKAGE_MINOR_VERSION, $app_vrs_minor)
215,217d185
< AC_ARG_WITH([product-id], [AS_HELP_STRING([--with-product-id], [Set the product ID])], [ app_cv_product_id="$withval" ],[ app_cv_product_id="br.app.pw3270" ])
< AC_SUBST(PRODUCT_ID,"$app_cv_product_id")
< 
221,223c189,191
< AC_DEFINE_UNQUOTED(PACKAGE_MAJOR_RELEASE, $app_rls_major, [The library major release])
< AC_DEFINE_UNQUOTED(PACKAGE_MINOR_RELEASE, $app_rls_minor, [The library minor release])
< AC_DEFINE_UNQUOTED(PACKAGE_RELEASE, "$app_cv_release", [The package release])
---
> AC_DEFINE_UNQUOTED(PACKAGE_MAJOR_RELEASE, $app_rls_major)
> AC_DEFINE_UNQUOTED(PACKAGE_MINOR_RELEASE, $app_rls_minor)
> AC_DEFINE_UNQUOTED(PACKAGE_RELEASE, "$app_cv_release")
237,238c205,206
< AC_DEFINE_UNQUOTED(RPQ_BUILD_DATE,"$rpq_build_date",[The RPQ build date])
< AC_DEFINE_UNQUOTED(RPQ_TIMESTAMP_VALUE,"$rpq_timestamp",[The RPQ timestamp])
---
> AC_DEFINE_UNQUOTED(RPQ_BUILD_DATE,"$rpq_build_date")
> AC_DEFINE_UNQUOTED(RPQ_TIMESTAMP_VALUE,"$rpq_timestamp")
240,241c208,209
< AC_DEFINE_UNQUOTED(SCCS_USER,"$USER",[The build user])
< AC_DEFINE_UNQUOTED(SCCS_DATE,"$sccs_date",[The build date])
---
> AC_DEFINE_UNQUOTED(SCCS_USER,"$USER")
> AC_DEFINE_UNQUOTED(SCCS_DATE,"$sccs_date")
243c211
< AC_DEFINE_UNQUOTED(RPQ_REVISION,"$rpq_revision",[The RPQ revision])
---
> AC_DEFINE_UNQUOTED(RPQ_REVISION,"$rpq_revision")
263c231
< 	AC_DEFINE(HAVE_LIBINTL, 1, [Libintl is available])
---
> 	AC_DEFINE(HAVE_LIBINTL, 1)
373a342,355
> AC_MSG_CHECKING(whether $CC accepts -fvisibility=hidden)
> AC_CACHE_VAL(app_cv_fvisibility_ok,
> [ac_save_cc="$CC"
> CC="$CC -fvisibility=hidden"
> AC_TRY_RUN([int main() { return 0; }],
>   app_cv_fvisibility_ok=yes,
>   app_cv_fvisibility_ok=no,
>   app_cv_fvisibility_ok=no)
> CC="$ac_save_cc"])
> AC_MSG_RESULT($app_cv_fvisibility_ok)
> if test $app_cv_fvisibility_ok = yes; then
>   CFLAGS="$CFLAGS -fvisibility=hidden"
>   CXXFLAGS="$CXXFLAGS -fvisibility=hidden"
> fi
374a357,359
> dnl ---------------------------------------------------------------------------
> dnl Check for C++ 2011 support
> dnl ---------------------------------------------------------------------------
391c376
< AX_CHECK_COMPILE_FLAG([-fvisibility=hidden], [CFLAGS="$CFLAGS -fvisibility=hidden"])
---
> AX_CHECK_COMPILE_FLAG([-std=c++11], [CPPFLAGS="$CPPFLAGS -std=c++11"])
398c383
< 	[AS_HELP_STRING([--enable-self-signed-cert-check], [Emit Warning when host presents a self signed certificate])],
---
> 	[AS_HELP_STRING([--enable-self-signed-cert-check], [Reject SSL connection when host presents a self signed certificate])],
402c387
< 	app_cv_self_signed_certs="yes"
---
> 	app_cv_self_signed_certs="no"
406c391
< 	AC_DEFINE(SSL_ENABLE_SELF_SIGNED_CERT_CHECK,[],[Should we accept self signed cert?])
---
> 	AC_DEFINE(SSL_ENABLE_SELF_SIGNED_CERT_CHECK)
418c403
< 	AC_DEFINE(SSL_ENABLE_CRL_CHECK,[],[Should we check the CRL?])
---
> 	AC_DEFINE(SSL_ENABLE_CRL_CHECK)
430c415
< 	AC_DEFINE(SSL_ENABLE_CRL_EXPIRATION_CHECK,[],[Should we check the CRL expiration])
---
> 	AC_DEFINE(SSL_ENABLE_CRL_EXPIRATION_CHECK)
437c422
< 	AC_DEFINE_UNQUOTED(SSL_CRL_URL,"$withval",[The default URL for CRL download])
---
> 	AC_DEFINE_UNQUOTED(SSL_CRL_URL,"$withval")
451c436
< 	AC_DEFINE(SSL_ENABLE_NOTIFICATION_WHEN_FAILED,[],[Should we emit a notification when ssl validation fails?])
---
> 	AC_DEFINE(SSL_ENABLE_NOTIFICATION_WHEN_FAILED)
490c475
< AC_DEFINE_UNQUOTED(LIB3270_NAME,$app_cv_libname,[The protocol library name])
---
> AC_DEFINE_UNQUOTED(LIB3270_NAME,$app_cv_libname)
493,494c478,479
< AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"lib$app_cv_libname-$app_vrs_major.$app_vrs_minor",[The gettext package name.])
< AC_SUBST(GETTEXT_PACKAGE,"lib$app_cv_libname-$app_vrs_major.$app_vrs_minor")
---
> AC_DEFINE_UNQUOTED(GETTEXT_PACKAGE,"lib$app_cv_libname")
> AC_SUBST(GETTEXT_PACKAGE,"lib$app_cv_libname")
511,512c496,499
< 	*-apple-darwin*)
< 		AC_SUBST(SONAME,lib$app_cv_libname-$app_vrs_major.$app_vrs_minor.dylib)
---
>  	s390x-*)
> 
> 		AC_SUBST(SONAME,lib$app_cv_libname.so)
> 
524c511
< AC_DEFINE(LIB3270_SDK_VERSION,$app_cv_sdkversion,[The SDK version number])
---
> AC_DEFINE(LIB3270_SDK_VERSION,$app_cv_sdkversion)
527,534c514
< AC_ARG_WITH([default-host], [AS_HELP_STRING([--with-default-host], [Set lib3270 default host url])],
< 	[ app_default_host="\"$withval\""],
< 	[ app_default_host=""])
< 
< if test "$app_default_host" != ""; then
< 	AC_DEFINE_UNQUOTED(LIB3270_DEFAULT_HOST, $app_default_host, ["The default tn3270 host"])
< 	AC_SUBST(LIB3270_DEFAULT_HOST,$app_default_host)
< fi
---
> AC_ARG_WITH([default-host], [AS_HELP_STRING([--with-default-host], [Set lib3270 default host url])], [ AC_DEFINE_UNQUOTED(LIB3270_DEFAULT_HOST,"$withval") ],[ AC_MSG_NOTICE(No default host)])
545c525
< 	AC_DEFINE(SSL_ENABLE_CRL_EXPIRATION_CHECK,[],[Should we check the CRL expiration date?])
---
> 	AC_DEFINE(SSL_ENABLE_CRL_EXPIRATION_CHECK)
560,562c540,542
< AC_CHECK_FUNC(vasprintf, AC_DEFINE(HAVE_VASPRINTF, [], [Do we have vasprintf?]) )
< AC_CHECK_FUNC(strtok_r, AC_DEFINE(HAVE_STRTOK_R, [], [Do we have strtok_r?]) )
< AC_CHECK_FUNC(localtime_r, AC_DEFINE(HAVE_LOCALTIME_R, [], [Do we have localtime_r?]) )
---
> AC_CHECK_FUNC(vasprintf, AC_DEFINE(HAVE_VASPRINTF) )
> AC_CHECK_FUNC(strtok_r, AC_DEFINE(HAVE_STRTOK_R) )
> AC_CHECK_FUNC(localtime_r, AC_DEFINE(HAVE_LOCALTIME_R) )
581c561
< 	AC_DEFINE(HAVE_INET_NTOP,[],[Do we have inet_ntop()?])
---
> 	AC_DEFINE(HAVE_INET_NTOP)
588c568
< PKG_CHECK_MODULES( [LIBSSL], [libssl libcrypto], AC_DEFINE(HAVE_LIBSSL,[],[Do we have libssl?]), AC_MSG_ERROR([libssl not present.]) )
---
> PKG_CHECK_MODULES( [LIBSSL], [libssl libcrypto], AC_DEFINE(HAVE_LIBSSL), AC_MSG_ERROR([libssl not present.]) )
650,658c630,640
< case "$host" in
< 
< 	*-mingw32|*-pc-msys)
< 		AC_SUBST(LIBCURL_LIBS)
< 		AC_SUBST(LIBCURL_CFLAGS)
< 		;;
< 
< 	*-apple-darwin*)
< 		AC_PATH_TOOL([CURLCONFIG], [curl-config], [no])
---
> AC_ARG_ENABLE([curl],
>         AS_HELP_STRING([--disable-curl],[Disable use of libcurl]),
>                 [case "${enableval}" in
>                         yes) have_curl=yes ;;
>                         no) have_curl=no ;;
>                         *) AC_MSG_ERROR(bad value ${enableval} for --disable-curl);;
>                 esac],
>                 [case "$host" in
> 			*-mingw32|*-pc-msys) have_curl=no ;;
> 			*) have_curl=yes;;
> 		esac])
660,670d641
< 		if test x$CURLCONFIG = xno; then
<         	AC_MSG_NOTICE([Building without CURL support])
< 			AC_SUBST(LIBCURL_CFLAGS)
< 			AC_SUBST(LIBCURL_LIBS)
< 		else
< 			AC_MSG_NOTICE([Using $($CURLCONFIG --version)])
< 			AC_DEFINE(HAVE_LIBCURL,[],[Do we have libcurl?])
< 			AC_SUBST(LIBCURL_CFLAGS,"$($CURLCONFIG --cflags)")
< 			AC_SUBST(LIBCURL_LIBS,"$($CURLCONFIG --libs)")
< 		fi
< 		;;
672,676c643,645
< 	*)
< 		PKG_CHECK_MODULES( [LIBCURL], [libcurl], AC_DEFINE(HAVE_LIBCURL,[],[Do we have libcurl?]), AC_MSG_ERROR([libcurl not present.]) )
< 		AC_SUBST(LIBCURL_CFLAGS)
< 		AC_SUBST(LIBCURL_LIBS)
< 		;;
---
> if test "x${have_curl}" != xno ; then
> 	PKG_CHECK_MODULES( [LIBCURL], [libcurl], AC_DEFINE(HAVE_LIBCURL), AC_MSG_ERROR([libcurl not present.]) )
> fi
678c647,648
< esac
---
> AC_SUBST(LIBCURL_LIBS)
> AC_SUBST(LIBCURL_CFLAGS)
685c655
< AC_SUBST(BUILDDIR,$app_cv_buildir)
---
> AC_SUBST(BASEDIR,$app_cv_buildir)
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/changelog lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/changelog
1c1
< lib3270 (5.4+git20240817-0) unstable; urgency=low
---
> lib3270 (5.4-0) unstable; urgency=low
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/compat lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/compat
1c1
< 10
---
> 9
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/control lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/control
11c11
< Provides: lib3270 (= ${binary:Version}), lib3270 (= 5.4)
---
> Provides: lib3270 (= ${binary:Version})
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian: control.in
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/lib3270.dsc lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/lib3270.dsc
3c3
< Version: 5.4+git20240817-0
---
> Version: 5.4-0
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/rules lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian/rules
26,27c26,33
< 	NOCONFIGURE=1 ./autogen.sh 
< 	./configure --prefix=/usr --disable-static
---
> 	aclocal
> 	autoconf
>     
> 	mkdir -p scripts
> 	automake --add-missing 2> /dev/null | true
>  
> 	./configure --prefix=/usr
>     
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/debian: shlibs.in
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/doxygen/doxyfile.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/doxygen/doxyfile.in
55c55
< OUTPUT_DIRECTORY       = @BUILDDIR@/doxygen
---
> OUTPUT_DIRECTORY       = @BASEDIR@/doxygen
143c143
< STRIP_FROM_PATH        = @BUILDDIR@/src
---
> STRIP_FROM_PATH        = @BASEDIR@/src
651c651
< WARN_LOGFILE           = @BUILDDIR@/doxygen/doxygen.log
---
> WARN_LOGFILE           = @BASEDIR@/doxygen/doxygen.log
662c662
< INPUT                  = @BUILDDIR@/src
---
> INPUT                  = @BASEDIR@/src
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.github/workflows: codeql-analysis.yml
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.github/workflows: codeql.yml
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.github/workflows: macos.yml
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.github/workflows: msys2.yml
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.github/workflows: publish.yml
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.gitignore lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.gitignore
59,60d58
< libtool
< m4
66,70d63
< *.orig
< ABOUT-NLS
< intl
< po
< *.tar.xz
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4: gitsync.sh
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/lib3270.cbp lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/lib3270.cbp
89,91d88
< 		<Unit filename="src/core/field.c">
< 			<Option compilerVar="CC" />
< 		</Unit>
104,106d100
< 		<Unit filename="src/core/ft/set.c">
< 			<Option compilerVar="CC" />
< 		</Unit>
263a258
> 		<Unit filename="src/include/action_table.h" />
278a274
> 		<Unit filename="src/include/lib3270++.h" />
299a296,297
> 		<Unit filename="src/include/proxyc.h" />
> 		<Unit filename="src/include/resolverc.h" />
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/locale/Makefile.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/locale/Makefile.in
41c41
< BASEDIR=@BUILDDIR@
---
> BASEDIR=@BASEDIR@
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/locale/pt_BR.po lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/locale/pt_BR.po
2c2
< # Perry Werneck <perry.werneck@gmail.com>, 2012-2023.
---
> # Perry Werneck <perry.werneck@gmail.com>, 2012, 2013, 2014, 2016, 2017, 2018, 2019, 2020.
8,9c8,9
< "POT-Creation-Date: 2023-06-16 13:05-0300\n"
< "PO-Revision-Date: 2023-04-21 08:40-0300\n"
---
> "POT-Creation-Date: 2020-10-17 11:58-0300\n"
> "PO-Revision-Date: 2020-09-03 18:36-0300\n"
11c11
< "Language-Team: Brazilian Portuguese <perry.werneck@gmail.com>\n"
---
> "Language-Team: Português <>\n"
19,20c19,21
< "Plural-Forms: nplurals=2; plural=(n > 1)\n"
< "X-Generator: Gtranslator 40.0\n"
---
> "Plural-Forms: nplurals=4; plural= (n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != "
> "11) ? 2 : 3;\n"
> "X-Generator: Gtranslator 2.91.7\n"
22c23
< #: src/core/ctlr.c:173
---
> #: src/core/ctlr.c:187
27c28
< #: src/core/ctlr.c:183
---
> #: src/core/ctlr.c:201
32c33
< #: src/network_modules/tools.c:175 src/network_modules/tools.c:191
---
> #: src/network_modules/tools.c:197 src/network_modules/tools.c:214
37c38
< #: src/core/keyboard/kybd.c:1763
---
> #: src/core/keyboard/kybd.c:1923
42c43
< #: src/core/keyboard/kybd.c:1908
---
> #: src/core/keyboard/kybd.c:2082
47c48
< #: src/core/keyboard/kybd.c:1861
---
> #: src/core/keyboard/kybd.c:2022
52c53
< #: src/core/keyboard/kybd.c:1889
---
> #: src/core/keyboard/kybd.c:2058
57c58
< #: src/core/keyboard/kybd.c:1872
---
> #: src/core/keyboard/kybd.c:2036
62c63
< #: src/core/keyboard/kybd.c:1814
---
> #: src/core/keyboard/kybd.c:1974
67c68
< #: src/core/telnet.c:1785
---
> #: src/core/telnet.c:1902
71c72
< #: src/core/actions/table.c:678
---
> #: src/core/actions/table.c:693
75c76
< #: src/network_modules/openssl/messages.c:314
---
> #: src/network_modules/openssl/messages.c:288
83c84
< #: src/core/actions/table.c:692
---
> #: src/core/actions/table.c:707
87c88
< #: src/core/ft/ft.c:100
---
> #: src/core/ft/ft.c:104
91c92
< #: src/core/ft/ft.c:612
---
> #: src/core/ft/ft.c:676
95c96
< #: src/core/ft/ft.c:98
---
> #: src/core/ft/ft.c:102
99c100
< #: src/core/paste.c:373
---
> #: src/core/paste.c:398
103c104
< #: src/core/toggles/table.c:256
---
> #: src/core/toggles/table.c:264
107,110d107
< #: src/network_modules/openssl/start.c:264
< msgid "An EOF was observed that violates the protocol"
< msgstr "Um EOF que viola o protocolo foi encontrado"
< 
123c120
< #: src/network_modules/openssl/messages.c:238
---
> #: src/network_modules/openssl/messages.c:222
132c129
< #: src/core/actions/table.c:691
---
> #: src/core/actions/table.c:706
136c133
< #: src/network_modules/openssl/messages.c:390
---
> #: src/network_modules/openssl/messages.c:357
140c137
< #: src/network_modules/openssl/messages.c:379
---
> #: src/network_modules/openssl/messages.c:347
144c141
< #: src/core/toggles/table.c:275
---
> #: src/core/toggles/table.c:283
148c145
< #: src/core/toggles/table.c:318 src/core/toggles/table.c:319
---
> #: src/core/toggles/table.c:183 src/core/toggles/table.c:184
152c149
< #: src/core/toggles/table.c:236
---
> #: src/core/toggles/table.c:244
166c163
< #: src/core/toggles/table.c:320
---
> #: src/core/toggles/table.c:185
170c167
< #: src/core/ft/ft.c:99
---
> #: src/core/ft/ft.c:103
174c171
< #: src/core/actions/table.c:677
---
> #: src/core/actions/table.c:692
178c175
< #: src/core/actions/table.c:504
---
> #: src/core/actions/table.c:519
182c179
< #: src/core/windows/connect.c:123
---
> #: src/core/windows/connect.c:125
186c183
< #: src/core/toggles/table.c:257
---
> #: src/core/toggles/table.c:265
194c191
< #: src/core/toggles/table.c:62 src/core/toggles/table.c:63
---
> #: src/core/toggles/table.c:63 src/core/toggles/table.c:64
198c195
< #: src/core/toggles/table.c:205 src/core/toggles/table.c:206
---
> #: src/core/toggles/table.c:213 src/core/toggles/table.c:214
202c199
< #: src/core/actions/table.c:705 src/core/actions/table.c:706
---
> #: src/core/actions/table.c:720 src/core/actions/table.c:721
206c203
< #: src/network_modules/tools.c:113
---
> #: src/network_modules/tools.c:128
226c223
< #: src/network_modules/openssl/messages.c:134
---
> #: src/network_modules/openssl/messages.c:127
230,231c227
< #: src/core/toggles/init.c:83 src/core/linux/connect.c:334
< #: src/core/windows/connect.c:372 src/core/macos/connect.c:334
---
> #: src/core/toggles/init.c:89 src/core/windows/connect.c:391
236c232
< #: src/core/windows/ldap.c:149
---
> #: src/core/windows/ldap.c:161
240,242c236
< #: src/core/linux/connect.c:215 src/core/linux/connect.c:269
< #: src/core/windows/connect.c:232 src/core/windows/connect.c:276
< #: src/core/macos/connect.c:215 src/core/macos/connect.c:269
---
> #: src/core/windows/connect.c:243 src/core/windows/connect.c:289
247c241
< #: src/core/windows/http.c:110
---
> #: src/core/windows/http.c:114
251,252c245
< #: src/core/linux/connect.c:165 src/core/windows/connect.c:197
< #: src/core/macos/connect.c:165
---
> #: src/core/windows/connect.c:204
256c249
< #: src/core/windows/http.c:121
---
> #: src/core/windows/http.c:126
260c253
< #: src/network_modules/openssl/start.c:71
---
> #: src/network_modules/openssl/start.c:70
264,265c257
< #: src/core/linux/ldap.c:167 src/core/windows/ldap.c:204
< #: src/core/macos/ldap.c:167
---
> #: src/core/windows/ldap.c:221
269c261
< #: src/core/connect.c:169
---
> #: src/core/connect.c:201
273c265
< #: src/core/ft/ft.c:391
---
> #: src/core/ft/ft.c:431
277c269
< #: src/core/windows/ldap.c:133
---
> #: src/core/windows/ldap.c:143
281,285c273
< #: src/core/linux/curl.c:171 src/core/macos/curl.c:171
< msgid "Can't initialize curl operation"
< msgstr "Erro ao inicializar operação CURL"
< 
< #: src/network_modules/openssl/context.c:236
---
> #: src/network_modules/openssl/context.c:169
289c277
< #: src/core/session.c:176
---
> #: src/core/session.c:201
293,308c281
< #: src/network_modules/openssl/context.c:338
< #, c-format
< msgid "Can't load \"%s\": %s"
< msgstr "Não foi possível carregar \"%s\": %s"
< 
< #: src/network_modules/openssl/context.c:291
< #, c-format
< msgid "Can't open \"%s\" (The Windows error code was %ld)"
< msgstr "Não foi possível abrir \"%s\" (O código de erro windows foi %ld)"
< 
< #: src/network_modules/openssl/context.c:304
< #, c-format
< msgid "Can't open \"%s\": %s"
< msgstr "Não foi possível abrir %s: %s"
< 
< #: src/core/windows/http.c:99
---
> #: src/core/windows/http.c:102
312c285
< #: src/core/session.c:164
---
> #: src/core/session.c:187
316,321c289
< #: src/network_modules/openssl/context.c:322
< #, c-format
< msgid "Can't read \"%s\": %s"
< msgstr "Não foi possível ler \"%s\": %s"
< 
< #: src/core/windows/http.c:173
---
> #: src/core/windows/http.c:181
325c293
< #: src/core/session.c:170
---
> #: src/core/session.c:194
329c297
< #: src/core/windows/http.c:134
---
> #: src/core/windows/http.c:140
333c301
< #: src/core/windows/ldap.c:141
---
> #: src/core/windows/ldap.c:152
337c305
< #: src/network_modules/tools.c:190
---
> #: src/network_modules/tools.c:213
341c309
< #: src/network_modules/tools.c:190
---
> #: src/network_modules/tools.c:213
345c313
< #: src/core/ft/ft.c:192
---
> #: src/core/ft/ft.c:208
349c317
< #: src/core/windows/connect.c:124
---
> #: src/core/windows/connect.c:126
353c321
< #: src/core/ft/ft.c:151
---
> #: src/core/ft/ft.c:160
357c325
< #: src/core/telnet.c:928
---
> #: src/core/telnet.c:982
361c329
< #: src/network_modules/openssl/start.c:213
---
> #: src/network_modules/openssl/start.c:193
367,379c335
< #: src/network_modules/openssl/context.c:332
< msgid "Cant load custom certificate file."
< msgstr "Não foi possível ler arquivo de certificado personalizado"
< 
< #: src/network_modules/openssl/context.c:286
< msgid "Cant open custom certificate directory."
< msgstr "Não foi possível abrir o diretório de certificados personalizados"
< 
< #: src/network_modules/openssl/context.c:316
< msgid "Cant read custom certificate file."
< msgstr "Não foi possível ler certificado personalizado"
< 
< #: src/network_modules/openssl/start.c:230
---
> #: src/network_modules/openssl/start.c:210
387c343
< #: src/network_modules/openssl/messages.c:156
---
> #: src/network_modules/openssl/messages.c:147
391c347
< #: src/network_modules/openssl/messages.c:145
---
> #: src/network_modules/openssl/messages.c:137
395c351
< #: src/network_modules/openssl/messages.c:346
---
> #: src/network_modules/openssl/messages.c:317
399c355
< #: src/network_modules/openssl/messages.c:357
---
> #: src/network_modules/openssl/messages.c:327
403c359
< #: src/network_modules/openssl/messages.c:302
---
> #: src/network_modules/openssl/messages.c:277
407c363
< #: src/network_modules/openssl/messages.c:123
---
> #: src/network_modules/openssl/messages.c:117
411c367
< #: src/core/toggles/table.c:277
---
> #: src/core/toggles/table.c:285
415c371
< #: src/core/telnet.c:1790
---
> #: src/core/telnet.c:1907
419c375
< #: src/core/actions/table.c:765
---
> #: src/core/actions/table.c:780
423c379
< #: src/core/actions/table.c:588
---
> #: src/core/actions/table.c:603
427c383
< #: src/core/actions/table.c:589
---
> #: src/core/actions/table.c:604
435c391
< #: src/core/telnet.c:1784
---
> #: src/core/telnet.c:1901
439c395
< #: src/core/toggles/table.c:235
---
> #: src/core/toggles/table.c:243
443,468c399
< #: src/core/properties/signed.c:46
< msgid "Connected in NVT ANSI mode"
< msgstr ""
< 
< #: src/core/properties/signed.c:51
< msgid "Connected in TN3270E mode, 3270 mode"
< msgstr ""
< 
< #: src/core/properties/signed.c:49
< msgid "Connected in TN3270E mode, NVT mode"
< msgstr ""
< 
< #: src/core/properties/signed.c:50
< msgid "Connected in TN3270E mode, SSCP-LU mode"
< msgstr ""
< 
< #: src/core/properties/signed.c:48
< #, fuzzy
< msgid "Connected in TN3270E mode, no negotiated"
< msgstr "Não está no modo 3270, transferência cancelada"
< 
< #: src/core/properties/signed.c:47
< msgid "Connected in old-style 3270 mode"
< msgstr ""
< 
< #: src/core/telnet.c:1764
---
> #: src/core/telnet.c:1879
472,477c403
< #: src/core/properties/signed.c:45
< #, fuzzy
< msgid "Connected, no mode yet"
< msgstr "Connected initial"
< 
< #: src/core/telnet.c:1782
---
> #: src/core/telnet.c:1899
481,490c407,408
< #: src/core/properties/signed.c:43
< #, fuzzy
< msgid "Connecting to host"
< msgstr "Não foi possível conectar no host"
< 
< #: src/network_modules/tools.c:160 src/core/linux/connect.c:230
< #: src/core/linux/connect.c:321 src/core/linux/connect.c:338
< #: src/core/windows/connect.c:358 src/core/windows/connect.c:376
< #: src/core/macos/connect.c:230 src/core/macos/connect.c:321
< #: src/core/macos/connect.c:338
---
> #: src/core/windows/connect.c:376 src/core/windows/connect.c:395
> #: src/network_modules/tools.c:181
494,503c412
< #: src/network_modules/openssl/start.c:246
< msgid "Connection failed"
< msgstr "Conexão falhou"
< 
< #: src/core/properties/signed.c:44
< #, fuzzy
< msgid "Connection pending"
< msgstr "Conexão falhou"
< 
< #: src/network_modules/tools.c:122
---
> #: src/network_modules/tools.c:139
507,516c416
< #: src/core/properties/signed.c:96
< #, fuzzy
< msgid "Connection secure with CA check"
< msgstr "A conexão é segura ?"
< 
< #: src/core/properties/signed.c:97
< msgid "Connection secure, no CA, self-signed or expired CRL"
< msgstr ""
< 
< #: src/core/properties/signed.c:121
---
> #: src/core/properties/signed.c:59
520,522c420,421
< #: src/network_modules/openssl/messages.c:80
< #: src/network_modules/openssl/messages.c:253
< #: src/network_modules/openssl/messages.c:268
---
> #: src/network_modules/openssl/messages.c:78
> #: src/network_modules/openssl/messages.c:246
526c425
< #: src/core/toggles/table.c:165 src/core/toggles/table.c:166
---
> #: src/core/toggles/table.c:163 src/core/toggles/table.c:164
530c429
< #: src/core/properties/unsigned.c:113
---
> #: src/core/properties/unsigned.c:114
534c433
< #: src/core/properties/unsigned.c:106
---
> #: src/core/properties/unsigned.c:107
538c437
< #: src/core/properties/signed.c:130
---
> #: src/core/properties/signed.c:67
542c441
< #: src/core/actions/table.c:158
---
> #: src/core/actions/table.c:173
546c445
< #: src/core/actions/table.c:172
---
> #: src/core/actions/table.c:187
550c449
< #: src/core/actions/table.c:186
---
> #: src/core/actions/table.c:201
554c453
< #: src/core/actions/table.c:200
---
> #: src/core/actions/table.c:215
560c459
< #: src/core/actions/table.c:228
---
> #: src/core/actions/table.c:243
564c463
< #: src/core/actions/table.c:214
---
> #: src/core/actions/table.c:229
568c467
< #: src/core/actions/table.c:144
---
> #: src/core/actions/table.c:159
572c471
< #: src/core/actions/table.c:650
---
> #: src/core/actions/table.c:665
576c475
< #: src/core/ft/ft_cut.c:163 src/core/ft/ft_cut.c:171
---
> #: src/core/ft/ft_cut.c:157 src/core/ft/ft_cut.c:166
580c479
< #: src/core/properties/string.c:143
---
> #: src/core/properties/string.c:163
584c483
< #: src/core/actions/table.c:635 src/core/actions/table.c:636
---
> #: src/core/actions/table.c:650 src/core/actions/table.c:651
588c487
< #: src/core/actions/table.c:517 src/core/actions/table.c:518
---
> #: src/core/actions/table.c:532 src/core/actions/table.c:533
592c491
< #: src/core/actions/table.c:503
---
> #: src/core/actions/table.c:518
596c495
< #: src/core/properties/string.c:157
---
> #: src/core/properties/string.c:177
600c499
< #: src/core/telnet.c:1175
---
> #: src/core/telnet.c:1244
604c503
< #: src/core/actions/table.c:127
---
> #: src/core/actions/table.c:142
608,614c507,508
< #: src/core/properties/signed.c:42
< #, fuzzy
< msgid "Disconnected"
< msgstr "Desconectado"
< 
< #: src/core/ft/ft.c:244 src/network_modules/openssl/main.c:100
< #: src/network_modules/openssl/main.c:148
---
> #: src/core/ft/ft.c:266 src/network_modules/openssl/main.c:102
> #: src/network_modules/openssl/main.c:153
618c512
< #: src/core/properties/string.c:114
---
> #: src/core/properties/string.c:124
622c516
< #: src/core/toggles/table.c:84
---
> #: src/core/toggles/table.c:85
626c520
< #: src/core/actions/table.c:157
---
> #: src/core/actions/table.c:172
630c524
< #: src/core/actions/table.c:649
---
> #: src/core/actions/table.c:664
634c528
< #: src/core/telnet.c:728
---
> #: src/core/telnet.c:777
638c532
< #: src/core/windows/http.c:157
---
> #: src/core/windows/http.c:165
642c536
< #: src/core/toggles/table.c:298
---
> #: src/core/toggles/table.c:305
646c540
< #: src/core/toggles/table.c:287
---
> #: src/core/toggles/table.c:295
650c544
< #: src/core/toggles/table.c:309
---
> #: src/core/toggles/table.c:315
654c548
< #: src/core/toggles/table.c:286
---
> #: src/core/toggles/table.c:294
658c552
< #: src/core/actions/table.c:605
---
> #: src/core/actions/table.c:620
662c556
< #: src/core/actions/table.c:574 src/core/actions/table.c:575
---
> #: src/core/actions/table.c:589 src/core/actions/table.c:590
666c560
< #: src/core/actions/table.c:546
---
> #: src/core/actions/table.c:561
670c564
< #: src/core/actions/table.c:560
---
> #: src/core/actions/table.c:575
674c568
< #: src/core/actions/table.c:547
---
> #: src/core/actions/table.c:562
678c572
< #: src/core/actions/table.c:561
---
> #: src/core/actions/table.c:576
682c576
< #: src/core/actions/table.c:533
---
> #: src/core/actions/table.c:548
686c580
< #: src/core/actions/table.c:532
---
> #: src/core/actions/table.c:547
690c584
< #: src/network_modules/tools.c:100
---
> #: src/network_modules/tools.c:112
694c588,592
< #: src/core/ft/ft_cut.c:408 src/core/ft/ft_dft.c:413
---
> #: src/core/util.c:267
> msgid "Error"
> msgstr "Erro"
> 
> #: src/core/ft/ft_dft.c:454 src/core/ft/ft_cut.c:423
699c597
< #: src/core/ft/ft_cut.c:504 src/core/ft/ft_dft.c:306
---
> #: src/core/ft/ft_dft.c:332 src/core/ft/ft_cut.c:528
712c610
< #: src/network_modules/openssl/main.c:170
---
> #: src/network_modules/openssl/main.c:176
716c614
< #: src/core/windows/http.c:145
---
> #: src/core/windows/http.c:152
720c618
< #: src/network_modules/tools.c:66 src/network_modules/tools.c:82
---
> #: src/network_modules/tools.c:65 src/network_modules/tools.c:90
732,734c630,632
< #: src/network_modules/openssl/main.c:123
< msgid "Error writing to host."
< msgstr "Erro enviando para o servidor"
---
> #: src/network_modules/openssl/main.c:125
> msgid "Error writing to host"
> msgstr "Erro enviando dados para o servidor"
736c634
< #: src/core/telnet.c:1789
---
> #: src/core/telnet.c:1906
740c638
< #: src/core/actions/table.c:663
---
> #: src/core/actions/table.c:678
744c642
< #: src/core/actions/table.c:664
---
> #: src/core/actions/table.c:679
748c646
< #: src/core/actions/table.c:443
---
> #: src/core/actions/table.c:458
760c658
< #: src/core/ft/ft.c:247
---
> #: src/core/ft/ft.c:271
764c662
< #: src/core/actions/table.c:457
---
> #: src/core/actions/table.c:472
768c666
< #: src/network_modules/openssl/messages.c:215
---
> #: src/network_modules/openssl/messages.c:201
772c670
< #: src/network_modules/openssl/messages.c:226
---
> #: src/network_modules/openssl/messages.c:211
776c674
< #: src/network_modules/openssl/messages.c:204
---
> #: src/network_modules/openssl/messages.c:191
780c678
< #: src/network_modules/openssl/messages.c:193
---
> #: src/network_modules/openssl/messages.c:181
784c682
< #: src/core/properties/boolean.c:175
---
> #: src/core/properties/boolean.c:181
788c686
< #: src/core/toggles/table.c:175 src/core/toggles/table.c:176
---
> #: src/core/toggles/table.c:173 src/core/toggles/table.c:174
792c690
< #: src/core/telnet.c:1783
---
> #: src/core/telnet.c:1900
796c694
< #: src/core/properties/boolean.c:154
---
> #: src/core/properties/boolean.c:160
800c698
< #: src/core/properties/string.c:107
---
> #: src/core/properties/string.c:117
804c702
< #: src/core/ft/ft.c:620
---
> #: src/core/ft/ft.c:685
808c706
< #: src/core/telnet.c:1233
---
> #: src/core/telnet.c:1302
816c714
< #: src/core/telnet.c:1163
---
> #: src/core/telnet.c:1227
820c718
< #: src/core/telnet.c:1173
---
> #: src/core/telnet.c:1240
824c722
< #: src/core/properties/string.c:84
---
> #: src/core/properties/string.c:94
828c726
< #: src/core/properties/unsigned.c:86
---
> #: src/core/properties/unsigned.c:87
832c730
< #: src/core/options.c:48
---
> #: src/core/options.c:49
836c734
< #: src/core/options.c:42
---
> #: src/core/options.c:43
840c738
< #: src/core/properties/signed.c:146
---
> #: src/core/properties/signed.c:81
844c742
< #: src/core/toggles/table.c:197
---
> #: src/core/toggles/table.c:205
852c750
< #: src/core/toggles/table.c:217
---
> #: src/core/toggles/table.c:225
856c754
< #: src/core/toggles/table.c:177
---
> #: src/core/toggles/table.c:175
860c758
< #: src/core/toggles/table.c:147
---
> #: src/core/toggles/table.c:145
882c780
< #: src/core/toggles/table.c:64
---
> #: src/core/toggles/table.c:65
886c784
< #: src/core/toggles/table.c:53
---
> #: src/core/toggles/table.c:54
890c788
< #: src/core/toggles/table.c:157
---
> #: src/core/toggles/table.c:155
898c796
< #: src/core/toggles/table.c:167
---
> #: src/core/toggles/table.c:165
908c806
< #: src/core/toggles/table.c:74
---
> #: src/core/toggles/table.c:75
916c814
< #: src/core/ft/ft_cut.c:484
---
> #: src/core/ft/ft_cut.c:505
928c826
< #: src/core/toggles/table.c:185
---
> #: src/core/toggles/table.c:193
932c830,835
< #: src/network_modules/openssl/messages.c:313
---
> #: src/core/util.c:63 src/core/util.c:73 src/core/util.c:85 src/core/util.c:180
> #: src/core/util.c:196 src/core/util.c:208 src/core/util.c:223
> msgid "Internal error"
> msgstr "Erro interno"
> 
> #: src/network_modules/openssl/messages.c:287
956,957c859,860
< #: src/core/ctlr.c:171 src/core/ctlr.c:181 src/core/ctlr.c:192
< #: src/core/ctlr.c:203
---
> #: src/core/ctlr.c:185 src/core/ctlr.c:199 src/core/ctlr.c:214
> #: src/core/ctlr.c:228
961c864
< #: src/core/properties/boolean.c:75
---
> #: src/core/properties/boolean.c:81
965c868
< #: src/core/properties/boolean.c:168
---
> #: src/core/properties/boolean.c:174
969c872
< #: src/core/properties/boolean.c:68
---
> #: src/core/properties/boolean.c:74
973c876
< #: src/core/properties/boolean.c:147
---
> #: src/core/properties/boolean.c:153
977c880
< #: src/core/properties/boolean.c:61
---
> #: src/core/properties/boolean.c:67
981c884
< #: src/core/toggles/table.c:215 src/core/toggles/table.c:216
---
> #: src/core/toggles/table.c:223 src/core/toggles/table.c:224
985c888
< #: src/network_modules/openssl/messages.c:401
---
> #: src/network_modules/openssl/messages.c:367
989c892
< #: src/core/paste.c:375
---
> #: src/core/paste.c:400
993c896
< #: src/core/properties/unsigned.c:165
---
> #: src/core/properties/unsigned.c:158
997,1001c900
< #: src/core/windows/ldap.c:179
< msgid "LDAP Search did not produce any attributes."
< msgstr "Pesquisa LDAP não produziu atributos."
< 
< #: src/core/linux/ldap.c:147 src/core/macos/ldap.c:147
---
> #: src/core/windows/ldap.c:193
1003,1004c902,903
< msgid "LDAP search did not produce any attributes."
< msgstr "Pesquisa LDAP não produziu atributos."
---
> msgid "LDAP Search did not produce any attributes."
> msgstr "Pesquisa LDAP não produziu nenhum atributo."
1006c905
< #: src/core/linux/ldap.c:157 src/core/macos/ldap.c:157
---
> #: src/core/windows/ldap.c:201
1008,1011d906
< msgid "LDAP search did not produce any values."
< msgstr "Pesquisa LDAP não produziu valores."
< 
< #: src/core/windows/ldap.c:186
1013c908
< msgstr "Pesquisa LDAP não produziu valores."
---
> msgstr "Pesquisa LDAP não produziu nenhum valor."
1015c910
< #: src/core/properties/signed.c:138
---
> #: src/core/properties/signed.c:74
1019c914
< #: src/core/actions/table.c:171
---
> #: src/core/actions/table.c:186
1023c918
< #: src/core/telnet.c:1786
---
> #: src/core/telnet.c:1903
1027c922
< #: src/core/properties/boolean.c:182
---
> #: src/core/properties/boolean.c:188
1031c926
< #: src/core/toggles/table.c:145
---
> #: src/core/toggles/table.c:143
1035c930
< #: src/core/properties/unsigned.c:127
---
> #: src/core/properties/unsigned.c:128
1039c934
< #: src/core/properties/unsigned.c:120
---
> #: src/core/properties/unsigned.c:121
1043c938
< #: src/core/properties/string.c:76
---
> #: src/core/properties/string.c:86
1047c942
< #: src/core/toggles/table.c:51
---
> #: src/core/toggles/table.c:52
1051c946
< #: src/core/actions/table.c:329
---
> #: src/core/actions/table.c:344
1055c950
< #: src/core/actions/table.c:343
---
> #: src/core/actions/table.c:358
1059c954
< #: src/core/actions/table.c:357
---
> #: src/core/actions/table.c:372
1063c958
< #: src/core/actions/table.c:315
---
> #: src/core/actions/table.c:330
1067c962
< #: src/core/actions/table.c:385
---
> #: src/core/actions/table.c:400
1071c966
< #: src/core/actions/table.c:399
---
> #: src/core/actions/table.c:414
1075c970
< #: src/core/actions/table.c:413
---
> #: src/core/actions/table.c:428
1079c974
< #: src/core/actions/table.c:371
---
> #: src/core/actions/table.c:386
1083c978
< #: src/core/actions/table.c:444
---
> #: src/core/actions/table.c:459
1088c983
< #: src/core/actions/table.c:458
---
> #: src/core/actions/table.c:473
1092c987
< #: src/core/actions/table.c:472
---
> #: src/core/actions/table.c:487
1096c991
< #: src/core/actions/table.c:486
---
> #: src/core/actions/table.c:501
1100,1108c995,996
< #: src/core/properties/signed.c:98
< #, fuzzy
< msgid "Negotiating SSL"
< msgstr "Negociação SSL"
< 
< #: src/core/telnet.c:304 src/core/linux/connect.c:200
< #: src/core/linux/event_dispatcher.c:130 src/core/windows/connect.c:223
< #: src/core/windows/event_dispatcher.c:135 src/core/macos/connect.c:200
< #: src/core/macos/event_dispatcher.c:130
---
> #: src/core/telnet.c:314 src/core/windows/event_dispatcher.c:150
> #: src/core/windows/connect.c:232
1112c1000
< #: src/core/toggles/table.c:285
---
> #: src/core/toggles/table.c:293
1116c1004
< #: src/core/actions/table.c:199
---
> #: src/core/actions/table.c:214
1120c1008
< #: src/core/actions/table.c:471
---
> #: src/core/actions/table.c:486
1124c1012
< #: src/core/actions/table.c:227
---
> #: src/core/actions/table.c:242
1128c1016
< #: src/network_modules/openssl/start.c:53
---
> #: src/network_modules/openssl/start.c:52
1132c1020
< #: src/network_modules/default/main.c:149
---
> #: src/network_modules/default/main.c:145
1136,1137c1024
< #: src/core/linux/download.c:55 src/core/windows/download.c:62
< #: src/core/macos/download.c:55
---
> #: src/core/windows/download.c:62
1141,1146c1028
< #: src/core/properties/signed.c:95
< #, fuzzy
< msgid "No secure connection"
< msgstr "Conexão _Segura."
< 
< #: src/network_modules/openssl/messages.c:292
---
> #: src/network_modules/openssl/messages.c:268
1154c1036
< #: src/core/ft/ft.c:97
---
> #: src/core/ft/ft.c:101
1158c1040
< #: src/core/properties/boolean.c:196
---
> #: src/core/properties/boolean.c:202
1162c1044
< #: src/core/properties/boolean.c:91
---
> #: src/core/properties/boolean.c:97
1166c1048
< #: src/core/properties/boolean.c:83
---
> #: src/core/properties/boolean.c:89
1170c1052
< #: src/core/windows/connect.c:307
---
> #: src/core/windows/connect.c:322
1174c1056
< #: src/core/ft/ft.c:626
---
> #: src/core/ft/ft.c:692
1184c1066
< #: src/core/options.c:54
---
> #: src/core/options.c:55
1188c1070
< #: src/core/options.c:60
---
> #: src/core/options.c:61
1192c1074
< #: src/network_modules/openssl/messages.c:237
---
> #: src/network_modules/openssl/messages.c:221
1196,1197c1078,1079
< #: src/core/actions/table.c:782 src/core/actions/table.c:796
< #: src/core/actions/table.c:810
---
> #: src/core/actions/table.c:797 src/core/actions/table.c:811
> #: src/core/actions/table.c:825
1201c1083
< #: src/core/actions/table.c:241
---
> #: src/core/actions/table.c:256
1205c1087
< #: src/core/actions/table.c:242
---
> #: src/core/actions/table.c:257
1209c1091
< #: src/core/actions/table.c:719 src/core/actions/table.c:720
---
> #: src/core/actions/table.c:734 src/core/actions/table.c:735
1213c1095
< #: src/core/toggles/table.c:146
---
> #: src/core/toggles/table.c:144
1217c1099
< #: src/network_modules/openssl/messages.c:324
---
> #: src/network_modules/openssl/messages.c:297
1221c1103
< #: src/core/telnet.c:1763
---
> #: src/core/telnet.c:1878
1229c1111
< #: src/core/properties/string.c:136
---
> #: src/core/properties/string.c:156
1233c1115
< #: src/core/actions/table.c:485
---
> #: src/core/actions/table.c:500
1237c1119
< #: src/core/actions/table.c:213
---
> #: src/core/actions/table.c:228
1241c1123
< #: src/core/telnet.c:1788
---
> #: src/core/telnet.c:1905
1245c1127
< #: src/core/actions/table.c:783
---
> #: src/core/actions/table.c:798
1249c1131
< #: src/core/actions/table.c:797
---
> #: src/core/actions/table.c:812
1253c1135
< #: src/core/actions/table.c:811
---
> #: src/core/actions/table.c:826
1257,1265c1139
< #: src/core/properties/string.c:128
< msgid "Protocol library revision"
< msgstr ""
< 
< #: src/core/properties/string.c:121
< msgid "Protocol library version"
< msgstr ""
< 
< #: src/core/rpq.c:229
---
> #: src/core/rpq.c:236
1270c1144
< #: src/core/rpq.c:338
---
> #: src/core/rpq.c:348
1284c1158
< #: src/core/rpq.c:222
---
> #: src/core/rpq.c:229
1288c1162
< #: src/core/rpq.c:403 src/core/rpq.c:412
---
> #: src/core/rpq.c:416 src/core/rpq.c:425
1292c1166
< #: src/core/rpq.c:520
---
> #: src/core/rpq.c:519
1296c1170
< #: src/core/rpq.c:545
---
> #: src/core/rpq.c:544
1300c1174
< #: src/core/rpq.c:526
---
> #: src/core/rpq.c:525
1305c1179
< #: src/core/rpq.c:570
---
> #: src/core/rpq.c:569
1310c1184
< #: src/core/rpq.c:350
---
> #: src/core/rpq.c:360
1315c1189
< #: src/core/rpq.c:224
---
> #: src/core/rpq.c:231
1320c1194
< #: src/core/rpq.c:465
---
> #: src/core/rpq.c:463
1324c1198
< #: src/core/rpq.c:434 src/core/rpq.c:444
---
> #: src/core/rpq.c:445
1328c1202
< #: src/core/rpq.c:424
---
> #: src/core/rpq.c:438
1341c1215
< #: src/core/actions/table.c:113
---
> #: src/core/actions/table.c:128
1345c1219
< #: src/core/telnet.c:1787
---
> #: src/core/telnet.c:1904
1349c1223
< #: src/core/actions/table.c:272 src/core/actions/table.c:273
---
> #: src/core/actions/table.c:287 src/core/actions/table.c:288
1353c1227
< #: src/core/ft/ft.c:192
---
> #: src/core/ft/ft.c:208
1361c1235
< #: src/core/actions/table.c:286 src/core/actions/table.c:287
---
> #: src/core/actions/table.c:301 src/core/actions/table.c:302
1365c1239
< #: src/core/actions/table.c:620
---
> #: src/core/actions/table.c:635
1369c1243
< #: src/core/actions/table.c:621
---
> #: src/core/actions/table.c:636
1373c1247
< #: src/core/toggles/table.c:276
---
> #: src/core/toggles/table.c:284
1377c1251
< #: src/core/telnet.c:1762 src/core/telnet.c:1781
---
> #: src/core/telnet.c:1877 src/core/telnet.c:1898
1381c1255
< #: src/core/actions/table.c:185
---
> #: src/core/actions/table.c:200
1393c1267,1271
< #: src/network_modules/openssl/start.c:229
---
> #: src/network_modules/openssl/start.c:234
> msgid "SSL Connect failed"
> msgstr "Conexão SSL falhou"
> 
> #: src/network_modules/openssl/start.c:209
1397c1275
< #: src/core/properties/unsigned.c:134
---
> #: src/core/properties/unsigned.c:135
1401c1279
< #: src/core/properties/string.c:165
---
> #: src/core/properties/string.c:185
1405c1283
< #: src/network_modules/openssl/messages.c:52
---
> #: src/network_modules/openssl/messages.c:51
1409c1287
< #: src/core/actions/table.c:328
---
> #: src/core/actions/table.c:343
1413c1291
< #: src/core/actions/table.c:429
---
> #: src/core/actions/table.c:444
1417c1295
< #: src/core/actions/table.c:342
---
> #: src/core/actions/table.c:357
1421c1299
< #: src/core/actions/table.c:314
---
> #: src/core/actions/table.c:329
1425c1303
< #: src/core/actions/table.c:258 src/core/actions/table.c:259
---
> #: src/core/actions/table.c:273 src/core/actions/table.c:274
1429c1307
< #: src/core/toggles/table.c:155 src/core/toggles/table.c:156
---
> #: src/core/toggles/table.c:153 src/core/toggles/table.c:154
1433c1311
< #: src/core/actions/table.c:428
---
> #: src/core/actions/table.c:443
1437c1315
< #: src/core/actions/table.c:356
---
> #: src/core/actions/table.c:371
1441c1319
< #: src/core/actions/table.c:300 src/core/actions/table.c:301
---
> #: src/core/actions/table.c:315 src/core/actions/table.c:316
1445,1447c1323
< #: src/core/linux/event_dispatcher.c:131
< #: src/core/windows/event_dispatcher.c:136
< #: src/core/macos/event_dispatcher.c:131
---
> #: src/core/windows/event_dispatcher.c:151
1451c1327
< #: src/core/actions/table.c:384
---
> #: src/core/actions/table.c:399
1455c1331
< #: src/core/actions/table.c:398
---
> #: src/core/actions/table.c:413
1459c1335
< #: src/core/actions/table.c:412
---
> #: src/core/actions/table.c:427
1463c1339
< #: src/core/actions/table.c:370
---
> #: src/core/actions/table.c:385
1467c1343
< #: src/network_modules/openssl/messages.c:252
---
> #: src/network_modules/openssl/messages.c:231
1471c1347
< #: src/network_modules/openssl/messages.c:269
---
> #: src/network_modules/openssl/messages.c:247
1475c1351
< #: src/core/actions/table.c:606
---
> #: src/core/actions/table.c:621
1479c1355
< #: src/core/toggles/table.c:186
---
> #: src/core/toggles/table.c:194
1483c1359
< #: src/core/toggles/table.c:265
---
> #: src/core/toggles/table.c:273
1487c1363
< #: src/core/toggles/table.c:266
---
> #: src/core/toggles/table.c:274
1491c1367
< #: src/core/toggles/table.c:226
---
> #: src/core/toggles/table.c:234
1495c1371
< #: src/core/actions/table.c:766
---
> #: src/core/actions/table.c:781
1499c1375
< #: src/core/actions/table.c:752
---
> #: src/core/actions/table.c:767
1503c1379
< #: src/core/toggles/table.c:72 src/core/toggles/table.c:73
---
> #: src/core/toggles/table.c:73 src/core/toggles/table.c:74
1507c1383
< #: src/core/toggles/table.c:195 src/core/toggles/table.c:196
---
> #: src/core/toggles/table.c:203 src/core/toggles/table.c:204
1511c1387
< #: src/network_modules/tools.c:173 src/network_modules/tools.c:189
---
> #: src/network_modules/tools.c:195 src/network_modules/tools.c:212
1515c1391
< #: src/core/toggles/table.c:255
---
> #: src/core/toggles/table.c:263
1519c1395
< #: src/core/properties/boolean.c:126
---
> #: src/core/properties/boolean.c:132
1523c1399
< #: src/core/properties/boolean.c:161
---
> #: src/core/properties/boolean.c:167
1527c1403
< #: src/network_modules/openssl/messages.c:368
---
> #: src/network_modules/openssl/messages.c:337
1531c1407
< #: src/core/actions/table.c:733
---
> #: src/core/actions/table.c:748
1535c1411
< #: src/core/actions/table.c:734
---
> #: src/core/actions/table.c:749
1539c1415
< #: src/core/telnet.c:995
---
> #: src/core/telnet.c:1056
1543c1419
< #: src/core/telnet.c:1766
---
> #: src/core/telnet.c:1881
1547c1423
< #: src/core/telnet.c:1765
---
> #: src/core/telnet.c:1880
1551c1427
< #: src/core/telnet.c:1767
---
> #: src/core/telnet.c:1882
1555c1431
< #: src/core/telnet.c:1770
---
> #: src/core/telnet.c:1885
1559c1435
< #: src/core/telnet.c:1768
---
> #: src/core/telnet.c:1883
1563c1439
< #: src/core/telnet.c:1769
---
> #: src/core/telnet.c:1884
1567c1443
< #: src/core/properties/unsigned.c:95
---
> #: src/core/properties/unsigned.c:96
1571c1447
< #: src/core/properties/string.c:98
---
> #: src/core/properties/string.c:108
1575c1451
< #: src/core/properties/string.c:91
---
> #: src/core/properties/string.c:101
1579c1455
< #: src/core/actions/table.c:751
---
> #: src/core/actions/table.c:766
1593c1469
< #: src/network_modules/openssl/messages.c:182
---
> #: src/network_modules/openssl/messages.c:171
1597c1473
< #: src/network_modules/openssl/messages.c:167
---
> #: src/network_modules/openssl/messages.c:157
1601c1477
< #: src/network_modules/openssl/messages.c:216
---
> #: src/network_modules/openssl/messages.c:202
1605c1481
< #: src/network_modules/openssl/messages.c:227
---
> #: src/network_modules/openssl/messages.c:212
1609c1485
< #: src/network_modules/openssl/messages.c:102
---
> #: src/network_modules/openssl/messages.c:98
1619c1495
< #: src/network_modules/openssl/messages.c:183
---
> #: src/network_modules/openssl/messages.c:172
1623c1499
< #: src/network_modules/openssl/messages.c:168
---
> #: src/network_modules/openssl/messages.c:158
1627c1503
< #: src/network_modules/openssl/messages.c:79
---
> #: src/network_modules/openssl/messages.c:77
1634,1635c1510,1511
< #: src/network_modules/openssl/main.c:124
< #: src/network_modules/openssl/main.c:171
---
> #: src/network_modules/openssl/main.c:122
> #: src/network_modules/openssl/main.c:173
1640,1647c1516
< #: src/core/linux/connect.c:191 src/core/macos/connect.c:191
< #, fuzzy, c-format
< msgid "The System error was '%s' (rc=%d)"
< msgstr "O erro do sistema foi \"%s\" (rc=%d)"
< 
< #: src/core/linux/ldap.c:82 src/core/linux/ldap.c:91
< #: src/core/windows/ldap.c:101 src/core/windows/ldap.c:110
< #: src/core/macos/ldap.c:82 src/core/macos/ldap.c:91
---
> #: src/core/windows/ldap.c:108 src/core/windows/ldap.c:118
1651c1520
< #: src/network_modules/openssl/messages.c:325
---
> #: src/network_modules/openssl/messages.c:298
1655c1524
< #: src/network_modules/openssl/messages.c:270
---
> #: src/network_modules/openssl/messages.c:248
1663c1532
< #: src/network_modules/openssl/messages.c:303
---
> #: src/network_modules/openssl/messages.c:278
1667c1536
< #: src/network_modules/openssl/messages.c:157
---
> #: src/network_modules/openssl/messages.c:148
1675c1544
< #: src/network_modules/openssl/messages.c:146
---
> #: src/network_modules/openssl/messages.c:138
1683c1552
< #: src/network_modules/openssl/messages.c:205
---
> #: src/network_modules/openssl/messages.c:192
1687c1556
< #: src/network_modules/openssl/messages.c:194
---
> #: src/network_modules/openssl/messages.c:182
1691c1560
< #: src/network_modules/openssl/messages.c:91
---
> #: src/network_modules/openssl/messages.c:88
1701c1570,1574
< #: src/core/properties/unsigned.c:77
---
> #: src/network_modules/openssl/start.c:235
> msgid "The client was unable to negotiate a secure connection with the host"
> msgstr "O cliente foi incapaz de negociar uma conexão segura com o servidor"
> 
> #: src/core/properties/unsigned.c:78
1705c1578
< #: src/network_modules/state.c:77
---
> #: src/network_modules/state.c:80
1709c1582
< #: src/network_modules/openssl/messages.c:53
---
> #: src/network_modules/openssl/messages.c:52
1713c1586
< #: src/network_modules/openssl/messages.c:391
---
> #: src/network_modules/openssl/messages.c:358
1725c1598
< #: src/network_modules/openssl/messages.c:402
---
> #: src/network_modules/openssl/messages.c:368
1733c1606
< #: src/network_modules/openssl/messages.c:380
---
> #: src/network_modules/openssl/messages.c:348
1743c1616
< #: src/network_modules/openssl/messages.c:369
---
> #: src/network_modules/openssl/messages.c:338
1753c1626
< #: src/core/properties/unsigned.c:158
---
> #: src/core/properties/unsigned.c:151
1772c1645
< #: src/core/ctlr.c:205
---
> #: src/core/ctlr.c:230
1783c1656
< #: src/network_modules/openssl/messages.c:281
---
> #: src/network_modules/openssl/messages.c:258
1791c1664
< #: src/network_modules/openssl/messages.c:64
---
> #: src/network_modules/openssl/messages.c:62
1799,1803c1672
< #: src/core/properties/string.c:173
< msgid "The log file name"
< msgstr "Define o nome do arquivo de log"
< 
< #: src/core/properties/unsigned.c:96
---
> #: src/core/properties/unsigned.c:97
1807c1676
< #: src/core/properties/string.c:56
---
> #: src/core/properties/string.c:66
1811c1680
< #: src/core/connect.c:170
---
> #: src/core/connect.c:202
1819c1688
< #: src/core/ctlr.c:204
---
> #: src/core/ctlr.c:229
1823c1692
< #: src/core/ctlr.c:172
---
> #: src/core/ctlr.c:186
1827c1696
< #: src/core/ctlr.c:182
---
> #: src/core/ctlr.c:200
1831c1700
< #: src/core/ctlr.c:193
---
> #: src/core/ctlr.c:215
1835c1704
< #: src/network_modules/openssl/messages.c:254
---
> #: src/network_modules/openssl/messages.c:232
1843c1712
< #: src/network_modules/openssl/messages.c:113
---
> #: src/network_modules/openssl/messages.c:108
1849c1718
< #: src/core/ft/ft.c:251
---
> #: src/core/ft/ft.c:277
1853c1722
< #: src/network_modules/openssl/messages.c:358
---
> #: src/network_modules/openssl/messages.c:328
1858c1727
< #: src/network_modules/openssl/messages.c:347
---
> #: src/network_modules/openssl/messages.c:318
1864,1865c1733,1734
< #: src/network_modules/openssl/main.c:102
< #: src/network_modules/openssl/main.c:150
---
> #: src/network_modules/openssl/main.c:104
> #: src/network_modules/openssl/main.c:155
1869c1738
< #: src/core/properties/string.c:150
---
> #: src/core/properties/string.c:170
1873c1742
< #: src/network_modules/default/main.c:148
---
> #: src/network_modules/default/main.c:144
1877,1878c1746,1747
< #: src/network_modules/openssl/messages.c:124
< #: src/network_modules/openssl/messages.c:135
---
> #: src/network_modules/openssl/messages.c:118
> #: src/network_modules/openssl/messages.c:128
1882c1751
< #: src/network_modules/openssl/messages.c:336
---
> #: src/network_modules/openssl/messages.c:308
1888c1757
< #: src/network_modules/tools.c:114 src/network_modules/tools.c:123
---
> #: src/network_modules/tools.c:129 src/network_modules/tools.c:140
1893c1762
< #: src/network_modules/tools.c:83 src/network_modules/tools.c:135
---
> #: src/network_modules/tools.c:82 src/network_modules/tools.c:154
1898c1767
< #: src/core/windows/connect.c:239
---
> #: src/core/windows/connect.c:250
1903,1906c1772,1773
< #: src/core/linux/connect.c:222 src/core/linux/connect.c:282
< #: src/core/windows/connect.c:298 src/core/windows/connect.c:306
< #: src/core/windows/connect.c:314 src/core/windows/connect.c:324
< #: src/core/macos/connect.c:222 src/core/macos/connect.c:282
---
> #: src/core/windows/connect.c:313 src/core/windows/connect.c:321
> #: src/core/windows/connect.c:329 src/core/windows/connect.c:340
1911,1912c1778,1779
< #: src/core/windows/connect.c:225 src/core/windows/connect.c:360
< #: src/core/windows/connect.c:378
---
> #: src/core/windows/connect.c:234 src/core/windows/connect.c:378
> #: src/core/windows/connect.c:397
1917c1784
< #: src/core/util.c:270
---
> #: src/network_modules/tools.c:113
1919,1924c1786,1787
< msgid "The system error was '%s' (rc=%d)"
< msgstr "O erro do sistema foi \"%s\" (rc=%d)"
< 
< #: src/core/properties/string.c:181
< msgid "The trace file name"
< msgstr "O nome do arquivo de trace"
---
> msgid "The system error was %s (%d)"
> msgstr "O erro do sistema operacional foi \"%s\" (%d)"
1926c1789
< #: src/core/ctlr.c:194
---
> #: src/core/ctlr.c:216
1931,1935d1793
< #: src/network_modules/tools.c:67 src/network_modules/tools.c:101
< #, c-format
< msgid "The windows error code was %u"
< msgstr "O erro do windows foi %u"
< 
1944,1948c1802
< #: src/core/properties/unsigned.c:142
< msgid "Time for auto-reconnect"
< msgstr "Tempo para reconexão automática"
< 
< #: src/core/windows/connect.c:299
---
> #: src/core/windows/connect.c:314
1956c1810
< #: src/core/toggles/table.c:135
---
> #: src/core/toggles/table.c:133
1960c1814
< #: src/core/toggles/table.c:296
---
> #: src/core/toggles/table.c:303
1964c1818
< #: src/core/toggles/table.c:308
---
> #: src/core/toggles/table.c:314
1968c1822
< #: src/core/toggles/table.c:124
---
> #: src/core/toggles/table.c:123
1972c1826
< #: src/core/toggles/table.c:307
---
> #: src/core/toggles/table.c:313
1976c1830
< #: src/core/toggles/table.c:136
---
> #: src/core/toggles/table.c:134
1980c1834
< #: src/core/toggles/table.c:297
---
> #: src/core/toggles/table.c:304
1984c1838
< #: src/core/toggles/table.c:125
---
> #: src/core/toggles/table.c:124
1988c1842
< #: src/core/toggles/table.c:82
---
> #: src/core/toggles/table.c:83
1992c1846
< #: src/core/toggles/table.c:83
---
> #: src/core/toggles/table.c:84
1996c1850
< #: src/core/ft/ft_cut.c:360
---
> #: src/core/ft/ft_cut.c:371
2000,2001c1854,1855
< #: src/core/ft/ft_cut.c:387 src/core/ft/ft_cut.c:475 src/core/ft/ft_dft.c:213
< #: src/core/ft/ft_dft.c:344
---
> #: src/core/ft/ft_dft.c:230 src/core/ft/ft_dft.c:373 src/core/ft/ft_cut.c:400
> #: src/core/ft/ft_cut.c:495
2005c1859
< #: src/core/ft/ft.c:526
---
> #: src/core/ft/ft.c:580
2009c1863
< #: src/core/ft/ft.c:530
---
> #: src/core/ft/ft.c:585
2013c1867
< #: src/core/ft/ft_cut.c:447
---
> #: src/core/ft/ft_cut.c:464
2017,2018c1871
< #: src/core/linux/connect.c:166 src/core/windows/connect.c:198
< #: src/core/macos/connect.c:166
---
> #: src/core/windows/connect.c:205
2022c1875
< #: src/core/properties/string.c:68
---
> #: src/core/properties/string.c:78
2026c1879
< #: src/core/ft/ft_dft.c:161
---
> #: src/core/ft/ft_dft.c:170
2030c1883
< #: src/network_modules/openssl/messages.c:112
---
> #: src/network_modules/openssl/messages.c:107
2034c1887
< #: src/network_modules/openssl/messages.c:101
---
> #: src/network_modules/openssl/messages.c:97
2039c1892
< #: src/network_modules/openssl/messages.c:90
---
> #: src/network_modules/openssl/messages.c:87
2043c1896
< #: src/network_modules/openssl/messages.c:78
---
> #: src/network_modules/openssl/messages.c:76
2047,2048c1900
< #: src/core/linux/connect.c:201 src/core/windows/connect.c:224
< #: src/core/macos/connect.c:201
---
> #: src/core/windows/connect.c:233
2052c1904
< #: src/network_modules/openssl/messages.c:63
---
> #: src/network_modules/openssl/messages.c:61
2056c1908
< #: src/network_modules/openssl/messages.c:280
---
> #: src/network_modules/openssl/messages.c:257
2060c1912
< #: src/core/session.c:176
---
> #: src/core/session.c:201
2064,2068c1916
< #: src/network_modules/openssl/start.c:247
< msgid "Unable to negotiate a secure connection with the host"
< msgstr "Incapaz de negociar uma conexão segura com o host"
< 
< #: src/core/paste.c:374
---
> #: src/core/paste.c:399
2072c1920
< #: src/core/session.c:164
---
> #: src/core/session.c:187
2076c1924
< #: src/core/session.c:170
---
> #: src/core/session.c:194
2080c1928
< #: src/core/ft/ft.c:478
---
> #: src/core/ft/ft.c:528
2084c1932
< #: src/network_modules/openssl/messages.c:291
---
> #: src/network_modules/openssl/messages.c:267
2088c1936
< #: src/core/telnet.c:1761
---
> #: src/core/telnet.c:1876
2092,2096c1940
< #: src/core/properties/signed.c:100
< msgid "Undefined"
< msgstr "Indefinido"
< 
< #: src/core/toggles/table.c:225
---
> #: src/core/toggles/table.c:233
2100,2104c1944
< #: src/network_modules/openssl/start.c:268
< msgid "Unexpected I/O error"
< msgstr "Erro de I/O inesperado"
< 
< #: src/core/paste.c:375
---
> #: src/core/paste.c:400
2108c1948
< #: src/network_modules/tools.c:134
---
> #: src/network_modules/tools.c:153
2112c1952
< #: src/core/keyboard/kybd.c:269
---
> #: src/core/keyboard/kybd.c:279
2117,2119c1957
< #: src/core/telnet.c:1774 src/core/telnet.c:1794
< #: src/core/properties/signed.c:59 src/core/properties/signed.c:88
< #: src/core/properties/signed.c:108
---
> #: src/core/telnet.c:1889 src/core/telnet.c:1911
2123c1961
< #: src/core/ctlr.c:402
---
> #: src/core/ctlr.c:676
2128c1966
< #: src/core/ft/ft_cut.c:368
---
> #: src/core/ft/ft_cut.c:379
2132c1970
< #: src/core/keyboard/kybd.c:1547
---
> #: src/core/keyboard/kybd.c:1686
2137c1975
< #: src/core/keyboard/kybd.c:1560
---
> #: src/core/keyboard/kybd.c:1701
2142c1980
< #: src/core/ft/ft_cut.c:297
---
> #: src/core/ft/ft_cut.c:303
2146c1984
< #: src/core/properties/unsigned.c:157
---
> #: src/core/properties/unsigned.c:150
2150c1988
< #: src/core/rpq.c:223
---
> #: src/core/rpq.c:230
2154c1992
< #: src/network_modules/openssl/messages.c:335
---
> #: src/network_modules/openssl/messages.c:307
2158c1996
< #: src/core/actions/table.c:143
---
> #: src/core/actions/table.c:158
2162c2000
< #: src/core/toggles/table.c:52
---
> #: src/core/toggles/table.c:53
2166c2004
< #: src/core/toggles/table.c:245 src/core/toggles/table.c:246
---
> #: src/core/toggles/table.c:253 src/core/toggles/table.c:254
2170c2008
< #: src/core/toggles/table.c:247
---
> #: src/core/toggles/table.c:255
2174,2178c2012
< #: src/core/properties/signed.c:99
< msgid "Verifying SSL (Getting CRL)"
< msgstr ""
< 
< #: src/core/windows/connect.c:111
---
> #: src/core/windows/connect.c:112
2182c2016
< #: src/core/ft/ft.c:487
---
> #: src/core/ft/ft.c:537
2186c2020
< #: src/core/ft/ft.c:489
---
> #: src/core/ft/ft.c:539
2190c2024
< #: src/core/telnet.c:727
---
> #: src/core/telnet.c:776
2194c2028
< #: src/core/windows/util.c:124 src/core/windows/util.c:167
---
> #: src/core/windows/util.c:132 src/core/windows/util.c:181
2203,2254d2036
< #: src/core/properties/signed.c:71 src/core/properties/signed.c:77
< #: src/core/properties/signed.c:78
< msgid "X"
< msgstr "X"
< 
< #: src/core/properties/signed.c:72
< msgid "X -f"
< msgstr "X -f"
< 
< #: src/core/properties/signed.c:69
< #, fuzzy
< msgid "X Connected"
< msgstr "X Desconectado"
< 
< #: src/core/properties/signed.c:80
< #, fuzzy
< msgid "X Connecting"
< msgstr "Conectando"
< 
< #: src/core/properties/signed.c:76
< msgid "X Inhibit"
< msgstr "X Inibido"
< 
< #: src/core/properties/signed.c:70
< msgid "X Not Connected"
< msgstr "X Desconectado"
< 
< #: src/core/properties/signed.c:74
< msgid "X Numeric"
< msgstr "X Numérico"
< 
< #: src/core/properties/signed.c:75
< msgid "X Overflow"
< msgstr "X Estouro"
< 
< #: src/core/properties/signed.c:73
< msgid "X Protected"
< msgstr "X Protegido"
< 
< #: src/core/properties/signed.c:79
< #, fuzzy
< msgid "X Resolving"
< msgstr "Resolvendo"
< 
< #: src/core/properties/signed.c:67
< msgid "X System"
< msgstr "X Sistema"
< 
< #: src/core/properties/signed.c:68
< msgid "X Wait"
< msgstr "X Aguarde"
< 
2330c2112
< #: src/core/actions/table.c:126
---
> #: src/core/actions/table.c:141
2334c2116
< #: src/core/actions/table.c:112
---
> #: src/core/actions/table.c:127
2338,2340c2120
< #: src/core/linux/connect.c:233 src/core/linux/connect.c:302
< #: src/core/windows/connect.c:340 src/core/macos/connect.c:233
< #: src/core/macos/connect.c:302
---
> #: src/core/windows/connect.c:357
2344,2345c2124
< #: src/core/toggles/init.c:83 src/core/linux/connect.c:334
< #: src/core/windows/connect.c:372 src/core/macos/connect.c:334
---
> #: src/core/toggles/init.c:89 src/core/windows/connect.c:391
2349,2350c2128
< #: src/core/toggles/init.c:83 src/core/linux/connect.c:334
< #: src/core/windows/connect.c:372 src/core/macos/connect.c:334
---
> #: src/core/toggles/init.c:89 src/core/windows/connect.c:391
2354c2132
< #: src/network_modules/tools.c:174
---
> #: src/network_modules/tools.c:196
2358c2136
< #: src/network_modules/tools.c:161
---
> #: src/network_modules/tools.c:182
2360c2138,2142
< msgstr "ioctlsocket(FIONBIO) falhou."
---
> msgstr "ioctlsocket(FIONBIO) failed."
> 
> #: src/core/properties/string.c:138
> msgid "lib3270 revision"
> msgstr "Revisão da lib3270"
2362c2144,2148
< #: src/core/properties/boolean.c:189
---
> #: src/core/properties/string.c:131
> msgid "lib3270 version"
> msgstr "Versão da lib3270"
> 
> #: src/core/properties/boolean.c:195
2366,2367c2152
< #: src/core/linux/connect.c:322 src/core/windows/connect.c:359
< #: src/core/macos/connect.c:322
---
> #: src/core/windows/connect.c:377
2369c2154
< msgstr "setsockopt(SO_OOBINLINE) falhou"
---
> msgstr "setsockopt(SO_OOBINLINE) has failed"
2659a2445,2450
> #~ msgid "Can't initialize curl operation"
> #~ msgstr "Erro ao inicializar operação CURL"
> 
> #~ msgid "Can't load \"%s\": %s"
> #~ msgstr "Não foi possível carregar \"%s\": %s"
> 
2671a2463,2468
> #~ msgid "Can't open \"%s\" (The Windows error code was %ld)\n"
> #~ msgstr "Não foi possível abrir \"%s\" (O código de erro windows foi %ld)\n"
> 
> #~ msgid "Can't open \"%s\": %s"
> #~ msgstr "Não foi possível abrir %s: %s"
> 
2701a2499,2501
> #~ msgid "Can't read \"%s\": %s"
> #~ msgstr "Não foi possível ler \"%s\": %s"
> 
2785a2586,2594
> #~ msgid "Cant load custom certificate file."
> #~ msgstr "Não foi possível ler arquivo de certificado personalizado"
> 
> #~ msgid "Cant open custom certificate directory."
> #~ msgstr "Não foi possível abrir o diretório de certificados personalizados"
> 
> #~ msgid "Cant read custom certificate file."
> #~ msgstr "Não foi possível ler certificado personalizado"
> 
2847a2657,2659
> #~ msgid "Connection failed"
> #~ msgstr "Conexão falhou"
> 
2953,2955d2764
< #~ msgid "Error"
< #~ msgstr "Erro"
< 
3167,3169d2975
< #~ msgid "Internal error"
< #~ msgstr "Erro interno"
< 
3240a3047,3049
> #~ msgid "Minutes for auto-disconnect"
> #~ msgstr "Minutos para desconexão automática"
> 
3675,3677d3483
< #~ msgid "SSL Connect failed"
< #~ msgstr "Conexão SSL falhou"
< 
3686a3493,3495
> #~ msgid "SSL negotiation"
> #~ msgstr "Negociação SSL"
> 
3872a3682,3684
> #~ msgid "Set trace filename"
> #~ msgstr "Define o nome do arquivo de trace"
> 
4063,4065d3874
< #~ msgid "The system error was %s (%d)"
< #~ msgstr "O erro do sistema operacional foi \"%s\" (%d)"
< 
4179a3989,3991
> #~ msgid "Undefined"
> #~ msgstr "Indefinido"
> 
4282a4095,4121
> #~ msgid "X"
> #~ msgstr "X"
> 
> #~ msgid "X -f"
> #~ msgstr "X -f"
> 
> #~ msgid "X Inhibit"
> #~ msgstr "X Inibido"
> 
> #~ msgid "X Not Connected"
> #~ msgstr "X Desconectado"
> 
> #~ msgid "X Numeric"
> #~ msgstr "X Numérico"
> 
> #~ msgid "X Overflow"
> #~ msgstr "X Estouro"
> 
> #~ msgid "X Protected"
> #~ msgstr "X Protegido"
> 
> #~ msgid "X System"
> #~ msgstr "X Sistema"
> 
> #~ msgid "X Wait"
> #~ msgstr "X Aguarde"
> 
4369a4209,4211
> #~ msgid "_Secure connection."
> #~ msgstr "Conexão _Segura."
> 
4399a4242,4244
> #~ msgid "disconnected"
> #~ msgstr "Desconectado"
> 
4405,4410d4249
< 
< #~ msgid "lib3270 revision"
< #~ msgstr "Revisão da lib3270"
< 
< #~ msgid "lib3270 version"
< #~ msgstr "Versão da lib3270"
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4: mac
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/Makefile.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/Makefile.in
27,43d26
< #---[ Paths ]----------------------------------------------------------------------------
< 
< prefix=@prefix@
< exec_prefix=@exec_prefix@
< srcdir=@srcdir@
< bindir=@bindir@
< srcdir=@srcdir@
< sbindir=@sbindir@
< libdir=@libdir@
< includedir=@includedir@
< datarootdir=@datarootdir@
< localedir=@localedir@
< docdir=@docdir@
< sysconfdir=@sysconfdir@
< datadir=$(datarootdir)/$(PRODUCT_NAME)
< confdir=$(sysconfdir)/$(PRODUCT_NAME)
< 
54,66d36
< COMMON_SOURCES= \
< 	$(wildcard $(srcdir)/src/core/*.c) \
< 	$(wildcard $(srcdir)/src/core/keyboard/*.c) \
< 	$(wildcard $(srcdir)/src/core/actions/*.c) \
< 	$(wildcard $(srcdir)/src/core/toggles/*.c) \
< 	$(wildcard $(srcdir)/src/core/charset/*.c) \
< 	$(wildcard $(srcdir)/src/core/ft/*.c) \
< 	$(wildcard $(srcdir)/src/core/properties/*.c) \
< 	$(wildcard $(srcdir)/src/selection/*.c) \
< 	$(wildcard $(srcdir)/src/network_modules/*.c) \
< 	$(BUILDDIR)/.tmp/$(LIBNAME)/fallbacks.c \
< 	$(foreach MODULE, $(NETWORK_MODULES), $(wildcard $(srcdir)/src/network_modules/$(MODULE)/*.c))
< 
68,70c38,50
< 	$(COMMON_SOURCES) \
< 	$(wildcard $(srcdir)/src/core/@OSNAME@/*.rc) \
< 	$(wildcard $(srcdir)/src/core/@OSNAME@/*.c)
---
> 	$(wildcard src/core/*.c) \
> 	$(wildcard src/core/keyboard/*.c) \
> 	$(wildcard src/core/actions/*.c) \
> 	$(wildcard src/core/toggles/*.c) \
> 	$(wildcard src/core/charset/*.c) \
> 	$(wildcard src/core/ft/*.c) \
> 	$(wildcard src/core/@OSNAME@/*.rc) \
> 	$(wildcard src/core/@OSNAME@/*.c) \
> 	$(wildcard src/core/properties/*.c) \
> 	$(wildcard src/selection/*.c) \
> 	$(wildcard src/network_modules/*.c) \
> 	$(BASEDIR)/.tmp/$(LIBNAME)/fallbacks.c \
> 	$(foreach MODULE, $(NETWORK_MODULES), $(wildcard src/network_modules/$(MODULE)/*.c))
73c53
< 	$(wildcard $(srcdir)/src/testprogram/*.c)
---
> 	$(wildcard src/testprogram/*.c)
95c75,88
< #---[ Build Paths ]----------------------------------------------------------------------
---
> #---[ Paths ]----------------------------------------------------------------------------
> 
> prefix=@prefix@
> exec_prefix=@exec_prefix@
> bindir=@bindir@
> sbindir=@sbindir@
> libdir=@libdir@
> includedir=@includedir@
> datarootdir=@datarootdir@
> localedir=@localedir@
> docdir=@docdir@
> sysconfdir=@sysconfdir@
> datadir=$(datarootdir)/$(PRODUCT_NAME)
> confdir=$(sysconfdir)/$(PRODUCT_NAME)
97c90
< BUILDDIR=@BUILDDIR@
---
> BASEDIR=@BASEDIR@
99c92
< POTDIR=$(BUILDDIR)/.pot
---
> POTDIR=$(BASEDIR)/.pot
101c94
< OBJDIR=$(BUILDDIR)/.obj/@OSNAME@
---
> OBJDIR=$(BASEDIR)/.obj/$(LIBNAME)
105c98
< BINDIR=$(BUILDDIR)/.bin
---
> BINDIR=$(BASEDIR)/.bin
110a104,110
> DEPENDS= \
> 	Makefile \
> 	src/include/*.h \
> 	src/include/lib3270/*.h \
> 	src/include/@OSNAME@/lib3270/*.h \
> 	$(BASEDIR)/src/include/lib3270/actions.h
> 
114,116c114,115
< 	-Isrc/include \
< 	-I$(srcdir)/src/include \
< 	-I$(srcdir)/src/include/@OSNAME@ \
---
> 	-I$(BASEDIR)/src/include \
> 	-I$(BASEDIR)/src/include/@OSNAME@ \
135,136c134,136
< 	%.c
< 	
---
> 	%.c \
> 	$(DEPENDS)
> 
161c161,162
< 	%.c
---
> 	%.c \
> 	$(DEPENDS)
234c235
< 		$(BUILDDIR)/win
---
> 		$(BASEDIR)/win
236,239d236
< all-linux: \
< 	$(BINRLS)/$(SONAME) \
< 	$(BINRLS)/$(LIBNAME).a \
< 	locale/$(PACKAGE_NAME).pot
241c238
< all-macos: \
---
> all-linux: \
308,318d304
< install-macos-lib: \
< 	$(BINRLS)/$(SONAME) \
< 	install-locale
< 
< 	# Install library
< 	@$(MKDIR) $(DESTDIR)$(libdir)
< 
< 	@$(INSTALL_PROGRAM) \
< 		$(BINRLS)/$(SONAME) \
< 		$(DESTDIR)$(libdir)/$(SONAME)
< 
348c334
< 	# Install delayed library
---
> 	# Install static library
370c356
< 		$(srcdir)/src/include/@OSNAME@/lib3270/*.h \
---
> 		src/include/@OSNAME@/lib3270/*.h \
374c360
< 		$(srcdir)/src/include/lib3270/*.h \
---
> 		src/include/lib3270/*.h \
378c364
< 		$(srcdir)/src/include/lib3270.h \
---
> 		src/include/lib3270.h \
400,409d385
< install-macos-dev:
< 
< 	@$(MKDIR) \
< 		$(DESTDIR)$(libdir)
< 
< 	@$(LN_S) \
< 		$(SONAME) \
< 		$(DESTDIR)$(libdir)/$(LIBNAME)@DLLEXT@
< 
< 
433,435c409,413
< 	@$(INSTALL_DATA) \
< 		$(srcdir)/CHANGELOG \
< 		$(DESTDIR)$(datarootdir)/$(PRODUCT_NAME)/$(PACKAGE_NAME).changes
---
> 	@rm -f $(DESTDIR)$(libdir)/$(LIBNAME)@DLLEXT@
> 	@$(LN_S) \
> 		$(bindir)/$(LIBNAME)@DLLEXT@ \
> 		$(DESTDIR)$(libdir)/$(LIBNAME)@DLLEXT@
> 	
439,441c417,419
< $(BUILDDIR)/.tmp/$(LIBNAME)/fallbacks.c: \
< 	$(srcdir)/src/core/X3270.xad \
< 	$(wildcard $(srcdir)/src/mkfb/*.c)
---
> $(BASEDIR)/.tmp/$(LIBNAME)/fallbacks.c: \
> 	src/core/X3270.xad \
> 	$(wildcard src/mkfb/*.c)
450c428
< 		-Isrc/include \
---
> 		-I$(BASEDIR)/src/include \
452c430
< 		$(wildcard $(srcdir)/src/mkfb/*.c)
---
> 		$(wildcard src/mkfb/*.c)
455c433
< 		-c $(srcdir)/src/core/X3270.xad \
---
> 		-c src/core/X3270.xad \
459,463c437,438
< 	$(foreach SRC, $(basename $(COMMON_SOURCES)), $(POTDIR)/$(LIBNAME)/$(SRC).pot) \
< 	$(foreach SRC, $(basename $(wildcard $(srcdir)/src/core/linux/*.c)), $(POTDIR)/$(LIBNAME)/$(SRC).pot) \
< 	$(foreach SRC, $(basename $(wildcard $(srcdir)/src/core/windows/*.c)), $(POTDIR)/$(LIBNAME)/$(SRC).pot) \
< 	$(foreach SRC, $(basename $(wildcard $(srcdir)/src/core/macos/*.c)), $(POTDIR)/$(LIBNAME)/$(SRC).pot)
< 	
---
> 	$(foreach SRC, $(basename $(SOURCES)), $(POTDIR)/$(LIBNAME)/$(SRC).pot)
> 
530,532c505
< 	@rm -fr $(BUILDDIR)/.obj
< 	@rm -fr $(BUILDDIR)/.bin
< 	@rm -fr $(BUILDDIR)/.tmp
---
> 	@rm -fr $(BASEDIR)/.tmp/$(LIBNAME)
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4: PKGBUILD.mingw
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4: pushtag.sh
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/README.md lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/README.md
1c1,2
< ## TN3270 Protocol Library for Linux/Windows
---
> TN3270 Protocol Library for Linux/Windows
> =========================================
5c6,7
< [![License: GPL v3](https://img.shields.io/badge/License-GPL%20v3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)
---
> See more details at https://softwarepublico.gov.br/social/pw3270/
> 
7,9d8
< [![build result](https://build.opensuse.org/projects/home:PerryWerneck:pw3270/packages/lib3270/badge.svg?type=percent)](https://build.opensuse.org/package/show/home:PerryWerneck:pw3270/lib3270)
< [![Publish](https://github.com/PerryWerneck/lib3270/actions/workflows/publish.yml/badge.svg)](https://github.com/PerryWerneck/lib3270/actions/workflows/publish.yml)
< ![Downloads](https://img.shields.io/github/downloads/PerryWerneck/lib3270/total.svg)
11d9
< ## Installation
13c11,12
< ### Pre build packages
---
> Installation repositories
> =========================
15c14
< You can download installation package for supported linux distributions in [Open Build Service](https://software.opensuse.org/download.html?project=home%3APerryWerneck%3Apw3270&package=lib3270)
---
>  You can find instalation repositories in SuSE Build Service:
17,18c16,18
< [<img src="https://raw.githubusercontent.com/PerryWerneck/pw3270/develop/branding/obs-badge-en.svg" alt="Download from open build service" height="80px">](https://software.opensuse.org/download.html?project=home%3APerryWerneck%3Apw3270&package=pw3270)
< [<img src="https://raw.githubusercontent.com/PerryWerneck/PerryWerneck/3aa96b8275d4310896c3a0b5b3965ed650fb7c2b/badges/github-msys-macos.svg" alt="Download from githut" height="80px">](https://github.com/PerryWerneck/lib3270/releases)
---
>  * Linux: https://software.opensuse.org/download.html?project=home%3APerryWerneck%3Apw3270&package=lib3270
>  * Windows cross (32 bits): https://software.opensuse.org/download.html?project=home%3APerryWerneck%3Apw3270&package=mingw32-lib3270
>  * Windows cross (64 bits): https://software.opensuse.org/download.html?project=home%3APerryWerneck%3Apw3270&package=mingw64-lib3270
20c20,21
< ## Building for Linux
---
> Building for Linux
> ==================
25c26
< 	git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
---
> 	$ git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
42c43
< 	(This command can make it easy on SuSE: grep -i buildrequires rpm/lib3270.spec | cut -d: -f2 | sudo xargs zypper in )
---
> (This command can make it easy on SuSE: grep -i buildrequires rpm/lib3270.spec | cut -d: -f2 | sudo xargs zypper in )
47,49c48,50
< 	./autogen.sh
< 	make clean
< 	make all
---
> 	$ ./autogen.sh
> 	$ make clean
> 	$ make all
52c53,54
< ## Building for Windows
---
> Building for Windows
> ====================
54c56,57
< ### Cross-compiling on SuSE Linux (Native or WSL)
---
> Cross-compiling on SuSE Linux (Native or WSL)
> ---------------------------------------------
59,61c62,64
< 	sudo zypper ar obs://windows:mingw:win32 mingw32
< 	sudo zypper ar obs://windows:mingw:win64 mingw64
< 	sudo zypper ref
---
> 	$ sudo zypper ar obs://windows:mingw:win32 mingw32
> 	$ sudo zypper ar obs://windows:mingw:win64 mingw64
> 	$ sudo zypper ref
67c70
< 	git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
---
> 	$ git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
73c76
< 	./lib3270/win/install-cross.sh --all (for 32 and 64 bits)
---
> 	$ ./lib3270/win/install-cross.sh --all (for 32 and 64 bits)
79c82
< 	./lib3270/win/win-configure.sh --64 (for 64 bits)
---
> 	$ ./lib3270/win/win-configure.sh --64 (for 64 bits)
85,104c88,90
< 	cd lib3270
< 	make clean
< 	make all
< 	```
< ### Windows native with MSYS2 (Using bundle script)
< 
< 1. Install and update MSYS2 
< 
< 	* Download and install [msys2](https://www.msys2.org/)
< 	* Update msys:
< 	
< 	```shell
< 	pacman -Syu
< 	```
< 	Afther this close and reopen mingw shell.
< 
< 2. Get lib3270 sources from git using the mingw shell
< 
< 	```shell
< 	git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
---
> 	$ cd lib3270
> 	$ make clean
> 	$ make all
107,114c93,94
< 3. Run bundle script
< 
< 	```shell
< 	cd lib3270
< 	./win/bundle.msys --pre-reqs --build
< 	```
< 
< ### Windows native with MSYS2 (Manual)
---
> Windows native with MSYS2
> -------------------------
118,124c98
< 	* Download and install [msys2](https://www.msys2.org/)
< 	* Update msys:
< 	
< 	```shell
< 	pacman -Syu
< 	```
< 	Afther this close and reopen mingw shell.
---
> 	* Download and install msys2 from https://www.msys2.org/ (Don't forget to update the package database and core system packages)
133c107
< 	pacman -S --needed zip dos2unix mingw-w64-x86_64-gcc automake autoconf make git pkgconf mingw-w64-x86_64-gettext gettext-devel mingw-w64-x86_64-openssl libtool
---
> 	$ pacman -S --needed mingw-w64-x86_64-gcc automake autoconf make git pkg-config mingw-w64-x86_64-gettext mingw-w64-x86_64-openssl
135d108
< 
141c114
< 	git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
---
> 	$ git clone https://github.com/PerryWerneck/lib3270.git ./lib3270
147,149c120,122
< 	cd lib3270
< 	./autogen.sh
< 	make all
---
> 	$ cd lib3270
> 	$ ./autogen.sh
> 	$ make all
155c128
< 	make install
---
> 	$ make install
158,162c131,132
< ## Building for macOS
< 
< ### Using homebrew
< 
< Install
---
> Building for macOS (using homebrew)
> ===================================
169,171c139
< 	brew update
< 	brew install xz automake binutils coreutils curl gettext libtool openssl pkgconfig
< 	brew upgrade
---
> 	$ brew install automake binutils coreutils curl gettext libtool openldap openssl pkgconfig
174c142
< 4. Configure, build and install
---
> 3. Use [open-keg](https://gist.github.com/andrebreves/5f36e78575e20162ed0a62bd27c4bcea) to make keg-only dependencies available during build process
177,180c145
< 	export PKG_CONFIG_PATH="$(brew --prefix curl)/lib/pkgconfig:$(brew --prefix openssl)/lib/pkgconfig"
< 	./autogen.sh --prefix="$(brew --cellar)/lib3270/5.4" --with-libiconv-prefix=$(brew --prefix gettext)
< 	make all && make install
< 	brew link lib3270
---
> 	$ open-keg curl openldap openssl
183c148
< Uninstall
---
> 4. Configure, build and install (inside the [open-keg](https://gist.github.com/andrebreves/5f36e78575e20162ed0a62bd27c4bcea) shell opened above)
186,187c151,153
< 	brew unlink lib3270
< 	rm -fr "$(brew --cellar)/lib3270"
---
> 	$ ./autogen.sh --prefix="$(brew --cellar)/lib3270/5.3"
> 	$ make all && make install
> 	$ brew link lib3270
189,190d154
< 	
< ### Using jhbuild
192c156,157
< 1. Install jhbuild
---
> Uninstalling
> ------------
194,196c159
< 	https://wiki.gnome.org/Projects/GTK/OSX/Building
< 	
< 2. build
---
> 1. To uninstall
199c162,163
< 	jhbuild --moduleset=https://raw.githubusercontent.com/PerryWerneck/lib3270/master/mac/lib3270.modules build lib3270
---
> 	$ brew unlink lib3270
> 	$ rm -fr "$(brew --cellar)/lib3270"
201,202d164
< 
< 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/rpm/lib3270.spec lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/rpm/lib3270.spec
4c4
< # Copyright (c) 2022 SUSE LLC
---
> # Copyright (c) 2019 SUSE LINUX GmbH, Nuernberg, Germany.
18a19
> 
20c21
< Version:        5.4+git20240817
---
> Version:        5.3
34d34
< BuildRequires:  libtool
37,38c37
< BuildRequires:  xz
< BuildRequires:  pkgconfig(libcurl)
---
> BuildRequires:  pkgconfig(libcrypto)
39a39,41
> BuildRequires:  pkgconfig(openssl)
> BuildRequires:  pkgconfig(libcurl)
> BuildRequires:  xz
56,57c58,59
< Summary:        TN3270 Access library
< Group:          Development/Libraries/C and C++
---
> Summary:    TN3270 Access library
> Group:      Development/Libraries/C and C++
65,67c67,69
< Summary:        TN3270 Access library development files
< Requires:       %{name}-%{_libvrs} = %{version}
< Group:          Development/Libraries/C and C++
---
> Summary:    TN3270 Access library development files
> Requires:   %{name}-%{_libvrs} = %{version}
> Group:      Development/Libraries/C and C++
75c77
< %configure --with-release=%{release} --disable-static
---
> %configure --with-release=%{release}
82,84c84
< mkdir -p %{buildroot}%{_libdir}/pw3270/%{MAJOR_VERSION}.%{MINOR_VERSION}/plugins
< 
< %find_lang %{name}-%{MAJOR_VERSION}.%{MINOR_VERSION} langfiles
---
> %find_lang %{name} langfiles
102,105d101
< 
< %{_libdir}/pw3270
< %{_libdir}/pw3270/%{MAJOR_VERSION}.%{MINOR_VERSION}
< %{_libdir}/pw3270/%{MAJOR_VERSION}.%{MINOR_VERSION}/plugins
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/rpm/_service lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/rpm/_service
8c8
< 		<param name="versionformat">5.4+git%cd</param>
---
> 		<param name="versionformat">@PARENT_TAG@+git%cd</param>
13c13,14
< 	<!-- service name="extract_file">
---
> 	
>     	<service name="extract_file">
16c17
< 	</service -->
---
> 	</service>
18c19
< 	<!-- service name="extract_file">
---
> 	<service name="extract_file">
21c22
< 	</service -->
---
> 	</service>
34c35
< 	<!-- service name="extract_file">
---
> 	<service name="extract_file">
38c39
< 	</service -->
---
> 	</service>
40c41
< 	<!-- service name="extract_file">
---
> 	<service name="extract_file">
44c45
< 	</service -->
---
> 	</service>
52c53
< 	<!-- service name="extract_file">
---
> 	<service name="extract_file">
56c57
< 	</service -->
---
> 	</service>
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/rpm: _servicedata
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270-delayed.pc.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270-delayed.pc.in
11,13d10
< default_host=@LIB3270_DEFAULT_HOST@
< product_id=@PRODUCT_ID@
< plugin_path=${libdir}/@PRODUCT_NAME@/@PACKAGE_MAJOR_VERSION@.@PACKAGE_MINOR_VERSION@/plugins
15c12
< Name: @PACKAGE_NAME@-delayed
---
> Name: @PACKAGE_NAME@
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270.pc.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270.pc.in
11,13d10
< default_host=@LIB3270_DEFAULT_HOST@
< product_id=@PRODUCT_ID@
< plugin_path=${libdir}/@PRODUCT_NAME@/@PACKAGE_MAJOR_VERSION@.@PACKAGE_MINOR_VERSION@/plugins
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270-static.pc.in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/sdk/lib3270-static.pc.in
11,13d10
< default_host=@LIB3270_DEFAULT_HOST@
< product_id=@PRODUCT_ID@
< plugin_path=${libdir}/@PRODUCT_ID@/@PACKAGE_MAJOR_VERSION@.@PACKAGE_MINOR_VERSION@/plugins
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/actions/actions.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/actions/actions.c
36c36,37
< struct lib3270_action_callback {
---
> struct lib3270_action_callback
> {
43c44,45
< const LIB3270_ACTION * lib3270_action_get_by_name(const char *name) {
---
> const LIB3270_ACTION * lib3270_action_get_by_name(const char *name)
> {
47c49,50
< 	for(f=0; actions[f].name; f++) {
---
> 	for(f=0; actions[f].name; f++)
> 	{
53c56,57
< 	for(f=0; actions[f].name; f++) {
---
> 	for(f=0; actions[f].name; f++)
> 	{
66c70,71
< LIB3270_EXPORT int lib3270_action_is_activatable(const LIB3270_ACTION *action, H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_action_is_activatable(const LIB3270_ACTION *action, H3270 *hSession)
> {
70c75,76
< LIB3270_EXPORT int lib3270_action_activate(const LIB3270_ACTION *action, H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_action_activate(const LIB3270_ACTION *action, H3270 *hSession)
> {
72c78,79
< 	if(!action->activatable(hSession)) {
---
> 	if(!action->activatable(hSession))
> 	{
83c90,91
< LIB3270_EXPORT int lib3270_activate_by_name(H3270 *hSession, const char *name) {
---
> LIB3270_EXPORT int lib3270_activate_by_name(H3270 *hSession, const char *name)
> {
92c100,101
< LIB3270_EXPORT int lib3270_action(H3270 *hSession, const char *name) {
---
> LIB3270_EXPORT int lib3270_action(H3270 *hSession, const char *name)
> {
96c105,106
< LIB3270_EXPORT void lib3270_action_group_notify(H3270 *hSession, LIB3270_ACTION_GROUP group) {
---
> LIB3270_EXPORT void lib3270_action_group_notify(H3270 *hSession, LIB3270_ACTION_GROUP group)
> {
98c108,109
< 	if(group < (sizeof(hSession->listeners.actions)/sizeof(hSession->listeners.actions[0]))) {
---
> 	if(group < (sizeof(hSession->listeners.actions)/sizeof(hSession->listeners.actions[0])))
> 	{
101c112,113
< 		for(node = hSession->listeners.actions[group].first; node; node = node->next) {
---
> 		for(node = hSession->listeners.actions[group].first; node; node = node->next)
> 		{
109c121,122
< LIB3270_EXPORT const void * lib3270_register_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, void (*func)(H3270 *, void *),void *data) {
---
> LIB3270_EXPORT const void * lib3270_register_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, void (*func)(H3270 *, void *),void *data)
> {
111c124,125
< 	if(group < (sizeof(hSession->listeners.actions)/sizeof(hSession->listeners.actions[0]))) {
---
> 	if(group < (sizeof(hSession->listeners.actions)/sizeof(hSession->listeners.actions[0])))
> 	{
120c134,135
< LIB3270_EXPORT int lib3270_unregister_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, const void *id) {
---
> LIB3270_EXPORT int lib3270_unregister_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, const void *id)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/actions/table.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/actions/table.c
44,94c44,107
< static int paste_file(H3270 *hSession) {
< 	return lib3270_load(hSession,NULL);
< }
< 
< static int connect_host(H3270 *hSession) {
< 	return hSession->cbk.reconnect(hSession,0);
< }
< 
< static int select_up(H3270 *hSession) {
< 	return lib3270_move_cursor(hSession,LIB3270_DIR_UP,1);
< }
< 
< static int select_down(H3270 *hSession) {
< 	return lib3270_move_cursor(hSession,LIB3270_DIR_DOWN,1);
< }
< 
< static int select_left(H3270 *hSession) {
< 	return lib3270_move_cursor(hSession,LIB3270_DIR_LEFT,1);
< }
< 
< static int select_right(H3270 *hSession) {
< 	return lib3270_move_cursor(hSession,LIB3270_DIR_RIGHT,1);
< }
< 
< static int selection_up(H3270 *hSession) {
< 	return lib3270_move_selection(hSession,LIB3270_DIR_UP);
< }
< 
< static int selection_down(H3270 *hSession) {
< 	return lib3270_move_selection(hSession,LIB3270_DIR_DOWN);
< }
< 
< static int selection_left(H3270 *hSession) {
< 	return lib3270_move_selection(hSession,LIB3270_DIR_LEFT);
< }
< 
< static int selection_right(H3270 *hSession) {
< 	return lib3270_move_selection(hSession,LIB3270_DIR_RIGHT);
< }
< 
< static int pa1(H3270 *hSession) {
< 	return lib3270_pakey(hSession,1);
< }
< 
< static int pa2(H3270 *hSession) {
< 	return lib3270_pakey(hSession,2);
< }
< 
< static int pa3(H3270 *hSession) {
< 	return lib3270_pakey(hSession,3);
< }
---
>  static int paste_file(H3270 *hSession)
>  {
>  	return lib3270_load(hSession,NULL);
>  }
> 
>  static int connect_host(H3270 *hSession)
>  {
> 	return lib3270_reconnect(hSession,0);
>  }
> 
>  static int select_up(H3270 *hSession)
>  {
>  	return lib3270_move_cursor(hSession,LIB3270_DIR_UP,1);
>  }
> 
>  static int select_down(H3270 *hSession)
>  {
>  	return lib3270_move_cursor(hSession,LIB3270_DIR_DOWN,1);
>  }
> 
>  static int select_left(H3270 *hSession)
>  {
>  	return lib3270_move_cursor(hSession,LIB3270_DIR_LEFT,1);
>  }
> 
>  static int select_right(H3270 *hSession)
>  {
>  	return lib3270_move_cursor(hSession,LIB3270_DIR_RIGHT,1);
>  }
> 
>  static int selection_up(H3270 *hSession)
>  {
>  	return lib3270_move_selection(hSession,LIB3270_DIR_UP);
>  }
> 
>  static int selection_down(H3270 *hSession)
>  {
>  	return lib3270_move_selection(hSession,LIB3270_DIR_DOWN);
>  }
> 
>  static int selection_left(H3270 *hSession)
>  {
>  	return lib3270_move_selection(hSession,LIB3270_DIR_LEFT);
>  }
> 
>  static int selection_right(H3270 *hSession)
>  {
>  	return lib3270_move_selection(hSession,LIB3270_DIR_RIGHT);
>  }
> 
>  static int pa1(H3270 *hSession)
>  {
>  	return lib3270_pakey(hSession,1);
>  }
> 
>  static int pa2(H3270 *hSession)
>  {
>  	return lib3270_pakey(hSession,1);
>  }
> 
>  static int pa3(H3270 *hSession)
>  {
>  	return lib3270_pakey(hSession,1);
>  }
100c113,114
< const LIB3270_ACTION * lib3270_get_actions() {
---
>  const LIB3270_ACTION * lib3270_get_actions()
>  {
102c116,117
< 	static const LIB3270_ACTION actions[] = {
---
> 	static const LIB3270_ACTION actions[] =
> 	{
111,112c126,127
< 			.icon = "connect",
< 			.label = N_( "_Reconnect" ),
---
> 			.icon = "gtk-connect",
> 			.label = N_( "_Reconnect" ) ,
125c140
< 			.icon = "disconnect",
---
> 			.icon = "gtk-disconnect",
530c545
< 			.keys = "",
---
> 			.keys = NULL,
586c601
< 			.keys = "<Alt>F1",
---
> 			.keys = NULL,
604c619
< 			.icon = "ok",
---
> 			.icon = "gtk-ok",
790c805
< 		{
---
> 			{
824c839
< }
---
>  }
826,828c841,844
< static int default_activatable_state(const H3270 *hSession) {
< 	return hSession == NULL ? 0 : 1;
< }
---
>  static int default_activatable_state(const H3270 *hSession)
>  {
>  	return hSession == NULL ? 0 : 1;
>  }
830c846
< LIB3270_EXPORT int lib3270_action_group_get_activatable(const H3270 *hSession, const LIB3270_ACTION_GROUP group) {
---
>  LIB3270_EXPORT int lib3270_action_group_get_activatable(const H3270 *hSession, const LIB3270_ACTION_GROUP group) {
836,842c852,858
< 		{ lib3270_is_connected			},	// LIB3270_ACTION_GROUP_ONLINE
< 		{ lib3270_is_disconnected		},	// LIB3270_ACTION_GROUP_OFFLINE
< 		{ lib3270_get_has_selection		},	// LIB3270_ACTION_GROUP_SELECTION
< 		{ lib3270_is_unlocked			},	// LIB3270_ACTION_GROUP_LOCK_STATE
< 		{ lib3270_is_formatted			},	// LIB3270_ACTION_GROUP_FORMATTED
< 		{ lib3270_get_has_copy			},	// LIB3270_ACTION_GROUP_COPY
< 	};
---
>  		{ lib3270_is_connected			},	// LIB3270_ACTION_GROUP_ONLINE
>  		{ lib3270_is_disconnected		},	// LIB3270_ACTION_GROUP_OFFLINE
>  		{ lib3270_get_has_selection		},	// LIB3270_ACTION_GROUP_SELECTION
>  		{ lib3270_is_unlocked			},	// LIB3270_ACTION_GROUP_LOCK_STATE
>  		{ lib3270_is_formatted			},	// LIB3270_ACTION_GROUP_FORMATTED
>  		{ lib3270_get_has_copy			},	// LIB3270_ACTION_GROUP_COPY
>  	};
844c860
< 	if(group < (sizeof(activatable)/sizeof(activatable[0]))) {
---
>  	if(group < (sizeof(activatable)/sizeof(activatable[0]))) {
846c862
< 	}
---
>  	}
848c864
< 	return default_activatable_state(hSession);
---
>  	return default_activatable_state(hSession);
850c866
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ansi.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ansi.c
40c40
< #pragma GCC diagnostic ignored "-Wstringop-truncation"
---
> 	#pragma GCC diagnostic ignored "-Wstringop-truncation"
62c62
< //#include "utf8c.h"
---
> #include "utf8c.h"
193,248c193,248
< 	/* 0 */		&ansi_data_mode,
< 	/* 1 */		&dec_save_cursor,
< 	/* 2 */		&dec_restore_cursor,
< 	/* 3 */		&ansi_newline,
< 	/* 4 */		&ansi_cursor_up,
< 	/* 5 */		&ansi_esc2,
< 	/* 6 */		&ansi_reset,
< 	/* 7 */		&ansi_insert_chars,
< 	/* 8 */		&ansi_cursor_down,
< 	/* 9 */		&ansi_cursor_right,
< 	/* 10 */	&ansi_cursor_left,
< 	/* 11 */	&ansi_cursor_motion,
< 	/* 12 */	&ansi_erase_in_display,
< 	/* 13 */	&ansi_erase_in_line,
< 	/* 14 */	&ansi_insert_lines,
< 	/* 15 */	&ansi_delete_lines,
< 	/* 16 */	&ansi_delete_chars,
< 	/* 17 */	&ansi_sgr,
< 	/* 18 */	&ansi_bell,
< 	/* 19 */	&ansi_newpage,
< 	/* 20 */	&ansi_backspace,
< 	/* 21 */	&ansi_cr,
< 	/* 22 */	&ansi_lf,
< 	/* 23 */	&ansi_htab,
< 	/* 24 */	&ansi_escape,
< 	/* 25 */	&ansi_nop,
< 	/* 26 */	&ansi_printing,
< 	/* 27 */	&ansi_semicolon,
< 	/* 28 */	&ansi_digit,
< 	/* 29 */	&ansi_reverse_index,
< 	/* 30 */	&ansi_send_attributes,
< 	/* 31 */	&ansi_set_mode,
< 	/* 32 */	&ansi_reset_mode,
< 	/* 33 */	&dec_return_terminal_id,
< 	/* 34 */	&ansi_status_report,
< 	/* 35 */	&ansi_cs_designate,
< 	/* 36 */	&ansi_esc3,
< 	/* 37 */	&dec_set,
< 	/* 38 */	&dec_reset,
< 	/* 39 */	&dec_save,
< 	/* 40 */	&dec_restore,
< 	/* 41 */	&dec_scrolling_region,
< 	/* 42 */	&xterm_text_mode,
< 	/* 43 */	&xterm_text_semicolon,
< 	/* 44 */	&xterm_text,
< 	/* 45 */	&xterm_text_do,
< 	/* 46 */	&ansi_htab_set,
< 	/* 47 */	&ansi_htab_clear,
< 	/* 48 */	&ansi_cs_designate2,
< 	/* 49 */	&ansi_select_g0,
< 	/* 50 */	&ansi_select_g1,
< 	/* 51 */	&ansi_select_g2,
< 	/* 52 */	&ansi_select_g3,
< 	/* 53 */	&ansi_one_g2,
< 	/* 54 */	&ansi_one_g3,
< 	/* 55 */	&ansi_multibyte,
---
> /* 0 */		&ansi_data_mode,
> /* 1 */		&dec_save_cursor,
> /* 2 */		&dec_restore_cursor,
> /* 3 */		&ansi_newline,
> /* 4 */		&ansi_cursor_up,
> /* 5 */		&ansi_esc2,
> /* 6 */		&ansi_reset,
> /* 7 */		&ansi_insert_chars,
> /* 8 */		&ansi_cursor_down,
> /* 9 */		&ansi_cursor_right,
> /* 10 */	&ansi_cursor_left,
> /* 11 */	&ansi_cursor_motion,
> /* 12 */	&ansi_erase_in_display,
> /* 13 */	&ansi_erase_in_line,
> /* 14 */	&ansi_insert_lines,
> /* 15 */	&ansi_delete_lines,
> /* 16 */	&ansi_delete_chars,
> /* 17 */	&ansi_sgr,
> /* 18 */	&ansi_bell,
> /* 19 */	&ansi_newpage,
> /* 20 */	&ansi_backspace,
> /* 21 */	&ansi_cr,
> /* 22 */	&ansi_lf,
> /* 23 */	&ansi_htab,
> /* 24 */	&ansi_escape,
> /* 25 */	&ansi_nop,
> /* 26 */	&ansi_printing,
> /* 27 */	&ansi_semicolon,
> /* 28 */	&ansi_digit,
> /* 29 */	&ansi_reverse_index,
> /* 30 */	&ansi_send_attributes,
> /* 31 */	&ansi_set_mode,
> /* 32 */	&ansi_reset_mode,
> /* 33 */	&dec_return_terminal_id,
> /* 34 */	&ansi_status_report,
> /* 35 */	&ansi_cs_designate,
> /* 36 */	&ansi_esc3,
> /* 37 */	&dec_set,
> /* 38 */	&dec_reset,
> /* 39 */	&dec_save,
> /* 40 */	&dec_restore,
> /* 41 */	&dec_scrolling_region,
> /* 42 */	&xterm_text_mode,
> /* 43 */	&xterm_text_semicolon,
> /* 44 */	&xterm_text,
> /* 45 */	&xterm_text_do,
> /* 46 */	&ansi_htab_set,
> /* 47 */	&ansi_htab_clear,
> /* 48 */	&ansi_cs_designate2,
> /* 49 */	&ansi_select_g0,
> /* 50 */	&ansi_select_g1,
> /* 51 */	&ansi_select_g2,
> /* 52 */	&ansi_select_g3,
> /* 53 */	&ansi_one_g2,
> /* 54 */	&ansi_one_g3,
> /* 55 */	&ansi_multibyte,
252,273c252,273
< 	/*
< 	 * State table for base processing (state == DATA)
< 	 */
< 	{
< 		/* 				0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,BL,BS,HT,LF,LF,NP,CR,G1,G0,
< 		/* 10 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,E1,Xx,Xx,Xx,Xx,
< 		/* 20 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* 30 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* 40 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* 50 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* 60 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* 70 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Xx,
< 		/* 80 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,
< 		/* 90 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,
< 		/* a0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* b0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* c0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* d0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* e0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
< 		/* f0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc
< 	},
---
> /*
>  * State table for base processing (state == DATA)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,BL,BS,HT,LF,LF,NP,CR,G1,G0,
> /* 10 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,E1,Xx,Xx,Xx,Xx,
> /* 20 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* 30 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* 40 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* 50 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* 60 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* 70 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Xx,
> /* 80 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,
> /* 90 */       Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,Xx,
> /* a0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* b0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* c0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* d0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* e0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,
> /* f0 */       Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc,Pc
> },
275,296c275,296
< 	/*
< 	 * State table for ESC processing (state == ESC)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */	0, 0, 0, 0, 0, 0, 0, 0,CS,CS,CS,CS, 0, 0, 0, 0,
< 		/* 30 */	0, 0, 0, 0, 0, 0, 0,SC,RC, 0, 0, 0, 0, 0, 0, 0,
< 		/* 40 */	0, 0, 0, 0, 0,NL, 0, 0,TS, 0, 0, 0, 0,RI,S2,S3,
< 		/* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,E2, 0,TM, 0, 0,
< 		/* 60 */	0, 0, 0,rS, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,G2,G3,
< 		/* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
< 	},
---
> /*
>  * State table for ESC processing (state == ESC)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */	0, 0, 0, 0, 0, 0, 0, 0,CS,CS,CS,CS, 0, 0, 0, 0,
> /* 30 */	0, 0, 0, 0, 0, 0, 0,SC,RC, 0, 0, 0, 0, 0, 0, 0,
> /* 40 */	0, 0, 0, 0, 0,NL, 0, 0,TS, 0, 0, 0, 0,RI,S2,S3,
> /* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,E2, 0,TM, 0, 0,
> /* 60 */	0, 0, 0,rS, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,G2,G3,
> /* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
> },
298,319c298,319
< 	/*
< 	 * State table for ESC ()*+ C processing (state == CSDES)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 30 */       C2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 40 */	0,C2,C2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 60 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
< 	},
---
> /*
>  * State table for ESC ()*+ C processing (state == CSDES)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 30 */       C2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 40 */	0,C2,C2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 60 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
> },
321,342c321,342
< 	/*
< 	 * State table for ESC [ processing (state == N1)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0,Sc, 0, 0, 0,E3,
< 		/* 40 */       IC,UP,DN,RT,LT, 0, 0, 0,CM, 0,ED,EL,IL,DL, 0, 0,
< 		/* 50 */       DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 60 */	0, 0, 0,DA, 0, 0,CM,TC,SM, 0, 0, 0,RM,SG,SR, 0,
< 		/* 70 */	0, 0,SS, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
< 	},
---
> /*
>  * State table for ESC [ processing (state == N1)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0,Sc, 0, 0, 0,E3,
> /* 40 */       IC,UP,DN,RT,LT, 0, 0, 0,CM, 0,ED,EL,IL,DL, 0, 0,
> /* 50 */       DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 60 */	0, 0, 0,DA, 0, 0,CM,TC,SM, 0, 0, 0,RM,SG,SR, 0,
> /* 70 */	0, 0,SS, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
> },
344,365c344,365
< 	/*
< 	 * State table for ESC [ ? processing (state == DECP)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0, 0, 0, 0, 0, 0,
< 		/* 40 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 60 */	0, 0, 0, 0, 0, 0, 0, 0,DS, 0, 0, 0,DR, 0, 0, 0,
< 		/* 70 */	0, 0,DT,DV, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
< 	},
---
> /*
>  * State table for ESC [ ? processing (state == DECP)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0, 0, 0, 0, 0, 0,
> /* 40 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 60 */	0, 0, 0, 0, 0, 0, 0, 0,DS, 0, 0, 0,DR, 0, 0, 0,
> /* 70 */	0, 0,DT,DV, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
> },
367,388c367,388
< 	/*
< 	 * State table for ESC ] processing (state == TEXT)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0,T2, 0, 0, 0, 0,
< 		/* 40 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 60 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
< 	},
---
> /*
>  * State table for ESC ] processing (state == TEXT)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 30 */       Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg,Dg, 0,T2, 0, 0, 0, 0,
> /* 40 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 50 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 60 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 70 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 80 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 90 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* a0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* b0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* c0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* d0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* e0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* f0 */	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
> },
390,433c390,433
< 	/*
< 	 * State table for ESC ] n ; processing (state == TEXT2)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */        0, 0, 0, 0, 0, 0, 0,TB, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 10 */        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
< 		/* 20 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 30 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 40 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 50 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 60 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 70 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,Xx,
< 		/* 80 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* 90 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* a0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* b0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* c0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* d0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* e0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
< 		/* f0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX
< 	},
< 	/*
< 	 * State table for multi-byte characters (state == MBPEND)
< 	 */
< 	{
< 		/* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
< 		/* 00 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 10 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 20 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 30 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 40 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 50 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 60 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 70 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 80 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* 90 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* a0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* b0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* c0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* d0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* e0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
< 		/* f0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB
< 	},
---
> /*
>  * State table for ESC ] n ; processing (state == TEXT2)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */        0, 0, 0, 0, 0, 0, 0,TB, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 10 */        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
> /* 20 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 30 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 40 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 50 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 60 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 70 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,Xx,
> /* 80 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* 90 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* a0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* b0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* c0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* d0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* e0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,
> /* f0 */       TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX,TX
> },
> /*
>  * State table for multi-byte characters (state == MBPEND)
>  */
> {
> 	     /* 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f  */
> /* 00 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 10 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 20 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 30 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 40 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 50 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 60 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 70 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 80 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* 90 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* a0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* b0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* c0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* d0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* e0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,
> /* f0 */       MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB,MB
> },
497c497,498
< ansi_data_mode(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_data_mode(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
502c503,504
< dec_save_cursor(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> dec_save_cursor(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
515c517,518
< static enum lib3270_ansi_state dec_restore_cursor(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state dec_restore_cursor(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
529c532,533
< static enum lib3270_ansi_state ansi_newline(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_newline(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
545c549,550
< ansi_cursor_up(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_cursor_up(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
560c565,566
< ansi_esc2(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_esc2(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
569c575,576
< static enum lib3270_ansi_state ansi_reset(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_reset(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
582c589
< 	for(i=0; i<4; i++)
---
> 	for(i=0;i<4;i++)
610c617,618
< 	if (!hSession->ansi_reset) {
---
> 	if (!hSession->ansi_reset)
> 	{
622c630,632
< static enum lib3270_ansi_state ansi_insert_chars(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state
> ansi_insert_chars(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
642c652,654
< static enum lib3270_ansi_state ansi_cursor_down(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state
> ansi_cursor_down(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
656c668,669
< static enum lib3270_ansi_state ansi_cursor_right(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_cursor_right(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
671c684,686
< static enum lib3270_ansi_state ansi_cursor_left(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state
> ansi_cursor_left(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
674c689,690
< 	if (hSession->held_wrap) {
---
> 	if (hSession->held_wrap)
> 	{
690c706,707
< ansi_cursor_motion(H3270 *hSession, int n1, int n2) {
---
> ansi_cursor_motion(H3270 *hSession, int n1, int n2)
> {
701c718,719
< ansi_erase_in_display(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_erase_in_display(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
703,704c721,722
< 	case 0:	/* below */
< 				ctlr_aclear(hSession, hSession->cursor_addr, (hSession->view.rows * hSession->view.cols) - hSession->cursor_addr, 1);
---
> 	    case 0:	/* below */
> 		ctlr_aclear(hSession, hSession->cursor_addr, (hSession->view.rows * hSession->view.cols) - hSession->cursor_addr, 1);
706c724
< 	case 1:	/* above */
---
> 	    case 1:	/* above */
709c727
< 	case 2:	/* all (without moving cursor) */
---
> 	    case 2:	/* all (without moving cursor) */
718c736,737
< ansi_erase_in_line(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_erase_in_line(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
722c741
< 	case 0:	/* to right */
---
> 	    case 0:	/* to right */
725c744
< 	case 1:	/* to left */
---
> 	    case 1:	/* to left */
728c747
< 	case 2:	/* all */
---
> 	    case 2:	/* all */
736c755,756
< ansi_insert_lines(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_insert_lines(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
761c781,782
< ansi_delete_lines(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_delete_lines(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
786c807,808
< ansi_delete_chars(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_delete_chars(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
807c829,830
< ansi_sgr(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_sgr(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
811c834
< 		switch (n[i]) {
---
> 	    switch (n[i]) {
813,816c836,839
< 			hSession->gr = 0;
< 			hSession->fg = 0;
< 			hSession->bg = 0;
< 			break;
---
> 		    hSession->gr = 0;
> 		    hSession->fg = 0;
> 		    hSession->bg = 0;
> 		    break;
818,819c841,842
< 			hSession->gr |= GR_INTENSIFY;
< 			break;
---
> 		    hSession->gr |= GR_INTENSIFY;
> 		    break;
821,822c844,845
< 			hSession->gr |= GR_UNDERLINE;
< 			break;
---
> 		    hSession->gr |= GR_UNDERLINE;
> 		    break;
824,825c847,848
< 			hSession->gr |= GR_BLINK;
< 			break;
---
> 		    hSession->gr |= GR_BLINK;
> 		    break;
827,828c850,851
< 			hSession->gr |= GR_REVERSE;
< 			break;
---
> 		    hSession->gr |= GR_REVERSE;
> 		    break;
830,831c853,854
< 			hSession->fg = 0xf0;	/* black */
< 			break;
---
> 		    hSession->fg = 0xf0;	/* black */
> 		    break;
833,834c856,857
< 			hSession->fg = 0xf2;	/* red */
< 			break;
---
> 		    hSession->fg = 0xf2;	/* red */
> 		    break;
836,837c859,860
< 			hSession->fg = 0xf4;	/* green */
< 			break;
---
> 		    hSession->fg = 0xf4;	/* green */
> 		    break;
839,840c862,863
< 			hSession->fg = 0xf6;	/* yellow */
< 			break;
---
> 		    hSession->fg = 0xf6;	/* yellow */
> 		    break;
842,843c865,866
< 			hSession->fg = 0xf1;	/* blue */
< 			break;
---
> 		    hSession->fg = 0xf1;	/* blue */
> 		    break;
845,846c868,869
< 			hSession->fg = 0xf3;	/* magenta */
< 			break;
---
> 		    hSession->fg = 0xf3;	/* magenta */
> 		    break;
849c872
< 			hSession->fg = 0xf6;	/* turquoise */
---
> 		    hSession->fg = 0xf6;	/* turquoise */
851c874
< 			hSession->fg = 0xfd;	/* cyan */
---
> 		    hSession->fg = 0xfd;	/* cyan */
853c876
< 			break;
---
> 		    break;
856c879
< 			hSession->fg = 0xf7;	/* white */
---
> 		    hSession->fg = 0xf7;	/* white */
858c881
< 			hSession->fg = 0xff;	/* white */
---
> 		    hSession->fg = 0xff;	/* white */
860c883
< 			break;
---
> 		    break;
862,863c885,886
< 			hSession->fg = 0;	/* default */
< 			break;
---
> 		    hSession->fg = 0;	/* default */
> 		    break;
865,866c888,889
< 			hSession->bg = 0xf0;	/* black */
< 			break;
---
> 		    hSession->bg = 0xf0;	/* black */
> 		    break;
868,869c891,892
< 			hSession->bg = 0xf2;	/* red */
< 			break;
---
> 		    hSession->bg = 0xf2;	/* red */
> 		    break;
871,872c894,895
< 			hSession->bg = 0xf4;	/* green */
< 			break;
---
> 		    hSession->bg = 0xf4;	/* green */
> 		    break;
874,875c897,898
< 			hSession->bg = 0xf6;	/* yellow */
< 			break;
---
> 		    hSession->bg = 0xf6;	/* yellow */
> 		    break;
877,878c900,901
< 			hSession->bg = 0xf1;	/* blue */
< 			break;
---
> 		    hSession->bg = 0xf1;	/* blue */
> 		    break;
880,881c903,904
< 			hSession->bg = 0xf3;	/* magenta */
< 			break;
---
> 		    hSession->bg = 0xf3;	/* magenta */
> 		    break;
884c907
< 			hSession->bg = 0xf6;	/* turquoise */
---
> 		    hSession->bg = 0xf6;	/* turquoise */
886c909
< 			hSession->bg = 0xfd;	/* cyan */
---
> 		    hSession->bg = 0xfd;	/* cyan */
888c911
< 			break;
---
> 		    break;
891c914
< 			hSession->bg = 0xf7;	/* white */
---
> 		    hSession->bg = 0xf7;	/* white */
893c916
< 			hSession->bg = 0xff;	/* white */
---
> 		    hSession->bg = 0xff;	/* white */
895c918
< 			break;
---
> 		    break;
897,899c920,922
< 			hSession->bg = 0;	/* default */
< 			break;
< 		}
---
> 		    hSession->bg = 0;	/* default */
> 		    break;
> 	    }
905c928,929
< ansi_bell(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_bell(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
910c934,935
< static enum lib3270_ansi_state ansi_newpage(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_newpage(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
915,916c940,943
< static enum lib3270_ansi_state ansi_backspace(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
< 	if (hSession->held_wrap) {
---
> static enum lib3270_ansi_state ansi_backspace(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
> 	if (hSession->held_wrap)
> 	{
921c948,949
< 	if (hSession->rev_wraparound_mode) {
---
> 	if (hSession->rev_wraparound_mode)
> 	{
924c952,954
< 	} else {
---
> 	}
> 	else
> 	{
931c961,962
< static enum lib3270_ansi_state ansi_cr(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_cr(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
942c973,974
< static enum lib3270_ansi_state ansi_lf(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_lf(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
948c980,981
< 	if((hSession->cursor_addr / hSession->view.cols) >= hSession->scroll_bottom) {
---
> 	if((hSession->cursor_addr / hSession->view.cols) >= hSession->scroll_bottom)
> 	{
961c994,995
< static enum lib3270_ansi_state ansi_htab(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_htab(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
975c1009,1010
< static enum lib3270_ansi_state ansi_escape(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_escape(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
979c1014,1015
< static enum lib3270_ansi_state ansi_nop(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_nop(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
998c1034,1035
< ansi_printing(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_printing(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1007,1034c1044,1070
< 	/*
< 		if ((hSession->pmi == 0) && (hSession->ansi_ch & 0x80)) {
< 		    	char mbs[2];
< 			enum ulfail fail;
< 			unsigned char ch;
< 
< 			mbs[0] = (char)hSession->ansi_ch;
< 			mbs[1] = '\0';
< 
< 			ch = utf8_lookup(mbs, &fail, NULL);
< 			if (ch == 0) {
< 				switch (fail) {
< 				case ULFAIL_NOUTF8:
< 				    	// Leave it alone.
< 					break;
< 				case ULFAIL_INCOMPLETE:
< 					// Start munching multi-byte.
< 					hSession->pmi = 0;
< 					hSession->pending_mbs[hSession->pmi++] = (char)hSession->ansi_ch;
< 					return MBPEND;
< 				case ULFAIL_INVALID:
< 					// Invalid multi-byte -> '?'
< 					hSession->ansi_ch = '?';
< 					// XXX: If DBCS, we should let
< 					// ICU have a crack at it
< 					//
< 					break;
< 				}
---
> /*
> 	if ((hSession->pmi == 0) && (hSession->ansi_ch & 0x80)) {
> 	    	char mbs[2];
> 		enum ulfail fail;
> 		unsigned char ch;
> 
> 		mbs[0] = (char)hSession->ansi_ch;
> 		mbs[1] = '\0';
> 
> 		ch = utf8_lookup(mbs, &fail, NULL);
> 		if (ch == 0) {
> 			switch (fail) {
> 			case ULFAIL_NOUTF8:
> 			    	// Leave it alone.
> 				break;
> 			case ULFAIL_INCOMPLETE:
> 				// Start munching multi-byte.
> 				hSession->pmi = 0;
> 				hSession->pending_mbs[hSession->pmi++] = (char)hSession->ansi_ch;
> 				return MBPEND;
> 			case ULFAIL_INVALID:
> 				// Invalid multi-byte -> '?'
> 				hSession->ansi_ch = '?';
> 				// XXX: If DBCS, we should let
> 				// ICU have a crack at it
> 				//
> 				break;
1037c1073,1074
< 		*/
---
> 	}
> 	*/
1040c1077,1078
< 	if (hSession->held_wrap) {
---
> 	if (hSession->held_wrap)
> 	{
1048,1049c1086,1088
< 	switch(hSession->csd[(hSession->once_cset != -1) ? hSession->once_cset : hSession->cset]) {
< 	case CSD_LD:	/* line drawing "0" */
---
> 	switch(hSession->csd[(hSession->once_cset != -1) ? hSession->once_cset : hSession->cset])
> 	{
> 	    case CSD_LD:	/* line drawing "0" */
1055c1094
< 	case CSD_UK:	/* UK "A" */
---
> 	    case CSD_UK:	/* UK "A" */
1061c1100
< 	case CSD_US:	/* US "B" */
---
> 	    case CSD_US:	/* US "B" */
1072,1073c1111,1112
< 				default:
< 				case 0:
---
> 				    default:
> 				    case 0:
1076c1115
< 				case 1:
---
> 				    case 1:
1080c1119
< 				case 2:
---
> 				    case 2:
1118c1157
< 		        (d == DBCS_RIGHT || d == DBCS_RIGHT_WRAP)) {
---
> 		    (d == DBCS_RIGHT || d == DBCS_RIGHT_WRAP)) {
1174c1213,1214
< static enum lib3270_ansi_state ansi_multibyte(H3270 *hSession, int ig1, int ig2) {
---
> static enum lib3270_ansi_state ansi_multibyte(H3270 *hSession, int ig1, int ig2)
> {
1180c1220,1221
< 	if (hSession->pmi >= MB_MAX - 2) {
---
> 	if (hSession->pmi >= MB_MAX - 2)
> 	{
1203c1244
< 		hSession->pending_mbs[hSession->pmi++] = (char)hSession->ansi_ch;
---
>     	hSession->pending_mbs[hSession->pmi++] = (char)hSession->ansi_ch;
1223c1264,1265
< static enum lib3270_ansi_state ansi_semicolon(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_semicolon(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1230c1272,1273
< static enum lib3270_ansi_state ansi_digit(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_digit(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1235c1278,1279
< static enum lib3270_ansi_state ansi_reverse_index(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_reverse_index(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1268c1312,1313
< static enum lib3270_ansi_state ansi_send_attributes(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_send_attributes(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
1274c1319,1320
< static enum lib3270_ansi_state dec_return_terminal_id(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state dec_return_terminal_id(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1278,1279c1324,1327
< static enum lib3270_ansi_state ansi_set_mode(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
< 	switch (nn) {
---
> static enum lib3270_ansi_state ansi_set_mode(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
> 	switch (nn)
> 	{
1281c1329
< 				hSession->insert_mode = 1;
---
> 		hSession->insert_mode = 1;
1290,1291c1338,1341
< static enum lib3270_ansi_state ansi_reset_mode(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
< 	switch (nn) {
---
> static enum lib3270_ansi_state ansi_reset_mode(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
> 	switch (nn)
> 	{
1293c1343
< 				hSession->insert_mode = 0;
---
> 		hSession->insert_mode = 0;
1302c1352,1353
< static enum lib3270_ansi_state ansi_status_report(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_status_report(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
1305c1356,1357
< 	switch (nn) {
---
> 	switch (nn)
> 	{
1318c1370,1371
< static enum lib3270_ansi_state ansi_cs_designate(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_cs_designate(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1323c1376,1377
< static enum lib3270_ansi_state ansi_cs_designate2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_cs_designate2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1328c1382,1383
< static enum lib3270_ansi_state ansi_select_g0(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_select_g0(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1333c1388,1389
< static enum lib3270_ansi_state ansi_select_g1(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state ansi_select_g1(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1339c1395,1396
< ansi_select_g2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_select_g2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1345c1402,1403
< ansi_select_g3(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_select_g3(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1351c1409,1410
< ansi_one_g2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_one_g2(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1357c1416,1417
< ansi_one_g3(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_one_g3(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1363c1423,1424
< ansi_esc3(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_esc3(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1368c1429,1430
< dec_set(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> dec_set(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1372c1434,1435
< 		switch (n[i]) {
---
> 		switch (n[i])
> 		{
1380c1443,1444
< 			if(hSession->allow_wide_mode) {
---
> 			if(hSession->allow_wide_mode)
> 			{
1402c1466,1467
< dec_reset(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> dec_reset(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1406c1471,1472
< 		switch (n[i]) {
---
> 		switch (n[i])
> 		{
1411c1477,1478
< 			if (hSession->allow_wide_mode) {
---
> 			if (hSession->allow_wide_mode)
> 			{
1432c1499,1500
< static enum lib3270_ansi_state dec_save(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> static enum lib3270_ansi_state dec_save(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1436c1504,1505
< 		switch (n[i]) {
---
> 		switch (n[i])
> 		{
1460c1529,1530
< dec_restore(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> dec_restore(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1464c1534,1535
< 		switch (n[i]) {
---
> 		switch (n[i])
> 		{
1469c1540,1541
< 			if (hSession->allow_wide_mode) {
---
> 			if (hSession->allow_wide_mode)
> 			{
1491c1563,1564
< dec_scrolling_region(H3270 *hSession, int top, int bottom) {
---
> dec_scrolling_region(H3270 *hSession, int top, int bottom)
> {
1497c1570,1571
< 	if (top <= bottom && (top > 1 || bottom < hSession->view.rows)) {
---
> 	if (top <= bottom && (top > 1 || bottom < hSession->view.rows))
> 	{
1501c1575,1577
< 	} else {
---
> 	}
> 	else
> 	{
1509c1585,1586
< xterm_text_mode(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> xterm_text_mode(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1516c1593,1594
< xterm_text_semicolon(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> xterm_text_semicolon(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1522c1600,1601
< xterm_text(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> xterm_text(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1529,1553c1608,1633
< xterm_text_do(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
< 	/*
< 	#if defined(X3270_DISPLAY) || defined(WC3270)
< 		text[tx] = '\0';
< 	#endif
< 
< 	#if defined(X3270_DISPLAY)
< 		switch (n[0]) {
< 		    case 0:	// icon name and window title
< 			XtVaSetValues(toplevel, XtNiconName, text, NULL);
< 			XtVaSetValues(toplevel, XtNtitle, text, NULL);
< 			break;
< 		    case 1:	// icon name
< 			XtVaSetValues(toplevel, XtNiconName, text, NULL);
< 			break;
< 		    case 2:	// window_title
< 			XtVaSetValues(toplevel, XtNtitle, text, NULL);
< 			break;
< 		    case 50:	// font
< 			screen_newfont(text, False, False);
< 			break;
< 		    default:
< 			break;
< 		}
< 	#endif
---
> xterm_text_do(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
> /*
> #if defined(X3270_DISPLAY) || defined(WC3270)
> 	text[tx] = '\0';
> #endif
> 
> #if defined(X3270_DISPLAY)
> 	switch (n[0]) {
> 	    case 0:	// icon name and window title
> 		XtVaSetValues(toplevel, XtNiconName, text, NULL);
> 		XtVaSetValues(toplevel, XtNtitle, text, NULL);
> 		break;
> 	    case 1:	// icon name
> 		XtVaSetValues(toplevel, XtNiconName, text, NULL);
> 		break;
> 	    case 2:	// window_title
> 		XtVaSetValues(toplevel, XtNtitle, text, NULL);
> 		break;
> 	    case 50:	// font
> 		screen_newfont(text, False, False);
> 		break;
> 	    default:
> 		break;
> 	}
> #endif
1556,1566c1636,1646
< 	#if defined(WC3270)
< 		switch (n[0]) {
< 		    case 0:	// icon name and window title
< 		    case 2:	// window_title
< 			screen_title(text);
< 			break;
< 		    default:
< 			break;
< 		}
< 	#endif
< 	*/
---
> #if defined(WC3270)
> 	switch (n[0]) {
> 	    case 0:	// icon name and window title
> 	    case 2:	// window_title
> 		screen_title(text);
> 		break;
> 	    default:
> 		break;
> 	}
> #endif
> */
1572c1652,1653
< ansi_htab_set(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2)) {
---
> ansi_htab_set(H3270 *hSession, int GNUC_UNUSED(ig1), int GNUC_UNUSED(ig2))
> {
1580c1661,1662
< ansi_htab_clear(H3270 *hSession, int nn, int GNUC_UNUSED(ig2)) {
---
> ansi_htab_clear(H3270 *hSession, int nn, int GNUC_UNUSED(ig2))
> {
1583c1665,1666
< 	switch (nn) {
---
> 	switch (nn)
> 	{
1599c1682,1683
< static void ansi_scroll(H3270 *hSession) {
---
> static void ansi_scroll(H3270 *hSession)
> {
1603c1687,1688
< 	if (hSession->scroll_top == 1 && hSession->scroll_bottom == hSession->view.rows) {
---
> 	if (hSession->scroll_top == 1 && hSession->scroll_bottom == hSession->view.rows)
> 	{
1613,1615c1698,1700
< 		           (hSession->scroll_top - 1) * hSession->view.cols,
< 		           (hSession->scroll_bottom - hSession->scroll_top) * hSession->view.cols,
< 		           1);
---
> 		    (hSession->scroll_top - 1) * hSession->view.cols,
> 		    (hSession->scroll_bottom - hSession->scroll_top) * hSession->view.cols,
> 		    1);
1622c1707,1708
< void ansi_in3270(H3270 *session, int in3270, void GNUC_UNUSED(*dunno)) {
---
> void ansi_in3270(H3270 *session, int in3270, void GNUC_UNUSED(*dunno))
> {
1628c1714,1715
< static void trace_pending_mb(H3270 *hSession) {
---
> static void trace_pending_mb(H3270 *hSession)
> {
1631c1718,1719
< 	for (i = 0; i < mb_pending; i++) {
---
> 	for (i = 0; i < mb_pending; i++)
> 	{
1642c1730,1731
< ansi_process(H3270 *hSession, unsigned int c) {
---
> ansi_process(H3270 *hSession, unsigned int c)
> {
1658c1747,1748
< 	if (mb_pending && fn != &ansi_printing) {
---
> 	if (mb_pending && fn != &ansi_printing)
> 	{
1670c1760,1761
< ansi_send_up(H3270 *hSession) {
---
> ansi_send_up(H3270 *hSession)
> {
1678c1769,1770
< ansi_send_down(H3270 *hSession) {
---
> ansi_send_down(H3270 *hSession)
> {
1686c1778,1779
< ansi_send_right(H3270 *hSession) {
---
> ansi_send_right(H3270 *hSession)
> {
1694c1787,1788
< ansi_send_left(H3270 *hSession) {
---
> ansi_send_left(H3270 *hSession)
> {
1702c1796,1797
< ansi_send_home(H3270 *hSession) {
---
> ansi_send_home(H3270 *hSession)
> {
1707c1802,1803
< ansi_send_clear(H3270 *hSession) {
---
> ansi_send_clear(H3270 *hSession)
> {
1712c1808,1809
< ansi_send_pf(H3270 *hSession, int nn) {
---
> ansi_send_pf(H3270 *hSession, int nn)
> {
1732c1829
< 	(void) snprintf(fn_buf, sizeof(fn_buf), "\033[%d~", code[nn-1]);
---
> 	(void) sprintf(fn_buf, "\033[%d~", code[nn-1]);
1736c1833,1834
< void ansi_send_pa(H3270 *hSession, int nn) {
---
> void ansi_send_pa(H3270 *hSession, int nn)
> {
1746c1844,1845
< void toggle_lineWrap(H3270 *hSession, struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(type)) {
---
> void toggle_lineWrap(H3270 *hSession, struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(type))
> {
1755c1854,1855
< static int dbcs_process(H3270 *hSession, int ch, unsigned char ebc[]) {
---
> static int dbcs_process(H3270 *hSession, int ch, unsigned char ebc[])
> {
1773c1873
< 		return 0;
---
> 	    	return 0;
1787c1887
< 			         Ubuf[0] & 0xffff);
---
> 			    Ubuf[0] & 0xffff);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/array.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/array.c
35,38c35,38
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <array.h>
< #include <string.h>
---
>  #include <lib3270.h>
>  #include <lib3270/log.h>
>  #include <array.h>
>  #include <string.h>
42c42,43
< LIB3270_STRING_ARRAY * lib3270_string_array_new(void) {
---
> LIB3270_STRING_ARRAY * lib3270_string_array_new(void)
> {
49c50,51
< void lib3270_string_array_free(LIB3270_STRING_ARRAY *array) {
---
> void lib3270_string_array_free(LIB3270_STRING_ARRAY *array)
> {
52c54,55
< 	if(array) {
---
> 	if(array)
> 	{
61,62c64,67
< static void lib3270_string_array_realloc(LIB3270_STRING_ARRAY *array) {
< 	if(array->str) {
---
> static void lib3270_string_array_realloc(LIB3270_STRING_ARRAY *array)
> {
> 	if(array->str)
> 	{
64c69,71
< 	} else {
---
> 	}
> 	else
> 	{
71c78,79
< void lib3270_string_array_append(LIB3270_STRING_ARRAY *array, const char *str) {
---
> void lib3270_string_array_append(LIB3270_STRING_ARRAY *array, const char *str)
> {
76c84,85
< void lib3270_string_array_append_with_length(LIB3270_STRING_ARRAY *array, const char *str, size_t length) {
---
> void lib3270_string_array_append_with_length(LIB3270_STRING_ARRAY *array, const char *str, size_t length)
> {
86c95,96
< void lib3270_autoptr_cleanup_LIB3270_STRING_ARRAY(LIB3270_STRING_ARRAY **ptr) {
---
> void lib3270_autoptr_cleanup_LIB3270_STRING_ARRAY(LIB3270_STRING_ARRAY **ptr)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/bounds.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/bounds.c
48c48,49
< LIB3270_EXPORT int lib3270_get_field_bounds(H3270 *hSession, int baddr, int *start, int *end) {
---
> LIB3270_EXPORT int lib3270_get_field_bounds(H3270 *hSession, int baddr, int *start, int *end)
> {
61c62,63
< 	if(end) {
---
> 	if(end)
> 	{
71c73,74
< LIB3270_EXPORT int lib3270_get_word_bounds(H3270 *session, int baddr, int *start, int *end) {
---
> LIB3270_EXPORT int lib3270_get_word_bounds(H3270 *session, int baddr, int *start, int *end)
> {
86,87c89,91
< 	if(start) {
< 		for(pos = baddr; pos > 0 && !isspace(session->text[pos].chr); pos--);
---
> 	if(start)
> 	{
> 		for(pos = baddr; pos > 0 && !isspace(session->text[pos].chr);pos--);
92c96,97
< 	if(end) {
---
> 	if(end)
> 	{
94c99
< 		for(pos = baddr; pos < maxlen && !isspace(session->text[pos].chr); pos++);
---
> 		for(pos = baddr; pos < maxlen && !isspace(session->text[pos].chr);pos++);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/charset.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/charset.c
54c54,55
< const unsigned short ebc2asc0[256] = {
---
> const unsigned short ebc2asc0[256] =
> {
89c90,91
< static const unsigned short asc2ebc0[256] = {
---
> static const unsigned short asc2ebc0[256] =
> {
124c126,127
< static const unsigned short asc2uc[UT_SIZE] = {
---
> static const unsigned short asc2uc[UT_SIZE] =
> {
151c154,155
< typedef struct _info {
---
> typedef struct _info
> {
157c161,162
< static const remap charset[] = {
---
> static const remap charset[] =
> {
161c166,167
< 		(const unsigned short []) {
---
> 		(const unsigned short [])
> 		{
169c175,176
< 		(const unsigned short []) {
---
> 		(const unsigned short [])
> 		{
181c188,189
< 		(const unsigned short []) {
---
> 		(const unsigned short [])
> 		{
201c209,210
< static void copy_charset(const unsigned short *from, unsigned short *to) {
---
> static void copy_charset(const unsigned short *from, unsigned short *to)
> {
203c212
< 	for(f=0; f < UT_SIZE; f++)
---
> 	for(f=0;f < UT_SIZE;f++)
207c216,217
< LIB3270_EXPORT void lib3270_reset_charset(H3270 *hSession, const char * host, const char * display, unsigned long cgcsgid) {
---
> LIB3270_EXPORT void lib3270_reset_charset(H3270 *hSession, const char * host, const char * display, unsigned long cgcsgid)
> {
210c220
< #define replace_pointer(x,v) if(x) { lib3270_free(x); }; x = strdup(v)
---
> 	#define replace_pointer(x,v) if(x) { lib3270_free(x); }; x = strdup(v)
228c238
< 	for(f=0; f<UT_OFFSET; f++)
---
> 	for(f=0;f<UT_OFFSET;f++)
235c245,246
< LIB3270_EXPORT int lib3270_set_host_charset(H3270 *hSession, const char *name) {
---
> LIB3270_EXPORT int lib3270_set_host_charset(H3270 *hSession, const char *name)
> {
240c251,252
< 	if(name && hSession->charset.host && !strcasecmp(name,hSession->charset.host)) {
---
> 	if(name && hSession->charset.host && !strcasecmp(name,hSession->charset.host))
> 	{
245c257,258
< 	if(!name) {
---
> 	if(!name)
> 	{
250c263,264
< 	if(!name) {
---
> 	if(!name)
> 	{
255,256c269,272
< 	for(f=0; charset[f].name != NULL; f++) {
< 		if(!strcasecmp(name,charset[f].name)) {
---
> 	for(f=0;charset[f].name != NULL;f++)
> 	{
> 		if(!strcasecmp(name,charset[f].name))
> 		{
264c280
< 			for(c=0; charset[f].chr[c]; c+=2)
---
> 			for(c=0;charset[f].chr[c];c+=2)
277c293,294
< LIB3270_EXPORT const char * lib3270_get_host_charset(const H3270 *hSession) {
---
> LIB3270_EXPORT const char * lib3270_get_host_charset(const H3270 *hSession)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/convert.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/convert.c
45c45,46
< LIB3270_EXPORT const char * lib3270_asc2ebc(H3270 *hSession, unsigned char *buffer, int sz) {
---
> LIB3270_EXPORT const char * lib3270_asc2ebc(H3270 *hSession, unsigned char *buffer, int sz)
> {
50,51c51,53
< 	if(sz > 0) {
< 		for(f=0; f<sz; f++)
---
> 	if(sz > 0)
> 	{
> 		for(f=0;f<sz;f++)
58c60,61
< LIB3270_EXPORT const char * lib3270_ebc2asc(H3270 *hSession, unsigned char *buffer, int sz) {
---
> LIB3270_EXPORT const char * lib3270_ebc2asc(H3270 *hSession, unsigned char *buffer, int sz)
> {
63,64c66,68
< 	if(sz > 0) {
< 		for(f=0; f<sz; f++)
---
> 	if(sz > 0)
> 	{
> 		for(f=0;f<sz;f++)
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/getset.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/getset.c
46c46,47
< LIB3270_EXPORT const char * lib3270_get_default_charset(void) {
---
> LIB3270_EXPORT const char * lib3270_get_default_charset(void)
> {
50c51,52
< LIB3270_EXPORT const char * lib3270_get_display_charset(const H3270 *hSession) {
---
> LIB3270_EXPORT const char * lib3270_get_display_charset(const H3270 *hSession)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/iconv.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/iconv.c
43c43,44
< struct _lib3270_iconv {
---
> struct _lib3270_iconv
> {
53c54,55
< LIB3270_ICONV * lib3270_iconv_new(const char *remote, const char *local) {
---
>  LIB3270_ICONV * lib3270_iconv_new(const char *remote, const char *local)
>  {
71c73
< }
---
>  }
73c75,76
< void lib3270_iconv_free(LIB3270_ICONV *conv) {
---
>  void lib3270_iconv_free(LIB3270_ICONV *conv)
>  {
83c86
< }
---
>  }
85c88,89
< static char *convert(iconv_t *converter, const char * str, int length) {
---
>  static char *convert(iconv_t *converter, const char * str, int length)
>  {
89c93,94
< 	if(length && converter != (iconv_t)(-1)) {
---
> 	if(length && converter != (iconv_t)(-1))
> 	{
111c116
< }
---
>  }
113c118,119
< char * lib3270_iconv_from_host(LIB3270_ICONV *conv, const char *str, int len) {
---
>  char * lib3270_iconv_from_host(LIB3270_ICONV *conv, const char *str, int len)
>  {
115c121
< }
---
>  }
117c123,124
< char * lib3270_iconv_to_host(LIB3270_ICONV *conv, const char *str, int len) {
---
>  char * lib3270_iconv_to_host(LIB3270_ICONV *conv, const char *str, int len)
>  {
119c126
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/remap.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/remap.c
49c49,50
< LIB3270_EXPORT void lib3270_remap_char(H3270 *hSession, unsigned short ebc, unsigned short iso, lib3270_remap_scope scope, unsigned char one_way) {
---
> LIB3270_EXPORT void lib3270_remap_char(H3270 *hSession, unsigned short ebc, unsigned short iso, lib3270_remap_scope scope, unsigned char one_way)
> {
63,65c64,69
< 	if (iso <= 0xff) {
< 		if (scope == BOTH || scope == CS_ONLY) {
< 			if (ebc > 0x40) {
---
> 	if (iso <= 0xff)
> 	{
> 		if (scope == BOTH || scope == CS_ONLY)
> 		{
> 			if (ebc > 0x40)
> 			{
75c79,80
< LIB3270_EXPORT unsigned short lib3270_translate_char(const char *id) {
---
> LIB3270_EXPORT unsigned short lib3270_translate_char(const char *id)
> {
77c82,83
< 	static const struct {
---
> 	static const struct
> 	{
81c87,88
< 	latin[] = {
---
> 	latin[] =
> 	{
280c287
< #if !defined(_WIN32)
---
> 	#if !defined(_WIN32)
287c294
< #endif
---
> 	#endif
292c299
< 	if(strncasecmp(id,"0x",2) == 0) {
---
>  	if(strncasecmp(id,"0x",2) == 0) {
294c301
< 		unsigned int rc = 0;
---
>         unsigned int rc = 0;
296c303,304
< 		if(sscanf(id + 2, "%x", &rc) != 1) {
---
> 		if(sscanf(id + 2, "%x", &rc) != 1)
> 		{
303c311
< 	}
---
>  	}
305c313
< 	for(ix=0; ix < (sizeof(latin)/sizeof(latin[0])); ix++) {
---
>  	for(ix=0;ix < (sizeof(latin)/sizeof(latin[0])); ix++) {
308c316
< 	}
---
>  	}
310c318,319
< 	if(strlen(id) != 1) {
---
>  	if(strlen(id) != 1)
> 	{
315c324
< 	return (unsigned short) *id;
---
>  	return (unsigned short) *id;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/utf8.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/utf8.c
42c42
< //#include "utf8c.h"
---
> #include "utf8c.h"
55c55
< 	/* Real translations from 8-bit encodings to UTF-8. */
---
>     	/* Real translations from 8-bit encodings to UTF-8. */
353d352
< /*
356,357c355,356
< if (fail != NULL)
< 	*fail = ULFAIL_NOUTF8;
---
> 	if (fail != NULL)
> 		*fail = ULFAIL_NOUTF8;
359c358
< return 0;
---
> 	return 0;
361d359
< */
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/view.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/charset/view.c
45c45,46
< LIB3270_EXPORT int lib3270_charsettable(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_charsettable(H3270 *hSession)
> {
61,64c62,65
< 	    (char *) hSession->ea_buf,
< 	    0,
< 	    ((size_t) hSession->view.rows) * ((size_t) hSession->view.cols) * sizeof(struct lib3270_ea)
< 	);
---
> 				(char *) hSession->ea_buf,
> 				0,
> 				((size_t) hSession->view.rows) * ((size_t) hSession->view.cols) * sizeof(struct lib3270_ea)
> 			);
68c69,70
< 	for(f=4; f<=0x0f; f++) {
---
> 	for(f=4;f<=0x0f;f++)
> 	{
79c81,82
< 	for(f=0; f<=0x0f; f++) {
---
> 	for(f=0;f<=0x0f;f++)
> 	{
90c93,94
< 	for(f=0; f<0x0c; f++) {
---
> 	for(f=0;f<0x0c;f++)
> 	{
92c96,97
< 		for(r=0; r<=0x0f; r++) {
---
> 		for(r=0;r<=0x0f;r++)
> 		{
103c108,109
< 	for(ptr=label; *ptr; ptr++) {
---
> 	for(ptr=label;*ptr;ptr++)
> 	{
113c119,120
< 	for(ptr=hSession->charset.host; *ptr; ptr++) {
---
> 	for(ptr=hSession->charset.host;*ptr;ptr++)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/connect.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/connect.c
43c43,44
< LIB3270_EXPORT int lib3270_connect_url(H3270 *hSession, const char *url, int seconds) {
---
>  LIB3270_EXPORT int lib3270_connect_url(H3270 *hSession, const char *url, int seconds)
>  {
46c47,48
< 	if(url && *url) {
---
> 	if(url && *url)
> 	{
50c52
< 	return hSession->cbk.reconnect(hSession, seconds);
---
> 	return lib3270_reconnect(hSession, seconds);
52c54
< }
---
>  }
54c56,83
< int lib3270_allow_reconnect(const H3270 *hSession) {
---
> /*
>  void connection_failed(H3270 *hSession, const char *message)
>  {
> 	lib3270_disconnect(hSession);
> 
> 	lib3270_autoptr(char) summary = lib3270_strdup_printf(
> 										_( "Can't connect to %s:%s"),
> 										hSession->host.current,
> 										hSession->host.srvc
> 									);
> 
> 	LIB3270_POPUP popup = {
> 		.name = "CantConnect",
> //		.title = _( "Connection failed" ),
> 		.type = LIB3270_NOTIFY_INFO,
> 		.summary = summary,
> 		.body = message,
> 		.label = _("Try again")
> 	};
> 
> 	if(hSession->cbk.popup(hSession,&popup,!hSession->auto_reconnect_inprogress) == 0)
> 		lib3270_activate_auto_reconnect(hSession,1000);
> 
>  }
> */
> 
>  int lib3270_allow_reconnect(const H3270 *hSession)
>  {
59c88,89
< 	if(hSession->auto_reconnect_inprogress) {
---
> 	if(hSession->auto_reconnect_inprogress)
> 	{
65,66c95,97
< 	// Is the session disconnected?
< 	if(!lib3270_is_disconnected(hSession)) {
---
>  	// Is the session disconnected?
> 	if(!lib3270_is_disconnected(hSession))
> 	{
73,75c104,106
< 	if(!(hSession->host.current && hSession->host.srvc && *hSession->host.current && *hSession->host.srvc)) {
< 		debug("%s('%s')",__FUNCTION__,hSession->host.url);
< 		errno = ENODATA;
---
> 	if(!(hSession->host.current && hSession->host.srvc && *hSession->host.current && *hSession->host.srvc))
> 	{
> 		errno = EINVAL;
79c110,111
< 	if(hSession->network.module->is_connected(hSession)) {
---
> 	if(hSession->network.module->is_connected(hSession))
> 	{
85c117
< }
---
>  }
87,88c119,121
< int lib3270_reconnect(H3270 *hSession, int seconds) {
< 	debug("%s",__FUNCTION__);
---
>  int lib3270_reconnect(H3270 *hSession, int seconds)
>  {
>  	debug("%s",__FUNCTION__);
90c123,124
< 	if(!lib3270_allow_reconnect(hSession)) {
---
>  	if(!lib3270_allow_reconnect(hSession))
> 	{
100,105c134,139
< 	    hSession->full_model_name,
< 	    LIB3270_FULL_MODEL_NAME_LENGTH,
< 	    "IBM-327%c-%d%s",
< 	    hSession->m3279 ? '9' : '8',
< 	    hSession->model_num,
< 	    hSession->extended ? "-E" : ""
---
> 		hSession->full_model_name,
> 		LIB3270_FULL_MODEL_NAME_LENGTH,
> 		"IBM-327%c-%d%s",
> 			hSession->m3279 ? '9' : '8',
> 			hSession->model_num,
> 			hSession->extended ? "-E" : ""
114c148
< }
---
>  }
116c150
< void lib3270_notify_tls(H3270 *hSession) {
---
>  void lib3270_notify_tls(H3270 *hSession) {
134,138c168
< }
< 
< int lib3270_start_tls(H3270 *hSession) {
< 
< 	debug("%s",__FUNCTION__);
---
>  }
139a170,171
>  int lib3270_start_tls(H3270 *hSession)
>  {
145c177
< #pragma GCC diagnostic push
---
> 	#pragma GCC diagnostic push
147c179
< #pragma GCC diagnostic ignored "-Wcast-function-type"
---
> 	#pragma GCC diagnostic ignored "-Wcast-function-type"
150,154c182,186
< 	             hSession,
< 	             (int(*)(H3270 *h, void *)) hSession->network.module->start_tls,
< 	             NULL
< 	         );
< #pragma GCC diagnostic pop
---
> 			hSession,
> 			(int(*)(H3270 *h, void *)) hSession->network.module->start_tls,
> 			NULL
> 		);
> 	#pragma GCC diagnostic pop
195c227
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ctlr.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ctlr.c
48a49
> #include "resources.h"
66a68
> // Boolean			dbcs = False;
68c70
< // Statics
---
> /* Statics */
73a76
> //static void ticking_stop(H3270 *session);
80c83,84
< static const unsigned char code_table[64] = {
---
> static const unsigned char code_table[64] =
> {
91a96,97
> 
> 
114c120,121
< void ctlr_init(H3270 *session, unsigned GNUC_UNUSED(cmask)) {
---
> void ctlr_init(H3270 *session, unsigned GNUC_UNUSED(cmask))
> {
124c131,132
< void ctlr_model_changed(H3270 *session) {
---
> void ctlr_model_changed(H3270 *session)
> {
142,143c150,153
< void ctlr_set_rows_cols(H3270 *session, int mn, int ovc, int ovr) {
< 	static const struct _sz {
---
> void ctlr_set_rows_cols(H3270 *session, int mn, int ovc, int ovr)
> {
> 	static const struct _sz
> 	{
146c156,157
< 	} sz[] = {
---
> 	} sz[] =
> 	{
155c166,167
< 	if(idx < 0 || idx >= (sizeof(sz)/sizeof(struct _sz))) {
---
> 	if(idx < 0 || idx >= (sizeof(sz)/sizeof(struct _sz)))
> 	{
166,167c178,181
< 	if (ovc != 0 || ovr != 0) {
< 		if (ovc <= 0 || ovr <= 0) {
---
> 	if (ovc != 0 || ovr != 0)
> 	{
> 		if (ovc <= 0 || ovr <= 0)
> 		{
169,174c183,188
< 			    session,
< 			    LIB3270_NOTIFY_ERROR,
< 			    _( "Invalid oversize" ),
< 			    _( "The oversize values are invalid." ), \
< 			    _( "%dx%d is negative or zero" ),
< 			    ovc, ovr
---
> 					session,
> 					LIB3270_NOTIFY_ERROR,
> 					_( "Invalid oversize" ),
> 					_( "The oversize values are invalid." ), \
> 					_( "%dx%d is negative or zero" ),
> 					ovc, ovr
177c191,195
< 		} else if (ovc * ovr >= 0x4000) {
---
> 			// popup_an_error(session,"Invalid %s %dx%d:\nNegative or zero",ResOversize, ovc, ovr);
> 
> 		}
> 		else if (ovc * ovr >= 0x4000)
> 		{
179,184c197,202
< 			    session,
< 			    LIB3270_NOTIFY_ERROR,
< 			    _( "Invalid oversize" ),
< 			    _( "The oversize values are too big." ), \
< 			    _( "%dx%d screen size is bigger than the maximum size" ),
< 			    ovc, ovr
---
> 					session,
> 					LIB3270_NOTIFY_ERROR,
> 					_( "Invalid oversize" ),
> 					_( "The oversize values are too big." ), \
> 					_( "%dx%d screen size is bigger than the maximum size" ),
> 					ovc, ovr
187c205,209
< 		} else if (ovc < session->max.cols) {
---
> //			popup_an_error(session,"Invalid %s %dx%d:\nToo big",ResOversize, ovc, ovr);
> 
> 		}
> 		else if (ovc > 0 && ovc < session->max.cols)
> 		{
190,195c212,217
< 			    session,
< 			    LIB3270_NOTIFY_ERROR,
< 			    _( "Invalid oversize" ),
< 			    _( "The oversize width is too small." ), \
< 			    _( "The width %d is less than model %d columns (%d)" ),
< 			    ovc, session->model_num, session->max.cols
---
> 					session,
> 					LIB3270_NOTIFY_ERROR,
> 					_( "Invalid oversize" ),
> 					_( "The oversize width is too small." ), \
> 					_( "The width %d is less than model %d columns (%d)" ),
> 					ovc, session->model_num, session->max.cols
198c220,223
< 		} else if (ovr < session->max.rows) {
---
> //			popup_an_error(session,"Invalid %s cols (%d):\nLess than model %d cols (%d)",ResOversize, ovc, session->model_num, session->maxCOLS);
> 		}
> 		else if (ovr > 0 && ovr < session->max.rows)
> 		{
201,206c226,231
< 			    session,
< 			    LIB3270_NOTIFY_ERROR,
< 			    _( "Invalid oversize" ),
< 			    _( "The oversize height is too small." ), \
< 			    _( "The height %d is less than model %d rows (%d)" ),
< 			    ovr, session->model_num, session->max.rows
---
> 					session,
> 					LIB3270_NOTIFY_ERROR,
> 					_( "Invalid oversize" ),
> 					_( "The oversize height is too small." ), \
> 					_( "The height %d is less than model %d rows (%d)" ),
> 					ovr, session->model_num, session->max.rows
209c234
< 		} else {
---
> //			popup_an_error(session,"Invalid %s rows (%d):\nLess than model %d rows (%d)",ResOversize, ovr, session->model_num, session->maxROWS);
210a236,238
> 		}
> 		else
> 		{
212d239
< 
220,221c247,250
< static void set_formatted(H3270 *hSession, int state) {
< 	if(state != hSession->formatted) {
---
> static void set_formatted(H3270 *hSession, int state)
> {
> 	if(state != hSession->formatted)
> 	{
234c263,264
< static void update_formatted(H3270 *hSession) {
---
> static void update_formatted(H3270 *hSession)
> {
240,241c270,273
< 	do {
< 		if(hSession->ea_buf[baddr].fa) {
---
> 	do
> 	{
> 		if(hSession->ea_buf[baddr].fa)
> 		{
255c287,288
< static void ctlr_half_connect(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno)) {
---
> static void ctlr_half_connect(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno))
> {
262c295,296
< static void ctlr_connect(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno)) {
---
> static void ctlr_connect(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno))
> {
263a298,299
> //	ticking_stop(hSession);
> //	status_untiming(hSession);
270c306,307
< 	if (!IN_3270 || (IN_SSCP && (hSession->kybdlock & KL_OIA_TWAIT))) {
---
> 	if (!IN_3270 || (IN_SSCP && (hSession->kybdlock & KL_OIA_TWAIT)))
> 	{
283a321,549
> LIB3270_EXPORT int lib3270_is_formatted(const H3270 *hSession)
> {
> 	if(check_online_session(hSession))
> 		return 0;
> 
> 	return hSession->formatted ? 1 : 0;
> }
> 
> /**
>  * @brief Get field address.
>  *
>  * @return Negative on error(sets errno) or field address.
>  *
>  */
> LIB3270_EXPORT int lib3270_get_field_start(H3270 *hSession, int baddr)
> {
> 	int sbaddr;
> 
> 	if(check_online_session(hSession))
> 		return - errno;
> 
> 	if (!hSession->formatted)
> 		return - (errno = ENOTSUP);
> 
>     if(baddr < 0)
> 		baddr = hSession->cursor_addr;
> 
> 	sbaddr = baddr;
> 	do
> 	{
> 		if(hSession->ea_buf[baddr].fa)
> 			return baddr;
> 		DEC_BA(baddr);
> 	} while (baddr != sbaddr);
> 
> 	return -1;
> 
> }
> 
> LIB3270_EXPORT int lib3270_get_field_len(H3270 *hSession, int baddr)
> {
> 	int saddr;
> 	int addr;
> 	int width = 0;
> 
> 	if(check_online_session(hSession))
> 		return - errno;
> 
> 	if (!hSession->formatted)
> 		return - (errno = ENOTSUP);
> 
> 	if(baddr < 0)
> 		baddr = hSession->cursor_addr;
> 
> 	addr = lib3270_field_addr(hSession,baddr);
> 	if(addr < 0)
> 		return addr;
> 
> 	saddr = addr;
> 	INC_BA(addr);
> 	do
> 	{
> 		if(hSession->ea_buf[addr].fa)
> 			return width;
> 		INC_BA(addr);
> 		width++;
> 	} while (addr != saddr);
> 
> 	return -(errno = ENODATA);
> }
> 
> LIB3270_EXPORT int lib3270_field_addr(const H3270 *hSession, int baddr)
> {
> 	int sbaddr;
> 
> 	if(!lib3270_is_connected(hSession))
> 		return -(errno = ENOTCONN);
> 
> 	if(!hSession->formatted)
> 		return -(errno = ENOTSUP);
> 
> 	if(baddr < 0)
> 		baddr = lib3270_get_cursor_address(hSession);
> 
> 	if(baddr > lib3270_get_length(hSession))
> 		return -(errno = EOVERFLOW);
> 
> 	sbaddr = baddr;
> 	do
> 	{
> 		if(hSession->ea_buf[baddr].fa)
> 			return baddr;
> 		DEC_BA(baddr);
> 	} while (baddr != sbaddr);
> 
> 	return -(errno = ENODATA);
> }
> 
> LIB3270_EXPORT LIB3270_FIELD_ATTRIBUTE lib3270_get_field_attribute(H3270 *hSession, int baddr)
> {
> 	int sbaddr;
> 
> 	FAIL_IF_NOT_ONLINE(hSession);
> 
> 	if(!hSession->formatted)
> 	{
> 		errno = ENOTCONN;
> 		return LIB3270_FIELD_ATTRIBUTE_INVALID;
> 	}
> 
> 	if(baddr < 0)
> 		baddr = lib3270_get_cursor_address(hSession);
> 
> 	sbaddr = baddr;
> 	do
> 	{
> 		if(hSession->ea_buf[baddr].fa)
> 			return (LIB3270_FIELD_ATTRIBUTE) hSession->ea_buf[baddr].fa;
> 
> 		DEC_BA(baddr);
> 	} while (baddr != sbaddr);
> 
> 	errno = EINVAL;
> 	return LIB3270_FIELD_ATTRIBUTE_INVALID;
> 
> }
> 
> /**
>  * @brief Get the length of the field at given buffer address.
>  *
>  * @param hSession	Session handle.
>  * @param addr		Buffer address of the field.
>  *
>  * @return field length or negative if invalid or not connected (sets errno).
>  *
>  */
> int lib3270_field_length(H3270 *hSession, int baddr)
> {
> 	int saddr;
> 	int addr;
> 	int width = 0;
> 
> 	addr = lib3270_field_addr(hSession,baddr);
> 	if(addr < 0)
> 		return addr;
> 
> 	saddr = addr;
> 	INC_BA(addr);
> 	do
> 	{
> 		if(hSession->ea_buf[addr].fa)
> 			return width;
> 		INC_BA(addr);
> 		width++;
> 	} while (addr != saddr);
> 
> 	return -(errno = EINVAL);
> 
> }
> 
> /**
>  * @brief Find the field attribute for the given buffer address.
>  *
>  * @return Field attribute.
>  *
>  */
> unsigned char get_field_attribute(H3270 *hSession, int baddr)
> {
> 	baddr = lib3270_field_addr(hSession,baddr);
> 	if(baddr < 0)
> 		return 0;
> 	return hSession->ea_buf[baddr].fa;
> }
> 
> /**
>  * @brief Find the next unprotected field.
>  *
>  * @param hSession	Session handle.
>  * @param baddr0	Search start addr (-1 to use current cursor position).
>  *
>  * @return address following the unprotected attribute byte, or 0 if no nonzero-width unprotected field can be found, negative if failed.
>  *
>  */
> LIB3270_EXPORT int lib3270_get_next_unprotected(H3270 *hSession, int baddr0)
> {
> 	register int baddr, nbaddr;
> 
> 	FAIL_IF_NOT_ONLINE(hSession);
> 
> 	if(!hSession->formatted)
> 		return -(errno = ENOTSUP);
> 
> 	if(baddr0 < 0)
> 		baddr0 = hSession->cursor_addr;
> 
> 	nbaddr = baddr0;
> 	do
> 	{
> 		baddr = nbaddr;
> 		INC_BA(nbaddr);
> 		if(hSession->ea_buf[baddr].fa &&!FA_IS_PROTECTED(hSession->ea_buf[baddr].fa) &&!hSession->ea_buf[nbaddr].fa)
> 			return nbaddr;
> 	} while (nbaddr != baddr0);
> 
> 	return 0;
> }
> 
> LIB3270_EXPORT int lib3270_get_is_protected_at(const H3270 *h, unsigned int row, unsigned int col) {
> 	return lib3270_get_is_protected(h, lib3270_translate_to_address(h,row,col));
> }
> 
> LIB3270_EXPORT int lib3270_get_is_protected(const H3270 *hSession, int baddr)
> {
> 	FAIL_IF_NOT_ONLINE(hSession);
> 
>     if(baddr < 0)
> 		baddr = hSession->cursor_addr;
> 
> 	int faddr = lib3270_field_addr(hSession,baddr);
> 
> 	return FA_IS_PROTECTED(hSession->ea_buf[faddr].fa) ? 1 : 0;
> }
> 
> LIB3270_EXPORT int lib3270_is_protected(H3270 *h, unsigned int baddr)
> {
> 	return lib3270_get_is_protected(h, baddr);
> }
> 
> 
288c554,555
< void ctlr_erase(H3270 *session, int alt) {
---
> void ctlr_erase(H3270 *session, int alt)
> {
298c565,566
< 	if (alt) {
---
> 	if (alt)
> 	{
302c570,572
< 	} else {
---
> 	}
> 	else
> 	{
305,306c575,578
< 		if (session->max.rows > 24 || session->max.cols > 80) {
< 			if(session->vcontrol) {
---
> 		if (session->max.rows > 24 || session->max.cols > 80)
> 		{
> 			if(session->vcontrol)
> 			{
326c598,599
< enum pds process_ds(H3270 *hSession, unsigned char *buf, int buflen) {
---
> enum pds process_ds(H3270 *hSession, unsigned char *buf, int buflen)
> {
334c607,608
< 	switch (buf[0]) { /* 3270 command */
---
> 	switch (buf[0]) /* 3270 command */
> 	{
410c684,685
< static void insert_sa1(H3270 *hSession, unsigned char attr, unsigned char value, unsigned char *currentp, Boolean *anyp) {
---
> static void insert_sa1(H3270 *hSession, unsigned char attr, unsigned char value, unsigned char *currentp, Boolean *anyp)
> {
427c702,703
< static unsigned char host_cs(unsigned char cs) {
---
> static unsigned char host_cs(unsigned char cs)
> {
431c707
< 		return 0xf0 | (cs & CS_MASK);
---
> 	    return 0xf0 | (cs & CS_MASK);
433c709
< 		return 0xf8;
---
> 	    return 0xf8;
435c711
< 		return 0;
---
> 	    return 0;
439c715,716
< static void insert_sa(H3270 *hSession, int baddr, unsigned char *current_fgp, unsigned char *current_bgp,unsigned char *current_grp, unsigned char *current_csp, Boolean *anyp) {
---
> static void insert_sa(H3270 *hSession, int baddr, unsigned char *current_fgp, unsigned char *current_bgp,unsigned char *current_grp, unsigned char *current_csp, Boolean *anyp)
> {
449c726,727
< 	if (memchr((char *) hSession->crm_attr, XA_HIGHLIGHTING, hSession->crm_nattr)) {
---
> 	if (memchr((char *) hSession->crm_attr, XA_HIGHLIGHTING, hSession->crm_nattr))
> 	{
458c736,737
< 	if (memchr((char *) hSession->crm_attr, XA_CHARSET, hSession->crm_nattr)) {
---
> 	if (memchr((char *) hSession->crm_attr, XA_CHARSET, hSession->crm_nattr))
> 	{
467c746,747
< void ctlr_read_modified(H3270 *hSession, unsigned char aid_byte, Boolean all) {
---
> void ctlr_read_modified(H3270 *hSession, unsigned char aid_byte, Boolean all)
> {
480c760,761
< 	if (aid_byte == AID_SF) {
---
> 	if (aid_byte == AID_SF)
> 	{
489c770,771
< 	switch (aid_byte) {
---
> 	switch (aid_byte)
> 	{
505c787
< 	/* fall through... */
---
> 		/* fall through... */
510c792
< 	/* fall through... */
---
> 		/* fall through... */
513c795,796
< 		if (!IN_SSCP) {
---
> 		if (!IN_SSCP)
> 		{
523c806,808
< 		} else {
---
> 		}
> 		else
> 		{
530c815,816
< 	if (hSession->formatted) {
---
> 	if (hSession->formatted)
> 	{
532c818,819
< 		do {
---
> 		do
> 		{
539,540c826,829
< 		do {
< 			if (FA_IS_MODIFIED(hSession->ea_buf[baddr].fa)) {
---
> 		do
> 		{
> 			if (FA_IS_MODIFIED(hSession->ea_buf[baddr].fa))
> 			{
548c837,838
< 				while (!hSession->ea_buf[baddr].fa) {
---
> 				while (!hSession->ea_buf[baddr].fa)
> 				{
550c840,841
< 					if (send_data && hSession->ea_buf[baddr].cc) {
---
> 					if (send_data && hSession->ea_buf[baddr].cc)
> 					{
552c843,844
< 						if (hSession->ea_buf[baddr].cs & CS_GE) {
---
> 						if (hSession->ea_buf[baddr].cs & CS_GE)
> 						{
572,574c864,868
< 			} else {
< 				/* not modified - skip */
< 				do {
---
> 			}
> 			else
> 			{	/* not modified - skip */
> 				do
> 				{
580c874,876
< 	} else {
---
> 	}
> 	else
> 	{
591,592c887,890
< 		do {
< 			if (hSession->ea_buf[baddr].cc) {
---
> 		do
> 		{
> 			if (hSession->ea_buf[baddr].cc)
> 			{
594c892,893
< 				if (hSession->ea_buf[baddr].cs & CS_GE) {
---
> 				if (hSession->ea_buf[baddr].cs & CS_GE)
> 				{
626c925
< rm_done:
---
>     rm_done:
635c934,935
< void ctlr_read_buffer(H3270 *hSession, unsigned char aid_byte) {
---
> void ctlr_read_buffer(H3270 *hSession, unsigned char aid_byte)
> {
646c946,947
< 	if (aid_byte == AID_SF) {
---
> 	if (aid_byte == AID_SF)
> 	{
662,663c963,966
< 		if (hSession->ea_buf[baddr].fa) {
< 			if (hSession->reply_mode == SF_SRM_FIELD) {
---
> 		if (hSession->ea_buf[baddr].fa)
> 		{
> 			if (hSession->reply_mode == SF_SRM_FIELD)
> 			{
666c969,971
< 			} else {
---
> 			}
> 			else
> 			{
679,680c984,985
< 			         (hSession->reply_mode == SF_SRM_FIELD) ? "" : "Extended",
< 			         rcba(hSession,baddr), see_attr(fa));
---
> 			    (hSession->reply_mode == SF_SRM_FIELD) ? "" : "Extended",
> 			    rcba(hSession,baddr), see_attr(fa));
682c987,988
< 			if (hSession->reply_mode != SF_SRM_FIELD) {
---
> 			if (hSession->reply_mode != SF_SRM_FIELD)
> 			{
702c1008
< 					                                hSession->ea_buf[baddr].gr | 0xf0));
---
> 					    hSession->ea_buf[baddr].gr | 0xf0));
727c1033
< 			        hSession->ea_buf[baddr].cc == 0xff) {
---
> 			    hSession->ea_buf[baddr].cc == 0xff) {
752c1058,1059
< void ctlr_erase_all_unprotected(H3270 *hSession) {
---
> void ctlr_erase_all_unprotected(H3270 *hSession)
> {
759c1066,1067
< 	if (hSession->formatted) {
---
> 	if (hSession->formatted)
> 	{
783c1091,1092
< 			} else {
---
> 			}
> 			else {
802c1111,1112
< enum pds ctlr_write(H3270 *hSession, unsigned char buf[], int buflen, Boolean erase) {
---
> enum pds ctlr_write(H3270 *hSession, unsigned char buf[], int buflen, Boolean erase)
> {
834c1144
< 	/* XXX: Should there be a ctlr_add_cs call here? */
---
> /* XXX: Should there be a ctlr_add_cs call here? */
860c1170,1171
< 	if (WCC_RESET(buf[1])) {
---
> 	if (WCC_RESET(buf[1]))
> 	{
867c1178,1179
< 	if (wcc_sound_alarm) {
---
> 	if (wcc_sound_alarm)
> 	{
875c1187,1188
< 	if (wcc_keyboard_restore) {
---
> 	if (wcc_keyboard_restore)
> 	{
880c1193,1194
< 	if (WCC_RESET_MDT(buf[1])) {
---
> 	if (WCC_RESET_MDT(buf[1]))
> 	{
886,887c1200,1203
< 		do {
< 			if (hSession->ea_buf[baddr].fa) {
---
> 		do
> 		{
> 			if (hSession->ea_buf[baddr].fa)
> 			{
910,911c1226,1229
< 	for (cp = &buf[2]; !aborted && cp < (buf + buflen); cp++) {
< 		switch (*cp) {
---
> 	for (cp = &buf[2]; !aborted && cp < (buf + buflen); cp++)
> 	{
> 		switch (*cp)
> 		{
932c1250,1251
< 			if(hSession->buffer_addr >= hSession->view.cols * hSession->view.rows) {
---
> 			if(hSession->buffer_addr >= hSession->view.cols * hSession->view.rows)
> 			{
958c1277,1278
< 			if (hSession->ea_buf[hSession->buffer_addr].fa && !FA_IS_PROTECTED(hSession->ea_buf[hSession->buffer_addr].fa)) {
---
> 			if (hSession->ea_buf[hSession->buffer_addr].fa && !FA_IS_PROTECTED(hSession->ea_buf[hSession->buffer_addr].fa))
> 			{
978c1298,1299
< 			if (!last_cmd || last_zpt) {
---
> 			if (!last_cmd || last_zpt)
> 			{
981c1302,1303
< 				while((hSession->buffer_addr != baddr) && (!hSession->ea_buf[hSession->buffer_addr].fa)) {
---
> 				while((hSession->buffer_addr != baddr) && (!hSession->ea_buf[hSession->buffer_addr].fa))
> 				{
992c1314,1315
< 			} else
---
> 			}
> 			else
1009c1332,1333
< 			if (dbcs) {
---
> 			if (dbcs)
> 			{
1011c1335,1336
< 				if (d == DBCS_RIGHT) {
---
> 				if (d == DBCS_RIGHT)
> 				{
1014c1339,1340
< 				if (default_cs == CS_DBCS || d == DBCS_LEFT) {
---
> 				if (default_cs == CS_DBCS || d == DBCS_LEFT)
> 				{
1018,1019c1344,1347
< 			if (add_dbcs) {
< 				if ((baddr - buffer_addr) % 2) {
---
> 			if (add_dbcs)
> 			{
> 				if ((baddr - buffer_addr) % 2)
> 				{
1024c1352,1353
< 				if (cp >= buf + buflen) {
---
> 				if (cp >= buf + buflen)
> 				{
1028,1029c1357,1360
< 				if (add_c1 == EBC_null) {
< 					switch (add_c2) {
---
> 				if (add_c1 == EBC_null)
> 				{
> 					switch (add_c2)
> 					{
1043c1374,1376
< 				} else if (add_c1 < 0x40 || add_c1 > 0xfe || add_c2 < 0x40 || add_c2 > 0xfe) {
---
> 				}
> 				else if (add_c1 < 0x40 || add_c1 > 0xfe || add_c2 < 0x40 || add_c2 > 0xfe)
> 				{
1049c1382,1383
< 			} else
---
> 			}
> 			else
1052c1386,1387
< 				if (*cp == ORDER_GE) {
---
> 				if (*cp == ORDER_GE)
> 				{
1066c1401,1402
< 			if (baddr >= hSession->view.cols * hSession->view.rows) {
---
> 			if (baddr >= hSession->view.cols * hSession->view.rows)
> 			{
1069,1070c1405,1408
< 			do {
< 				if (add_dbcs) {
---
> 			do
> 			{
> 				if (add_dbcs)
> 				{
1072c1410,1412
< 				} else {
---
> 				}
> 				else
> 				{
1085c1425,1426
< 				if (add_dbcs) {
---
> 				if (add_dbcs)
> 				{
1108c1449,1450
< 			if (baddr >= hSession->view.cols * hSession->view.rows) {
---
> 			if (baddr >= hSession->view.cols * hSession->view.rows)
> 			{
1112c1454,1455
< 			if (d == DBCS_RIGHT) {
---
> 			if (d == DBCS_RIGHT)
> 			{
1116c1459,1460
< 			if (d == DBCS_LEFT) {
---
> 			if (d == DBCS_LEFT)
> 			{
1119c1463,1464
< 			do {
---
> 			do
> 			{
1122c1467,1468
< 				else if (!FA_IS_PROTECTED(current_fa)) {
---
> 				else if (!FA_IS_PROTECTED(current_fa))
> 				{
1162,1163c1508,1511
< 			if (hSession->ea_buf[hSession->buffer_addr].fa) {
< 				for (i = 0; i < (int)na; i++) {
---
> 			if (hSession->ea_buf[hSession->buffer_addr].fa)
> 			{
> 				for (i = 0; i < (int)na; i++)
> 				{
1165c1513,1514
< 					if (*cp == XA_3270) {
---
> 					if (*cp == XA_3270)
> 					{
1170c1519,1521
< 					} else if (*cp == XA_FOREGROUND) {
---
> 					}
> 					else if (*cp == XA_FOREGROUND)
> 					{
1175c1526,1528
< 					} else if (*cp == XA_BACKGROUND) {
---
> 					}
> 					else if (*cp == XA_BACKGROUND)
> 					{
1180c1533,1535
< 					} else if (*cp == XA_HIGHLIGHTING) {
---
> 					}
> 					else if (*cp == XA_HIGHLIGHTING)
> 					{
1184c1539,1541
< 					} else if (*cp == XA_CHARSET) {
---
> 					}
> 					else if (*cp == XA_CHARSET)
> 					{
1194c1551,1553
< 					} else if (*cp == XA_ALL) {
---
> 					}
> 					else if (*cp == XA_ALL)
> 					{
1197c1556,1558
< 					} else if (*cp == XA_INPUT_CONTROL) {
---
> 					}
> 					else if (*cp == XA_INPUT_CONTROL)
> 					{
1201c1562,1564
< 					} else {
---
> 					}
> 					else
> 					{
1207c1570,1571
< 			} else
---
> 			}
> 			else
1263c1627
< 						efa_ic = (*(cp + 1) == 1);
---
> 					    efa_ic = (*(cp + 1) == 1);
1307,1308c1671,1672
< 					hSession->default_cs = CS_APL;
< 					break;
---
> 				    hSession->default_cs = CS_APL;
> 				    break;
1310,1311c1674,1675
< 					hSession->default_cs = CS_DBCS;
< 					break;
---
> 				    hSession->default_cs = CS_DBCS;
> 				    break;
1313,1314c1677,1678
< 					hSession->default_cs = CS_BASE;
< 					break;
---
> 				    hSession->default_cs = CS_BASE;
> 				    break;
1389,1390c1753,1754
< 			        ((fa_addr >= 0 && baddr != fa_addr) ||
< 			         (fa_addr < 0 && baddr != hSession->view.rows*hSession->view.cols - 1))) {
---
> 			       ((fa_addr >= 0 && baddr != fa_addr) ||
> 			        (fa_addr < 0 && baddr != hSession->view.rows*hSession->view.cols - 1))) {
1463c1827,1828
< 			if (add_dbcs) {
---
> 			if (add_dbcs)
> 			{
1500c1865
< 				        add_c2 < 0x40 || add_c2 > 0xfe) {
---
> 				    add_c2 < 0x40 || add_c2 > 0xfe) {
1503,1506c1868,1871
< 				}
< 				add_dbcs = True;
< 				dbcs_to_mb(add_c1, add_c2, mb);
< 				trace_ds_nb(hSession,"%s", mb);
---
> 			       }
> 			       add_dbcs = True;
> 			       dbcs_to_mb(add_c1, add_c2, mb);
> 			       trace_ds_nb(hSession,"%s", mb);
1555a1921,1923
> 	/* Let a script go. */
> //	sms_host_output();
> 
1571c1939,1940
< void ctlr_write_sscp_lu(H3270 *hSession, unsigned char buf[], int buflen) {
---
> void ctlr_write_sscp_lu(H3270 *hSession, unsigned char buf[], int buflen)
> {
1575a1945
> //	int baddr;
1593c1963,1964
< 			while ((hSession->buffer_addr / hSession->view.cols) == s_row) {
---
> 			while ((hSession->buffer_addr / hSession->view.cols) == s_row)
> 			{
1620a1992
> //			baddr = DECODE_BADDR(*(cp+1), *(cp+2));
1680c2052,2053
< ctlr_lookleft_state(int baddr, enum dbcs_why *why) {
---
> ctlr_lookleft_state(int baddr, enum dbcs_why *why)
> {
1689,1690c2062,2063
< 	/* If we're not in DBCS state, everything is DBCS_NONE. */
< 	if (!dbcs)
---
> 	 /* If we're not in DBCS state, everything is DBCS_NONE. */
> 	 if (!dbcs)
1717,1719c2090,2092
< 		        ea_buf[xaddr].cs == CS_DBCS &&
< 		        ea_buf[xaddr].cc != EBC_so &&
< 		        ea_buf[xaddr].cc != EBC_si) {
---
> 		       ea_buf[xaddr].cs == CS_DBCS &&
> 		       ea_buf[xaddr].cc != EBC_so &&
> 		       ea_buf[xaddr].cc != EBC_si) {
1752c2125,2126
< valid_dbcs_char(unsigned char c1, unsigned char c2) {
---
> valid_dbcs_char(unsigned char c1, unsigned char c2)
> {
1785c2159,2160
< int ctlr_dbcs_postprocess(H3270 *hSession) {
---
> int ctlr_dbcs_postprocess(H3270 *hSession)
> {
1835,1846c2210,2221
< 				/* Two SO's or SO in DBCS field are invalid. */
< 				if (so || dbcs_field) {
< 					trace_ds(hSession,"DBCS postprocess: invalid SO found at %s\n", rcba(baddr));
< 					rc = -1;
< 				} else {
< 					dbaddr = baddr;
< 					INC_BA(dbaddr);
< 				}
< 				ea_buf[baddr].db = DBCS_NONE;
< 				so = True;
< 				si = False;
< 				break;
---
> 			    /* Two SO's or SO in DBCS field are invalid. */
> 			    if (so || dbcs_field) {
> 				    trace_ds(hSession,"DBCS postprocess: invalid SO found at %s\n", rcba(baddr));
> 				    rc = -1;
> 			    } else {
> 				    dbaddr = baddr;
> 				    INC_BA(dbaddr);
> 			    }
> 			    ea_buf[baddr].db = DBCS_NONE;
> 			    so = True;
> 			    si = False;
> 			    break;
1848,1859c2223,2234
< 				/* Two SI's or SI in DBCS field are invalid. */
< 				if (si || dbcs_field) {
< 					trace_ds(hSession,"Postprocess: Invalid SO found at %s\n", rcba(baddr));
< 					rc = -1;
< 					ea_buf[baddr].db = DBCS_NONE;
< 				} else {
< 					ea_buf[baddr].db = DBCS_SI;
< 				}
< 				dbaddr = -1;
< 				si = True;
< 				so = False;
< 				break;
---
> 			    /* Two SI's or SI in DBCS field are invalid. */
> 			    if (si || dbcs_field) {
> 				    trace_ds(hSession,"Postprocess: Invalid SO found at %s\n", rcba(baddr));
> 				    rc = -1;
> 				    ea_buf[baddr].db = DBCS_NONE;
> 			    } else {
> 				    ea_buf[baddr].db = DBCS_SI;
> 			    }
> 			    dbaddr = -1;
> 			    si = True;
> 			    so = False;
> 			    break;
1861,1901c2236,2276
< 				/* Non-base CS in DBCS subfield is invalid. */
< 				if (so && ea_buf[baddr].cs != CS_BASE) {
< 					trace_ds(hSession,"DBCS postprocess: invalid character set found at %s\n",rcba(baddr));
< 					rc = -1;
< 					ea_buf[baddr].cs = CS_BASE;
< 				}
< 				if ((ea_buf[baddr].cs & CS_MASK) == CS_DBCS) {
< 					/*
< 					 * Beginning or continuation of an SA DBCS
< 					 * subfield.
< 					 */
< 					if (dbaddr < 0) {
< 						dbaddr = baddr;
< 					}
< 				} else if (!so && !dbcs_field) {
< 					/*
< 					 * End of SA DBCS subfield.
< 					 */
< 					dbaddr = -1;
< 				}
< 				if (dbaddr >= 0) {
< 					/*
< 					 * Turn invalid characters into spaces,
< 					 * silently.
< 					 */
< 					if ((baddr + ROWS*COLS - dbaddr) % 2) {
< 						if (!valid_dbcs_char(
< 						            ea_buf[pbaddr].cc,
< 						            ea_buf[baddr].cc)) {
< 							ea_buf[pbaddr].cc =
< 							    EBC_space;
< 							ea_buf[baddr].cc =
< 							    EBC_space;
< 						}
< 						MAKE_RIGHT(baddr);
< 					} else {
< 						MAKE_LEFT(baddr);
< 					}
< 				} else
< 					ea_buf[baddr].db = DBCS_NONE;
< 				break;
---
> 			    /* Non-base CS in DBCS subfield is invalid. */
> 			    if (so && ea_buf[baddr].cs != CS_BASE) {
> 				    trace_ds(hSession,"DBCS postprocess: invalid character set found at %s\n",rcba(baddr));
> 				    rc = -1;
> 				    ea_buf[baddr].cs = CS_BASE;
> 			    }
> 			    if ((ea_buf[baddr].cs & CS_MASK) == CS_DBCS) {
> 				    /*
> 				     * Beginning or continuation of an SA DBCS
> 				     * subfield.
> 				     */
> 				    if (dbaddr < 0) {
> 					    dbaddr = baddr;
> 				    }
> 			    } else if (!so && !dbcs_field) {
> 				    /*
> 				     * End of SA DBCS subfield.
> 				     */
> 				    dbaddr = -1;
> 			    }
> 			    if (dbaddr >= 0) {
> 				    /*
> 				     * Turn invalid characters into spaces,
> 				     * silently.
> 				     */
> 				    if ((baddr + ROWS*COLS - dbaddr) % 2) {
> 					    if (!valid_dbcs_char(
> 							ea_buf[pbaddr].cc,
> 							ea_buf[baddr].cc)) {
> 						    ea_buf[pbaddr].cc =
> 							EBC_space;
> 						    ea_buf[baddr].cc =
> 							EBC_space;
> 					    }
> 					    MAKE_RIGHT(baddr);
> 				    } else {
> 					    MAKE_LEFT(baddr);
> 				    }
> 			    } else
> 				    ea_buf[baddr].db = DBCS_NONE;
> 			    break;
1910,1912c2285,2287
< 		        IS_LEFT(ea_buf[pbaddr].db) &&
< 		        !IS_RIGHT(ea_buf[baddr].db) &&
< 		        ea_buf[pbaddr].db != DBCS_DEAD) {
---
> 		    IS_LEFT(ea_buf[pbaddr].db) &&
> 		    !IS_RIGHT(ea_buf[baddr].db) &&
> 		    ea_buf[pbaddr].db != DBCS_DEAD) {
1940c2315,2316
< void ps_process(H3270 *hSession) {
---
> void ps_process(H3270 *hSession)
> {
1947,1951c2323,2328
< 	        hSession->formatted &&          								/* screen is formatted */
< 	        !hSession->screen_alt &&        								/* 24x80 screen */
< 	        !hSession->kybdlock &&                							/* keyboard not locked */
< 	        /* magic field */
< 	        hSession->ea_buf[1919].fa && FA_IS_SKIP(hSession->ea_buf[1919].fa)) {
---
> 	    hSession->formatted &&          								/* screen is formatted */
> 	    !hSession->screen_alt &&        								/* 24x80 screen */
> 	    !hSession->kybdlock &&                							/* keyboard not locked */
> 	    /* magic field */
> 	    hSession->ea_buf[1919].fa && FA_IS_SKIP(hSession->ea_buf[1919].fa))
> 	{
1960c2337,2338
< int ctlr_any_data(H3270 *session) {
---
> int ctlr_any_data(H3270 *session)
> {
1963c2341,2342
< 	for(i = 0; i < session->view.rows * session->view.cols; i++) {
---
> 	for(i = 0; i < session->view.rows * session->view.cols; i++)
> 	{
1973c2352,2353
< void ctlr_clear(H3270 *session, Boolean can_snap) {
---
> void ctlr_clear(H3270 *session, Boolean can_snap)
> {
1977c2357,2358
< 	if (ctlr_any_data(session)) {
---
> 	if (ctlr_any_data(session))
> 	{
1988,1991c2369,2372
< 	    (char *)session->ea_buf,
< 	    0,
< 	    ((size_t)session->view.rows) * ((size_t) session->view.cols) * sizeof(struct lib3270_ea)
< 	);
---
> 				(char *)session->ea_buf,
> 				0,
> 				((size_t)session->view.rows) * ((size_t) session->view.cols) * sizeof(struct lib3270_ea)
> 			);
2017c2398,2399
< static void ctlr_blanks(H3270 *session) {
---
> static void ctlr_blanks(H3270 *session)
> {
2020c2402,2403
< 	for (baddr = 0; baddr < session->view.rows * session->view.cols; baddr++) {
---
> 	for (baddr = 0; baddr < session->view.rows * session->view.cols; baddr++)
> 	{
2035c2418,2419
< void ctlr_add(H3270 *hSession, int baddr, unsigned char c, unsigned char cs) {
---
> void ctlr_add(H3270 *hSession, int baddr, unsigned char c, unsigned char cs)
> {
2038,2039c2422,2425
< 	if(hSession->ea_buf[baddr].fa || ((oc = hSession->ea_buf[baddr].cc) != c || hSession->ea_buf[baddr].cs != cs)) {
< 		if (hSession->trace_primed && !IsBlank(oc)) {
---
> 	if(hSession->ea_buf[baddr].fa || ((oc = hSession->ea_buf[baddr].cc) != c || hSession->ea_buf[baddr].cs != cs))
> 	{
> 		if (hSession->trace_primed && !IsBlank(oc))
> 		{
2057c2443,2444
< void ctlr_add_fa(H3270 *hSession, int baddr, unsigned char fa, unsigned char cs) {
---
> void ctlr_add_fa(H3270 *hSession, int baddr, unsigned char fa, unsigned char cs)
> {
2072,2073c2459,2462
< ctlr_add_cs(H3270 *hSession, int baddr, unsigned char cs) {
< 	if (hSession->ea_buf[baddr].cs != cs) {
---
> ctlr_add_cs(H3270 *hSession, int baddr, unsigned char cs)
> {
> 	if (hSession->ea_buf[baddr].cs != cs)
> 	{
2086,2087c2475,2478
< void ctlr_add_gr(H3270 *hSession, int baddr, unsigned char gr) {
< 	if (hSession->ea_buf[baddr].gr != gr) {
---
> void ctlr_add_gr(H3270 *hSession, int baddr, unsigned char gr)
> {
> 	if (hSession->ea_buf[baddr].gr != gr)
> 	{
2098c2489,2490
< void ctlr_add_fg(H3270 *hSession, int baddr, unsigned char color) {
---
> void ctlr_add_fg(H3270 *hSession, int baddr, unsigned char color)
> {
2105c2497,2498
< 	if (hSession->ea_buf[baddr].fg != color) {
---
> 	if (hSession->ea_buf[baddr].fg != color)
> 	{
2114c2507,2508
< void ctlr_add_bg(H3270 *hSession, int baddr, unsigned char color) {
---
> void ctlr_add_bg(H3270 *hSession, int baddr, unsigned char color)
> {
2121c2515,2516
< 	if (hSession->ea_buf[baddr].bg != color) {
---
> 	if (hSession->ea_buf[baddr].bg != color)
> 	{
2130c2525,2526
< static void ctlr_add_ic(H3270 *hSession, int baddr, unsigned char ic) {
---
> static void ctlr_add_ic(H3270 *hSession, int baddr, unsigned char ic)
> {
2137c2533,2534
< void ctlr_wrapping_memmove(H3270 *hSession, int baddr_to, int baddr_from, int count) {
---
> void ctlr_wrapping_memmove(H3270 *hSession, int baddr_to, int baddr_from, int count)
> {
2147c2544
< 	        baddr_to + count <= hSession->view.rows * hSession->view.cols) {
---
> 	    baddr_to + count <= hSession->view.rows * hSession->view.cols) {
2153,2162c2550,2559
< 			if (baddr_to > baddr_from) {
< 				/* Shifting right, move left. */
< 				to = (baddr_to + count - 1 - i) % hSession->view.rows * hSession->view.cols;
< 				from = (baddr_from + count - 1 - i) % hSession->view.rows * hSession->view.cols;
< 			} else {
< 				/* Shifting left, move right. */
< 				to = (baddr_to + i) % hSession->view.rows * hSession->view.cols;
< 				from = (baddr_from + i) % hSession->view.rows * hSession->view.cols;
< 			}
< 			ctlr_bcopy(hSession,from, to, 1, True);
---
> 		    if (baddr_to > baddr_from) {
> 			/* Shifting right, move left. */
> 			to = (baddr_to + count - 1 - i) % hSession->view.rows * hSession->view.cols;
> 			from = (baddr_from + count - 1 - i) % hSession->view.rows * hSession->view.cols;
> 		    } else {
> 			/* Shifting left, move right. */
> 			to = (baddr_to + i) % hSession->view.rows * hSession->view.cols;
> 			from = (baddr_from + i) % hSession->view.rows * hSession->view.cols;
> 		    }
> 		    ctlr_bcopy(hSession,from, to, 1, True);
2176c2573,2574
< void ctlr_bcopy(H3270 *hSession, int baddr_from, int baddr_to, int count, int GNUC_UNUSED(move_ea)) {
---
> void ctlr_bcopy(H3270 *hSession, int baddr_from, int baddr_to, int count, int GNUC_UNUSED(move_ea))
> {
2178c2576,2577
< 	if (memcmp((char *) &hSession->ea_buf[baddr_from],(char *) &hSession->ea_buf[baddr_to],count * sizeof(struct lib3270_ea))) {
---
> 	if (memcmp((char *) &hSession->ea_buf[baddr_from],(char *) &hSession->ea_buf[baddr_to],count * sizeof(struct lib3270_ea)))
> 	{
2192c2591,2592
< void ctlr_aclear(H3270 *hSession, int baddr, int count, int GNUC_UNUSED(clear_ea)) {
---
> void ctlr_aclear(H3270 *hSession, int baddr, int count, int GNUC_UNUSED(clear_ea))
> {
2194c2594
< 	           count * sizeof(struct lib3270_ea))) {
---
> 		    count * sizeof(struct lib3270_ea))) {
2196c2596
< 		              count * sizeof(struct lib3270_ea));
---
> 				count * sizeof(struct lib3270_ea));
2208c2608,2609
< void ctlr_scroll(H3270 *hSession) {
---
> void ctlr_scroll(H3270 *hSession)
> {
2230,2231c2631,2633
< void ctlr_altbuffer(H3270 *session, int alt) {
< 	CHECK_SESSION_HANDLE(session);
---
> void ctlr_altbuffer(H3270 *session, int alt)
> {
>     CHECK_SESSION_HANDLE(session);
2233c2635,2636
< 	if (alt != session->is_altbuffer) {
---
> 	if (alt != session->is_altbuffer)
> 	{
2256c2659,2660
< void mdt_set(H3270 *hSession, int baddr) {
---
> void mdt_set(H3270 *hSession, int baddr)
> {
2260c2664,2665
< 	if (faddr >= 0 && !(hSession->ea_buf[faddr].fa & FA_MODIFY)) {
---
> 	if (faddr >= 0 && !(hSession->ea_buf[faddr].fa & FA_MODIFY))
> 	{
2267c2672,2673
< void mdt_clear(H3270 *hSession, int baddr) {
---
> void mdt_clear(H3270 *hSession, int baddr)
> {
2270c2676,2677
< 	if (faddr >= 0 && (hSession->ea_buf[faddr].fa & FA_MODIFY)) {
---
> 	if (faddr >= 0 && (hSession->ea_buf[faddr].fa & FA_MODIFY))
> 	{
2292c2699,2700
< enum dbcs_state ctlr_dbcs_state(int baddr) {
---
> enum dbcs_state ctlr_dbcs_state(int baddr)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/cursor.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/cursor.c
57c57
< static const struct {
---
>  static const struct {
59c59
< } calls[LIB3270_DIR_COUNT] = {
---
>  } calls[LIB3270_DIR_COUNT] = {
65c65
< };
---
>  };
80c80,81
< LIB3270_EXPORT int lib3270_move_cursor(H3270 *hSession, LIB3270_DIRECTION dir, unsigned char sel) {
---
> LIB3270_EXPORT int lib3270_move_cursor(H3270 *hSession, LIB3270_DIRECTION dir, unsigned char sel)
> {
83c84,85
< 	if(dir < 0 || dir >= LIB3270_DIR_COUNT) {
---
> 	if(dir < 0 || dir >= LIB3270_DIR_COUNT)
> 	{
87,88c89,92
< 	if (hSession->kybdlock) {
< 		if (KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if (KYBDLOCK_IS_OERR(hSession))
> 		{
91c95,97
< 		} else {
---
> 		}
> 		else
> 		{
93,94c99
< 			if(!ta)
< 				return -1;
---
> 
109,110c114,117
< 	if(sel) {
< 		if(hSession->cursor_addr < saved_cursor) {
---
> 	if(sel)
> 	{
> 		if(hSession->cursor_addr < saved_cursor)
> 		{
113,115c120,122
< 			    hSession,
< 			    hSession->cursor_addr,
< 			    ((hSession->selected ? hSession->select.end : saved_cursor))
---
> 					hSession,
> 					hSession->cursor_addr,
> 					((hSession->selected ? hSession->select.end : saved_cursor))
118c125,127
< 		} else {
---
> 		}
> 		else
> 		{
121,123c130,132
< 			    hSession,
< 			    ((hSession->selected ? hSession->select.start : saved_cursor)),
< 			    hSession->cursor_addr
---
> 					hSession,
> 					((hSession->selected ? hSession->select.start : saved_cursor)),
> 					hSession->cursor_addr
127c136,138
< 	} else if(hSession->selected && !lib3270_get_toggle(hSession,LIB3270_TOGGLE_KEEP_SELECTED)) {
---
> 	}
> 	else if(hSession->selected && !lib3270_get_toggle(hSession,LIB3270_TOGGLE_KEEP_SELECTED))
> 	{
134c145,146
< LIB3270_EXPORT int lib3270_cursor_up(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_cursor_up(H3270 *hSession)
> {
138c150,151
< LIB3270_EXPORT int lib3270_cursor_down(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_cursor_down(H3270 *hSession)
> {
142c155,156
< LIB3270_EXPORT int lib3270_cursor_left(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_cursor_left(H3270 *hSession)
> {
146c160,161
< LIB3270_EXPORT int lib3270_cursor_right(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_cursor_right(H3270 *hSession)
> {
153c168,169
< static void do_left(H3270 *hSession) {
---
> static void do_left(H3270 *hSession)
> {
165,167c181,186
< static int cursor_left(H3270 *hSession) {
< 	if (hSession->kybdlock) {
< 		if(KYBDLOCK_IS_OERR(hSession)) {
---
> static int cursor_left(H3270 *hSession)
> {
> 	if (hSession->kybdlock)
> 	{
> 		if(KYBDLOCK_IS_OERR(hSession))
> 		{
170c189,191
< 		} else {
---
> 		}
> 		else
> 		{
176c197,198
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
182c204,205
< 	if (!hSession->flipped) {
---
> 	if (!hSession->flipped)
> 	{
184c207,209
< 	} else {
---
> 	}
> 	else
> 	{
195c220,221
< static int cursor_right(H3270 *hSession) {
---
> static int cursor_right(H3270 *hSession)
> {
199,200c225,228
< 	if (hSession->kybdlock) {
< 		if (KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if (KYBDLOCK_IS_OERR(hSession))
> 		{
203c231,233
< 		} else {
---
> 		}
> 		else
> 		{
214c244,245
< 	if (!hSession->flipped) {
---
> 	if (!hSession->flipped)
> 	{
221c252,254
< 	} else {
---
> 	}
> 	else
> 	{
227c260,261
< static int cursor_up(H3270 *hSession) {
---
> static int cursor_up(H3270 *hSession)
> {
231,232c265,268
< 	if (hSession->kybdlock) {
< 		if (KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if (KYBDLOCK_IS_OERR(hSession))
> 		{
235c271,273
< 		} else {
---
> 		}
> 		else
> 		{
255c293,294
< static int cursor_down(H3270 *hSession) {
---
> static int cursor_down(H3270 *hSession)
> {
258,259c297,300
< 	if (hSession->kybdlock) {
< 		if (KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if (KYBDLOCK_IS_OERR(hSession))
> 		{
262c303,304
< 		} else {
---
> 		} else
> 		{
269c311,312
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
279c322,323
< static int cursor_end(H3270 *hSession) {
---
> static int cursor_end(H3270 *hSession)
> {
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core: field.c
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft.c
35,36c35,36
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
49c49
< #include <malloc.h>
---
> 	#include <malloc.h>
88,96c88,100
< H3270FT * get_ft_handle(H3270 *hSession) {
< 	return hSession->ft;
< }
< 
< static void set_ft_state(H3270FT *session, LIB3270_FT_STATE state) {
< 	static const struct _msg {
< 		LIB3270_FT_STATE 	  state;
< 		const char			* text;
< 	} msg[] = {
---
>  H3270FT * get_ft_handle(H3270 *hSession)
>  {
>  	return hSession->ft;
>  }
> 
>  static void set_ft_state(H3270FT *session, LIB3270_FT_STATE state)
>  {
>  	static const struct _msg
>  	{
>  		LIB3270_FT_STATE 	  state;
>  		const char			* text;
>  	} msg[] =
>  	{
111,112c115,118
< 	for(f = 0; f < sizeof(msg)/sizeof(msg[0]); f++) {
< 		if(msg[f].state == state) {
---
> 	for(f = 0; f < sizeof(msg)/sizeof(msg[0]);f++)
> 	{
> 		if(msg[f].state == state)
> 		{
123c129
< }
---
>  }
125c131,132
< void ft_init(H3270 *hSession) {
---
>  void ft_init(H3270 *hSession)
>  {
129c136
< }
---
>  }
131,132c138,140
< LIB3270_EXPORT int lib3270_ft_cancel(H3270 *hSession, int force, const char *reason) {
< 	H3270FT *ft;
---
>  LIB3270_EXPORT int lib3270_ft_cancel(H3270 *hSession, int force, const char *reason)
>  {
>  	H3270FT *ft;
140c148,149
< 	if (ft->state == LIB3270_FT_STATE_RUNNING) {
---
> 	if (ft->state == LIB3270_FT_STATE_RUNNING)
> 	{
156c165
< }
---
>  }
158,160c167,175
< static void def_complete(H3270 *hSession, unsigned long GNUC_UNUSED(length), double GNUC_UNUSED(kbytes_sec), const char *msg, void GNUC_UNUSED(*userdata)) {
< 	hSession->ft->cbk.message(hSession,msg,hSession->ft->user_data);
< }
---
>  static void def_complete(H3270 *hSession, unsigned long GNUC_UNUSED(length), double GNUC_UNUSED(kbytes_sec), const char *msg, void GNUC_UNUSED(*userdata))
>  {
>  	hSession->ft->cbk.message(hSession,msg,hSession->ft->user_data);
>  }
> 
>  static void def_failed(H3270 *hSession, unsigned long length, double kbytes_sec, const char *msg, void *userdata)
>  {
>  	hSession->ft->cbk.complete(hSession,length,kbytes_sec,msg,userdata);
>  }
162,166c177,178
< static void def_failed(H3270 *hSession, unsigned long length, double kbytes_sec, const char *msg, void *userdata) {
< 	hSession->ft->cbk.complete(hSession,length,kbytes_sec,msg,userdata);
< }
< 
< static void def_message(H3270 *hSession, const char *msg, void GNUC_UNUSED(*userdata)) {
---
>  static void def_message(H3270 *hSession, const char *msg, void GNUC_UNUSED(*userdata))
>  {
168c180
< }
---
>  }
170c182,183
< static void def_update(H3270 GNUC_UNUSED(*hSession), unsigned long GNUC_UNUSED(current), unsigned long GNUC_UNUSED(length), double GNUC_UNUSED(kbytes_sec), void GNUC_UNUSED(*userdata)) {
---
>  static void def_update(H3270 GNUC_UNUSED(*hSession), unsigned long GNUC_UNUSED(current), unsigned long GNUC_UNUSED(length), double GNUC_UNUSED(kbytes_sec), void GNUC_UNUSED(*userdata))
>  {
172c185
< }
---
>  }
174c187,188
< static void def_running(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(is_cut), void GNUC_UNUSED(*userdata)) {
---
>  static void def_running(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(is_cut), void GNUC_UNUSED(*userdata))
>  {
176c190
< }
---
>  }
178c192,193
< static void def_aborting(H3270 GNUC_UNUSED(*hSession), const char GNUC_UNUSED(*reason), void GNUC_UNUSED(*userdata)) {
---
>  static void def_aborting(H3270 GNUC_UNUSED(*hSession), const char GNUC_UNUSED(*reason), void GNUC_UNUSED(*userdata))
>  {
180c195
< }
---
>  }
182c197,198
< static void def_state_changed(H3270 GNUC_UNUSED(*hSession), LIB3270_FT_STATE GNUC_UNUSED(state), const char GNUC_UNUSED(*text), void GNUC_UNUSED(*userdata)) {
---
>  static void def_state_changed(H3270 GNUC_UNUSED(*hSession), LIB3270_FT_STATE GNUC_UNUSED(state), const char GNUC_UNUSED(*text), void GNUC_UNUSED(*userdata))
>  {
184c200
< }
---
>  }
186c202
< static H3270FT * ft_creation_failed(H3270 *session, int rc, const char **dest, const char *message) {
---
>  static H3270FT * ft_creation_failed(H3270 *session, int rc, const char **dest, const char *message) {
198c214
< }
---
>  }
200,217c216,235
< LIB3270_EXPORT H3270FT * lib3270_ft_new(H3270 *session, LIB3270_FT_OPTION flags, const char *local, const char *remote, int lrecl, int blksize, int primspace, int secspace, int dft, const char **message) {
< 	static const unsigned short asc2ft[256] = {
< 		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
< 		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
< 		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
< 		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
< 		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
< 		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xd5, 0x5c, 0xe5, 0xd8, 0x5f,
< 		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
< 		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x5d, 0x7d, 0x7e, 0x7f,
< 		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
< 		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x00,
< 		0xa0, 0xd2, 0x5b, 0xd9, 0xd0, 0xda, 0x7c, 0xdd, 0xe3, 0xdc, 0xcb, 0xc4, 0x5e, 0xe8, 0xd7, 0xe4,
< 		0xca, 0xc9, 0xf4, 0xfa, 0xe6, 0xd1, 0xde, 0xdb, 0xce, 0xee, 0xcc, 0xc5, 0xdf, 0xe0, 0xe1, 0xd3,
< 		0xb4, 0xb5, 0xb2, 0xb6, 0xb3, 0xb7, 0xcf, 0xb8, 0xbe, 0xbb, 0xbc, 0xbd, 0xc2, 0xbf, 0xc0, 0xc1,
< 		0xd4, 0xb9, 0xf7, 0xf8, 0xf5, 0xf9, 0xf6, 0xe7, 0xc3, 0xfd, 0xfe, 0xfb, 0xfc, 0xe2, 0xd6, 0xb1,
< 		0xa3, 0xa4, 0xa1, 0xa5, 0xa2, 0xa6, 0xcd, 0xa7, 0xac, 0xa9, 0xaa, 0xab, 0xb0, 0xad, 0xae, 0xaf,
< 		0xc6, 0xa8, 0xeb, 0xec, 0xe9, 0xed, 0xea, 0x9f, 0xba, 0xf1, 0xf2, 0xef, 0xf0, 0xc7, 0xc8, 0xf3
---
>  LIB3270_EXPORT H3270FT * lib3270_ft_new(H3270 *session, LIB3270_FT_OPTION flags, const char *local, const char *remote, int lrecl, int blksize, int primspace, int secspace, int dft, const char **message)
>  {
> 	static const unsigned short asc2ft[256] =
> 	{
>         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
>         0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
>         0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
>         0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
>         0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xd5, 0x5c, 0xe5, 0xd8, 0x5f,
>         0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
>         0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x5d, 0x7d, 0x7e, 0x7f,
>         0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
>         0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x00,
>         0xa0, 0xd2, 0x5b, 0xd9, 0xd0, 0xda, 0x7c, 0xdd, 0xe3, 0xdc, 0xcb, 0xc4, 0x5e, 0xe8, 0xd7, 0xe4,
>         0xca, 0xc9, 0xf4, 0xfa, 0xe6, 0xd1, 0xde, 0xdb, 0xce, 0xee, 0xcc, 0xc5, 0xdf, 0xe0, 0xe1, 0xd3,
>         0xb4, 0xb5, 0xb2, 0xb6, 0xb3, 0xb7, 0xcf, 0xb8, 0xbe, 0xbb, 0xbc, 0xbd, 0xc2, 0xbf, 0xc0, 0xc1,
>         0xd4, 0xb9, 0xf7, 0xf8, 0xf5, 0xf9, 0xf6, 0xe7, 0xc3, 0xfd, 0xfe, 0xfb, 0xfc, 0xe2, 0xd6, 0xb1,
>         0xa3, 0xa4, 0xa1, 0xa5, 0xa2, 0xa6, 0xcd, 0xa7, 0xac, 0xa9, 0xaa, 0xab, 0xb0, 0xad, 0xae, 0xaf,
>         0xc6, 0xa8, 0xeb, 0xec, 0xe9, 0xed, 0xea, 0x9f, 0xba, 0xf1, 0xf2, 0xef, 0xf0, 0xc7, 0xc8, 0xf3
220,236c238,255
< 	static const unsigned short ft2asc[256] = {
< 		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
< 		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
< 		0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
< 		0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
< 		0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
< 		0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xa2, 0x5c, 0x7c, 0xac, 0x5f,
< 		0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
< 		0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0xa6, 0x7d, 0x7e, 0x7f,
< 		0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
< 		0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xf7,
< 		0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, 0xe7, 0xf1, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef,
< 		0xec, 0xdf, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, 0xc7, 0xd1, 0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd,
< 		0xce, 0xcf, 0xcc, 0xd8, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, 0xb0, 0xaa, 0xba, 0xe6, 0xb8, 0xc6,
< 		0xa4, 0xb5, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, 0x5e, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc,
< 		0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, 0xb9, 0xfb,
< 		0xfc, 0xf9, 0xfa, 0xff, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0xff
---
> 	static const unsigned short ft2asc[256] =
> 	{
>         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
>         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
>         0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
>         0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
>         0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
>         0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0xa2, 0x5c, 0x7c, 0xac, 0x5f,
>         0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
>         0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0xa6, 0x7d, 0x7e, 0x7f,
>         0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
>         0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xf7,
>         0xa0, 0xe2, 0xe4, 0xe0, 0xe1, 0xe3, 0xe5, 0xe7, 0xf1, 0xe9, 0xea, 0xeb, 0xe8, 0xed, 0xee, 0xef,
>         0xec, 0xdf, 0xc2, 0xc4, 0xc0, 0xc1, 0xc3, 0xc5, 0xc7, 0xd1, 0xf8, 0xc9, 0xca, 0xcb, 0xc8, 0xcd,
>         0xce, 0xcf, 0xcc, 0xd8, 0xab, 0xbb, 0xf0, 0xfd, 0xfe, 0xb1, 0xb0, 0xaa, 0xba, 0xe6, 0xb8, 0xc6,
>         0xa4, 0xb5, 0xa1, 0xbf, 0xd0, 0x5b, 0xde, 0xae, 0x5e, 0xa3, 0xa5, 0xb7, 0xa9, 0xa7, 0xb6, 0xbc,
>         0xbd, 0xbe, 0xdd, 0xa8, 0xaf, 0x5d, 0xb4, 0xd7, 0xad, 0xf4, 0xf6, 0xf2, 0xf3, 0xf5, 0xb9, 0xfb,
>         0xfc, 0xf9, 0xfa, 0xff, 0xb2, 0xd4, 0xd6, 0xd2, 0xd3, 0xd5, 0xb3, 0xdb, 0xdc, 0xd9, 0xda, 0xff
239,241c258,261
< 	H3270FT				* ftHandle		= (H3270FT *) session->ft;
< 	FILE				* ft_local_file	= NULL;
< 	int                   f;
---
>  	H3270FT				* ftHandle		= (H3270FT *) session->ft;
>  	FILE				* ft_local_file	= NULL;
>  	int                   f;
> // 	unsigned long		  length		= 0L;
242a263
> //	trace("%s(%s)",__FUNCTION__,local);
243a265
> 	{
244a267
> 	}
246a270
> 	{
247a272
> 	}
250a276
> 	{
251a278
> 	}
260a288
> 	{
261a290
> 	}
264c293,294
< 	lib3270_set_dft_buffersize(session, dft);
---
> 	session->dft_buffersize = dft;
> 	set_dft_buffersize(session);
270d299
< 	session->ft					= ftHandle;
273d301
< 	ftHandle->ft_is_cut  		= 0;
278a307
> 	ftHandle->ft_is_cut  		= 0;
293,295c322,325
< 	for(f=0; f<0x0100; f++) {
< 		ftHandle->charset.ebc2asc[f] = ft2asc[f];
< 		ftHandle->charset.asc2ebc[f] = asc2ft[f];
---
> 	for(f=0;f<0x0100;f++)
>     {
>         ftHandle->charset.ebc2asc[f] = ft2asc[f];
>         ftHandle->charset.asc2ebc[f] = asc2ft[f];
304a335
> 	session->ft				= ftHandle;
308,309c339,340
< 	return ftHandle;
< }
---
>  	return ftHandle;
>  }
311,312c342,344
< LIB3270_EXPORT int lib3270_reset_ft_callbacks(H3270 *hSession) {
< 	CHECK_SESSION_HANDLE(hSession);
---
>  LIB3270_EXPORT int lib3270_reset_ft_callbacks(H3270 *hSession)
>  {
>  	CHECK_SESSION_HANDLE(hSession);
314c346,347
< 	if(!hSession->ft) {
---
>  	if(!hSession->ft)
> 	{
327c360
< }
---
>  }
329,330c362,364
< LIB3270_EXPORT void lib3270_ft_set_user_data(H3270 *hSession, void *ptr) {
< 	H3270FT * ft;
---
>  LIB3270_EXPORT void lib3270_ft_set_user_data(H3270 *hSession, void *ptr)
>  {
>  	H3270FT * ft;
340c374
< }
---
>  }
342,343c376,378
< LIB3270_EXPORT void * lib3270_ft_get_user_data(H3270 *hSession) {
< 	H3270FT * ft;
---
>  LIB3270_EXPORT void * lib3270_ft_get_user_data(H3270 *hSession)
>  {
>  	H3270FT * ft;
352c387
< }
---
>  }
354,356c389,392
< LIB3270_EXPORT int lib3270_ft_start(H3270 *hSession) {
< 	static const char	* rec			= "FVU";
< 	static const char	* un[]			= { "tracks", "cylinders", "avblock" };
---
>  LIB3270_EXPORT int lib3270_ft_start(H3270 *hSession)
>  {
>  	static const char	* rec			= "FVU";
>  	static const char	* un[]			= { "tracks", "cylinders", "avblock" };
358,359c394,395
< 	char 				  op[4096];
< 	char				  buffer[4096];
---
>  	char 				  op[4096];
>  	char				  buffer[4096];
361,363c397,399
< 	unsigned short		  recfm;
< 	unsigned short		  units;
< 	H3270FT 			* ft;
---
>  	unsigned short		  recfm;
>  	unsigned short		  units;
>  	H3270FT 			* ft;
371,372c407,408
< 	recfm			= (ft->flags & LIB3270_FT_RECORD_FORMAT_MASK) >> 8;
< 	units			= (ft->flags & LIB3270_FT_ALLOCATION_UNITS_MASK) >> 12;
---
>  	recfm			= (ft->flags & LIB3270_FT_RECORD_FORMAT_MASK) >> 8;
>  	units			= (ft->flags & LIB3270_FT_ALLOCATION_UNITS_MASK) >> 12;
377c413,414
< 	if(ft->flags & LIB3270_FT_OPTION_RECEIVE) {
---
> 	if(ft->flags & LIB3270_FT_OPTION_RECEIVE)
> 	{
380,388c417,427
< 		    ft->host,
< 		    "\nReceiving file %s (%s %s %s %s)\n",
< 		    ft->local,
< 		    ft->ascii_flag	?	"ASCII" 	: "BINARY",
< 		    ft->cr_flag 	?	"CRLF" 		: "NOCRLF",
< 		    ft->remap_flag	?	"REMAP" 	: "NOREMAP",
< 		    ft->unix_text	?	"LF Only"	: "CR/LF"
< 		);
< 	} else {
---
> 					ft->host,
> 					"\nReceiving file %s (%s %s %s %s)\n",
> 					ft->local,
> 					ft->ascii_flag	?	"ASCII" 	: "BINARY",
> 					ft->cr_flag 	?	"CRLF" 		: "NOCRLF",
> 					ft->remap_flag	?	"REMAP" 	: "NOREMAP",
> 					ft->unix_text	?	"LF Only"	: "CR/LF"
> 				);
> 	}
> 	else
> 	{
390c429,430
< 		if(fseek(ft->local_file,0L,SEEK_END) < 0) {
---
> 		if(fseek(ft->local_file,0L,SEEK_END) < 0)
> 		{
398,406c438,446
< 		    ft->host,
< 		    "\nSending file %s (%ld bytes %s %s %s %s)\n",
< 		    ft->local,
< 		    ft->length,
< 		    ft->ascii_flag	?	"ASCII" 	: "BINARY",
< 		    ft->cr_flag		?	"CRLF"		: "NOCRLF",
< 		    ft->remap_flag	?	"REMAP" 	: "NOREMAP",
< 		    ft->unix_text	?	"LF only"	: "CR/LF"
< 		);
---
> 				ft->host,
> 				"\nSending file %s (%ld bytes %s %s %s %s)\n",
> 				ft->local,
> 				ft->length,
> 				ft->ascii_flag	?	"ASCII" 	: "BINARY",
> 				ft->cr_flag		?	"CRLF"		: "NOCRLF",
> 				ft->remap_flag	?	"REMAP" 	: "NOREMAP",
> 				ft->unix_text	?	"LF only"	: "CR/LF"
> 			);
411,416c451,456
< 	/* Build the ind$file command */
< 	snprintf(op,4095,"%s%s%s",
< 	         (ft->flags & LIB3270_FT_OPTION_ASCII) 	? " ASCII"	: "",
< 	         (ft->flags & LIB3270_FT_OPTION_CRLF) 	? " CRLF"	: "",
< 	         (ft->flags & LIB3270_FT_OPTION_APPEND)	? " APPEND"	: ""
< 	        );
---
>  	/* Build the ind$file command */
>  	snprintf(op,4095,"%s%s%s",
> 						(ft->flags & LIB3270_FT_OPTION_ASCII) 	? " ASCII"	: "",
> 						(ft->flags & LIB3270_FT_OPTION_CRLF) 	? " CRLF"	: "",
> 						(ft->flags & LIB3270_FT_OPTION_APPEND)	? " APPEND"	: ""
> 			);
420c460,461
< 	if(!(ft->flags & LIB3270_FT_OPTION_RECEIVE)) {
---
> 	if(!(ft->flags & LIB3270_FT_OPTION_RECEIVE))
> 	{
423c464,465
< 		if(lib3270_is_tso(hSession)) {
---
> 		if(lib3270_is_tso(hSession))
> 		{
425c467,468
< 			if(recfm > 0) {
---
> 			if(recfm > 0)
> 			{
435c478,479
< 			if(units > 0) {
---
> 			if(units > 0)
> 			{
438c482,483
< 				if(ft->primspace > 0) {
---
> 				if(ft->primspace > 0)
> 				{
445c490,492
< 		} else {
---
> 		}
> 		else
> 		{
447c494,495
< 			if(recfm > 0) {
---
> 			if(recfm > 0)
> 			{
458,459c506,507
< 	         (ft->flags & LIB3270_FT_OPTION_RECEIVE) ? "GET" : "PUT",
< 	         ft->remote );
---
> 										(ft->flags & LIB3270_FT_OPTION_RECEIVE) ? "GET" : "PUT",
> 										ft->remote );
461c509,510
< 	if(*op) {
---
> 	if(*op)
> 	{
476,477c525,527
< 	if (!flen || flen < strlen(buffer) - 1) {
< 		lib3270_write_log(ft->host, "ft", "Unable to send command \"%s\" (flen=%d szBuffer=%u)",buffer,flen,(unsigned int) strlen(buffer));
---
> 	if (!flen || flen < strlen(buffer) - 1)
> 	{
> 		lib3270_write_log(ft->host, "Unable to send command \"%s\" (flen=%d szBuffer=%d)",buffer,flen,strlen(buffer));
493c543
< }
---
>  }
497c547,548
< void ft_message(H3270FT *ft, const char *msg) {
---
> void ft_message(H3270FT *ft, const char *msg)
> {
502c553,554
< static double finish(H3270FT *ft) {
---
> static double finish(H3270FT *ft)
> {
508,509c560,561
< 	             ((double)(t1.tv_sec - ft->starting_time.tv_sec) +
< 	              (double)(t1.tv_usec - ft->starting_time.tv_usec) / 1.0e6);
---
> 		((double)(t1.tv_sec - ft->starting_time.tv_sec) +
> 		 (double)(t1.tv_usec - ft->starting_time.tv_usec) / 1.0e6);
512c564,565
< 	if(ft->local_file) {
---
> 	if(ft->local_file)
> 	{
525c578,579
< void ft_complete(H3270FT *ft, const char *errmsg) {
---
> void ft_complete(H3270FT *ft, const char *errmsg)
> {
529c583,584
< void ft_failed(H3270FT *ft, const char *errmsg) {
---
> void ft_failed(H3270FT *ft, const char *errmsg)
> {
533c588,589
< LIB3270_EXPORT int lib3270_ft_destroy(H3270 *hSession, const char *reason) {
---
> LIB3270_EXPORT int lib3270_ft_destroy(H3270 *hSession, const char *reason)
> {
542c598,599
< 	if (session->state != LIB3270_FT_STATE_NONE) {
---
> 	if (session->state != LIB3270_FT_STATE_NONE)
> 	{
546c603,604
< 	if(session->local_file) {
---
> 	if(session->local_file)
> 	{
559c617,618
< void ft_update_length(H3270FT *session) {
---
> void ft_update_length(H3270FT *session)
> {
562c621,622
< 	if(session->ft_length > 1024.0) {
---
> 	if(session->ft_length > 1024.0)
> 	{
567,568c627,628
< 		             ((double)(t1.tv_sec - session->starting_time.tv_sec) +
< 		              (double)(t1.tv_usec - session->starting_time.tv_usec) / 1.0e6);
---
> 			((double)(t1.tv_sec - session->starting_time.tv_sec) +
> 			 (double)(t1.tv_usec - session->starting_time.tv_usec) / 1.0e6);
579c639,640
< void ft_running(H3270FT *ft, Boolean is_cut) {
---
> void ft_running(H3270FT *ft, Boolean is_cut)
> {
594c655,656
< LIB3270_EXPORT struct lib3270_ft_callbacks * lib3270_get_ft_callbacks(H3270 *session, unsigned short sz) {
---
> LIB3270_EXPORT struct lib3270_ft_callbacks * lib3270_get_ft_callbacks(H3270 *session, unsigned short sz)
> {
609,610c671,674
< void ft_aborting(H3270FT *h, const char *reason) {
< 	if (h->state == LIB3270_FT_STATE_RUNNING || h->state == LIB3270_FT_STATE_ABORT_WAIT) {
---
> void ft_aborting(H3270FT *h, const char *reason)
> {
> 	if (h->state == LIB3270_FT_STATE_RUNNING || h->state == LIB3270_FT_STATE_ABORT_WAIT)
> 	{
618c682,683
< static void ft_connected(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno)) {
---
> static void ft_connected(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno))
> {
623,624c688,690
< /// @brief Process an abort from no longer being in 3270 mode.
< static void ft_in3270(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno)) {
---
> /* Process an abort from no longer being in 3270 mode. */
> static void ft_in3270(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno))
> {
629c695,696
< LIB3270_EXPORT LIB3270_FT_STATE lib3270_get_ft_state(H3270 *session) {
---
> LIB3270_EXPORT LIB3270_FT_STATE lib3270_get_ft_state(H3270 *session)
> {
637,656d703
< 
< LIB3270_EXPORT int lib3270_send(H3270 *hSession, const char GNUC_UNUSED(*from), const char GNUC_UNUSED(*to), const char GNUC_UNUSED(**args)) {
< 
< 	FAIL_IF_NOT_ONLINE(hSession);
< 
< 	if(hSession->ft)
< 		return EBUSY;
< 
< 	return ENOTSUP;
< }
< 
< LIB3270_EXPORT int lib3270_receive(H3270 *hSession, const char GNUC_UNUSED(*from), const char GNUC_UNUSED(*to), const char GNUC_UNUSED(**args)) {
< 	FAIL_IF_NOT_ONLINE(hSession);
< 
< 	if(hSession->ft)
< 		return EBUSY;
< 
< 	return ENOTSUP;
< }
< 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft_cut.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft_cut.c
69c69,70
< static const struct {
---
> static const struct
> {
73,120c74,109
< 	{
< 		0x5e,	/* ';' */
< 		{
< 			0x40,0xc1,0xc2,0xc3, 0xc4,0xc5,0xc6,0xc7, 0xc8,0xc9,0xd1,0xd2,
< 			0xd3,0xd4,0xd5,0xd6, 0xd7,0xd8,0xd9,0xe2, 0xe3,0xe4,0xe5,0xe6,
< 			0xe7,0xe8,0xe9,0x81, 0x82,0x83,0x84,0x85, 0x86,0x87,0x88,0x89,
< 			0x91,0x92,0x93,0x94, 0x95,0x96,0x97,0x98, 0x99,0xa2,0xa3,0xa4,
< 			0xa5,0xa6,0xa7,0xa8, 0xa9,0xf0,0xf1,0xf2, 0xf3,0xf4,0xf5,0xf6,
< 			0xf7,0xf8,0xf9,0x6c, 0x50,0x6d,0x4d,0x5d, 0x4c,0x4e,0x6b,0x60,
< 			0x4b,0x61,0x7a,0x6e, 0x6f
< 		}
< 	},
< 	{
< 		0x7e,	/* '=' */
< 		{
< 			0x20,0x41,0x42,0x43, 0x44,0x45,0x46,0x47, 0x48,0x49,0x4a,0x4b,
< 			0x4c,0x4d,0x4e,0x4f, 0x50,0x51,0x52,0x53, 0x54,0x55,0x56,0x57,
< 			0x58,0x59,0x5a,0x61, 0x62,0x63,0x64,0x65, 0x66,0x67,0x68,0x69,
< 			0x6a,0x6b,0x6c,0x6d, 0x6e,0x6f,0x70,0x71, 0x72,0x73,0x74,0x75,
< 			0x76,0x77,0x78,0x79, 0x7a,0x30,0x31,0x32, 0x33,0x34,0x35,0x36,
< 			0x37,0x38,0x39,0x25, 0x26,0x27,0x28,0x29, 0x2a,0x2b,0x2c,0x2d,
< 			0x2e,0x2f,0x3a,0x3b, 0x3f
< 		}
< 	},
< 	{
< 		0x5c,	/* '*' */
< 		{
< 			0x00,0x00,0x01,0x02, 0x03,0x04,0x05,0x06, 0x07,0x08,0x09,0x0a,
< 			0x0b,0x0c,0x0d,0x0e, 0x0f,0x10,0x11,0x12, 0x13,0x14,0x15,0x16,
< 			0x17,0x18,0x19,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
< 			0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
< 			0x00,0x00,0x00,0x00, 0x00,0x3c,0x3d,0x3e, 0x00,0xfa,0xfb,0xfc,
< 			0xfd,0xfe,0xff,0x7b, 0x7c,0x7d,0x7e,0x7f, 0x1a,0x1b,0x1c,0x1d,
< 			0x1e,0x1f,0x00,0x00, 0x00
< 		}
< 	},
< 	{
< 		0x7d,	/* '\'' */
< 		{
< 			0x00,0xa0,0xa1,0xea, 0xeb,0xec,0xed,0xee, 0xef,0xe0,0xe1,0xaa,
< 			0xab,0xac,0xad,0xae, 0xaf,0xb0,0xb1,0xb2, 0xb3,0xb4,0xb5,0xb6,
< 			0xb7,0xb8,0xb9,0x80, 0x00,0xca,0xcb,0xcc, 0xcd,0xce,0xcf,0xc0,
< 			0x00,0x8a,0x8b,0x8c, 0x8d,0x8e,0x8f,0x90, 0x00,0xda,0xdb,0xdc,
< 			0xdd,0xde,0xdf,0xd0, 0x00,0x00,0x21,0x22, 0x23,0x24,0x5b,0x5c,
< 			0x00,0x5e,0x5f,0x00, 0x9c,0x9d,0x9e,0x9f, 0xba,0xbb,0xbc,0xbd,
< 			0xbe,0xbf,0x9a,0x9b, 0x00
< 		}
< 	}
---
>     {	0x5e,	/* ';' */
> 	{ 0x40,0xc1,0xc2,0xc3, 0xc4,0xc5,0xc6,0xc7, 0xc8,0xc9,0xd1,0xd2,
> 	  0xd3,0xd4,0xd5,0xd6, 0xd7,0xd8,0xd9,0xe2, 0xe3,0xe4,0xe5,0xe6,
> 	  0xe7,0xe8,0xe9,0x81, 0x82,0x83,0x84,0x85, 0x86,0x87,0x88,0x89,
> 	  0x91,0x92,0x93,0x94, 0x95,0x96,0x97,0x98, 0x99,0xa2,0xa3,0xa4,
> 	  0xa5,0xa6,0xa7,0xa8, 0xa9,0xf0,0xf1,0xf2, 0xf3,0xf4,0xf5,0xf6,
> 	  0xf7,0xf8,0xf9,0x6c, 0x50,0x6d,0x4d,0x5d, 0x4c,0x4e,0x6b,0x60,
> 	  0x4b,0x61,0x7a,0x6e, 0x6f }
>     },
>     {	0x7e,	/* '=' */
> 	{ 0x20,0x41,0x42,0x43, 0x44,0x45,0x46,0x47, 0x48,0x49,0x4a,0x4b,
> 	  0x4c,0x4d,0x4e,0x4f, 0x50,0x51,0x52,0x53, 0x54,0x55,0x56,0x57,
> 	  0x58,0x59,0x5a,0x61, 0x62,0x63,0x64,0x65, 0x66,0x67,0x68,0x69,
> 	  0x6a,0x6b,0x6c,0x6d, 0x6e,0x6f,0x70,0x71, 0x72,0x73,0x74,0x75,
> 	  0x76,0x77,0x78,0x79, 0x7a,0x30,0x31,0x32, 0x33,0x34,0x35,0x36,
> 	  0x37,0x38,0x39,0x25, 0x26,0x27,0x28,0x29, 0x2a,0x2b,0x2c,0x2d,
> 	  0x2e,0x2f,0x3a,0x3b, 0x3f }
>     },
>     {	0x5c,	/* '*' */
> 	{ 0x00,0x00,0x01,0x02, 0x03,0x04,0x05,0x06, 0x07,0x08,0x09,0x0a,
> 	  0x0b,0x0c,0x0d,0x0e, 0x0f,0x10,0x11,0x12, 0x13,0x14,0x15,0x16,
> 	  0x17,0x18,0x19,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
> 	  0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
> 	  0x00,0x00,0x00,0x00, 0x00,0x3c,0x3d,0x3e, 0x00,0xfa,0xfb,0xfc,
> 	  0xfd,0xfe,0xff,0x7b, 0x7c,0x7d,0x7e,0x7f, 0x1a,0x1b,0x1c,0x1d,
> 	  0x1e,0x1f,0x00,0x00, 0x00 }
>     },
>     {	0x7d,	/* '\'' */
> 	{ 0x00,0xa0,0xa1,0xea, 0xeb,0xec,0xed,0xee, 0xef,0xe0,0xe1,0xaa,
> 	  0xab,0xac,0xad,0xae, 0xaf,0xb0,0xb1,0xb2, 0xb3,0xb4,0xb5,0xb6,
> 	  0xb7,0xb8,0xb9,0x80, 0x00,0xca,0xcb,0xcc, 0xcd,0xce,0xcf,0xc0,
> 	  0x00,0x8a,0x8b,0x8c, 0x8d,0x8e,0x8f,0x90, 0x00,0xda,0xdb,0xdc,
> 	  0xdd,0xde,0xdf,0xd0, 0x00,0x00,0x21,0x22, 0x23,0x24,0x5b,0x5c,
> 	  0x00,0x5e,0x5f,0x00, 0x9c,0x9d,0x9e,0x9f, 0xba,0xbb,0xbc,0xbd,
> 	  0xbe,0xbf,0x9a,0x9b, 0x00 }
>     }
144c133,134
< static int upload_convert(H3270 *hSession, unsigned char *buf, int len) {
---
> static int upload_convert(H3270 *hSession, unsigned char *buf, int len)
> {
149c139,140
< 	while (len--) {
---
> 	while (len--)
> 	{
155,156c146,148
< retry:
< 		if (ft->quadrant < 0) {
---
> 	    retry:
> 		if (ft->quadrant < 0)
> 		{
158c150,151
< 			for (ft->quadrant = 0; ft->quadrant < NQ; ft->quadrant++) {
---
> 			for (ft->quadrant = 0; ft->quadrant < NQ; ft->quadrant++)
> 			{
162c155,156
< 			if (ft->quadrant >= NQ) {
---
> 			if (ft->quadrant >= NQ)
> 			{
170c164,165
< 		if (c < 0x40 || c > 0xf9) {
---
> 		if (c < 0x40 || c > 0xf9)
> 		{
177c172,173
< 		if (ixp == (char *)NULL) {
---
> 		if (ixp == (char *)NULL)
> 		{
189c185,186
< 		if (ft->quadrant != OTHER_2 && c != XLATE_NULL && !conv[ft->quadrant].xlate[ix]) {
---
> 		if (ft->quadrant != OTHER_2 && c != XLATE_NULL && !conv[ft->quadrant].xlate[ix])
> 		{
214c211,212
< static int download_convert(H3270FT *ft, unsigned const char *buf, unsigned len, unsigned char *xobuf) {
---
> static int download_convert(H3270FT *ft, unsigned const char *buf, unsigned len, unsigned char *xobuf)
> {
219c217,218
< 	while (len--) {
---
> 	while (len--)
> 	{
226,227c225,228
< 		if (!c) {
< 			if (ft->quadrant != OTHER_2) {
---
> 		if (!c)
> 		{
> 			if (ft->quadrant != OTHER_2)
> 			{
242c243,244
< 			if (ixp != (unsigned char *)NULL) {
---
> 			if (ixp != (unsigned char *)NULL)
> 			{
251c253,254
< 		for (ft->quadrant = 0; ft->quadrant < NQ; ft->quadrant++) {
---
> 		for (ft->quadrant = 0; ft->quadrant < NQ; ft->quadrant++)
> 		{
264c267,268
< 		if (ft->quadrant >= NQ) {
---
> 		if (ft->quadrant >= NQ)
> 		{
277,279c281,285
< void ft_cut_data(H3270 *hSession) {
< 	switch (hSession->ea_buf[O_FRAME_TYPE].cc) {
< 	case FT_CONTROL_CODE:
---
> void ft_cut_data(H3270 *hSession)
> {
> 	switch (hSession->ea_buf[O_FRAME_TYPE].cc)
> 	{
>     case FT_CONTROL_CODE:
283c289
< 	case FT_DATA_REQUEST:
---
>     case FT_DATA_REQUEST:
287c293
< 	case FT_RETRANSMIT:
---
>     case FT_RETRANSMIT:
291c297
< 	case FT_DATA:
---
>     case FT_DATA:
295c301
< 	default:
---
>     default:
305c311,312
< static void cut_control_code(H3270 *hSession) {
---
> static void cut_control_code(H3270 *hSession)
> {
315c322,323
< 	switch (code) {
---
> 	switch (code)
> 	{
339c347,348
< 		if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_SENT && ft->saved_errmsg != CN) {
---
> 		if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_SENT && ft->saved_errmsg != CN)
> 		{
342c351,353
< 		} else {
---
> 		}
> 		else
> 		{
376c387,388
< static void cut_data_request(H3270 *hSession) {
---
> static void cut_data_request(H3270 *hSession)
> {
386c398,399
< 	if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT) {
---
> 	if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT)
> 	{
394c407,408
< 	while (count < O_UP_MAX && (c = xlate_getc(hSession->ft)) != EOF) {
---
> 	while (count < O_UP_MAX && (c = xlate_getc(hSession->ft)) != EOF)
> 	{
400c414,415
< 	if (ferror(((H3270FT *) hSession->ft)->local_file)) {
---
> 	if (ferror(((H3270FT *) hSession->ft)->local_file))
> 	{
413c428,429
< 	if (!count && feof(((H3270FT *) hSession->ft)->local_file)) {
---
> 	if (!count && feof(((H3270FT *) hSession->ft)->local_file))
> 	{
445c461,462
< static void  cut_retransmit(H3270 *hSession) {
---
> static void  cut_retransmit(H3270 *hSession)
> {
453c470,471
< static unsigned from6(H3270 *hSession, unsigned char c) {
---
> static unsigned from6(H3270 *hSession, unsigned char c)
> {
466c484,485
< static void cut_data(H3270 *hSession) {
---
> static void cut_data(H3270 *hSession)
> {
474c493,494
< 	if (ft->state == LIB3270_FT_STATE_ABORT_WAIT) {
---
> 	if (ft->state == LIB3270_FT_STATE_ABORT_WAIT)
> 	{
481c501
< 	             from6(hSession, hSession->ea_buf[O_DT_LEN + 1].cc);
---
> 		     from6(hSession, hSession->ea_buf[O_DT_LEN + 1].cc);
483c503,504
< 	if ((int)raw_length > O_RESPONSE - O_DT_DATA) {
---
> 	if ((int)raw_length > O_RESPONSE - O_DT_DATA)
> 	{
491c512,513
< 	if (raw_length == 2 && cvbuf[0] == EOF_DATA1 && cvbuf[1] == EOF_DATA2) {
---
> 	if (raw_length == 2 && cvbuf[0] == EOF_DATA1 && cvbuf[1] == EOF_DATA2)
> 	{
498c520,521
< 	if (conv_length < 0) {
---
> 	if (conv_length < 0)
> 	{
503c526,527
< 	if (fwrite((char *)cvbuf, conv_length, 1, ft->local_file) == 0) {
---
> 	if (fwrite((char *)cvbuf, conv_length, 1, ft->local_file) == 0)
> 	{
505c529,531
< 	} else {
---
> 	}
> 	else
> 	{
515c541,542
< static void cut_ack(H3270 *hSession) {
---
> static void cut_ack(H3270 *hSession)
> {
523c550,551
< static void cut_abort(H3270 *hSession, unsigned short reason, const char *fmt, ...) {
---
> static void cut_abort(H3270 *hSession, unsigned short reason, const char *fmt, ...)
> {
553c581,582
< static int xlate_getc(H3270FT *ft) {
---
> static int xlate_getc(H3270FT *ft)
> {
561c590,591
< 	if (ft->xlate_buffered) {
---
> 	if (ft->xlate_buffered)
> 	{
575c605,606
< 	if (ft->ascii_flag && ft->cr_flag && !ft->ft_last_cr && c == '\n') {
---
> 	if (ft->ascii_flag && ft->cr_flag && !ft->ft_last_cr && c == '\n')
> 	{
577c608,610
< 	} else {
---
> 	}
> 	else
> 	{
588c621,622
< 	if (nc > 1) {
---
> 	if (nc > 1)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft_dft.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ft_dft.c
40,41c40,41
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
45d44
< #include <lib3270/filetransfer.h>
70c69,70
< struct data_buffer {
---
> struct data_buffer
> {
94c94,95
< void ft_dft_data(H3270 *hSession, unsigned char *data, int GNUC_UNUSED(length)) {
---
> void ft_dft_data(H3270 *hSession, unsigned char *data, int GNUC_UNUSED(length))
> {
99c100,101
< 	if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_NONE) {
---
> 	if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_NONE)
> 	{
113,114c115,117
< 	switch (data_type) {
< 	case TR_OPEN_REQ:
---
> 	switch (data_type)
> 	{
>     case TR_OPEN_REQ:
118c121
< 	case TR_INSERT_REQ:	/* Insert Request */
---
>     case TR_INSERT_REQ:	/* Insert Request */
122c125
< 	case TR_DATA_INSERT:
---
>     case TR_DATA_INSERT:
126c129
< 	case TR_SET_CUR_REQ:
---
>     case TR_SET_CUR_REQ:
130c133
< 	case TR_GET_REQ:
---
>     case TR_GET_REQ:
138c141
< 	default:
---
>     default:
145c148,149
< static void dft_open_request(H3270 *hSession, unsigned short len, unsigned char *cp) {
---
> static void dft_open_request(H3270 *hSession, unsigned short len, unsigned char *cp)
> {
152c156,157
< 	if (len == 0x23) {
---
> 	if (len == 0x23)
> 	{
154c159,161
< 	} else if (len == 0x29) {
---
> 	}
> 	else if (len == 0x29)
> 	{
160c167,169
< 	} else {
---
> 	}
> 	else
> 	{
168c177,178
< 	while (s >= namebuf && *s == ' ') {
---
> 	while (s >= namebuf && *s == ' ')
> 	{
172c182,183
< 	if (recsz) {
---
> 	if (recsz)
> 	{
174c185,187
< 	} else {
---
> 	}
> 	else
> 	{
180c193,194
< 	else {
---
> 	else
> 	{
200c214,215
< static void dft_insert_request(H3270 *hSession) {
---
> static void dft_insert_request(H3270 *hSession)
> {
206c221,222
< static void dft_data_insert(H3270 *hSession, struct data_buffer *data_bufr) {
---
> static void dft_data_insert(H3270 *hSession, struct data_buffer *data_bufr)
> {
212c228,229
< 	if(!ft->message_flag && lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT) {
---
> 	if(!ft->message_flag && lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT)
> 	{
231c248,249
< 	if (ft->message_flag) {
---
> 	if (ft->message_flag)
> 	{
254c272,274
< 		} else if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_SENT && ((H3270FT *) hSession->ft)->abort_string != CN) {
---
> 		}
> 		else if (lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_SENT && ((H3270FT *) hSession->ft)->abort_string != CN)
> 		{
259c279,281
< 		} else {
---
> 		}
> 		else
> 		{
267c289,290
< 		if (ft->ascii_flag && ft->remap_flag) {
---
> 		if (ft->ascii_flag && ft->remap_flag)
> 		{
272c295,296
< 			while (len--) {
---
> 			while (len--)
> 			{
279c303,304
< 		if (ft->unix_text) {
---
> 		if (ft->unix_text)
> 		{
288c313,314
< 				if (l) {
---
> 				if (l)
> 				{
306c332
< 			dft_abort(hSession,TR_DATA_INSERT, _( "Error \"%s\" writing to local file (rc=%d)" ), strerror(errno), errno);
---
> 			dft_abort(hSession,TR_DATA_INSERT, _( "Error \"%s\" writing to local file (rc=%d)" ) , strerror(errno), errno);
328c354,355
< static void dft_set_cur_req(H3270 *hSession) {
---
> static void dft_set_cur_req(H3270 *hSession)
> {
334c361,362
< static void dft_get_request(H3270 *hSession) {
---
> static void dft_get_request(H3270 *hSession)
> {
343c371,372
< 	if (!ft->message_flag && lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT) {
---
> 	if (!ft->message_flag && lib3270_get_ft_state(hSession) == LIB3270_FT_STATE_ABORT_WAIT)
> 	{
349c378
< 	lib3270_set_dft_buffersize(hSession,hSession->dft_buffersize);
---
> 	set_dft_buffersize(hSession);
354,355c383,386
< 	while (!ft->dft_eof && numbytes) {
< 		if (ft->unix_text) {
---
> 	while (!ft->dft_eof && numbytes)
> 	{
> 		if (ft->unix_text)
> 		{
362c393,394
< 			if (c == EOF) {
---
> 			if (c == EOF)
> 			{
365,366c397,400
< 			if (!ft->ft_last_cr && c == '\n') {
< 				if (numbytes < 2) {
---
> 			if (!ft->ft_last_cr && c == '\n')
> 			{
> 				if (numbytes < 2)
> 				{
382c416,418
< 		} else {
---
> 		}
> 		else
> 		{
385,386c421,423
< 			if (numread <= 0) {
< 				lib3270_write_log(hSession,"ft","Error %s reading source file (rc=%d)",strerror(errno),errno);
---
> 			if (numread <= 0)
> 			{
> 				lib3270_write_log(hSession,"Error %s reading source file (rc=%d)",strerror(errno),errno);
390c427,428
< 			if (ft->ascii_flag && ft->remap_flag) {
---
> 			if (ft->ascii_flag && ft->remap_flag)
> 			{
395c433,434
< 				while (i) {
---
> 				while (i)
> 				{
406c445,446
< 		if (feof(ft->local_file) || ferror(ft->local_file)) {
---
> 		if (feof(ft->local_file) || ferror(ft->local_file))
> 		{
412c452,453
< 	if (ferror(((H3270FT *) hSession->ft)->local_file)) {
---
> 	if (ferror(((H3270FT *) hSession->ft)->local_file))
> 	{
423c464,465
< 	if (total_read) {
---
> 	if (total_read)
> 	{
436c478,479
< 		if (feof(ft->local_file)) {
---
> 		if (feof(ft->local_file))
> 		{
440c483,485
< 	} else {
---
> 	}
> 	else
> 	{
456c501,502
< 	if (ft->dft_savebuf_len > ft->dft_savebuf_max) {
---
> 	if (ft->dft_savebuf_len > ft->dft_savebuf_max)
> 	{
469c515,516
< static void dft_close_request(H3270 *hSession) {
---
> static void dft_close_request(H3270 *hSession)
> {
486c533,534
< static void dft_abort(H3270 *hSession, unsigned short code, const char *fmt, ...) {
---
> static void dft_abort(H3270 *hSession, unsigned short code, const char *fmt, ...)
> {
515c563,564
< filter_len(char *s, register int len) {
---
> filter_len(char *s, register int len)
> {
528c577,578
< void dft_read_modified(H3270 *hSession) {
---
> void dft_read_modified(H3270 *hSession)
> {
531c581,582
< 	if(ft->dft_savebuf_len) {
---
> 	if(ft->dft_savebuf_len)
> 	{
541c592,594
< /*
---
> /**
>  * Update the buffersize for generating a Query Reply.
>  */
553,560d605
< */
< 
< #endif /*]*/
< 
< LIB3270_EXPORT int	lib3270_set_dft_buffersize(H3270 *hSession, int dft_buffersize) {
< 	CHECK_SESSION_HANDLE(hSession);
< 
< 	hSession->dft_buffersize = dft_buffersize;
562,572d606
< 	if (hSession->dft_buffersize == 0)
< 		hSession->dft_buffersize = DFT_BUF;
< 
< 	if (hSession->dft_buffersize > DFT_MAX_BUF)
< 		hSession->dft_buffersize = DFT_MAX_BUF;
< 
< 	if (hSession->dft_buffersize < DFT_MIN_BUF)
< 		hSession->dft_buffersize = DFT_MIN_BUF;
< 
< 	return 0;
< }
573a608
> #endif /*]*/
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ftmessages.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft/ftmessages.c
133c133
< 	*/
---
> */
230c230,231
< LIB3270_EXPORT const LIB3270_FT_MESSAGE * lib3270_translate_ft_message(const char *msg) {
---
> LIB3270_EXPORT const LIB3270_FT_MESSAGE * lib3270_translate_ft_message(const char *msg)
> {
233,234c234,237
< 	for(ix = 0; ix < (sizeof(ftmsg)/sizeof(ftmsg[0])); ix++) {
< 		if(strncasecmp(msg,ftmsg[ix].id,7) == 0) {
---
> 	for(ix = 0; ix < (sizeof(ftmsg)/sizeof(ftmsg[0])); ix++)
> 	{
> 		if(strncasecmp(msg,ftmsg[ix].id,7) == 0)
> 		{
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/ft: set.c
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/host.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/host.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,14c6,21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como host.c e possui 1078 linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
24a27,29
>  * licinio@bb.com.br		(Licínio Luis Branco)
>  * kraucer@bb.com.br		(Kraucer Fernandes Mazuco)
>  * macmiranda@bb.com.br		(Marco Aurélio Caldas Miranda)
27a33
> 
35c41
< #include <malloc.h>
---
> 	#include <malloc.h>
40c46
< //#include "resources.h"
---
> #include "resources.h"
64c70,71
< static int check_for_auto_reconnect(H3270 *hSession, void GNUC_UNUSED(*userdata)) {
---
> static int check_for_auto_reconnect(H3270 *hSession, void GNUC_UNUSED(*userdata))
> {
66c73,74
< 	if(hSession->auto_reconnect_inprogress) {
---
> 	if(hSession->auto_reconnect_inprogress)
> 	{
69c77
< 		if(hSession->cbk.reconnect(hSession,0))
---
> 		if(lib3270_reconnect(hSession,0))
86c94,95
< int lib3270_activate_auto_reconnect(H3270 *hSession, unsigned long msec) {
---
> int lib3270_activate_auto_reconnect(H3270 *hSession, unsigned long msec)
> {
96c105,106
< LIB3270_EXPORT int lib3270_disconnect(H3270 *h) {
---
> LIB3270_EXPORT int lib3270_disconnect(H3270 *h)
> {
101,113c111,120
< /// @brief Do disconnect.
< /// @param hSession Session handle.
< /// @param failed	Non zero if it was a failure.
< int host_disconnect(H3270 *hSession, int failed) {
< 
< 	CHECK_SESSION_HANDLE(hSession);
< 
< 	debug("%s: connected=%s half connected=%s network=%s",
< 	      __FUNCTION__,
< 	      (CONNECTED ? "Yes" : "No"),
< 	      (HALF_CONNECTED ? "Yes" : "No"),
< 	      (hSession->network.module->is_connected(hSession) ? "Active" : "Inactive")
< 	     );
---
> int host_disconnect(H3270 *hSession, int failed)
> {
>     CHECK_SESSION_HANDLE(hSession);
> 
>     debug("%s: connected=%s half connected=%s network=%s",
> 				__FUNCTION__,
> 				(CONNECTED ? "Yes" : "No"),
> 				(HALF_CONNECTED ? "Yes" : "No"),
> 				(hSession->network.module->is_connected(hSession) ? "Active" : "Inactive")
> 		);
115c122,123
< 	if (CONNECTED || HALF_CONNECTED) {
---
> 	if (CONNECTED || HALF_CONNECTED)
> 	{
122,124c130,137
< 		//
< 		// Remember a disconnect from ANSI mode, to keep screen tracing in sync.
< 		//
---
> 		if(failed && lib3270_get_toggle(hSession,LIB3270_TOGGLE_RECONNECT))
> 			lib3270_activate_auto_reconnect(hSession,failed ? RECONNECT_ERR_MS : RECONNECT_MS);
> 
> 		/*
> 		 * Remember a disconnect from ANSI mode, to keep screen tracing
> 		 * in sync.
> 		 */
> #if defined(X3270_TRACE) /*[*/
126a140
> #endif /*]*/
130,142d143
< 		if(hSession->connection.error) {
< 
< 			// TODO: Add 'reconnect' option in the popup dialog for optional auto reconnect.
< 			lib3270_popup(hSession,hSession->connection.error,!hSession->auto_reconnect_inprogress);
< 
< 			lib3270_free(hSession->connection.error);
< 			hSession->connection.error = NULL;
< 
< 		}
< 
< 		if(failed && hSession->connection.retry && lib3270_get_toggle(hSession,LIB3270_TOGGLE_RECONNECT))
< 			lib3270_activate_auto_reconnect(hSession,hSession->connection.retry);
< 
157c158,159
< int lib3270_set_cstate(H3270 *hSession, LIB3270_CSTATE cstate) {
---
> int lib3270_set_cstate(H3270 *hSession, LIB3270_CSTATE cstate)
> {
160c162,163
< 	if(hSession->connection.state != cstate) {
---
> 	if(hSession->connection.state != cstate)
> 	{
162,165c165,168
< 		    hSession,
< 		    "Connection state changes from %s to %s.\n",
< 		    lib3270_connection_state_get_name(hSession->connection.state),
< 		    lib3270_connection_state_get_name(cstate)
---
> 			hSession,
> 			"Connection state changes from %s to %s.\n",
> 				lib3270_connection_state_get_name(hSession->connection.state),
> 				lib3270_connection_state_get_name(cstate)
197c200,201
< void host_in3270(H3270 *hSession, LIB3270_CSTATE new_cstate) {
---
> void host_in3270(H3270 *hSession, LIB3270_CSTATE new_cstate)
> {
199,200c203,204
< 	                   new_cstate == LIB3270_CONNECTED_SSCP ||
< 	                   new_cstate == LIB3270_CONNECTED_TN3270E);
---
> 			   new_cstate == LIB3270_CONNECTED_SSCP ||
> 			   new_cstate == LIB3270_CONNECTED_TN3270E);
207c211,212
< void lib3270_set_connected_initial(H3270 *hSession) {
---
> void lib3270_set_connected_initial(H3270 *hSession)
> {
217c222,223
< void lib3270_set_disconnected(H3270 *hSession) {
---
> void lib3270_set_disconnected(H3270 *hSession)
> {
243c249,250
< void lib3270_st_changed(H3270 *hSession, LIB3270_STATE tx, int mode) {
---
> void lib3270_st_changed(H3270 *hSession, LIB3270_STATE tx, int mode)
> {
247,252c254,259
< 	trace_dsn(
< 	    hSession,
< 	    "Notifying state %s with mode %d.\n",
< 	    lib3270_state_get_name(tx),
< 	    mode
< 	);
---
>     trace_dsn(
>         hSession,
>         "Notifying state %s with mode %d.\n",
>             lib3270_state_get_name(tx),
>             mode
>     );
254c261,262
< 	for(node = hSession->listeners.state[tx].first; node; node = node->next) {
---
> 	for(node = hSession->listeners.state[tx].first; node; node = node->next)
> 	{
260c268,269
< static void update_url(H3270 *hSession) {
---
> static void update_url(H3270 *hSession)
> {
262,267c271,276
< 	    lib3270_strdup_printf(
< 	        "%s://%s:%s",
< 	        hSession->network.module->name,
< 	        hSession->host.current,
< 	        hSession->host.srvc
< 	    );
---
> 			lib3270_strdup_printf(
> 				"%s://%s:%s",
> 					hSession->network.module->name,
> 					hSession->host.current,
> 					hSession->host.srvc
> 	);
269c278,279
< 	if(hSession->host.url && !strcmp(hSession->host.url,url)) {
---
> 	if(hSession->host.url && !strcmp(hSession->host.url,url))
> 	{
286c296,297
< LIB3270_EXPORT const char * lib3270_get_associated_luname(const H3270 *hSession) {
---
> LIB3270_EXPORT const char * lib3270_get_associated_luname(const H3270 *hSession)
> {
293c304,305
< LIB3270_EXPORT const char * lib3270_get_url(const H3270 *hSession) {
---
> LIB3270_EXPORT const char * lib3270_get_url(const H3270 *hSession)
> {
300c312,313
< LIB3270_EXPORT const char * lib3270_get_default_host(const H3270 GNUC_UNUSED(*hSession)) {
---
> LIB3270_EXPORT const char * lib3270_get_default_host(const H3270 GNUC_UNUSED(*hSession))
> {
303c316
< 		lib3270_auto_cleanup(HKEY) hKey = 0;
---
> 		lib3270_auto_cleanup(HKEY) hKey;
306,314c319,327
< 		    HKEY_LOCAL_MACHINE,
< 		    "Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),
< 		    0,
< 		    NULL,
< 		    REG_OPTION_NON_VOLATILE,
< 		    KEY_QUERY_VALUE|KEY_READ,
< 		    NULL,
< 		    &hKey,
< 		    &disp);
---
> 						HKEY_LOCAL_MACHINE,
> 						"Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),
> 						0,
> 						NULL,
> 						REG_OPTION_NON_VOLATILE,
> 						KEY_QUERY_VALUE|KEY_READ,
> 						NULL,
> 						&hKey,
> 						&disp);
316c329,330
< 		if(rc == ERROR_SUCCESS) {
---
> 		if(rc == ERROR_SUCCESS)
> 		{
320c334,335
< 			if(!default_host) {
---
> 			if(!default_host)
> 			{
322c337,339
< 			} else {
---
> 			}
> 			else
> 			{
328c345,346
< 			if(dwRet == ERROR_SUCCESS) {
---
> 			if(dwRet == ERROR_SUCCESS)
> 			{
330,331c348,349
< 				default_host[cbData] = 0;
< 				return default_host;
---
>                 default_host[cbData] = 0;
>                 return default_host;
348,349c366,368
< LIB3270_EXPORT int lib3270_set_url(H3270 *h, const char *n) {
< 	FAIL_IF_ONLINE(h);
---
> LIB3270_EXPORT int lib3270_set_url(H3270 *h, const char *n)
> {
>     FAIL_IF_ONLINE(h);
371c390,391
< 	if(ptr) {
---
> 	if(ptr)
> 	{
376c396,398
< 	} else {
---
> 	}
> 	else
> 	{
392c414,415
< 	if(query && *query) {
---
> 	if(query && *query)
> 	{
398c421
< 		for(ptr = strtok_r(str,"&",&saveptr); ptr; ptr=strtok_r(NULL,"&",&saveptr))
---
> 		for(ptr = strtok_r(str,"&",&saveptr);ptr;ptr=strtok_r(NULL,"&",&saveptr))
400c423
< 		for(ptr = strtok(str,"&"); ptr; ptr=strtok(NULL,"&"))
---
> 		for(ptr = strtok(str,"&");ptr;ptr=strtok(NULL,"&"))
405c428,429
< 			if(val) {
---
> 			if(val)
> 			{
413c437,439
< 			} else {
---
> 			}
> 			else
> 			{
433c459,460
< LIB3270_EXPORT const char * lib3270_get_host(const H3270 *h) {
---
> LIB3270_EXPORT const char * lib3270_get_host(const H3270 *h)
> {
437c464,465
< LIB3270_EXPORT int lib3270_has_active_script(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_has_active_script(const H3270 *h)
> {
441c469,470
< LIB3270_EXPORT int lib3270_get_typeahead(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_get_typeahead(const H3270 *h)
> {
445c474,475
< LIB3270_EXPORT int lib3270_get_undera(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_get_undera(const H3270 *h)
> {
449c479,480
< LIB3270_EXPORT int lib3270_get_oia_box_solid(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_get_oia_box_solid(const H3270 *h)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/init.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/init.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,14c6,21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
27a30
> 
33,34c36,37
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
41c44
< #include <curl/curl.h>
---
> 	#include <curl/curl.h>
47,49c50,52
< #include <winsock2.h>
< #include <windows.h>
< #include "winversc.h"
---
> 	#include <winsock2.h>
> 	#include <windows.h>
> 	#include "winversc.h"
56c59
< #include <syslog.h>
---
> 	#include <syslog.h>
60c63
< BOOL WINAPI DllMain(HANDLE hinst, DWORD dwcallpurpose, LPVOID lpvResvd);
---
> 	BOOL WINAPI DllMain(HANDLE hinst, DWORD dwcallpurpose, LPVOID lpvResvd);
62,63c65,66
< int lib3270_loaded(void) __attribute__((constructor));
< int lib3270_unloaded(void) __attribute__((destructor));
---
> 	int lib3270_loaded(void) __attribute__((constructor));
> 	int lib3270_unloaded(void) __attribute__((destructor));
77c80,81
< static char parse_ctlchar(char *s) {
---
> static char parse_ctlchar(char *s)
> {
81c85,86
< 	if ((int) strlen(s) > 1) {
---
> 	if ((int) strlen(s) > 1)
> 	{
92c97,98
< int lib3270_loaded(void) {
---
> int lib3270_loaded(void)
> {
130c136
< 	return 0;
---
>     return 0;
133c139,140
< int lib3270_unloaded(void) {
---
> int lib3270_unloaded(void)
> {
142c149,150
< 	if(use_syslog) {
---
> 	if(use_syslog)
> 	{
147c155
< 	return 0;
---
>     return 0;
153c161,162
< BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwcallpurpose, LPVOID GNUC_UNUSED(lpvResvd)) {
---
> BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwcallpurpose, LPVOID GNUC_UNUSED(lpvResvd))
> {
156,158c165,168
< 	switch(dwcallpurpose) {
< 	case DLL_PROCESS_ATTACH:
< 		hModule = hInstance;
---
>     switch(dwcallpurpose)
>     {
>     case DLL_PROCESS_ATTACH:
>     	hModule = hInstance;
166c176,177
< 		if(hEventLog) {
---
> 		if(hEventLog)
> 		{
172c183
< 	}
---
>     }
174c185
< 	debug("%s ends",__FUNCTION__);
---
>     debug("%s ends",__FUNCTION__);
176c187
< 	return TRUE;
---
>     return TRUE;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/iocalls.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/iocalls.c
42c42
< #include <ws2tcpip.h>
---
> 	#include <ws2tcpip.h>
44,49c44,49
< #include <sys/types.h>
< #include <sys/socket.h>
< #include <sys/ioctl.h>
< #include <netinet/in.h>
< #include <netdb.h>
< #include <fcntl.h>
---
> 	#include <sys/types.h>
> 	#include <sys/socket.h>
> 	#include <sys/ioctl.h>
> 	#include <netinet/in.h>
> 	#include <netdb.h>
> 	#include <fcntl.h>
65,66c65,66
< static void      internal_remove_timer(H3270 *session, void *timer);
< static void	* internal_add_timer(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata);
---
>  static void      internal_remove_timer(H3270 *session, void *timer);
>  static void	* internal_add_timer(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata);
68,69c68,69
< static void	* internal_add_poll(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata );
< static void	  internal_remove_poll(H3270 *session, void *id);
---
>  static void	* internal_add_poll(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata );
>  static void	  internal_remove_poll(H3270 *session, void *id);
71c71
< static void	  internal_set_poll_state(H3270 *session, void *id, int enabled);
---
>  static void	  internal_set_poll_state(H3270 *session, void *id, int enabled);
73c73
< static int		  internal_wait(H3270 *session, int seconds);
---
>  static int		  internal_wait(H3270 *session, int seconds);
75c75
< static void	  internal_ring_bell(H3270 *session);
---
>  static void	  internal_ring_bell(H3270 *session);
77c77
< static int		  internal_run_task(H3270 *session, int(*callback)(H3270 *, void *), void *parm);
---
>  static int		  internal_run_task(H3270 *session, int(*callback)(H3270 *, void *), void *parm);
81,82c81,82
< static void	* (*add_timer)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata)
<     = internal_add_timer;
---
>  static void	* (*add_timer)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata)
> 					= internal_add_timer;
84,85c84,85
< static void	  (*remove_timer)(H3270 *session, void *timer)
<     = internal_remove_timer;
---
>  static void	  (*remove_timer)(H3270 *session, void *timer)
> 					= internal_remove_timer;
87,88c87,88
< static void	* (*add_poll)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata)
<     = internal_add_poll;
---
>  static void	* (*add_poll)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata)
> 					= internal_add_poll;
90,91c90,91
< static void	  (*remove_poll)(H3270 *session, void *id)
<     = internal_remove_poll;
---
>  static void	  (*remove_poll)(H3270 *session, void *id)
> 					= internal_remove_poll;
93,94c93,94
< static void	  (*set_poll_state)(H3270 *session, void *id, int enabled)
<     = internal_set_poll_state;
---
>  static void	  (*set_poll_state)(H3270 *session, void *id, int enabled)
> 					= internal_set_poll_state;
96,97c96,97
< static int	  	  (*wait_callback)(H3270 *session, int seconds)
<     = internal_wait;
---
>  static int	  	  (*wait_callback)(H3270 *session, int seconds)
> 					= internal_wait;
99,100c99,100
< static int 	  (*event_dispatcher)(H3270 *session,int wait)
<     = lib3270_default_event_dispatcher;
---
>  static int 	  (*event_dispatcher)(H3270 *session,int wait)
> 					= lib3270_default_event_dispatcher;
102,103c102,103
< static void	  (*ring_bell)(H3270 *)
<     = internal_ring_bell;
---
>  static void	  (*ring_bell)(H3270 *)
> 					= internal_ring_bell;
105,106c105,106
< static int		  (*run_task)(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm)
<     = internal_run_task;
---
>  static int		  (*run_task)(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm)
> 					= internal_run_task;
110c110
< #define TN	(timeout_t *)NULL
---
>  #define TN	(timeout_t *)NULL
118c118,119
< static void ms_ts(unsigned long long *u) {
---
> static void ms_ts(unsigned long long *u)
> {
130c131,132
< static void * internal_add_timer(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata) {
---
> static void * internal_add_timer(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata)
> {
154c156,157
< 	if (t_new->tv.tv_usec > MILLION) {
---
> 	if (t_new->tv.tv_usec > MILLION)
> 	{
162c165,166
< 	for (t = (timeout_t *) session->timeouts.first; t != TN; t = (timeout_t *) t->next) {
---
> 	for (t = (timeout_t *) session->timeouts.first; t != TN; t = (timeout_t *) t->next)
> 	{
168c172
< 			break;
---
> 		break;
174c178,179
< 	if (prev == TN) {
---
> 	if (prev == TN)
> 	{
178c183,185
< 	} else if (t == TN) {
---
> 	}
> 	else if (t == TN)
> 	{
183,184c190,192
< 	} else {
< 		// t_new is Middle.
---
> 	}
> 	else
> 	{	// t_new is Middle.
194c202,203
< static void internal_remove_timer(H3270 *session, void * timer) {
---
> static void internal_remove_timer(H3270 *session, void * timer)
> {
206c215,216
< static void * internal_add_poll(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata ) {
---
> static void * internal_add_poll(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata )
> {
219c229,230
< static void internal_remove_poll(H3270 *session, void *id) {
---
> static void internal_remove_poll(H3270 *session, void *id)
> {
224c235,236
< static void internal_set_poll_state(H3270 *session, void *id, int enabled) {
---
>  static void internal_set_poll_state(H3270 *session, void *id, int enabled)
>  {
227,228c239,242
< 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next) {
< 		if (ip == (input_t *)id) {
---
> 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next)
> 	{
> 		if (ip == (input_t *)id)
> 		{
236c250
< }
---
>  }
239c253,254
< LIB3270_EXPORT void	 lib3270_remove_poll(H3270 *session, void *id) {
---
> LIB3270_EXPORT void	 lib3270_remove_poll(H3270 *session, void *id)
> {
243,244c258,261
< LIB3270_EXPORT void	lib3270_set_poll_state(H3270 *session, void *id, int enabled) {
< 	if(id) {
---
> LIB3270_EXPORT void	lib3270_set_poll_state(H3270 *session, void *id, int enabled)
> {
> 	if(id)
> 	{
250c267,268
< LIB3270_EXPORT void lib3270_remove_poll_fd(H3270 *session, int fd) {
---
> LIB3270_EXPORT void lib3270_remove_poll_fd(H3270 *session, int fd)
> {
253,254c271,274
< 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next) {
< 		if(ip->fd == fd) {
---
> 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next)
> 	{
> 		if(ip->fd == fd)
> 		{
264c284,285
< LIB3270_EXPORT void lib3270_update_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag) {
---
> LIB3270_EXPORT void lib3270_update_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag)
> {
267,268c288,291
< 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next) {
< 		if(ip->fd == fd) {
---
> 	for (ip = (input_t *) session->input.list.first; ip; ip = (input_t *) ip->next)
> 	{
> 		if(ip->fd == fd)
> 		{
283c306,307
< static int internal_wait(H3270 *hSession, int seconds) {
---
> static int internal_wait(H3270 *hSession, int seconds)
> {
286c310,311
< 	while(time(0) < end) {
---
> 	while(time(0) < end)
> 	{
293c318,319
< static void internal_ring_bell(H3270 GNUC_UNUSED(*session)) {
---
> static void internal_ring_bell(H3270 GNUC_UNUSED(*session))
> {
299c325,326
< void * AddTimer(unsigned long interval_ms, H3270 *session, int (*proc)(H3270 *session, void *userdata), void *userdata) {
---
> void * AddTimer(unsigned long interval_ms, H3270 *session, int (*proc)(H3270 *session, void *userdata), void *userdata)
> {
301,305c328,332
< 	                  session,
< 	                  interval_ms ? interval_ms : 100,	// Prevents a zero-value timer.
< 	                  proc,
< 	                  userdata
< 	              );
---
> 						session,
> 						interval_ms ? interval_ms : 100,	// Prevents a zero-value timer.
> 						proc,
> 						userdata
> 					);
310c337,338
< void RemoveTimer(H3270 *session, void * timer) {
---
> void RemoveTimer(H3270 *session, void * timer)
> {
317c345,346
< void x_except_on(H3270 *h) {
---
> void x_except_on(H3270 *h)
> {
334,335c363,366
< void remove_input_calls(H3270 *session) {
< 	if(session->xio.read) {
---
> void remove_input_calls(H3270 *session)
> {
> 	if(session->xio.read)
> 	{
339c370,371
< 	if(session->xio.except) {
---
> 	if(session->xio.except)
> 	{
343c375,376
< 	if(session->xio.write) {
---
> 	if(session->xio.write)
> 	{
349c382,383
< LIB3270_EXPORT void lib3270_register_timer_handlers(void * (*add)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session,void *userdata), void *userdata), void (*rm)(H3270 *session, void *timer)) {
---
> LIB3270_EXPORT void lib3270_register_timer_handlers(void * (*add)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session,void *userdata), void *userdata), void (*rm)(H3270 *session, void *timer))
> {
366c400,401
< LIB3270_EXPORT int lib3270_register_io_controller(const LIB3270_IO_CONTROLLER *cbk) {
---
> LIB3270_EXPORT int lib3270_register_io_controller(const LIB3270_IO_CONTROLLER *cbk)
> {
392c427,428
< LIB3270_EXPORT void lib3270_main_iterate(H3270 *hSession, int block) {
---
> LIB3270_EXPORT void lib3270_main_iterate(H3270 *hSession, int block)
> {
397c433,434
< LIB3270_EXPORT int lib3270_wait(H3270 *hSession, int seconds) {
---
> LIB3270_EXPORT int lib3270_wait(H3270 *hSession, int seconds)
> {
402c439,440
< LIB3270_EXPORT void lib3270_ring_bell(H3270 *session) {
---
> LIB3270_EXPORT void lib3270_ring_bell(H3270 *session)
> {
423,424c461,463
< LIB3270_EXPORT int lib3270_run_task(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm) {
< 	int rc;
---
> LIB3270_EXPORT int lib3270_run_task(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm)
> {
>         int rc;
426c465,469
< 	CHECK_SESSION_HANDLE(hSession);
---
>         CHECK_SESSION_HANDLE(hSession);
> 
> 		hSession->cbk.set_timer(hSession,1);
> 		rc = run_task(hSession,callback,parm);
> 		hSession->cbk.set_timer(hSession,0);
428,433c471
< 	hSession->cbk.set_timer(hSession,1);
< 	hSession->tasks++;
< 	rc = run_task(hSession,callback,parm);
< 	hSession->cbk.set_timer(hSession,0);
< 	hSession->tasks--;
< 	return rc;
---
>         return rc;
437c475,476
< int non_blocking(H3270 *hSession, Boolean on) {
---
> int non_blocking(H3270 *hSession, Boolean on)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/actions.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/actions.c
47c47
< #include <stdlib.h>
---
> 	#include <stdlib.h>
60c60
< //#include "resources.h"
---
> #include "resources.h"
74c74
< //#include "utf8c.h"
---
> #include "utf8c.h"
82c82,83
< LIB3270_EXPORT int lib3270_break(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_break(H3270 *hSession)
> {
94c95,96
< LIB3270_EXPORT int lib3270_attn(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_attn(H3270 *hSession)
> {
103c105,106
< LIB3270_EXPORT int lib3270_nextfield(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_nextfield(H3270 *hSession)
> {
107,108c110,113
< 	if (hSession->kybdlock) {
< 		if(KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if(KYBDLOCK_IS_OERR(hSession))
> 		{
111c116,117
< 		} else {
---
> 		} else
> 		{
117c123,124
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
129c136,137
< LIB3270_EXPORT int lib3270_previousfield(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_previousfield(H3270 *hSession)
> {
135,136c143,146
< 	if (hSession->kybdlock) {
< 		if (KYBDLOCK_IS_OERR(hSession)) {
---
> 	if (hSession->kybdlock)
> 	{
> 		if (KYBDLOCK_IS_OERR(hSession))
> 		{
139c149,151
< 		} else {
---
> 		}
> 		else
> 		{
155,156c167,168
< 		        !FA_IS_PROTECTED(hSession->ea_buf[baddr].fa) &&
< 		        !hSession->ea_buf[nbaddr].fa)
---
> 		    !FA_IS_PROTECTED(hSession->ea_buf[baddr].fa) &&
> 		    !hSession->ea_buf[nbaddr].fa)
172c184,185
< LIB3270_EXPORT int lib3270_firstfield(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_firstfield(H3270 *hSession)
> {
175c188,189
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
185c199,200
< 	if (!hSession->formatted) {
---
> 	if (!hSession->formatted)
> 	{
198c213,214
< static void do_left(H3270 *hSession) {
---
> static void do_left(H3270 *hSession)
> {
217c233,234
< static Boolean do_delete(H3270 *hSession) {
---
> static Boolean do_delete(H3270 *hSession)
> {
228c245,246
< 	if (FA_IS_PROTECTED(fa) || hSession->ea_buf[baddr].fa) {
---
> 	if (FA_IS_PROTECTED(fa) || hSession->ea_buf[baddr].fa)
> 	{
233c251,252
< 	if (hSession->ea_buf[baddr].cc == EBC_so || hSession->ea_buf[baddr].cc == EBC_si) {
---
> 	if (hSession->ea_buf[baddr].cc == EBC_so || hSession->ea_buf[baddr].cc == EBC_si)
> 	{
240c259,260
< 		if (hSession->ea_buf[xaddr].cc == SOSI(hSession->ea_buf[baddr].cc)) {
---
> 		if (hSession->ea_buf[xaddr].cc == SOSI(hSession->ea_buf[baddr].cc))
> 		{
242c262,264
< 		} else {
---
> 		}
> 		else
> 		{
246c268,270
< 	} else if (IS_DBCS(hSession->ea_buf[baddr].db)) {
---
> 	}
> 	else if (IS_DBCS(hSession->ea_buf[baddr].db))
> 	{
250c274,275
< 	} else
---
> 	}
> 	else
254c279,280
< 	if (hSession->formatted) {
---
> 	if (hSession->formatted)
> 	{
256c282,283
< 		do {
---
> 		do
> 		{
262c289,291
< 	} else {
---
> 	}
> 	else
> 	{
269c298,299
< 	if (end_baddr > baddr) {
---
> 	if (end_baddr > baddr)
> 	{
271c301,303
< 	} else if (end_baddr != baddr) {
---
> 	}
> 	else if (end_baddr != baddr)
> 	{
290c322,323
< LIB3270_EXPORT int lib3270_delete(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_delete(H3270 *hSession)
> {
293c326,327
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
298c332,333
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
305c340,341
< 	if (hSession->reverse) {
---
> 	if (hSession->reverse)
> 	{
319c355,356
< LIB3270_EXPORT int lib3270_backspace(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_backspace(H3270 *hSession)
> {
322c359,360
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
350c388,389
< static void do_erase(H3270 *hSession) {
---
> static void do_erase(H3270 *hSession)
> {
356c395,396
< 	if (faddr == baddr || FA_IS_PROTECTED(hSession->ea_buf[baddr].fa)) {
---
> 	if (faddr == baddr || FA_IS_PROTECTED(hSession->ea_buf[baddr].fa))
> 	{
369c409,410
< 	if (hSession->ea_buf[hSession->cursor_addr].cc == EBC_si) {
---
> 	if (hSession->ea_buf[hSession->cursor_addr].cc == EBC_si)
> 	{
382c423,424
< 	if (IS_RIGHT(d)) {
---
> 	if (IS_RIGHT(d))
> 	{
400c442,443
< 	if (hSession->ea_buf[baddr].cc == EBC_so && hSession->ea_buf[hSession->cursor_addr].cc == EBC_si) {
---
> 	if (hSession->ea_buf[baddr].cc == EBC_so && hSession->ea_buf[hSession->cursor_addr].cc == EBC_si)
> 	{
407c450,451
< int lib3270_erase(H3270 *hSession) {
---
> int lib3270_erase(H3270 *hSession)
> {
410c454,455
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
415c460,461
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
427c473,474
< LIB3270_EXPORT int lib3270_previousword(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_previousword(H3270 *hSession)
> {
500c547,548
< LIB3270_EXPORT int lib3270_deleteword(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_deleteword(H3270 *hSession)
> {
511c559,560
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
535c584
< 		        hSession->ea_buf[baddr].cc == EBC_space)
---
> 		    hSession->ea_buf[baddr].cc == EBC_space)
542c591,592
< 	for (;;) {
---
> 	for (;;)
> 	{
548c598
< 		        hSession->ea_buf[baddr].cc == EBC_space)
---
> 		    hSession->ea_buf[baddr].cc == EBC_space)
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/kybd.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/kybd.c
48c48
< #include <stdlib.h>
---
> 	#include <stdlib.h>
61c61
< //#include "resources.h"
---
> #include "resources.h"
75c75
< //#include "utf8c.h"
---
> #include "utf8c.h"
84c84,85
< static const char *ia_name[] = {
---
> static const char *ia_name[] =
> {
91c92,93
< static const unsigned char pf_xlate[] = {
---
> static const unsigned char pf_xlate[] =
> {
97c99,100
< static const unsigned char pa_xlate[] = {
---
> static const unsigned char pa_xlate[] =
> {
110d112
< /*
116d117
< */
131d131
<  * @retval NULL Host is not connected or malloc error.
133,134c133,135
< struct ta * new_ta(H3270 *hSession, enum _ta_type type) {
< 	struct ta *ta = NULL;
---
> struct ta * new_ta(H3270 *hSession, enum _ta_type type)
> {
> 	struct ta *ta;
137c138,139
< 	if (!lib3270_is_connected(hSession)) {
---
> 	if (!lib3270_is_connected(hSession))
> 	{
140d141
< 		errno = ENOTCONN;
145c146,147
< 	if (hSession->kybdlock & KL_OERR_MASK) {
---
> 	if (hSession->kybdlock & KL_OERR_MASK)
> 	{
148d149
< 		errno = EINVAL;
153c154,155
< 	if (hSession->kybdlock & KL_SCROLLED) {
---
> 	if (hSession->kybdlock & KL_SCROLLED)
> 	{
156d157
< 		errno = EINVAL;
161c162,163
< 	if (!hSession->typeahead) {
---
> 	if (!hSession->typeahead)
> 	{
164d165
< 		errno = EINVAL;
172c173,174
< 	if(hSession->ta_head) {
---
> 	if(hSession->ta_head)
> 	{
174c176,178
< 	} else {
---
> 	}
> 	else
> 	{
191c195,196
< static void enq_key(H3270 *hSession, unsigned char aid_code) {
---
>  static void enq_key(H3270 *hSession, unsigned char aid_code)
>  {
194c199
< 	if(!ta)
---
>  	if(!ta)
200c205
< }
---
>  }
206c211,212
< void enq_ta(H3270 *hSession, void (*fn)(H3270 *, const char *, const char *), const char *parm1, const char *parm2) {
---
> void enq_ta(H3270 *hSession, void (*fn)(H3270 *, const char *, const char *), const char *parm1, const char *parm2)
> {
209c215
< 	if(!ta)
---
>  	if(!ta)
224c230,231
< void enq_action(H3270 *hSession, int (*fn)(H3270 *)) {
---
> void enq_action(H3270 *hSession, int (*fn)(H3270 *))
> {
238c245,246
< int run_ta(H3270 *hSession) {
---
> int run_ta(H3270 *hSession)
> {
244c252,253
< 	if ((hSession->ta_head = ta->next) == (struct ta *)NULL) {
---
> 	if ((hSession->ta_head = ta->next) == (struct ta *)NULL)
> 	{
249c258,259
< 	switch(ta->type) {
---
> 	switch(ta->type)
> 	{
282c292,293
< static int flush_ta(H3270 *hSession) {
---
> static int flush_ta(H3270 *hSession)
> {
286,287c297,300
< 	for (ta = hSession->ta_head; ta != (struct ta *) NULL; ta = next) {
< 		if(ta->type == TA_TYPE_DEFAULT) {
---
> 	for (ta = hSession->ta_head; ta != (struct ta *) NULL; ta = next)
> 	{
> 		if(ta->type == TA_TYPE_DEFAULT)
> 		{
303c316,317
< static void kybdlock_set(H3270 *hSession, unsigned int bits) {
---
> static void kybdlock_set(H3270 *hSession, unsigned int bits)
> {
307c321,322
< 	if (n != hSession->kybdlock) {
---
> 	if (n != hSession->kybdlock)
> 	{
311c326,327
< 		if ((hSession->kybdlock ^ bits) & KL_DEFERRED_UNLOCK) {
---
> 		if ((hSession->kybdlock ^ bits) & KL_DEFERRED_UNLOCK)
> 		{
324c340,341
< void lib3270_kybdlock_clear(H3270 *hSession, LIB3270_KEYBOARD_LOCK_STATE bits) {
---
> void lib3270_kybdlock_clear(H3270 *hSession, LIB3270_KEYBOARD_LOCK_STATE bits)
> {
329c346,347
< 	if (n != hSession->kybdlock) {
---
> 	if (n != hSession->kybdlock)
> 	{
333c351,352
< 		if ((hSession->kybdlock ^ n) & KL_DEFERRED_UNLOCK) {
---
> 		if ((hSession->kybdlock ^ n) & KL_DEFERRED_UNLOCK)
> 		{
349,350c368,371
< void kybd_inhibit(H3270 *session, Boolean inhibit) {
< 	if (inhibit) {
---
> void kybd_inhibit(H3270 *session, Boolean inhibit)
> {
> 	if (inhibit)
> 	{
354c375,377
< 	} else {
---
> 	}
> 	else
> 	{
364c387,388
< void kybd_connect(H3270 *session, int connected, void GNUC_UNUSED(*dunno)) {
---
> void kybd_connect(H3270 *session, int connected, void GNUC_UNUSED(*dunno))
> {
370c394,395
< 	if (connected) {
---
> 	if (connected)
> 	{
373c398,400
< 	} else {
---
> 	}
> 	else
> 	{
382c409,410
< void kybd_in3270(H3270 *hSession, int GNUC_UNUSED(in3270), void GNUC_UNUSED(*dunno)) {
---
> void kybd_in3270(H3270 *hSession, int GNUC_UNUSED(in3270), void GNUC_UNUSED(*dunno))
> {
398,399c426,429
< void operator_error(H3270 *hSession, int error_type) {
< 	if(hSession->oerr_lock) {
---
> void operator_error(H3270 *hSession, int error_type)
> {
> 	if(hSession->oerr_lock)
> 	{
404c434,436
< 	} else {
---
> 	}
> 	else
> 	{
415c447,448
< static void key_AID(H3270 *hSession, unsigned char aid_code) {
---
> static void key_AID(H3270 *hSession, unsigned char aid_code)
> {
446c479,480
< 	if (IN_SSCP) {
---
> 	if (IN_SSCP)
> 	{
450c484,485
< 		if (aid_code != AID_ENTER && aid_code != AID_CLEAR) {
---
> 		if (aid_code != AID_ENTER && aid_code != AID_CLEAR)
> 		{
457c492,493
< 	if (IN_SSCP && aid_code == AID_ENTER) {
---
> 	if (IN_SSCP && aid_code == AID_ENTER)
> 	{
462c498,499
< 	if (!IN_SSCP || aid_code != AID_CLEAR) {
---
> 	if (!IN_SSCP || aid_code != AID_CLEAR)
> 	{
475c512,513
< LIB3270_EXPORT int lib3270_pfkey(H3270 *hSession, int key) {
---
> LIB3270_EXPORT int lib3270_pfkey(H3270 *hSession, int key)
> {
484c522,523
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
488,489c527,530
< 		enq_key(hSession,pf_xlate[key-1]);
< 	} else {
---
>  		enq_key(hSession,pf_xlate[key-1]);
> 	}
> 	else
> 	{
499c540,541
< LIB3270_EXPORT int lib3270_pakey(H3270 *hSession, int key) {
---
> LIB3270_EXPORT int lib3270_pakey(H3270 *hSession, int key)
> {
502c544,545
< 	if (key < 1 || key > PA_SZ) {
---
> 	if (key < 1 || key > PA_SZ)
> 	{
521c564,565
< static Boolean ins_prep(H3270 *hSession, int faddr, int baddr, int count) {
---
> static Boolean ins_prep(H3270 *hSession, int faddr, int baddr, int count)
> {
530c574,575
< 	if (faddr == -1) {
---
> 	if (faddr == -1)
> 	{
533c578,580
< 	} else {
---
> 	}
> 	else
> 	{
536c583,584
< 		while (next_faddr != faddr && !hSession->ea_buf[next_faddr].fa) {
---
> 		while (next_faddr != faddr && !hSession->ea_buf[next_faddr].fa)
> 		{
549,550c597,598
< 		         ((hSession->ea_buf[xaddr].cc == EBC_space) ||
< 		          (hSession->ea_buf[xaddr].cc == EBC_underscore))) {
---
> 			((hSession->ea_buf[xaddr].cc == EBC_space) ||
> 			 (hSession->ea_buf[xaddr].cc == EBC_underscore))) {
563c611,612
< 	if (need - ntb > 0) {
---
> 	if (need - ntb > 0)
> 	{
579,580c628,629
< 		        ((hSession->ea_buf[xaddr].cc == EBC_null) ||
< 		         (tb_start >= 0 && xaddr >= tb_start))) {
---
> 		       ((hSession->ea_buf[xaddr].cc == EBC_null) ||
> 		        (tb_start >= 0 && xaddr >= tb_start))) {
595,600c644,649
< 			/*
< 			#if defined(_ST)
< 						printf("found %d NULLs at %d\n", n_nulls, first_null);
< 						printf("copying %d from %d to %d\n", copy_len, to,first_null);
< 			#endif
< 			*/
---
> /*
> #if defined(_ST)
> 			printf("found %d NULLs at %d\n", n_nulls, first_null);
> 			printf("copying %d from %d to %d\n", copy_len, to,first_null);
> #endif
> */
614c663,664
< static void key_Character_wrapper(H3270 *hSession, const char *param1, const char GNUC_UNUSED(*param2)) {
---
> static void key_Character_wrapper(H3270 *hSession, const char *param1, const char GNUC_UNUSED(*param2))
> {
621c671,672
< 	if (code & GE_WFLAG) {
---
> 	if (code & GE_WFLAG)
> 	{
626c677,678
< 	if (code & PASTE_WFLAG) {
---
> 	if (code & PASTE_WFLAG)
> 	{
640c692,693
< static Boolean key_Character(H3270 *hSession, int code, Boolean with_ge, Boolean pasting, Boolean *skipped) {
---
> static Boolean key_Character(H3270 *hSession, int code, Boolean with_ge, Boolean pasting, Boolean *skipped)
> {
648c701,702
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
661c715,716
< 	if (hSession->ea_buf[baddr].fa || FA_IS_PROTECTED(fa)) {
---
> 	if (hSession->ea_buf[baddr].fa || FA_IS_PROTECTED(fa))
> 	{
667,668c722,723
< 	        !((code >= EBC_0 && code <= EBC_9) ||
< 	          code == EBC_minus || code == EBC_period)) {
---
> 	    !((code >= EBC_0 && code <= EBC_9) ||
> 	      code == EBC_minus || code == EBC_period)) {
682c737,738
< 		if (baddr == faddr) {
---
> 		if (baddr == faddr)
> 		{
691c747,748
< 		if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT)) {
---
> 		if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT))
> 		{
694c751,753
< 		} else {
---
> 		}
> 		else
> 		{
712c771,772
< 			if (!was_si) {
---
> 			if (!was_si)
> 			{
723,724c783,784
< 		case DBCS_RIGHT:
< 			DEC_BA(baddr);
---
> 	case DBCS_RIGHT:
> 		DEC_BA(baddr);
726,741c786,790
< 		case DBCS_LEFT:
< 			if (why == DBCS_ATTRIBUTE) {
< 				if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT)) {
< 					if (!ins_prep(hSession,faddr, baddr, 1))
< 						return False;
< 				} else {
< 					/*
< 					 * Replace single DBCS char with
< 					 * x/space.
< 					 */
< 					xaddr = baddr;
< 					INC_BA(xaddr);
< 					ctlr_add(hSession,xaddr, EBC_space, CS_BASE);
< 					ctlr_add_fg(hSession,xaddr, 0);
< 					ctlr_add_gr(hSession,xaddr, 0);
< 				}
---
> 	case DBCS_LEFT:
> 		if (why == DBCS_ATTRIBUTE) {
> 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT)) {
> 				if (!ins_prep(hSession,faddr, baddr, 1))
> 					return False;
743c792,803
< 				Boolean was_si;
---
> 				/*
> 				 * Replace single DBCS char with
> 				 * x/space.
> 				 */
> 				xaddr = baddr;
> 				INC_BA(xaddr);
> 				ctlr_add(hSession,xaddr, EBC_space, CS_BASE);
> 				ctlr_add_fg(hSession,xaddr, 0);
> 				ctlr_add_gr(hSession,xaddr, 0);
> 			}
> 		} else {
> 			Boolean was_si;
745,774c805,821
< 				if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT)) {
< 					/*
< 					 * Inserting SBCS into a DBCS subfield.
< 					 * If this is the first position, we
< 					 * can just insert one character in
< 					 * front of the SO.  Otherwise, we'll
< 					 * need room for SI (to end subfield),
< 					 * the character, and SO (to begin the
< 					 * subfield again).
< 					 */
< 					xaddr = baddr;
< 					DEC_BA(xaddr);
< 					if (hSession->ea_buf[xaddr].cc == EBC_so) {
< 						DEC_BA(baddr);
< 						if (!ins_prep(hSession, faddr, baddr, 1))
< 							return False;
< 					} else {
< 						if (!ins_prep(hSession, faddr, baddr, 3))
< 							return False;
< 						xaddr = baddr;
< 						ctlr_add(hSession,xaddr, EBC_si,CS_BASE);
< 						ctlr_add_fg(hSession,xaddr, 0);
< 						ctlr_add_gr(hSession,xaddr, 0);
< 						INC_BA(xaddr);
< 						INC_BA(baddr);
< 						INC_BA(xaddr);
< 						ctlr_add(hSession,xaddr, EBC_so,CS_BASE);
< 						ctlr_add_fg(hSession,xaddr, 0);
< 						ctlr_add_gr(hSession,xaddr, 0);
< 					}
---
> 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT))
> 			{
> 				/*
> 				 * Inserting SBCS into a DBCS subfield.
> 				 * If this is the first position, we
> 				 * can just insert one character in
> 				 * front of the SO.  Otherwise, we'll
> 				 * need room for SI (to end subfield),
> 				 * the character, and SO (to begin the
> 				 * subfield again).
> 				 */
> 				xaddr = baddr;
> 				DEC_BA(xaddr);
> 				if (hSession->ea_buf[xaddr].cc == EBC_so) {
> 					DEC_BA(baddr);
> 					if (!ins_prep(hSession, faddr, baddr, 1))
> 						return False;
776c823,824
< 					/* Overwriting part of a subfield. */
---
> 					if (!ins_prep(hSession, faddr, baddr, 3))
> 						return False;
778c826
< 					ctlr_add(hSession,xaddr, EBC_si, CS_BASE);
---
> 					ctlr_add(hSession,xaddr, EBC_si,CS_BASE);
784,785c832,852
< 					was_si = (hSession->ea_buf[xaddr].cc == EBC_si);
< 					ctlr_add(hSession,xaddr, EBC_space, CS_BASE);
---
> 					ctlr_add(hSession,xaddr, EBC_so,CS_BASE);
> 					ctlr_add_fg(hSession,xaddr, 0);
> 					ctlr_add_gr(hSession,xaddr, 0);
> 				}
> 			} else {
> 				/* Overwriting part of a subfield. */
> 				xaddr = baddr;
> 				ctlr_add(hSession,xaddr, EBC_si, CS_BASE);
> 				ctlr_add_fg(hSession,xaddr, 0);
> 				ctlr_add_gr(hSession,xaddr, 0);
> 				INC_BA(xaddr);
> 				INC_BA(baddr);
> 				INC_BA(xaddr);
> 				was_si = (hSession->ea_buf[xaddr].cc == EBC_si);
> 				ctlr_add(hSession,xaddr, EBC_space, CS_BASE);
> 				ctlr_add_fg(hSession,xaddr, 0);
> 				ctlr_add_gr(hSession,xaddr, 0);
> 				if (!was_si)
> 				{
> 					INC_BA(xaddr);
> 					ctlr_add(hSession,xaddr, EBC_so,CS_BASE);
788,793d854
< 					if (!was_si) {
< 						INC_BA(xaddr);
< 						ctlr_add(hSession,xaddr, EBC_so,CS_BASE);
< 						ctlr_add_fg(hSession,xaddr, 0);
< 						ctlr_add_gr(hSession,xaddr, 0);
< 					}
796,801d856
< 			break;
< 		default:
< 		case DBCS_NONE:
< 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT) && !ins_prep(hSession, faddr, baddr, 1))
< 				return False;
< 			break;
802a858,864
> 		break;
> 	default:
> 	case DBCS_NONE:
> 		if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_INSERT) && !ins_prep(hSession, faddr, baddr, 1))
> 			return False;
> 		break;
> 	}
809c871,872
< 	if (hSession->formatted && lib3270_get_toggle(hSession,LIB3270_TOGGLE_BLANK_FILL)) {
---
> 	if (hSession->formatted && lib3270_get_toggle(hSession,LIB3270_TOGGLE_BLANK_FILL))
> 	{
816c879,880
< 			if ((baddr_fill % hSession->view.cols) == hSession->view.cols - 1) {
---
> 			if ((baddr_fill % hSession->view.cols) == hSession->view.cols - 1)
> 			{
825c889,890
< 					if (hSession->ea_buf[baddr_scan].cc != EBC_null) {
---
> 					if (hSession->ea_buf[baddr_scan].cc != EBC_null)
> 					{
850,851c915,918
< 	if (pasting || (code != EBC_dup)) {
< 		while (hSession->ea_buf[baddr].fa) {
---
> 	if (pasting || (code != EBC_dup))
> 	{
> 		while (hSession->ea_buf[baddr].fa)
> 		{
866c933,934
< LIB3270_EXPORT int lib3270_input_string(H3270 *hSession, const unsigned char *str, int length) {
---
> LIB3270_EXPORT int lib3270_input_string(H3270 *hSession, const unsigned char *str, int length)
> {
869c937,938
< 	if(check_online_session(hSession)) {
---
> 	if(check_online_session(hSession))
> 	{
878c947,948
< 	for(pos = 0; pos < length && str[pos] && !rc; pos++) {
---
> 	for(pos = 0; pos < length && str[pos] && !rc; pos++)
> 	{
895c965,966
< int key_ACharacter(H3270 *hSession, unsigned char c, enum keytype keytype, enum iaction cause,Boolean *skipped) {
---
> int key_ACharacter(H3270 *hSession, unsigned char c, enum keytype keytype, enum iaction cause,Boolean *skipped)
> {
901,902c972,975
< 	if (IN_3270) {
< 		if (c < ' ') {
---
> 	if (IN_3270)
> 	{
> 		if (c < ' ')
> 		{
909c982,983
< 	else if (IN_ANSI) {
---
> 	else if (IN_ANSI)
> 	{
913c987,988
< 	else {
---
> 	else
> 	{
920c995,996
< LIB3270_EXPORT int lib3270_clear_operator_error(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_clear_operator_error(H3270 *hSession)
> {
924c1000,1001
< 	if(KYBDLOCK_IS_OERR(hSession)) {
---
> 	if(KYBDLOCK_IS_OERR(hSession))
> 	{
935c1012,1013
< static int defer_unlock(H3270 *hSession, void GNUC_UNUSED(*userdata)) {
---
> static int defer_unlock(H3270 *hSession, void GNUC_UNUSED(*userdata))
> {
950c1028,1029
< void do_reset(H3270 *hSession, Boolean explicit) {
---
> void do_reset(H3270 *hSession, Boolean explicit)
> {
956c1035,1036
< 	if (explicit || lib3270_get_ft_state(hSession) != LIB3270_FT_STATE_NONE) {
---
> 	if (explicit || lib3270_get_ft_state(hSession) != LIB3270_FT_STATE_NONE)
> 	{
979c1059,1060
< 	if (explicit || lib3270_get_ft_state(hSession) != LIB3270_FT_STATE_NONE || (!hSession->unlock_delay) || (hSession->unlock_delay_time != 0 && (time(NULL) - hSession->unlock_delay_time) > 1)) {
---
> 	if (explicit || lib3270_get_ft_state(hSession) != LIB3270_FT_STATE_NONE || (!hSession->unlock_delay) || (hSession->unlock_delay_time != 0 && (time(NULL) - hSession->unlock_delay_time) > 1))
> 	{
981c1062,1064
< 	} else if (hSession->kybdlock & (KL_DEFERRED_UNLOCK | KL_OIA_TWAIT | KL_OIA_LOCKED | KL_AWAITING_FIRST)) {
---
> 	}
> 	else if (hSession->kybdlock & (KL_DEFERRED_UNLOCK | KL_OIA_TWAIT | KL_OIA_LOCKED | KL_AWAITING_FIRST))
> 	{
985c1068,1069
< 		if(hSession->unlock_delay_ms) {
---
> 		if(hSession->unlock_delay_ms)
> 		{
987c1071,1073
< 		} else {
---
> 		}
> 		else
> 		{
1000c1086,1087
< LIB3270_EXPORT int lib3270_kybdreset(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_kybdreset(H3270 *hSession)
> {
1007c1094,1095
< static int nu_word(H3270 *hSession, int baddr) {
---
> static int nu_word(H3270 *hSession, int baddr)
> {
1014c1102,1103
< 	do {
---
> 	do
> 	{
1031c1120,1121
< static int nt_word(H3270 *hSession, int baddr) {
---
> static int nt_word(H3270 *hSession, int baddr)
> {
1036c1126,1127
< 	do {
---
> 	do
> 	{
1042c1133,1134
< 		if (in_word) {
---
> 		if (in_word)
> 		{
1045c1137,1138
< 		} else {
---
> 		} else
> 		{
1059c1152,1153
< LIB3270_EXPORT int lib3270_nextword(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_nextword(H3270 *hSession)
> {
1079c1173
< 	        FA_IS_PROTECTED(get_field_attribute(hSession,hSession->cursor_addr))) {
---
> 	    FA_IS_PROTECTED(get_field_attribute(hSession,hSession->cursor_addr))) {
1124c1218,1219
< LIB3270_EXPORT int lib3270_newline(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_newline(H3270 *hSession)
> {
1130c1225,1226
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1135c1231,1232
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
1155c1252,1253
< LIB3270_EXPORT int lib3270_dup(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_dup(H3270 *hSession)
> {
1158c1256,1257
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1166c1265,1266
< 	if (key_Character(hSession, EBC_dup, False, False, NULL)) {
---
> 	if (key_Character(hSession, EBC_dup, False, False, NULL))
> 	{
1177c1277,1278
< LIB3270_EXPORT int lib3270_fieldmark(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_fieldmark(H3270 *hSession)
> {
1180c1281,1282
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1199c1301,1302
< LIB3270_EXPORT int lib3270_enter(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_enter(H3270 *hSession)
> {
1204c1307,1308
< 	if (hSession->kybdlock & KL_OIA_MINUS) {
---
> 	if (hSession->kybdlock & KL_OIA_MINUS)
> 	{
1206c1310,1312
< 	} else if (hSession->kybdlock) {
---
> 	}
> 	else if (hSession->kybdlock)
> 	{
1208c1314,1316
< 	} else {
---
> 	}
> 	else
> 	{
1215c1323,1324
< LIB3270_EXPORT int lib3270_sysreq(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_sysreq(H3270 *hSession)
> {
1218c1327,1328
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
1223c1333,1334
< 	if (IN_E) {
---
> 	if (IN_E)
> 	{
1225c1336,1337
< 	} else
---
> 	}
> 	else
1242c1354,1355
< LIB3270_EXPORT int lib3270_clear(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_clear(H3270 *hSession)
> {
1268c1381,1382
< LIB3270_EXPORT int lib3270_eraseeol(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_eraseeol(H3270 *hSession)
> {
1275c1389,1390
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1286c1401,1402
< 	if (FA_IS_PROTECTED(fa) || hSession->ea_buf[baddr].fa) {
---
> 	if (FA_IS_PROTECTED(fa) || hSession->ea_buf[baddr].fa)
> 	{
1291c1407,1408
< 	if (hSession->formatted) {
---
> 	if (hSession->formatted)
> 	{
1293c1410,1411
< 		do {
---
> 		do
> 		{
1299c1417,1419
< 	} else {
---
> 	}
> 	else
> 	{
1301c1421,1422
< 		do {
---
> 		do
> 		{
1309,1310c1430,1433
< 	if (IS_DBCS(d) && why == DBCS_SUBFIELD) {
< 		if (d == DBCS_RIGHT) {
---
> 	if (IS_DBCS(d) && why == DBCS_SUBFIELD)
> 	{
> 		if (d == DBCS_RIGHT)
> 		{
1326c1449,1450
< LIB3270_EXPORT int lib3270_eraseeof(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_eraseeof(H3270 *hSession)
> {
1333c1457,1458
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1347,1349c1472,1475
< 	if (hSession->formatted) {
< 		/* erase to next field attribute */
< 		do {
---
> 	if (hSession->formatted)
> 	{	/* erase to next field attribute */
> 		do
> 		{
1376c1502,1503
< LIB3270_EXPORT int lib3270_eraseinput(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_eraseinput(H3270 *hSession)
> {
1390c1517,1518
< 	if (hSession->formatted) {
---
> 	if (hSession->formatted)
> 	{
1439c1567,1568
< LIB3270_EXPORT int lib3270_deletefield(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_deletefield(H3270 *hSession)
> {
1485c1614,1615
< LIB3270_EXPORT int lib3270_fieldend(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_fieldend(H3270 *hSession)
> {
1488c1618,1619
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
1500c1631,1632
< int lib3270_get_field_end(H3270 *hSession, int baddr) {
---
> int lib3270_get_field_end(H3270 *hSession, int baddr)
> {
1506c1638,1639
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
1520c1653,1654
< 	while (True) {
---
> 	while (True)
> 	{
1529c1663,1664
< 	if (last_nonblank == -1) {
---
> 	if (last_nonblank == -1)
> 	{
1532c1667,1669
< 	} else {
---
> 	}
> 	else
> 	{
1545,1546c1682,1685
< static void do_pa(H3270 *hSession, unsigned n) {
< 	if (n < 1 || n > PA_SZ) {
---
> static void do_pa(H3270 *hSession, unsigned n)
> {
> 	if (n < 1 || n > PA_SZ)
> 	{
1558,1559c1697,1700
< static void do_pf(H3270 *hSession, unsigned n) {
< 	if (n < 1 || n > PF_SZ) {
---
> static void do_pf(H3270 *hSession, unsigned n)
> {
> 	if (n < 1 || n > PF_SZ)
> 	{
1571c1712,1713
< static Boolean remargin(H3270 *hSession, int lmargin) {
---
> static Boolean remargin(H3270 *hSession, int lmargin)
> {
1578c1720,1721
< 	while (BA_TO_COL(baddr) < lmargin) {
---
> 	while (BA_TO_COL(baddr) < lmargin)
> 	{
1580c1723,1724
< 		if (!ever) {
---
> 		if (!ever)
> 		{
1587c1731,1732
< 		if (faddr == baddr || FA_IS_PROTECTED(fa)) {
---
> 		if (faddr == baddr || FA_IS_PROTECTED(fa))
> 		{
1598c1743,1744
< LIB3270_EXPORT int lib3270_emulate_input(H3270 *hSession, const char *s, int len, int pasting) {
---
> LIB3270_EXPORT int lib3270_emulate_input(H3270 *hSession, const char *s, int len, int pasting)
> {
1631c1777,1778
< 	if (len > w_ibuf_len) {
---
> 	if (len > w_ibuf_len)
> 	{
1636c1783,1784
< 	if (len < 0) {
---
> 	if (len < 0)
> 	{
1648c1796,1797
< 	while (len) {
---
> 	while (len)
> 	{
1654c1803,1804
< 		if (hSession->kybdlock) {
---
> 		if (hSession->kybdlock)
> 		{
1659c1809,1810
< 		if (pasting && IN_3270) {
---
> 		if (pasting && IN_3270)
> 		{
1666c1817,1818
< 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col) {
---
> 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col)
> 			{
1675,1677c1827,1831
< 		switch (state) {
< 		case BASE:
< 			switch (c) {
---
> 		switch (state)
> 		{
> 		    case BASE:
> 			switch (c)
> 			{
1679c1833
< 				lib3270_cursor_left(hSession);
---
> 			    lib3270_cursor_left(hSession);
1684c1838,1839
< 				if (pasting) {
---
> 				if (pasting)
> 				{
1686c1841,1842
< 				} else {
---
> 				} else
> 				{
1695c1851,1852
< 				if (pasting) {
---
> 				if (pasting)
> 				{
1699c1856,1858
< 				} else {
---
> 				}
> 				else
> 				{
1711c1870
< 				lib3270_nextfield(hSession);
---
> 			    lib3270_nextfield(hSession);
1736,1754c1895,1913
< 				/*
< 				#if defined(X3270_DBCS)
< 								//
< 								// Try mapping it to the 8-bit character set,
< 								// otherwise to the 16-bit character set.
< 								//
< 								if (dbcs_map8(c, &cx)) {
< 									key_ACharacter((unsigned char)cx,
< 									    KT_STD, ia_cause, &skipped);
< 									break;
< 								} else if (dbcs_map16(c, ebc)) {
< 									(void) key_WCharacter(ebc, &skipped);
< 									break;
< 								} else {
< 									lib3270_write_event_trace(hSession,"Cannot convert U+%04x to "
< 									    "EBCDIC\n", c & 0xffff);
< 									break;
< 								}
< 				#endif */
---
> /*
> #if defined(X3270_DBCS)
> 				//
> 				// Try mapping it to the 8-bit character set,
> 				// otherwise to the 16-bit character set.
> 				//
> 				if (dbcs_map8(c, &cx)) {
> 					key_ACharacter((unsigned char)cx,
> 					    KT_STD, ia_cause, &skipped);
> 					break;
> 				} else if (dbcs_map16(c, ebc)) {
> 					(void) key_WCharacter(ebc, &skipped);
> 					break;
> 				} else {
> 					lib3270_write_event_trace(hSession,"Cannot convert U+%04x to "
> 					    "EBCDIC\n", c & 0xffff);
> 					break;
> 				}
> #endif */
1760,1765c1919,1925
< 		case BACKSLASH:	/* last character was a backslash */
< 			switch (c) {
< 			case 'a':
< 				popup_an_error(hSession,_( "%s: Bell not supported" ),action_name(String_action));
< 				state = BASE;
< 				break;
---
> 		    case BACKSLASH:	/* last character was a backslash */
> 				switch (c)
> 				{
> 				case 'a':
> 					popup_an_error(hSession,_( "%s: Bell not supported" ),action_name(String_action));
> 					state = BASE;
> 					break;
1767,1771c1927,1931
< 			case 'b':
< 				lib3270_cursor_left(hSession);
< 				skipped = False;
< 				state = BASE;
< 				break;
---
> 				case 'b':
> 					lib3270_cursor_left(hSession);
> 					skipped = False;
> 					state = BASE;
> 					break;
1773,1779c1933,1952
< 			case 'f':
< 				lib3270_clear(hSession);
< 				skipped = False;
< 				state = BASE;
< 				if (IN_3270)
< 					return len-1;
< 				else
---
> 				case 'f':
> 					lib3270_clear(hSession);
> 					skipped = False;
> 					state = BASE;
> 					if (IN_3270)
> 						return len-1;
> 					else
> 						break;
> 
> 				case 'n':
> 					lib3270_enter(hSession);
> 					skipped = False;
> 					state = BASE;
> 					if (IN_3270)
> 						return len-1;
> 					else
> 						break;
> 
> 				case 'p':
> 					state = BACKP;
1782,1788c1955,1958
< 			case 'n':
< 				lib3270_enter(hSession);
< 				skipped = False;
< 				state = BASE;
< 				if (IN_3270)
< 					return len-1;
< 				else
---
> 				case 'r':
> 					lib3270_newline(hSession);
> 					skipped = False;
> 					state = BASE;
1791,1793c1961,1965
< 			case 'p':
< 				state = BACKP;
< 				break;
---
> 				case 't':
> 					lib3270_nextfield(hSession);
> 					skipped = False;
> 					state = BASE;
> 					break;
1795,1799c1967,1971
< 			case 'r':
< 				lib3270_newline(hSession);
< 				skipped = False;
< 				state = BASE;
< 				break;
---
> 				case 'T':
> 					lib3270_nextfield(hSession);
> 					skipped = False;
> 					state = BASE;
> 					break;
1801,1805c1973,1976
< 			case 't':
< 				lib3270_nextfield(hSession);
< 				skipped = False;
< 				state = BASE;
< 				break;
---
> 				case 'v':
> 					popup_an_error(hSession,_( "%s: Vertical tab not supported" ),action_name(String_action));
> 					state = BASE;
> 					break;
1807,1810c1978,2003
< 			case 'T':
< 				lib3270_nextfield(hSession);
< 				skipped = False;
< 				state = BASE;
---
> 				case 'x':
> 					state = BACKX;
> 					break;
> 
> 				case '\\':
> 					key_ACharacter(hSession,(unsigned char) c, KT_STD, ia,&skipped);
> 					state = BASE;
> 					break;
> 
> 				case '0':
> 				case '1':
> 				case '2':
> 				case '3':
> 				case '4':
> 				case '5':
> 				case '6':
> 				case '7':
> 					state = OCTAL;
> 					literal = 0;
> 					nc = 0;
> 					continue;
> 
> 				default:
> 					state = BASE;
> 					continue;
> 				}
1813,1815c2006,2025
< 			case 'v':
< 				popup_an_error(hSession,_( "%s: Vertical tab not supported" ),action_name(String_action));
< 				state = BASE;
---
> 		    case BACKP:	/* last two characters were "\p" */
> 				switch (c)
> 				{
> 				case 'a':
> 					literal = 0;
> 					nc = 0;
> 					state = BACKPA;
> 					break;
> 
> 				case 'f':
> 					literal = 0;
> 					nc = 0;
> 					state = BACKPF;
> 					break;
> 
> 				default:
> 					popup_an_error(hSession,_( "%s: Unknown character after \\p" ),action_name(String_action));
> 					state = BASE;
> 					break;
> 				}
1818,1819c2028,2047
< 			case 'x':
< 				state = BACKX;
---
> 		    case BACKPF: /* last three characters were "\pf" */
> 				if (nc < 2 && isdigit(c))
> 				{
> 					literal = (literal * 10) + (c - '0');
> 					nc++;
> 				}
> 				else if (!nc)
> 				{
> 					popup_an_error(hSession,_( "%s: Unknown character after \\pf" ),action_name(String_action));
> 					state = BASE;
> 				}
> 				else
> 				{
> 					do_pf(hSession,literal);
> 					skipped = False;
> 					if (IN_3270)
> 						return len-1;
> 					state = BASE;
> 					continue;
> 				}
1822,1824c2050,2069
< 			case '\\':
< 				key_ACharacter(hSession,(unsigned char) c, KT_STD, ia,&skipped);
< 				state = BASE;
---
> 		    case BACKPA: /* last three characters were "\pa" */
> 				if (nc < 1 && isdigit(c))
> 				{
> 					literal = (literal * 10) + (c - '0');
> 					nc++;
> 				}
> 				else if (!nc)
> 				{
> 					popup_an_error(hSession,_( "%s: Unknown character after \\pa" ),action_name(String_action));
> 					state = BASE;
> 				}
> 				else
> 				{
> 					do_pa(hSession, literal);
> 					skipped = False;
> 					if (IN_3270)
> 						return len-1;
> 					state = BASE;
> 					continue;
> 				}
1827,1837c2072,2085
< 			case '0':
< 			case '1':
< 			case '2':
< 			case '3':
< 			case '4':
< 			case '5':
< 			case '6':
< 			case '7':
< 				state = OCTAL;
< 				literal = 0;
< 				nc = 0;
---
> 		    case BACKX:	/* last two characters were "\x" */
> 				if (isxdigit(c))
> 				{
> 					state = HEX;
> 					literal = 0;
> 					nc = 0;
> 					continue;
> 				}
> 				else
> 				{
> 					popup_an_error(hSession,_( "%s: Missing hex digits after \\x" ),action_name(String_action));
> 					state = BASE;
> 					continue;
> 				}
1840,1844c2088,2100
< 			default:
< 				state = BASE;
< 				continue;
< 			}
< 			break;
---
> 		    case OCTAL:	/* have seen \ and one or more octal digits */
> 				if (nc < 3 && isdigit(c) && c < '8')
> 				{
> 					literal = (literal * 8) + FROM_HEX(c);
> 					nc++;
> 					break;
> 				}
> 				else
> 				{
> 					key_ACharacter(hSession,(unsigned char) literal, KT_STD,ia, &skipped);
> 					state = BASE;
> 					continue;
> 				}
1846,1852c2102,2114
< 		case BACKP:	/* last two characters were "\p" */
< 			switch (c) {
< 			case 'a':
< 				literal = 0;
< 				nc = 0;
< 				state = BACKPA;
< 				break;
---
> 		    case HEX:	/* have seen \ and one or more hex digits */
> 				if (nc < 2 && isxdigit(c))
> 				{
> 					literal = (literal * 16) + FROM_HEX(c);
> 					nc++;
> 					break;
> 				}
> 				else
> 				{
> 					key_ACharacter(hSession,(unsigned char) literal, KT_STD, ia, &skipped);
> 					state = BASE;
> 					continue;
> 				}
1854,1858c2116,2121
< 			case 'f':
< 				literal = 0;
< 				nc = 0;
< 				state = BACKPF;
< 				break;
---
> 		    case XGE:	/* have seen ESC */
> 				switch (c)
> 				{
> 					case ';':	/* FM */
> 						key_Character(hSession, EBC_fm, False, True, &skipped);
> 						break;
1860,1861c2123,2130
< 			default:
< 				popup_an_error(hSession,_( "%s: Unknown character after \\p" ),action_name(String_action));
---
> 					case '*':	/* DUP */
> 						key_Character(hSession, EBC_dup, False, True, &skipped);
> 						break;
> 
> 					default:
> 						key_ACharacter(hSession,(unsigned char) c, KT_GE, ia,&skipped);
> 						break;
> 				}
1864,1865c2133,2136
< 			}
< 			break;
---
> 		}
> 		ws++;
> 		len--;
> 	}
1867,1880c2138,2143
< 		case BACKPF: /* last three characters were "\pf" */
< 			if (nc < 2 && isdigit(c)) {
< 				literal = (literal * 10) + (c - '0');
< 				nc++;
< 			} else if (!nc) {
< 				popup_an_error(hSession,_( "%s: Unknown character after \\pf" ),action_name(String_action));
< 				state = BASE;
< 			} else {
< 				do_pf(hSession,literal);
< 				skipped = False;
< 				if (IN_3270)
< 					return len-1;
< 				state = BASE;
< 				continue;
---
> 	switch (state)
> 	{
> 	    case BASE:
> 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col)
> 			{
> 				(void) remargin(hSession,orig_col);
1884,1897c2147,2153
< 		case BACKPA: /* last three characters were "\pa" */
< 			if (nc < 1 && isdigit(c)) {
< 				literal = (literal * 10) + (c - '0');
< 				nc++;
< 			} else if (!nc) {
< 				popup_an_error(hSession,_( "%s: Unknown character after \\pa" ),action_name(String_action));
< 				state = BASE;
< 			} else {
< 				do_pa(hSession, literal);
< 				skipped = False;
< 				if (IN_3270)
< 					return len-1;
< 				state = BASE;
< 				continue;
---
> 	    case OCTAL:
> 	    case HEX:
> 			key_ACharacter(hSession,(unsigned char) literal, KT_STD, ia, &skipped);
> 			state = BASE;
> 			if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col)
> 			{
> 				(void) remargin(hSession,orig_col);
1901,1920c2157,2160
< 		case BACKX:	/* last two characters were "\x" */
< 			if (isxdigit(c)) {
< 				state = HEX;
< 				literal = 0;
< 				nc = 0;
< 				continue;
< 			} else {
< 				popup_an_error(hSession,_( "%s: Missing hex digits after \\x" ),action_name(String_action));
< 				state = BASE;
< 				continue;
< 			}
< 			continue;
< 
< 		case OCTAL:	/* have seen \ and one or more octal digits */
< 			if (nc < 3 && isdigit(c) && c < '8') {
< 				literal = (literal * 8) + FROM_HEX(c);
< 				nc++;
< 				break;
< 			} else {
< 				key_ACharacter(hSession,(unsigned char) literal, KT_STD,ia, &skipped);
---
> 	    case BACKPF:
> 			if (nc > 0)
> 			{
> 				do_pf(hSession,literal);
1922d2161
< 				continue;
1923a2163
> 			break;
1925,1931c2165,2168
< 		case HEX:	/* have seen \ and one or more hex digits */
< 			if (nc < 2 && isxdigit(c)) {
< 				literal = (literal * 16) + FROM_HEX(c);
< 				nc++;
< 				break;
< 			} else {
< 				key_ACharacter(hSession,(unsigned char) literal, KT_STD, ia, &skipped);
---
> 	    case BACKPA:
> 			if (nc > 0)
> 			{
> 				do_pa(hSession,literal);
1933,1948d2169
< 				continue;
< 			}
< 
< 		case XGE:	/* have seen ESC */
< 			switch (c) {
< 			case ';':	/* FM */
< 				key_Character(hSession, EBC_fm, False, True, &skipped);
< 				break;
< 
< 			case '*':	/* DUP */
< 				key_Character(hSession, EBC_dup, False, True, &skipped);
< 				break;
< 
< 			default:
< 				key_ACharacter(hSession,(unsigned char) c, KT_GE, ia,&skipped);
< 				break;
1950d2170
< 			state = BASE;
1952,1955d2171
< 		}
< 		ws++;
< 		len--;
< 	}
1957,1989c2173,2175
< 	switch (state) {
< 	case BASE:
< 		if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col) {
< 			(void) remargin(hSession,orig_col);
< 		}
< 		break;
< 
< 	case OCTAL:
< 	case HEX:
< 		key_ACharacter(hSession,(unsigned char) literal, KT_STD, ia, &skipped);
< 		state = BASE;
< 		if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < orig_col) {
< 			(void) remargin(hSession,orig_col);
< 		}
< 		break;
< 
< 	case BACKPF:
< 		if (nc > 0) {
< 			do_pf(hSession,literal);
< 			state = BASE;
< 		}
< 		break;
< 
< 	case BACKPA:
< 		if (nc > 0) {
< 			do_pa(hSession,literal);
< 			state = BASE;
< 		}
< 		break;
< 
< 	default:
< 		popup_an_error(hSession,"%s: Missing data after \\",action_name(String_action));
< 		break;
---
> 	    default:
> 			popup_an_error(hSession,"%s: Missing data after \\",action_name(String_action));
> 			break;
2002c2188,2189
< int kybd_prime(H3270 *hSession) {
---
> int kybd_prime(H3270 *hSession)
> {
2015c2202,2203
< 	if (hSession->ea_buf[hSession->cursor_addr].fa || FA_IS_PROTECTED(fa)) {
---
> 	if (hSession->ea_buf[hSession->cursor_addr].fa || FA_IS_PROTECTED(fa))
> 	{
2027c2215,2217
< 	} else {
---
> 	}
> 	else
> 	{
2030c2220,2221
< 		while (!hSession->ea_buf[baddr].fa) {
---
> 		while (!hSession->ea_buf[baddr].fa)
> 		{
2040c2231,2232
< 	while (!hSession->ea_buf[baddr].fa) {
---
> 	while (!hSession->ea_buf[baddr].fa)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/properties.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/keyboard/properties.c
34c34,35
< LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_get_keyboard_lock_state(const H3270 *hSession) {
---
> LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_get_keyboard_lock_state(const H3270 *hSession)
> {
41c42,43
< LIB3270_EXPORT int lib3270_set_lock_on_operator_error(H3270 *hSession, int enable) {
---
> LIB3270_EXPORT int lib3270_set_lock_on_operator_error(H3270 *hSession, int enable)
> {
46c48,49
< LIB3270_EXPORT int lib3270_set_numeric_lock(H3270 *hSession, int enable) {
---
> LIB3270_EXPORT int lib3270_set_numeric_lock(H3270 *hSession, int enable)
> {
51,52c54,56
< int lib3270_get_lock_on_operator_error(const H3270 *hSession) {
< 	return (int) hSession->oerr_lock;
---
> int lib3270_get_lock_on_operator_error(const H3270 *hSession)
> {
>  	return (int) hSession->oerr_lock;
55,56c59,61
< int lib3270_get_numeric_lock(const H3270 *hSession) {
< 	return (int) hSession->numeric_lock;
---
> int lib3270_get_numeric_lock(const H3270 *hSession)
> {
>  	return (int) hSession->numeric_lock;
59c64,65
< LIB3270_EXPORT int lib3270_set_unlock_delay(H3270 *hSession, unsigned int delay) {
---
> LIB3270_EXPORT int lib3270_set_unlock_delay(H3270 *hSession, unsigned int delay)
> {
65c71,72
< LIB3270_EXPORT unsigned int lib3270_get_unlock_delay(const H3270 *hSession) {
---
> LIB3270_EXPORT unsigned int lib3270_get_unlock_delay(const H3270 *hSession)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linkedlist.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linkedlist.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,14c6,21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como linkedlist.c e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
27a30
> 
32,36c35,38
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <linkedlist.h>
< #include <string.h>
< #include <errno.h>
---
>  #include <lib3270.h>
>  #include <lib3270/log.h>
>  #include <linkedlist.h>
>  #include <string.h>
40c42,43
< void * lib3270_linked_list_append_node(struct lib3270_linked_list_head *head, size_t szBlock, void *userdata) {
---
> void * lib3270_linked_list_append_node(struct lib3270_linked_list_head *head, size_t szBlock, void *userdata)
> {
46,49c49,55
< 	if(head->last) {
< 		head->last->next = node;
< 		node->prev = head->last;
< 	} else {
---
> 	if(head->last)
> 	{
>         head->last->next = node;
>         node->prev = head->last;
> 	}
> 	else
> 	{
56c62
< 	#ifdef DEBUG
---
> #ifdef DEBUG
68c74
< 	#endif // DEBUG
---
> #endif // DEBUG
75c81,82
< int lib3270_linked_list_delete_node(struct lib3270_linked_list_head *head, const void *node) {
---
> int lib3270_linked_list_delete_node(struct lib3270_linked_list_head *head, const void *node)
> {
79c86,87
< 	for(current = head->first; current; current = current->next) {
---
> 	for(current = head->first;current;current = current->next)
> 	{
81c89,90
< 		if(current == node) {
---
> 		if(current == node)
> 		{
96c105
< 			#ifdef DEBUG
---
> #ifdef DEBUG
108,109c117,118
< 			#endif // DEBUG
< 			*/
---
> #endif // DEBUG
> 		*/
120c129,130
< void lib3270_linked_list_free(struct lib3270_linked_list_head *head) {
---
> void lib3270_linked_list_free(struct lib3270_linked_list_head *head)
> {
123c133,134
< 	while(node) {
---
> 	while(node)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/connect.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/connect.c
62c62
< static int sock_connect(H3270 *hSession, int sock, const struct sockaddr *address, socklen_t address_len) {
---
>  static int sock_connect(H3270 *hSession, int sock, const struct sockaddr *address, socklen_t address_len) {
92c92
< 			if(pfd.revents & POLLOUT) {
---
> 			if(pfd.revents && POLLOUT) {
103c103
< }
---
>  }
106c106
< int lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state) {
---
>  int lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state) {
115c115
< 	struct addrinfo * result	= NULL;
---
>  	struct addrinfo * result	= NULL;
124,125c124,126
< 	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
< 	if(rc) {
---
>  	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
>  	if(rc)
> 	{
138c139,140
< 	for(rp = result; sock < 0 && rp != NULL && state->syserror != ECANCELED; rp = rp->ai_next) {
---
> 	for(rp = result; sock < 0 && rp != NULL && state->syserror != ECANCELED; rp = rp->ai_next)
> 	{
141c143,144
< 		if(sock < 0) {
---
> 		if(sock < 0)
> 		{
148c151,152
< 		if(sock_connect(hSession, sock, rp->ai_addr, rp->ai_addrlen)) {
---
> 		if(sock_connect(hSession, sock, rp->ai_addr, rp->ai_addrlen))
> 		{
161c165,166
< 	if(sock < 0) {
---
> 	if(sock < 0)
> 	{
177c182
< }
---
>  }
179,181c184,187
< static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno)) {
< 	int 		err	= 0;
< 	socklen_t	len	= sizeof(err);
---
>  static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno))
>  {
> 	int 		err;
> 	socklen_t	len		= sizeof(err);
189,195c195,197
< 	if(hSession->network.module->getsockopt(hSession, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0) {
< 		lib3270_autoptr(char) body = lib3270_strdup_printf(
< 		                                 _("The System error was '%s' (rc=%d)"),
< 		                                 strerror(errno),
< 		                                 errno
< 		                             );
< 
---
> 	if(hSession->network.module->getsockopt(hSession, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0)
> 	{
> 		int err = errno;
197,206c199,205
< 
< 		LIB3270_POPUP popup = {
< 			.type = LIB3270_NOTIFY_ERROR,
< 			.title = _( "Network error" ),
< 			.summary = _( "Unable to get connection state." ),
< 			.body = body
< 		};
< 
< 		lib3270_popup(hSession,&popup,0);
< 
---
> 		lib3270_popup_dialog(
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Network error" ),
> 			_( "Unable to get connection state." ),
> 			_( "The system error was %s" ), strerror(err)
> 		);
207a207,223
> 	}
> 	else if(err)
> 	{
> 		lib3270_autoptr(LIB3270_POPUP) popup =
> 			lib3270_popup_clone_printf(
> 				NULL,
> 				_( "Can't connect to %s:%s"),
> 				hSession->host.current,
> 				hSession->host.srvc
> 			);
> 
> 		lib3270_autoptr(char) syserror =
> 						lib3270_strdup_printf(
> 							_("The system error was \"%s\" (rc=%d)"),
> 							strerror(err),
> 							err
> 						);
209,236c225
< 	} else if(err) {
< 
< 		lib3270_disconnect(hSession);
< 
< 		lib3270_autoptr(char) summary =
< 		    lib3270_strdup_printf(
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
< 
< 		lib3270_autoptr(char) body =
< 		    lib3270_strdup_printf(
< 		        _("The system error was \"%s\" (rc=%d)"),
< 		        strerror(err),
< 		        err
< 		    );
< 
< 
< 		LIB3270_POPUP popup = {
< 			.type = LIB3270_NOTIFY_ERROR,
< 			.title = _( "Connection error" ),
< 			.summary = summary,
< 			.body = body,
< 			.label = _("_Retry")
< 		};
< 
< 		if(lib3270_popup(hSession,&popup,!hSession->auto_reconnect_inprogress) == 0)
---
> 		if(hSession->cbk.popup(hSession,popup,!hSession->auto_reconnect_inprogress) == 0)
255c244
< }
---
>  }
257c246,247
< int net_reconnect(H3270 *hSession, int seconds) {
---
>  int net_reconnect(H3270 *hSession, int seconds)
>  {
261c251
< 	// Initialize and connect to host
---
>  	// Initialize and connect to host
265c255,256
< 	if(lib3270_run_task(hSession, (int(*)(H3270 *, void *)) hSession->network.module->connect, &state)) {
---
> 	if(lib3270_run_task(hSession, (int(*)(H3270 *, void *)) hSession->network.module->connect, &state))
> 	{
267,272c258,263
< 		    lib3270_popup_clone_printf(
< 		        NULL,
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
---
> 			lib3270_popup_clone_printf(
> 				NULL,
> 				_( "Can't connect to %s:%s"),
> 				hSession->host.current,
> 				hSession->host.srvc
> 			);
274c265,266
< 		if(!popup->summary) {
---
> 		if(!popup->summary)
> 		{
280c272,273
< 		if(state.syserror) {
---
> 		if(state.syserror)
> 		{
282,285c275,278
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               strerror(state.syserror),
< 			               state.syserror
< 			           );
---
> 							_("The system error was \"%s\" (rc=%d)"),
> 							strerror(state.syserror),
> 							state.syserror
> 						);
288,289c281,283
< 		else if(state.winerror) {
< #error TODO
---
> 		else if(state.winerror)
> 		{
> 			#error TODO
293c287,288
< 		if(!popup->body) {
---
> 		if(!popup->body)
> 		{
317c312,313
< 	if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_OOBINLINE, &optval, sizeof(optval)) < 0) {
---
> 	if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_OOBINLINE, &optval, sizeof(optval)) < 0)
> 	{
320,324c316,320
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        _( "setsockopt(SO_OOBINLINE) has failed" ),
< 		                        "%s",
< 		                        strerror(rc));
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								_( "setsockopt(SO_OOBINLINE) has failed" ),
> 								"%s",
> 								strerror(rc));
330c326,327
< 	if (hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
---
> 	if (hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0)
> 	{
337,341c334,338
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        buffer,
< 		                        "%s",
< 		                        strerror(rc));
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								buffer,
> 								"%s",
> 								strerror(rc));
345c342,344
< 	} else {
---
> 	}
> 	else
> 	{
351c350
< 	#if defined(OMTU)
---
> #if defined(OMTU)
357c356
< 	#endif
---
> #endif
369c368,369
< 	if(seconds) {
---
> 	if(seconds)
> 	{
371c371,372
< 		if(rc) {
---
> 		if(rc)
> 		{
375a377,416
> 
> 		/*
> 		time_t end = time(0)+seconds;
> 
> 		while(time(0) < end)
> 		{
> 			lib3270_main_iterate(hSession,1);
> 
> 			switch(hSession->connection.state)
> 			{
> 			case LIB3270_PENDING:
> 			case LIB3270_CONNECTED_INITIAL:
> 			case LIB3270_CONNECTED_ANSI:
> 			case LIB3270_CONNECTED_3270:
> 			case LIB3270_CONNECTED_INITIAL_E:
> 			case LIB3270_CONNECTED_NVT:
> 			case LIB3270_CONNECTED_SSCP:
> 			case LIB3270_CONNECTING:
> 				break;
> 
> 			case LIB3270_NOT_CONNECTED:
> 				return errno = ENOTCONN;
> 
> 			case LIB3270_CONNECTED_TN3270E:
> 				if(!hSession->starting)
> 					return 0;
> 				break;
> 
> 			default:
> 				lib3270_write_log(hSession,"connect", "%s: State changed to unexpected state %d",__FUNCTION__,hSession->connection.state);
> 				return errno = EINVAL;
> 			}
> 
> 		}
> 
> 		lib3270_disconnect(hSession);
> 		lib3270_write_log(hSession,"connect", "%s: %s",__FUNCTION__,strerror(ETIMEDOUT));
> 
> 		return errno = ETIMEDOUT;
> 		*/
380c421
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/curl.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/curl.c
44c44,45
< static inline void lib3270_autoptr_cleanup_CURL(CURL **ptr) {
---
> static inline void lib3270_autoptr_cleanup_CURL(CURL **ptr)
> {
51c52,53
< typedef struct _curldata {
---
> typedef struct _curldata
> {
61c63,64
< static inline void lib3270_autoptr_cleanup_CURLDATA(CURLDATA **ptr) {
---
> static inline void lib3270_autoptr_cleanup_CURLDATA(CURLDATA **ptr)
> {
63c66,67
< 	if(*ptr) {
---
> 	if(*ptr)
> 	{
75c79,80
< static size_t internal_curl_write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
---
> static size_t internal_curl_write_callback(void *contents, size_t size, size_t nmemb, void *userp)
> {
84c89,90
< 	if((realsize + data->length) > data->data.length) {
---
> 	if((realsize + data->length) > data->data.length)
> 	{
92c98,99
< 	if(lib3270_get_toggle(data->hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(data->hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
94,97c101,104
< 		    data->hSession,
< 		    "Received",
< 		    (const unsigned char *) contents,
< 		    realsize
---
> 			data->hSession,
> 			"Received",
> 			(const unsigned char *) contents,
> 			realsize
111c118,119
< static int internal_curl_trace_callback(CURL GNUC_UNUSED(*handle), curl_infotype type, char *data, size_t size, void *userp) {
---
> static int internal_curl_trace_callback(CURL GNUC_UNUSED(*handle), curl_infotype type, char *data, size_t size, void *userp)
> {
149,152c157,160
< 	    ((CURLDATA *) userp)->hSession,
< 	    text,
< 	    (const unsigned char *) data,
< 	    size
---
> 		((CURLDATA *) userp)->hSession,
> 		text,
> 		(const unsigned char *) data,
> 		size
158c166,167
< char * lib3270_url_get_using_curl(H3270 *hSession, const char *url, const char **error) {
---
> char * lib3270_url_get_using_curl(H3270 *hSession, const char *url, const char **error)
> {
170c179,180
< 	if(!hCurl) {
---
> 	if(!hCurl)
> 	{
187c197,198
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
195c206,207
< 	if(res != CURLE_OK) {
---
> 	if(res != CURLE_OK)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/download.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/download.c
35c35
< char * lib3270_url_get(H3270 *hSession, const char *u, const char **error) {
---
>  char * lib3270_url_get(H3270 *hSession, const char *u, const char **error) {
63c63
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/event_dispatcher.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/event_dispatcher.c
30,33c30,33
< /**
<  * @brief Implements the default event dispatcher for linux.
<  *
<  */
---
>  /**
>   * @brief Implements the default event dispatcher for linux.
>   *
>   */
53c53,54
< int lib3270_default_event_dispatcher(H3270 *hSession, int block) {
---
> int lib3270_default_event_dispatcher(H3270 *hSession, int block)
> {
77,78c78,81
< 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next) {
< 		if(!ip->enabled) {
---
> 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next)
> 	{
> 		if(!ip->enabled)
> 		{
83c86,87
< 		if(ip->flag & LIB3270_IO_FLAG_READ) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_READ)
> 		{
88c92,93
< 		if(ip->flag & LIB3270_IO_FLAG_WRITE) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_WRITE)
> 		{
93c98,99
< 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION)
> 		{
99,100c105,108
< 	if (block) {
< 		if (hSession->timeouts.first) {
---
> 	if (block)
> 	{
> 		if (hSession->timeouts.first)
> 		{
111c119,121
< 		} else {
---
> 		}
> 		else
> 		{
116c126,128
< 	} else {
---
> 	}
> 	else
> 	{
127c139,140
< 	if (ns < 0 && errno != EINTR) {
---
> 	if (ns < 0 && errno != EINTR)
> 	{
129,136c142,153
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Network error" ),
< 		                        _( "Select() failed when processing for events." ),
< 		                        "%s",
< 		                        strerror(errno));
< 	} else {
< 		for (ip = (input_t *) hSession->input.list.first; ip != (input_t *) NULL; ip = (input_t *) ip->next) {
< 			if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds)) {
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Network error" ),
> 								_( "Select() failed when processing for events." ),
> 								"%s",
> 								strerror(errno));
> 	}
> 	else
> 	{
> 		for (ip = (input_t *) hSession->input.list.first; ip != (input_t *) NULL; ip = (input_t *) ip->next)
> 		{
> 			if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds))
> 			{
143c160,161
< 			if((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds)) {
---
> 			if((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds))
> 			{
150c168,169
< 			if((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds)) {
---
> 			if((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds))
> 			{
160c179,180
< 	if (hSession->timeouts.first) {
---
> 	if (hSession->timeouts.first)
> 	{
164,165c184,186
< 		while(hSession->timeouts.first) {
< 			t = (struct timeout *) hSession->timeouts.first;
---
> 		while(hSession->timeouts.first)
> 		{
>             t = (struct timeout *) hSession->timeouts.first;
167c188,189
< 			if (t->tv.tv_sec < now.tv_sec ||(t->tv.tv_sec == now.tv_sec && t->tv.tv_usec < now.tv_usec)) {
---
> 			if (t->tv.tv_sec < now.tv_sec ||(t->tv.tv_sec == now.tv_sec && t->tv.tv_usec < now.tv_usec))
> 			{
176c198,200
< 			} else {
---
> 			}
> 			else
> 			{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/ldap.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/ldap.c
48c48,49
< static inline void lib3270_autoptr_cleanup_LDAPMessage(LDAPMessage **message) {
---
> static inline void lib3270_autoptr_cleanup_LDAPMessage(LDAPMessage **message)
> {
55c56,57
< static inline void lib3270_autoptr_cleanup_LDAP(LDAP **ld) {
---
> static inline void lib3270_autoptr_cleanup_LDAP(LDAP **ld)
> {
62c64,65
< static inline void lib3270_autoptr_cleanup_BerElement(BerElement **ber) {
---
> static inline void lib3270_autoptr_cleanup_BerElement(BerElement **ber)
> {
69c72,73
< static inline void lib3270_autoptr_cleanup_LDAPPTR(char **ptr) {
---
> static inline void lib3270_autoptr_cleanup_LDAPPTR(char **ptr)
> {
127,138c131,142
< 	         ld,						// Specifies the LDAP pointer returned by a previous call to ldap_init(), ldap_ssl_init(), or ldap_open().
< 	         base,					// Specifies the DN of the entry at which to start the search.
< 	         LDAP_SCOPE_BASE,		// Specifies the scope of the search.
< 	         NULL,					// Specifies a string representation of the filter to apply in the search.
< 	         (char **)  &attrs,		// Specifies a null-terminated array of character string attribute types to return from entries that match filter.
< 	         0,						// Should be set to 1 to request attribute types only. Set to 0 to request both attributes types and attribute values.
< 	         NULL,
< 	         NULL,
< 	         NULL,
< 	         0,
< 	         &results
< 	     );
---
> 				ld,						// Specifies the LDAP pointer returned by a previous call to ldap_init(), ldap_ssl_init(), or ldap_open().
> 				base,					// Specifies the DN of the entry at which to start the search.
> 				LDAP_SCOPE_BASE,		// Specifies the scope of the search.
> 				NULL,					// Specifies a string representation of the filter to apply in the search.
> 				(char **)  &attrs,		// Specifies a null-terminated array of character string attribute types to return from entries that match filter.
> 				0,						// Should be set to 1 to request attribute types only. Set to 0 to request both attributes types and attribute values.
> 				NULL,
> 				NULL,
> 				NULL,
> 				0,
> 				&results
> 			);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/log.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/log.c
38c38
< #include <syslog.h>
---
> 	#include <syslog.h>
43c43
< int use_syslog = 0;
---
>  int use_syslog = 0;
45c45,46
< int default_loghandler(const H3270 GNUC_UNUSED(*session), void GNUC_UNUSED(*userdata), const char *module, int GNUC_UNUSED(rc), const char *message) {
---
>  void default_log_writer(H3270 GNUC_UNUSED(*session), const char *module, int GNUC_UNUSED(rc), const char *fmt, va_list arg_ptr)
>  {
47,50c48,56
< 	if(use_syslog) {
< 		syslog(LOG_INFO, "%s: %s", module, message);
< 	} else {
< 		printf("%s %s\n", module, message);
---
> 	if(use_syslog)
> 	{
> 		vsyslog(LOG_INFO, fmt, arg_ptr);
> 	}
> 	else
> 	{
> 		printf("%s:\t",module);
> 		vprintf(fmt,arg_ptr);
> 		printf("\n");
54c60,62
< 	printf("%s %s\n", module, message);
---
>  	printf("%s:\t",module);
> 	vprintf(fmt,arg_ptr);
> 	printf("\n");
57,58c65
< 	return 0;
< }
---
>  }
60c67,68
< LIB3270_EXPORT int lib3270_set_syslog(int flag) {
---
>  LIB3270_EXPORT int lib3270_set_syslog(int flag)
>  {
62,63c70,73
< 	if(flag) {
< 		if(!use_syslog) {
---
> 	if(flag)
> 	{
> 		if(!use_syslog)
> 		{
67,68c77,81
< 	} else {
< 		if(use_syslog) {
---
> 	}
> 	else
> 	{
> 		if(use_syslog)
> 		{
77c90
< 	return errno  = ENOENT;
---
>  	return errno  = ENOENT;
79c92
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/private.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/private.h
32c32
< #define PRIVATE_H_INCLUDED
---
> 	#define PRIVATE_H_INCLUDED
34,35c34,35
< #include <config.h>
< #include <internals.h>
---
> 	#include <config.h>
> 	#include <internals.h>
37,38c37,38
< #include <lib3270.h>
< #include <lib3270/log.h>
---
> 	#include <lib3270.h>
>  	#include <lib3270/log.h>
40,42c40,42
< #if defined(HAVE_LIBCURL)
< LIB3270_INTERNAL char * lib3270_url_get_using_curl(H3270 *hSession, const char *u, const char **error);
< #endif // HAVE_LIBCURL
---
>  #if defined(HAVE_LIBCURL)
> 	LIB3270_INTERNAL char * lib3270_url_get_using_curl(H3270 *hSession, const char *u, const char **error);
>  #endif // HAVE_LIBCURL
44,46c44,46
< #if defined(HAVE_LDAP)
< LIB3270_INTERNAL char * lib3270_url_get_using_ldap(H3270 *hSession, const char *u, const char **error);
< #endif // HAVE_LDAP
---
>  #if defined(HAVE_LDAP)
> 	LIB3270_INTERNAL char * lib3270_url_get_using_ldap(H3270 *hSession, const char *u, const char **error);
>  #endif // HAVE_LDAP
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/util.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/linux/util.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,5
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob
>  * o nome G3270.
6,14c7,22
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d23
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
38c41,42
< static char * concat(char *path, const char *name, size_t *length) {
---
> static char * concat(char *path, const char *name, size_t *length)
> {
46c50,51
< 	if(szCurrent >= *length) {
---
> 	if(szCurrent >= *length)
> 	{
56c61,62
< static char * build_filename(const char *root, const char *str, va_list args) {
---
> static char * build_filename(const char *root, const char *str, va_list args)
> {
70c76,77
< char * lib3270_build_data_filename(const char *str, ...) {
---
> char * lib3270_build_data_filename(const char *str, ...)
> {
81c88,89
< char * lib3270_build_config_filename(const char *str, ...) {
---
> char * lib3270_build_config_filename(const char *str, ...)
> {
92c100,101
< char * lib3270_build_filename(const char *str, ...) {
---
> char * lib3270_build_filename(const char *str, ...)
> {
111c120,121
< 	static const char * paths[] = {
---
> 	static const char * paths[] =
> 	{
117c127,128
< 	for(ix = 0; ix < (sizeof(paths)/sizeof(paths[0])); ix++) {
---
> 	for(ix = 0; ix < (sizeof(paths)/sizeof(paths[0])); ix++)
> 	{
120c131,132
< 		if(access(tempname, F_OK) == 0) {
---
> 		if(access(tempname, F_OK) == 0)
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/log.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/log.c
33,34d32
< #include <config.h>
< 
36,37c34,35
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
50,51c48
< static LIB3270_LOG_HANDLER loghandler = default_loghandler;
< static void *loguserdata = NULL;
---
>  static void (*loghandler)(H3270 *session, const char *module, int rc, const char *fmt, va_list arg_ptr) = default_log_writer;
55,133c52,54
< static void write_log(const H3270 *session, const char *module, int rc, const char *fmt, va_list args) {
< 
< 	// 'mount' message.
< 	char *message = lib3270_vsprintf(fmt,args);
< 
< 	// Write log
< 	if(session) {
< 
< 		if(session->log.file) {
< 
< 			// Has log file. Use it if possible.
< 			FILE *f = fopen(session->log.file, "a");
< 
< 			if(f) {
< 
< 				time_t ltime = time(0);
< 
< 			   char timestamp[80];
< 		#ifdef HAVE_LOCALTIME_R
< 				struct tm tm;
< 				strftime(timestamp, 79, "%x %X", localtime_r(&ltime,&tm));
< 		#else
< 				strftime(timestamp, 79, "%x %X", localtime(&ltime));
< 		#endif // HAVE_LOCALTIME_R
< 
< 				fprintf(f,"%s %s\t%s\n",timestamp,module,message);
< 
< 				fclose(f);
< 
< 			}
< 
< 		}
< 
< 		session->log.handler(session,session->log.userdata,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),rc,message);
< 
< 	} else {
< 
< 		loghandler(session, loguserdata, (module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME)),rc,message);
< 
< 	}
< 
< 	lib3270_free(message);
< 
< }
< 
< LIB3270_EXPORT const char * lib3270_get_log_filename(const H3270 * hSession) {
< 	return hSession->log.file;
< }
< 
< LIB3270_EXPORT int lib3270_set_log_filename(H3270 * hSession, const char *filename) {
< 
< 	if(!hSession) {
< 		return EINVAL;
< 	}
< 
< 	if(hSession->log.file) {
< 		lib3270_free(hSession->log.file);
< 	}
< 
< 	hSession->log.file = NULL;
< 
< 	if(filename && *filename) {
< 		hSession->log.file = lib3270_strdup(filename);
< 	}
< 
< 	return 0;
< 
< }
< 
< LIB3270_EXPORT void lib3270_set_log_handler(H3270 *session, const LIB3270_LOG_HANDLER handler, void *userdata) {
< 
< 	if(session) {
< 		session->log.handler = (handler ? handler : loghandler);
< 		session->log.userdata = userdata;
< 	} else {
< 		loghandler = (handler ? handler : default_loghandler);
< 		loguserdata = userdata;
< 	}
< }
---
>  LIB3270_EXPORT void lib3270_set_log_handler(void (*handler)(H3270 *, const char *, int, const char *, va_list)) {
> 	loghandler = handler ? handler : default_log_writer;
>  }
135c56
< LIB3270_EXPORT int lib3270_write_log(const H3270 *session, const char *module, const char *fmt, ...) {
---
>  LIB3270_EXPORT int lib3270_write_log(H3270 *session, const char *module, const char *fmt, ...) {
138c59
< 	write_log(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),0,fmt,arg_ptr);
---
> 	loghandler(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),0,fmt,arg_ptr);
140,141c61,62
< 	return 0;
< }
---
>     return 0;
>  }
143c64
< LIB3270_EXPORT int lib3270_write_rc(const H3270 *session, const char *module, int rc, const char *fmt, ...) {
---
>  LIB3270_EXPORT int lib3270_write_rc(H3270 *session, const char *module, int rc, const char *fmt, ...) {
146c67
< 	write_log(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),rc,fmt,arg_ptr);
---
> 	loghandler(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),rc,fmt,arg_ptr);
148,149c69,70
< 	return rc;
< }
---
>     return rc;
>  }
151,153c72,74
< LIB3270_EXPORT void lib3270_write_va_log(const H3270 *session, const char *module, const char *fmt, va_list arg) {
< 	write_log(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),0,fmt,arg);
< }
---
>  LIB3270_EXPORT void lib3270_write_va_log(H3270 *session, const char *module, const char *fmt, va_list arg) {
> 	loghandler(session,module ? module : LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),0,fmt,arg);
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/connect.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/connect.c
41a42
> #include <unistd.h>
43a45,46
> #define SOCK_CLOSE(s)	close(s->connection.sock); s->connection.sock = -1;
> 
50d52
< #include "utilc.h"
55,58d56
< #include <lib3270/os.h>
< #include <networking.h>
< //#include <fcntl.h>
< #include <poll.h>
62,67d59
< static int sock_connect(H3270 *hSession, int sock, const struct sockaddr *address, socklen_t address_len) {
< 
< 	lib3270_socket_set_non_blocking(hSession, sock, 1);
< 
< 	if(!connect(sock,address,address_len))
< 		return 0;
69,70c61,64
< 	if(errno != EINPROGRESS)
< 		return errno;
---
> static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno))
> {
> 	int 		err;
> 	socklen_t	len		= sizeof(err);
72,76c66,70
< 	unsigned int timer;
< 	for(timer = 0; timer < hSession->connection.timeout; timer += 10) {
< 
< 		if(lib3270_get_connection_state(hSession) != LIB3270_CONNECTING)
< 			return errno = ECANCELED;
---
> 	if(hSession->xio.write) {
> 		trace("%s write=%p",__FUNCTION__,hSession->xio.write);
> 		lib3270_remove_poll(hSession, hSession->xio.write);
> 		hSession->xio.write = NULL;
> 	}
78,81c72,86
< 		struct pollfd pfd = {
< 			.fd = sock,
< 			.events = POLLOUT
< 		};
---
> 	if(getsockopt(hSession->connection.sock, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0)
> 	{
> 		lib3270_disconnect(hSession);
> 		lib3270_popup_dialog(
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Network error" ),
> 			_( "Unable to get connection state." ),
> 			_( "%s" ), strerror(errno)
> 		);
> 		return;
> 	}
> 	else if(err)
> 	{
> 		char buffer[4096];
83,85c88
< 		switch(poll(&pfd,1,10)) {
< 		case -1:	// Poll error
< 			return errno;
---
> 		snprintf(buffer,4095,_( "Can't connect to %s" ), lib3270_get_url(hSession) );
87,88c90,99
< 		case 0:
< 			break;
---
> 		lib3270_disconnect(hSession);
> 		lib3270_popup_dialog(
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Connection failed" ),
> 			buffer,
> 			_( "%s" ), strerror(err)
> 		);
> 		return;
> 	}
90,97c101,102
< 		case 1:
< 			// Got response.
< 			if(pfd.revents & POLLOUT) {
< 				debug("%s: Connection complete",__FUNCTION__);
< 				return 0;
< 			}
< 			break;
< 		}
---
> 	hSession->xio.except	= lib3270_add_poll_fd(hSession,hSession->connection.sock,LIB3270_IO_FLAG_EXCEPTION,net_exception,0);
> 	hSession->xio.read		= lib3270_add_poll_fd(hSession,hSession->connection.sock,LIB3270_IO_FLAG_READ,net_input,0);
98a104,108
> #if defined(HAVE_LIBSSL)
> 	if(hSession->ssl.con && hSession->ssl.state == LIB3270_SSL_UNDEFINED)
> 	{
> 		if(ssl_negotiate(hSession))
> 			return;
99a110
> #endif
101c112,113
< 	return errno = ETIMEDOUT;
---
> 	lib3270_setup_session(hSession);
> 	lib3270_set_connected_initial(hSession);
104a117,120
>  struct resolver
>  {
> 	const char 			* message;
>  };
106c122,123
< int lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state) {
---
>  static int background_connect(H3270 *hSession, void *host)
>  {
108,113d124
< 	// Reset state
< 	set_ssl_state(hSession,LIB3270_SSL_UNDEFINED);
< 
< 	//
< 	// Resolve hostname
< 	//
115c126,128
< 	struct addrinfo * result	= NULL;
---
>  	struct addrinfo * result	= NULL;
> 	struct addrinfo * rp		= NULL;
> 
124,126c137,140
< 	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
< 	if(rc) {
< 		state->error_message = gai_strerror(rc);
---
>  	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
>  	if(rc != 0)
> 	{
> 		((struct resolver *) host)->message = gai_strerror(rc);
130,135d143
< 	//
< 	// Try connecting to hosts.
< 	//
< 	int sock = -1;
< 	struct addrinfo * rp = NULL;
< 
138,143c146,151
< 	for(rp = result; sock < 0 && rp != NULL && state->syserror != ECANCELED; rp = rp->ai_next) {
< 		// Got socket from host definition.
< 		sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
< 		if(sock < 0) {
< 			// Can't get socket.
< 			state->syserror = errno;
---
> 	for(rp = result; hSession->connection.sock < 0 && rp != NULL; rp = rp->ai_next)
> 	{
> 		hSession->connection.sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
> 		if(hSession->connection.sock < 0)
> 		{
> 			((struct resolver *) host)->message = strerror(errno);
147,152c155,159
< 		// Try connect.
< 		if(sock_connect(hSession, sock, rp->ai_addr, rp->ai_addrlen)) {
< 			// Can't connect to host
< 			state->syserror = errno;
< 			close(sock);
< 			sock = -1;
---
> 		// Connected!
> 		if(connect(hSession->connection.sock, rp->ai_addr, rp->ai_addrlen))
> 		{
> 			SOCK_CLOSE(hSession);
> 			((struct resolver *) host)->message = strerror(errno);
156d162
< 		lib3270_socket_set_non_blocking(hSession,sock,0);
161,209c167
< 	if(sock < 0) {
< 		static const LIB3270_POPUP popup = {
< 			.name = "CantConnect",
< 			.type = LIB3270_NOTIFY_ERROR,
< 			.summary = N_("Can't connect to host"),
< 			.label = N_("Try again")
< 		};
< 
< 		state->popup = &popup;
< 		return sock;
< 	}
< 
< 	// don't share the socket with our children
< 	(void) fcntl(sock, F_SETFD, 1);
< 
< 	return sock;
< }
< 
< static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno)) {
< 	int 		err	= 0;
< 	socklen_t	len	= sizeof(err);
< 
< 	if(hSession->xio.write) {
< 		trace("%s write=%p",__FUNCTION__,hSession->xio.write);
< 		lib3270_remove_poll(hSession, hSession->xio.write);
< 		hSession->xio.write = NULL;
< 	}
< 
< 	if(hSession->network.module->getsockopt(hSession, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0) {
< 		lib3270_autoptr(char) body = lib3270_strdup_printf(
< 		                                 _("The System error was '%s' (rc=%d)"),
< 		                                 strerror(errno),
< 		                                 errno
< 		                             );
< 
< 		lib3270_disconnect(hSession);
< 
< 		LIB3270_POPUP popup = {
< 			.type = LIB3270_NOTIFY_ERROR,
< 			.title = _( "Network error" ),
< 			.summary = _( "Unable to get connection state." ),
< 			.body = body
< 		};
< 
< 		lib3270_popup(hSession,&popup,0);
< 
< 		return;
< 
< 	} else if(err) {
---
> 	return 0;
211c169
< 		lib3270_disconnect(hSession);
---
>  }
213,234c171,174
< 		lib3270_autoptr(char) summary =
< 		    lib3270_strdup_printf(
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
< 
< 		lib3270_autoptr(char) body =
< 		    lib3270_strdup_printf(
< 		        _("The system error was \"%s\" (rc=%d)"),
< 		        strerror(err),
< 		        err
< 		    );
< 
< 
< 		LIB3270_POPUP popup = {
< 			.type = LIB3270_NOTIFY_ERROR,
< 			.title = _( "Connection error" ),
< 			.summary = summary,
< 			.body = body,
< 			.label = _("_Retry")
< 		};
---
>  int net_reconnect(H3270 *hSession, int seconds)
>  {
> 	struct resolver		  host;
> 	memset(&host,0,sizeof(host));
236,237c176,180
< 		if(lib3270_popup(hSession,&popup,!hSession->auto_reconnect_inprogress) == 0)
< 			lib3270_activate_auto_reconnect(hSession,1000);
---
> 	// Connect to host
> 	if(lib3270_run_task(hSession, background_connect, &host) || hSession->connection.sock < 0)
> 	{
> 		char buffer[4096];
> 		snprintf(buffer,4095,_( "Can't connect to %s:%s"), hSession->host.current, hSession->host.srvc);
239,240c182,187
< 		return;
< 	}
---
> 		lib3270_popup_dialog(	hSession,
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								buffer,
> 								"%s",
> 								host.message);
242,244c189,190
< 	if(lib3270_start_tls(hSession)) {
< 		lib3270_disconnect(hSession);
< 		return;
---
> 		lib3270_set_disconnected(hSession);
> 		return errno = ENOTCONN;
247,277c193,194
< 	hSession->xio.except = hSession->network.module->add_poll(hSession,LIB3270_IO_FLAG_EXCEPTION,net_exception,0);
< 	hSession->xio.read = hSession->network.module->add_poll(hSession,LIB3270_IO_FLAG_READ,net_input,0);
< 
< 	lib3270_setup_session(hSession);
< 	lib3270_set_connected_initial(hSession);
< 
< 	lib3270_notify_tls(hSession);
< 
< }
< 
< int net_reconnect(H3270 *hSession, int seconds) {
< 	LIB3270_NETWORK_STATE state;
< 	memset(&state,0,sizeof(state));
< 
< 	// Initialize and connect to host
< 	set_ssl_state(hSession,LIB3270_SSL_UNDEFINED);
< 	lib3270_set_cstate(hSession,LIB3270_CONNECTING);
< 
< 	if(lib3270_run_task(hSession, (int(*)(H3270 *, void *)) hSession->network.module->connect, &state)) {
< 		lib3270_autoptr(LIB3270_POPUP) popup =
< 		    lib3270_popup_clone_printf(
< 		        NULL,
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
< 
< 		if(!popup->summary) {
< 			popup->summary = popup->body;
< 			popup->body = NULL;
< 		}
---
> 	/* don't share the socket with our children */
> 	(void) fcntl(hSession->connection.sock, F_SETFD, 1);
279,300c196
< 		lib3270_autoptr(char) syserror = NULL;
< 		if(state.syserror) {
< 			syserror = lib3270_strdup_printf(
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               strerror(state.syserror),
< 			               state.syserror
< 			           );
< 		}
< #ifdef _WIN32
< 		else if(state.winerror) {
< #error TODO
< 		}
< #endif // _WIN32
< 
< 		if(!popup->body) {
< 			if(state.error_message)
< 				popup->body = state.error_message;
< 			else
< 				popup->body = syserror;
< 		}
< 
< 		lib3270_disconnect(hSession);	// To cleanup states.
---
> 	hSession->ever_3270 = False;
302,304c198,205
< 		popup->label = _("_Retry");
< 		if(lib3270_popup(hSession,popup,!hSession->auto_reconnect_inprogress) == 0)
< 			lib3270_activate_auto_reconnect(hSession,1000);
---
> #if defined(HAVE_LIBSSL)
> 	debug("%s: TLS/SSL is %s",__FUNCTION__,hSession->ssl.enabled ? "ENABLED" : "DISABLED")
> 	trace_dsn(hSession,"TLS/SSL is %s\n", hSession->ssl.enabled ? "enabled" : "disabled" );
> 	if(hSession->ssl.enabled)
> 	{
> 		hSession->ssl.host = 1;
> 		if(ssl_init(hSession))
> 			return errno = ENOTCONN;
306d206
< 		return errno = ENOTCONN;
308,313c208
< 
< 
< 	//
< 	// Connected
< 	//
< 	hSession->ever_3270 = False;
---
> #endif // HAVE_LIBSSL
317c212,213
< 	if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_OOBINLINE, &optval, sizeof(optval)) < 0) {
---
> 	if (setsockopt(hSession->connection.sock, SOL_SOCKET, SO_OOBINLINE, (char *)&optval,sizeof(optval)) < 0)
> 	{
320,325c216,221
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        _( "setsockopt(SO_OOBINLINE) has failed" ),
< 		                        "%s",
< 		                        strerror(rc));
< 		hSession->network.module->disconnect(hSession);
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								_( "setsockopt(SO_OOBINLINE) has failed" ),
> 								"%s",
> 								strerror(rc));
> 		SOCK_CLOSE(hSession);
330c226,227
< 	if (hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
---
> 	if (setsockopt(hSession->connection.sock, SOL_SOCKET, SO_KEEPALIVE, (char *)&optval, sizeof(optval)) < 0)
> 	{
337,343c234,239
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        buffer,
< 		                        "%s",
< 		                        strerror(rc));
< 
< 		hSession->network.module->disconnect(hSession);
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								buffer,
> 								"%s",
> 								strerror(rc));
> 		SOCK_CLOSE(hSession);
345c241,243
< 	} else {
---
> 	}
> 	else
> 	{
351c249
< 	#if defined(OMTU)
---
> #if defined(OMTU)
357c255
< 	#endif
---
> #endif
365c263,264
< 	hSession->xio.write = hSession->network.module->add_poll(hSession,LIB3270_IO_FLAG_WRITE,net_connected,0);
---
> 	hSession->xio.write = lib3270_add_poll_fd(hSession,hSession->connection.sock,LIB3270_IO_FLAG_WRITE,net_connected,0);
> 	// hSession->ns_write_id = AddOutput(hSession->sock, hSession, net_connected);
369,377c268,269
< 	if(seconds) {
< 		int rc = lib3270_wait_for_cstate(hSession,LIB3270_CONNECTED_TN3270E,seconds);
< 		if(rc) {
< 			lib3270_disconnect(hSession);
< 			lib3270_write_log(hSession,"connect", "%s: %s",__FUNCTION__,strerror(ETIMEDOUT));
< 			return errno = rc;
< 		}
< 
< 		/*
---
> 	if(seconds)
> 	{
393c285
< 			case LIB3270_CONNECTING:
---
> 			case LIB3270_RESOLVING:
415d306
< 		*/
420c311
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/curl.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/curl.c
44c44,45
< static inline void lib3270_autoptr_cleanup_CURL(CURL **ptr) {
---
> static inline void lib3270_autoptr_cleanup_CURL(CURL **ptr)
> {
51c52,53
< typedef struct _curldata {
---
> typedef struct _curldata
> {
61c63,64
< static inline void lib3270_autoptr_cleanup_CURLDATA(CURLDATA **ptr) {
---
> static inline void lib3270_autoptr_cleanup_CURLDATA(CURLDATA **ptr)
> {
63c66,67
< 	if(*ptr) {
---
> 	if(*ptr)
> 	{
75c79,80
< static size_t internal_curl_write_callback(void *contents, size_t size, size_t nmemb, void *userp) {
---
> static size_t internal_curl_write_callback(void *contents, size_t size, size_t nmemb, void *userp)
> {
84c89,90
< 	if((realsize + data->length) > data->data.length) {
---
> 	if((realsize + data->length) > data->data.length)
> 	{
92c98,99
< 	if(lib3270_get_toggle(data->hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(data->hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
94,97c101,104
< 		    data->hSession,
< 		    "Received",
< 		    (const unsigned char *) contents,
< 		    realsize
---
> 			data->hSession,
> 			"Received",
> 			(const unsigned char *) contents,
> 			realsize
111c118,119
< static int internal_curl_trace_callback(CURL GNUC_UNUSED(*handle), curl_infotype type, char *data, size_t size, void *userp) {
---
> static int internal_curl_trace_callback(CURL GNUC_UNUSED(*handle), curl_infotype type, char *data, size_t size, void *userp)
> {
149,152c157,160
< 	    ((CURLDATA *) userp)->hSession,
< 	    text,
< 	    (const unsigned char *) data,
< 	    size
---
> 		((CURLDATA *) userp)->hSession,
> 		text,
> 		(const unsigned char *) data,
> 		size
158c166,167
< char * lib3270_url_get_using_curl(H3270 *hSession, const char *url, const char **error) {
---
> char * lib3270_get_from_url(H3270 *hSession, const char *url, size_t *length, const char **error_message)
> {
162c171
< 	lib3270_autoptr(CURLDATA)	curl_data		= lib3270_malloc(sizeof(CURLDATA));
---
> 	lib3270_autoptr(CURLDATA)	crl_data		= lib3270_malloc(sizeof(CURLDATA));
165,171c174,182
< 	memset(curl_data,0,sizeof(CURLDATA));
< 	curl_data->hSession			= hSession;
< 	curl_data->data.length		= CRL_DATA_LENGTH;
< 	curl_data->data.contents	= lib3270_malloc(curl_data->data.length);
< 
< 	if(!hCurl) {
< 		*error = _( "Can't initialize curl operation" );
---
> 	memset(crl_data,0,sizeof(CURLDATA));
> 	crl_data->hSession		= hSession;
> 	crl_data->data.length	= CRL_DATA_LENGTH;
> 	crl_data->data.contents = lib3270_malloc(crl_data->data.length);
> 
> 	if(!hCurl)
> 	{
> 		*error_message= _( "Can't initialize curl operation" );
> 		errno = EINVAL;
180c191
< 	curl_easy_setopt(hCurl, CURLOPT_ERRORBUFFER, curl_data->errbuf);
---
> 	curl_easy_setopt(hCurl, CURLOPT_ERRORBUFFER, crl_data->errbuf);
183c194
< 	curl_easy_setopt(hCurl, CURLOPT_WRITEDATA, (void *) curl_data);
---
> 	curl_easy_setopt(hCurl, CURLOPT_WRITEDATA, (void *) crl_data);
187c198,199
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
190c202
< 		curl_easy_setopt(hCurl, CURLOPT_DEBUGDATA, (void *) curl_data);
---
> 		curl_easy_setopt(hCurl, CURLOPT_DEBUGDATA, (void *) crl_data);
195,197c207,210
< 	if(res != CURLE_OK) {
< 		if(curl_data->errbuf[0])
< 			lib3270_write_log(hSession,"curl","%s: %s",url, curl_data->errbuf);
---
> 	if(res != CURLE_OK)
> 	{
> 		if(crl_data->errbuf[0])
> 			lib3270_write_log(hSession,"curl","%s: %s",url, crl_data->errbuf);
199c212
< 		*error = curl_easy_strerror(res);
---
> 		*error_message = curl_easy_strerror(res);
201c214
< 		lib3270_write_log(hSession,"curl","%s: %s",url, *error);
---
> 		lib3270_write_log(hSession,"curl","%s: %s",url, *error_message);
207,209c220,225
< 	char * httpText = lib3270_malloc(curl_data->length+1);
< 	memset(httpText,0,curl_data->length+1);
< 	memcpy(httpText,curl_data->data.contents,curl_data->length);
---
> 	if(length)
> 		*length = (size_t) crl_data->length;
> 
> 	char * httpText = lib3270_malloc(crl_data->length+1);
> 	memset(httpText,0,crl_data->length+1);
> 	memcpy(httpText,crl_data->data.contents,crl_data->length);
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos: download.c
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/event_dispatcher.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/event_dispatcher.c
30,33c30,33
< /**
<  * @brief Implements the default event dispatcher for linux.
<  *
<  */
---
>  /**
>   * @brief Implements the default event dispatcher for linux.
>   *
>   */
53c53,54
< int lib3270_default_event_dispatcher(H3270 *hSession, int block) {
---
> int lib3270_default_event_dispatcher(H3270 *hSession, int block)
> {
77,78c78,81
< 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next) {
< 		if(!ip->enabled) {
---
> 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next)
> 	{
> 		if(!ip->enabled)
> 		{
83c86,87
< 		if(ip->flag & LIB3270_IO_FLAG_READ) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_READ)
> 		{
88c92,93
< 		if(ip->flag & LIB3270_IO_FLAG_WRITE) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_WRITE)
> 		{
93c98,99
< 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION)
> 		{
99,100c105,108
< 	if (block) {
< 		if (hSession->timeouts.first) {
---
> 	if (block)
> 	{
> 		if (hSession->timeouts.first)
> 		{
111c119,121
< 		} else {
---
> 		}
> 		else
> 		{
116c126,128
< 	} else {
---
> 	}
> 	else
> 	{
127c139,140
< 	if (ns < 0 && errno != EINTR) {
---
> 	if (ns < 0 && errno != EINTR)
> 	{
129,136c142,153
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Network error" ),
< 		                        _( "Select() failed when processing for events." ),
< 		                        "%s",
< 		                        strerror(errno));
< 	} else {
< 		for (ip = (input_t *) hSession->input.list.first; ip != (input_t *) NULL; ip = (input_t *) ip->next) {
< 			if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds)) {
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Network error" ),
> 								_( "Select() failed when processing for events." ),
> 								"%s",
> 								strerror(errno));
> 	}
> 	else
> 	{
> 		for (ip = (input_t *) hSession->input.list.first; ip != (input_t *) NULL; ip = (input_t *) ip->next)
> 		{
> 			if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds))
> 			{
143c160,161
< 			if((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds)) {
---
> 			if((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds))
> 			{
150c168,169
< 			if((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds)) {
---
> 			if((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds))
> 			{
160c179,180
< 	if (hSession->timeouts.first) {
---
> 	if (hSession->timeouts.first)
> 	{
164,165c184,186
< 		while(hSession->timeouts.first) {
< 			t = (struct timeout *) hSession->timeouts.first;
---
> 		while(hSession->timeouts.first)
> 		{
>             t = (struct timeout *) hSession->timeouts.first;
167c188,189
< 			if (t->tv.tv_sec < now.tv_sec ||(t->tv.tv_sec == now.tv_sec && t->tv.tv_usec < now.tv_usec)) {
---
> 			if (t->tv.tv_sec < now.tv_sec ||(t->tv.tv_sec == now.tv_sec && t->tv.tv_usec < now.tv_usec))
> 			{
169,172c191
< 
< 				(*t->proc)(hSession,t->userdata);
< 				lib3270_linked_list_delete_node(&hSession->timeouts,t);
< 
---
> 				(*t->proc)(hSession);
174a194
> 				lib3270_linked_list_delete_node(&hSession->timeouts,t);
176c196,198
< 			} else {
---
> 			}
> 			else
> 			{
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos: ldap.c
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/log.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/log.c
38c38
< #include <syslog.h>
---
> 	#include <syslog.h>
43c43
< int use_syslog = 0;
---
>  int use_syslog = 0;
45c45,46
< int default_loghandler(const H3270 GNUC_UNUSED(*session), void GNUC_UNUSED(*userdata), const char *module, int GNUC_UNUSED(rc), const char *message) {
---
>  void default_log_writer(H3270 GNUC_UNUSED(*session), const char *module, int GNUC_UNUSED(rc), const char *fmt, va_list arg_ptr)
>  {
47,50c48,56
< 	if(use_syslog) {
< 		syslog(LOG_INFO, "%s: %s", module, message);
< 	} else {
< 		printf("%s %s\n", module, message);
---
> 	if(use_syslog)
> 	{
> 		vsyslog(LOG_INFO, fmt, arg_ptr);
> 	}
> 	else
> 	{
> 		printf("%s:\t",module);
> 		vprintf(fmt,arg_ptr);
> 		printf("\n");
54c60,62
< 	printf("%s %s\n", module, message);
---
>  	printf("%s:\t",module);
> 	vprintf(fmt,arg_ptr);
> 	printf("\n");
57,58c65
< 	return 0;
< }
---
>  }
60c67,68
< LIB3270_EXPORT int lib3270_set_syslog(int flag) {
---
>  LIB3270_EXPORT int lib3270_set_syslog(int flag)
>  {
62,63c70,73
< 	if(flag) {
< 		if(!use_syslog) {
---
> 	if(flag)
> 	{
> 		if(!use_syslog)
> 		{
67,68c77,81
< 	} else {
< 		if(use_syslog) {
---
> 	}
> 	else
> 	{
> 		if(use_syslog)
> 		{
77c90
< 	return errno  = ENOENT;
---
>  	return errno  = ENOENT;
79c92
< }
---
>  }
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos: private.h
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/util.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/macos/util.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,24
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob
>  * o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
>  *
>  * Contatos:
6,14c26,27
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * perry.werneck@gmail.com	(Alexandre Perry de Souza Werneck)
>  * erico.mendonca@gmail.com	(Erico Mascarenhas Mendonça)
16,17d28
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
21c32
<  * @brief Mac Utility functions.
---
>  * @brief Linux Utility functions.
32,33d42
< #include <lib3270.h>
< #include <lib3270/os.h>
35c44,45
< static char * concat(char *path, const char *name, size_t *length) {
---
> static char * concat(char *path, const char *name, size_t *length)
> {
43c53,54
< 	if(szCurrent >= *length) {
---
> 	if(szCurrent >= *length)
> 	{
53c64,65
< static char * build_filename(const char *root, const char *str, va_list args) {
---
> static char * build_filename(const char *root, const char *str, va_list args)
> {
67,92c79,80
< LIB3270_EXPORT char	* lib3270_get_installation_path() {
< 
< 	char lpFilename[PATH_MAX+1];
< 
< 	memset(lpFilename,0,sizeof(lpFilename));
< 	uint32_t szPath = PATH_MAX;
< 	_NSGetExecutablePath(lpFilename, &szPath);
< 	lpFilename[szPath] = 0;
< 
< 	char *ptr = strrchr(lpFilename,'/');
< 	if(ptr) {
< 		ptr[0] = 0;
< 
< 		ptr = strrchr(lpFilename,'/');
< 		if(ptr && !(strcasecmp(ptr,"/bin") && strcasecmp(ptr,"/lib"))) {
< 			*ptr = 0;
< 		}
< 
< 		strncat(lpFilename,"/",PATH_MAX);
< 	}
< 
< 	return strdup(lpFilename);
< }
< 
< char * lib3270_build_data_filename(const char *str, ...) {
< 
---
> char * lib3270_build_data_filename(const char *str, ...)
> {
93a82
> 	va_start (args, str);
95,101c84
< 	size_t szPath = PATH_MAX;
< 	lib3270_autoptr(char) path = (char *) lib3270_malloc(szPath);
< 	char *filename = NULL;
< 
< 	//
< 	// Try bundle 
< 	//
---
> 	char *filename;
103d85
< 
105,107c87
< 
< 		CFURLRef url = CFBundleCopyBundleURL(mainBundle);
< 
---
> 	    CFURLRef url = CFBundleCopyBundleURL(mainBundle);
109,110c89,91
< 
< 			CFURLGetFileSystemRepresentation(url, true, (UInt8 *) path, szPath);
---
> 			size_t szPath = PATH_MAX;
> 			char *path = (char *) lib3270_malloc(szPath);
> 			CFURLGetFileSystemRepresentation(url, true, path, szPath);
113,124c94,97
< 
< 			if(access(path,R_OK) == 0) {
< 				va_start (args, str);
< 				filename = build_filename(path, str, args);
< 				va_end (args);
< 				return filename;
< 			}
< #ifdef DEBUG
< 			else {
< 				debug("No bundle in '%s'",path);
< 			}
< #endif // DEBUG 
---
> 			filename = build_filename(path, str, args);
> 			lib3270_free(path);
> 		} else {
> 			filename = build_filename(LIB3270_STRINGIZE_VALUE_OF(DATADIR), str, args);
126c99,100
< 
---
> 	} else {
> 		filename = build_filename(LIB3270_STRINGIZE_VALUE_OF(DATADIR), str, args);
129,188c103
< 	//
< 	// Try installation path
< 	//
< 	{
< 		char *ptr;
< 		lib3270_autoptr(char) instpath = lib3270_get_installation_path();
< 
< 		if( *(instpath+strlen(instpath)-1) == '/') {
< 			instpath[strlen(instpath)-1] = 0;
< 		}
< 
< 		char relative[PATH_MAX+1];
< 		memset(relative,0,PATH_MAX);
< 
< 		{
< 			va_list args;
< 			va_start (args, str);
< 
< 			while(str) {
< 
< 				if(str[0] == '/') {
< 					strncat(relative,str,PATH_MAX);
< 				} else {
< 					strncat(relative,"/",PATH_MAX);
< 					strncat(relative,str,PATH_MAX);
< 				}
< 
< 				str = va_arg(args, const char *);
< 			}
< 
< 			va_end (args);
< 		}
< 
< 		char filename[PATH_MAX+1];
< 		memset(filename,0,PATH_MAX+1);
< 
< 		// Check instdir
< 		strncpy(filename,instpath,PATH_MAX);
< 		strncat(filename,"/share",PATH_MAX);
< 		strncat(filename,relative,PATH_MAX);
< 
< 		if(access(filename,0) == 0) {
< 			return strdup(filename);
< 		}
< 
< 		strncpy(filename,instpath,PATH_MAX);
< 		strncat(filename,"/share/",PATH_MAX);
< 		strncat(filename,LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),PATH_MAX);
< 		strncat(filename,relative,PATH_MAX);
< 
< 		if(access(filename,0) == 0) {
< 			return strdup(filename);
< 		}
< 
< 		// Default behavior.
< 		strncpy(filename,instpath,PATH_MAX);
< 		strncat(filename,relative,PATH_MAX);
< 
< 		return strdup(filename);
< 	}
---
> 	va_end (args);
189a105
> 	return filename;
192c108,109
< char * lib3270_build_config_filename(const char *str, ...) {
---
> char * lib3270_build_config_filename(const char *str, ...)
> {
203c120,121
< char * lib3270_build_filename(const char *str, ...) {
---
> char * lib3270_build_filename(const char *str, ...)
> {
222c140,141
< 	static const char * paths[] = {
---
> 	static const char * paths[] =
> 	{
228c147,148
< 	for(ix = 0; ix < (sizeof(paths)/sizeof(paths[0])); ix++) {
---
> 	for(ix = 0; ix < (sizeof(paths)/sizeof(paths[0])); ix++)
> 	{
231c151,152
< 		if(access(tempname, F_OK) == 0) {
---
> 		if(access(tempname, F_OK) == 0)
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/model.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/model.c
30,37c30,42
< #include <internals.h>
< #include <stdlib.h>
< #include "screen.h"
< #include "ctlrc.h"
< #include "popupsc.h"
< #include <lib3270/trace.h>
< #include <lib3270/log.h>
< #include <lib3270/properties.h>
---
>  #include <internals.h>
>  #include <stdlib.h>
>  #include "screen.h"
>  #include "ctlrc.h"
>  #include "popupsc.h"
>  #include <lib3270/trace.h>
>  #include <lib3270/log.h>
>  #include <lib3270/properties.h>
> 
>  const char * lib3270_get_oversize(const H3270 *hSession)
>  {
>  	return hSession->oversize.str;
>  }
39,43c44,45
< const char * lib3270_get_oversize(const H3270 *hSession) {
< 	return hSession->oversize.str;
< }
< 
< int lib3270_set_oversize(H3270 *hSession, const char *value) {
---
>  int lib3270_set_oversize(H3270 *hSession, const char *value)
>  {
50c52,53
< 	if(hSession->oversize.str) {
---
> 	if(hSession->oversize.str)
> 	{
61c64,65
< 	if(value) {
---
> 	if(value)
> 	{
77c81
< }
---
>  }
85c89,90
< unsigned int lib3270_get_model_number(const H3270 *hSession) {
---
> unsigned int lib3270_get_model_number(const H3270 *hSession)
> {
89c94,95
< const char * lib3270_get_model(const H3270 *hSession) {
---
> const char * lib3270_get_model(const H3270 *hSession)
> {
93c99,100
< const char * lib3270_get_model_name(const H3270 *hSession) {
---
> const char * lib3270_get_model_name(const H3270 *hSession)
> {
97,105c104,113
< /**
<  * @brief Parse the model number.
<  *
<  * @param session	Session Handle.
<  * @param m		Model number (NULL for "2").
<  *
<  * @return -1 (error), 0 (default), or the specified number.
<  */
< static int parse_model_number(H3270 *session, const char *m) {
---
>  /**
>   * @brief Parse the model number.
>   *
>   * @param session	Session Handle.
>   * @param m		Model number (NULL for "2").
>   *
>   * @return -1 (error), 0 (default), or the specified number.
>   */
> static int parse_model_number(H3270 *session, const char *m)
> {
123c131,132
< 		if (!strncmp(m, "3278", 4)) {
---
> 		if (!strncmp(m, "3278", 4))
> 		{
125c134,136
< 		} else if (!strncmp(m, "3279", 4)) {
---
> 		}
> 		else if (!strncmp(m, "3279", 4))
> 		{
127c138,140
< 		} else {
---
> 		}
> 		else
> 		{
169c182,183
< int lib3270_set_model_name(H3270 *hSession, const char *model_name) {
---
> int lib3270_set_model_name(H3270 *hSession, const char *model_name)
> {
173c187,188
< int lib3270_set_model(H3270 *hSession, const char *model_name) {
---
> int lib3270_set_model(H3270 *hSession, const char *model_name)
> {
177c192,193
< int lib3270_set_model_number(H3270 *hSession, unsigned int model_number) {
---
> int lib3270_set_model_number(H3270 *hSession, unsigned int model_number)
> {
184c200,201
< 	if (!model_number) {
---
> 	if (!model_number)
> 	{
197c214,215
< 	if(!hSession->extended) {
---
> 	if(!hSession->extended)
> 	{
214c232,233
< 	if (!hSession->extended || hSession->oversize.str == CN || sscanf(hSession->oversize.str, "%dx%d%c", &ovc, &ovr, &junk) != 2) {
---
> 	if (!hSession->extended || hSession->oversize.str == CN || sscanf(hSession->oversize.str, "%dx%d%c", &ovc, &ovr, &junk) != 2)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/options.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/options.c
38c38,39
< static const LIB3270_HOST_TYPE_ENTRY host_type[] = {
---
>  static const LIB3270_HOST_TYPE_ENTRY host_type[] =
>  {
40,43c41,44
< 		.type = LIB3270_HOST_S390,
< 		.name = "S390",
< 		.description = N_( "IBM S/390" ),
< 		.tooltip = NULL
---
> 		LIB3270_HOST_S390,
> 		"S390",
> 		N_( "IBM S/390" ),
> 		NULL
46,49c47,50
< 		.type = LIB3270_HOST_AS400,
< 		.name = "AS400",
< 		.description = N_( "IBM AS/400" ),
< 		.tooltip = NULL
---
> 		LIB3270_HOST_AS400,
> 		"AS400",
> 		N_( "IBM AS/400" ),
> 		NULL
52,55c53,56
< 		.type = LIB3270_HOST_TSO,
< 		.name = "TSO",
< 		.description = N_( "Other (TSO)" ),
< 		.tooltip = NULL
---
> 		LIB3270_HOST_TSO,
> 		"TSO",
> 		N_( "Other (TSO)" ),
> 		NULL
58,61c59,62
< 		.type = LIB3270_HOST_OTHER,
< 		.name = "VM/CMS",
< 		.description = N_( "Other (VM/CMS)"	),
< 		.tooltip = NULL
---
> 		0,
> 		"VM/CMS",
> 		N_( "Other (VM/CMS)"	),
> 		NULL
65,68c66,69
< 		.type = LIB3270_HOST_OTHER,
< 		.name = NULL,
< 		.description = NULL,
< 		.tooltip = NULL
---
> 		0,
> 		NULL,
> 		NULL,
> 		NULL
70c71
< };
---
>  };
75c76,77
< LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_get_host_type(const H3270 *hSession) {
---
> LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_get_host_type(const H3270 *hSession)
> {
79,80c81,83
< LIB3270_EXPORT int lib3270_set_host_type(H3270 *hSession, LIB3270_HOST_TYPE opt) {
< 	FAIL_IF_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_set_host_type(H3270 *hSession, LIB3270_HOST_TYPE opt)
> {
>     FAIL_IF_ONLINE(hSession);
85c88,89
< LIB3270_EXPORT unsigned int lib3270_get_color_type(const H3270 *hSession) {
---
> LIB3270_EXPORT unsigned int lib3270_get_color_type(const H3270 *hSession)
> {
89c93,94
< LIB3270_EXPORT int lib3270_set_color_type(H3270 *hSession, unsigned int colortype) {
---
> LIB3270_EXPORT int lib3270_set_color_type(H3270 *hSession, unsigned int colortype)
> {
92c97,98
< 	switch(colortype) {
---
> 	switch(colortype)
> 	{
120c126,127
< LIB3270_EXPORT const LIB3270_HOST_TYPE_ENTRY * lib3270_get_option_list(void) {
---
> LIB3270_EXPORT const LIB3270_HOST_TYPE_ENTRY * lib3270_get_option_list(void)
> {
124c131,132
< LIB3270_EXPORT int lib3270_is_tso(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_is_tso(const H3270 *hSession)
> {
128,129c136,138
< LIB3270_EXPORT int lib3270_set_tso(H3270 *hSession, int on) {
< 	FAIL_IF_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_set_tso(H3270 *hSession, int on)
> {
>     FAIL_IF_ONLINE(hSession);
131c140
< 	if(on)
---
>     if(on)
139c148,149
< LIB3270_EXPORT int lib3270_is_as400(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_is_as400(const H3270 *hSession)
> {
143,144c153,155
< LIB3270_EXPORT int lib3270_set_as400(H3270 *hSession, int on) {
< 	FAIL_IF_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_set_as400(H3270 *hSession, int on)
> {
>     FAIL_IF_ONLINE(hSession);
146c157
< 	if(on)
---
>     if(on)
154c165,166
< LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_parse_host_type(const char *name) {
---
> LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_parse_host_type(const char *name)
> {
158c170,171
< 	for(f=0; host_type[f].name; f++) {
---
> 	for(f=0;host_type[f].name;f++)
> 	{
167c180,181
< LIB3270_EXPORT int lib3270_set_host_type_by_name(H3270 *hSession, const char *name) {
---
> LIB3270_EXPORT int lib3270_set_host_type_by_name(H3270 *hSession, const char *name)
> {
171,172c185,188
< 	for(f=0; f<(sizeof(host_type)/sizeof(host_type[0])); f++) {
< 		if(host_type[f].name && !strcasecmp(host_type[f].name,name)) {
---
> 	for(f=0;f<(sizeof(host_type)/sizeof(host_type[0]));f++)
> 	{
> 		if(host_type[f].name && !strcasecmp(host_type[f].name,name))
> 		{
181c197,198
< LIB3270_EXPORT const char * lib3270_get_host_type_name(const H3270 *hSession) {
---
> LIB3270_EXPORT const char * lib3270_get_host_type_name(const H3270 *hSession)
> {
184,185c201,204
< 	for(f=0; f<(sizeof(host_type)/sizeof(host_type[0])); f++) {
< 		if(hSession->host_type == host_type[f].type) {
---
> 	for(f=0;f<(sizeof(host_type)/sizeof(host_type[0]));f++)
> 	{
> 		if(hSession->host_type == host_type[f].type)
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/paste.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/paste.c
41c41
< #define XK_APL
---
> 	#define XK_APL
47c47
< //#include "resources.h"
---
> #include "resources.h"
72c72
< //#include "utf8c.h"
---
> #include "utf8c.h"
86,88c86,89
< typedef struct _paste_data {
< 	int qtd;
< 	int row;
---
>  typedef struct _paste_data
>  {
>  	int qtd;
>  	int row;
91c92
< } PASTE_DATA;
---
>  } PASTE_DATA;
100c101,102
< static int remargin(H3270 *hSession, int lmargin) {
---
>  static int remargin(H3270 *hSession, int lmargin)
>  {
106c108,109
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE))
> 	{
108c111,112
< 		while(BA_TO_COL(baddr) < ((unsigned int) lmargin)) {
---
> 		while(BA_TO_COL(baddr) < ((unsigned int) lmargin))
> 		{
110c114,115
< 			if (!ever) {
---
> 			if (!ever)
> 			{
117c122,123
< 			if (faddr == baddr || FA_IS_PROTECTED(fa)) {
---
> 			if (faddr == baddr || FA_IS_PROTECTED(fa))
> 			{
128c134
< }
---
>  }
130c136,137
< static int paste_char(H3270 *hSession, PASTE_DATA *data, unsigned char c) {
---
>  static int paste_char(H3270 *hSession, PASTE_DATA *data, unsigned char c)
>  {
132c139,140
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SMART_PASTE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SMART_PASTE))
> 	{
138c146,148
< 	} else {
---
> 	}
> 	else
> 	{
144,145c154,156
< 	if(BA_TO_ROW(hSession->cursor_addr) != ((unsigned int) data->row)) {
< 		trace("Row changed from %d to %d",data->row,BA_TO_ROW(hSession->cursor_addr));
---
>  	if(BA_TO_ROW(hSession->cursor_addr) != ((unsigned int) data->row))
>  	{
>  		trace("Row changed from %d to %d",data->row,BA_TO_ROW(hSession->cursor_addr));
149,150c160,161
< 		return '\n';
< 	}
---
>  		return '\n';
>  	}
152c163
< 	return c;
---
>  	return c;
155c166,167
< static int set_string(H3270 *hSession, const unsigned char *str, int length) {
---
> static int set_string(H3270 *hSession, const unsigned char *str, int length)
> {
161c173
< 	data.row		= BA_TO_ROW(hSession->cursor_addr);
---
>  	data.row		= BA_TO_ROW(hSession->cursor_addr);
169,170c181,184
< 	for(ix = 0; ix < length && *str && last && !hSession->kybdlock && hSession->cursor_addr >= data.orig_addr; ix++) {
< 		switch(*str) {
---
> 	for(ix = 0; ix < length && *str && last && !hSession->kybdlock && hSession->cursor_addr >= data.orig_addr; ix++)
> 	{
> 		switch(*str)
> 		{
176c190,191
< 			if(last != '\n') {
---
> 			if(last != '\n')
> 			{
202c217,218
< 		if(IN_3270 && lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < ((unsigned int) data.orig_col)) {
---
> 		if(IN_3270 && lib3270_get_toggle(hSession,LIB3270_TOGGLE_MARGINED_PASTE) && BA_TO_COL(hSession->cursor_addr) < ((unsigned int) data.orig_col))
> 		{
215,216c231,233
< LIB3270_EXPORT int lib3270_set_string_at(H3270 *hSession, unsigned int row, unsigned int col, const unsigned char *str, int length) {
< 	int rc = 0;
---
> LIB3270_EXPORT int lib3270_set_string_at(H3270 *hSession, unsigned int row, unsigned int col, const unsigned char *str, int length)
> {
>     int rc = 0;
248c265,266
< LIB3270_EXPORT int lib3270_set_string_at_address(H3270 *hSession, int baddr, const unsigned char *str, int length) {
---
> LIB3270_EXPORT int lib3270_set_string_at_address(H3270 *hSession, int baddr, const unsigned char *str, int length)
> {
263c281,282
< 	if(baddr >= 0) {
---
> 	if(baddr >= 0)
> 	{
279c298,299
< LIB3270_EXPORT int lib3270_set_field(H3270 *hSession, const char *text, int length) {
---
> LIB3270_EXPORT int lib3270_set_field(H3270 *hSession, const char *text, int length)
> {
326c346
< 	return hSession->cursor_addr;
---
>     return hSession->cursor_addr;
331c351,352
< LIB3270_EXPORT int lib3270_set_string(H3270 *hSession, const unsigned char *str, int length) {
---
> LIB3270_EXPORT int lib3270_set_string(H3270 *hSession, const unsigned char *str, int length)
> {
353c374,375
< LIB3270_EXPORT int lib3270_paste_text(H3270 *hSession, const unsigned char *str) {
---
> LIB3270_EXPORT int lib3270_paste_text(H3270 *hSession, const unsigned char *str)
> {
357c379,380
< 	if(!str) {
---
> 	if(!str)
> 	{
362c385,386
< 	if(hSession->paste_buffer) {
---
> 	if(hSession->paste_buffer)
> 	{
368c392,393
< 	if(sz < 0) {
---
> 	if(sz < 0)
> 	{
371,375c396,400
< 		    hSession,
< 		    LIB3270_NOTIFY_WARNING,
< 		    _( "Action failed" ),
< 		    _( "Unable to paste text" ),
< 		    "%s", sz == -EPERM ? _( "Keyboard is locked" ) : _( "Unexpected error" )
---
> 				hSession,
> 				LIB3270_NOTIFY_WARNING,
> 				_( "Action failed" ),
> 				_( "Unable to paste text" ),
> 				"%s", sz == -EPERM ? _( "Keyboard is locked" ) : _( "Unexpected error" )
381c406,407
< 	if((int) strlen((char *) str) > sz) {
---
> 	if((int) strlen((char *) str) > sz)
> 	{
390c416,417
< LIB3270_EXPORT int lib3270_can_paste_next(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_can_paste_next(const H3270 *hSession)
> {
397c424,425
< LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession)
> {
403c431,432
< 	if(!(lib3270_is_connected(hSession) && hSession->paste_buffer)) {
---
> 	if(!(lib3270_is_connected(hSession) && hSession->paste_buffer))
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/popup.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/popup.c
41d40
< #include <networking.h>
46c45,47
< 	return hSession->cbk.popup(hSession,popup,wait);
---
> 	int rc = hSession->cbk.popup(hSession,popup,wait);
> 	debug("%s rc=%d (%s)",__FUNCTION__,rc,strerror(rc));
> 	return rc;
69,77c70
< 	int rc = hSession->cbk.popup(hSession,&translated,wait);
< 
< 	debug("%s - User response was '%s' (rc=%d)",__FUNCTION__,strerror(rc),rc);
< 
< 	if(rc) {
< 		lib3270_write_trace(hSession,"User response was '%s' (rc=%d)",strerror(rc),rc);
< 	}
< 
< 	return rc;
---
> 	return hSession->cbk.popup(hSession,&translated,wait);
81c74,75
< void popup_an_error(H3270 *hSession, const char *fmt, ...) {
---
> void popup_an_error(H3270 *hSession, const char *fmt, ...)
> {
85c79,80
< 	if(fmt) {
---
> 	if(fmt)
> 	{
101c96,97
< void popup_system_error(H3270 *hSession, const char *title, const char *summary, const char *fmt, ...) {
---
> void popup_system_error(H3270 *hSession, const char *title, const char *summary, const char *fmt, ...)
> {
105c101,102
< 	if(fmt) {
---
> 	if(fmt)
> 	{
123c120,121
< LIB3270_EXPORT void lib3270_popup_dialog(H3270 *session, LIB3270_NOTIFY id, const char *title, const char *message, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_popup_dialog(H3270 *session, LIB3270_NOTIFY id , const char *title, const char *message, const char *fmt, ...)
> {
126c124
< 	lib3270_popup_va(session, id, title, message, fmt, args);
---
>     lib3270_popup_va(session, id, title, message, fmt, args);
130c128,129
< LIB3270_EXPORT void lib3270_popup_va(H3270 *hSession, LIB3270_NOTIFY id, const char *title, const char *message, const char *fmt, va_list args) {
---
> LIB3270_EXPORT void lib3270_popup_va(H3270 *hSession, LIB3270_NOTIFY id , const char *title, const char *message, const char *fmt, va_list args)
> {
150c149,150
< LIB3270_POPUP * lib3270_popup_clone_printf(const LIB3270_POPUP *origin, const char *fmt, ...) {
---
> LIB3270_POPUP * lib3270_popup_clone_printf(const LIB3270_POPUP *origin, const char *fmt, ...)
> {
163c163,164
< 	if(origin) {
---
> 	if(origin)
> 	{
165c166,168
< 	} else {
---
> 	}
> 	else
> 	{
174c177,178
< static int def_popup(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char GNUC_UNUSED wait) {
---
> static int def_popup(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char GNUC_UNUSED wait)
> {
183c187,188
< 	for(ix = 0; ix < (sizeof(text)/sizeof(text[0])); ix++) {
---
> 	for(ix = 0; ix < (sizeof(text)/sizeof(text[0])); ix++)
> 	{
201,230d205
< 
< void lib3270_set_network_error(H3270 *hSession, const char *summary, const char *fmt, ...) {
< 
< 	// Release last error.
< 	if(hSession->connection.error) {
< 		lib3270_free(hSession->connection.error);
< 		hSession->connection.error = NULL;
< 	}
< 
< 	// Format body.
< 	va_list	  args;
< 	va_start(args, fmt);
< 	lib3270_autoptr(char) body = lib3270_vsprintf(fmt, args);
< 	va_end(args);
< 
< 	hSession->connection.error = lib3270_malloc(sizeof(LIB3270_POPUP) + strlen(summary) + strlen(body) + 3);
< 
< 	// Set type.
< 	hSession->connection.error->type = LIB3270_NOTIFY_ERROR;
< 
< 	// Copy summary
< 	hSession->connection.error->summary = (char *) (hSession->connection.error + 1);
< 	strcpy((char *) hSession->connection.error->summary,summary);
< 
< 	// Copy body.
< 	hSession->connection.error->body = hSession->connection.error->summary + strlen(hSession->connection.error->summary) + 1;
< 	strcpy((char *) hSession->connection.error->body,body);
< 
< }
< 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/printer.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/printer.c
51c51
< #include "windows.h"
---
> 	#include "windows.h"
61c61
< //#include "resources.h"
---
> #include "resources.h"
72c72
< #include "screenc.h"
---
> 	#include "screenc.h"
118c118,119
< printer_init(void) {
---
> printer_init(void)
> {
131c132,133
< printer_start(const char *lu) {
---
> printer_start(const char *lu)
> {
227c229
< 		proxy_cmd = xs_buffer("-proxy \"%s\"", appres.proxy);
---
> 	    	proxy_cmd = xs_buffer("-proxy \"%s\"", appres.proxy);
293c295
< 				if (proxy_cmd != CN)
---
> 			    	if (proxy_cmd != CN)
311,315c313,317
< 			popup_an_errno(errno, charset_file);
< 			Free(cmd_text);
< 			if (proxy_cmd != CN)
< 				Free(proxy_cmd);
< 			return;
---
> 		    popup_an_errno(errno, charset_file);
> 		    Free(cmd_text);
> 		    if (proxy_cmd != CN)
> 			    Free(proxy_cmd);
> 		    return;
318c320
< 		               "for pr3287\n");
---
> 		    "for pr3287\n");
321c323
< 		               lib3270_get_charset(&h3270));
---
> 		    lib3270_get_charset(&h3270));
326c328
< 			               cgcsgid_dbcs);
---
> 				       cgcsgid_dbcs);
329c331
< 				               encoding);
---
> 					       encoding);
331c333
< 			               converter_names);
---
> 				       converter_names);
335,337c337,339
< 			if (ebc2asc[i] != ebc2asc0[i]) {
< 				(void) fprintf(f, " %u=%u", i, ebc2asc[i]);
< 			}
---
> 		    if (ebc2asc[i] != ebc2asc0[i]) {
> 			(void) fprintf(f, " %u=%u", i, ebc2asc[i]);
> 		    }
367c369
< 	case 0:	/* child process */
---
> 	    case 0:	/* child process */
379c381
< 	default:	/* parent process */
---
> 	    default:	/* parent process */
388c390
< 	case -1:	/* error */
---
> 	    case -1:	/* error */
418,419c420,421
< 	        !strcasecmp(subcommand, "wpr3287")) {
< 		char *pc;
---
> 	    !strcasecmp(subcommand, "wpr3287")) {
> 	    	char *pc;
421c423
< 		pc = xs_buffer("%s%s", ".", subcommand);
---
> 	    	pc = xs_buffer("%s%s", ".", subcommand);
435,444c437,446
< 	            subcommand,
< 	            cmd_text,
< 	            NULL,
< 	            NULL,
< 	            FALSE,
< 	            0, /* creation flags */
< 	            NULL,
< 	            NULL,
< 	            &startupinfo,
< 	            &process_information) == 0) {
---
> 	    subcommand,
> 	    cmd_text,
> 	    NULL,
> 	    NULL,
> 	    FALSE,
> 	    0, /* creation flags */
> 	    NULL,
> 	    NULL,
> 	    &startupinfo,
> 	    &process_information) == 0) {
466c468,469
< printer_data(struct pr3o *p, Boolean is_err) {
---
> printer_data(struct pr3o *p, Boolean is_err)
> {
522c525,526
< static void printer_output(H3270 *session) {
---
> static void printer_output(H3270 *session)
> {
527c531,532
< static void printer_error(H3270 *session) {
---
> static void printer_error(H3270 *session)
> {
533c538,539
< printer_timeout(struct pr3o *p, Boolean is_err) {
---
> printer_timeout(struct pr3o *p, Boolean is_err)
> {
543c549,550
< printer_otimeout(H3270 *session) {
---
> printer_otimeout(H3270 *session)
> {
549c556,557
< printer_etimeout(H3270 *session) {
---
> printer_etimeout(H3270 *session)
> {
555c563,564
< printer_dump(struct pr3o *p, Boolean is_err, Boolean is_dead) {
---
> printer_dump(struct pr3o *p, Boolean is_err, Boolean is_dead)
> {
569c578
< 		                     "%s", p->buf);
---
> 		    "%s", p->buf);
581c590,591
< printer_check(void) {
---
> printer_check(void)
> {
585,586c595,596
< 	        GetExitCodeProcess(printer_handle, &exit_code) != 0 &&
< 	        exit_code != STILL_ACTIVE) {
---
> 	    GetExitCodeProcess(printer_handle, &exit_code) != 0 &&
> 	    exit_code != STILL_ACTIVE) {
593c603
< 			(void) unlink(charset_file);
---
> 		    (void) unlink(charset_file);
604c614,615
< printer_stop(void) {
---
> printer_stop(void)
> {
644c655
< 		(void) unlink(charset_file);
---
> 	    (void) unlink(charset_file);
652c663,664
< printer_exiting(H3270 *session, int GNUC_UNUSED(b), void *dunno) {
---
> printer_exiting(H3270 *session, int GNUC_UNUSED(b), void *dunno)
> {
659c671,672
< lu_callback(Widget w, XtPointer client_data, XtPointer G_GNUC_UNUSED(call_data)) {
---
> lu_callback(Widget w, XtPointer client_data, XtPointer G_GNUC_UNUSED(call_data))
> {
677c690,691
< printer_host_connect(H3270 *session, int GNUC_UNUSED(connected), void *dunno) {
---
> printer_host_connect(H3270 *session, int GNUC_UNUSED(connected), void *dunno)
> {
686c700
< 					          "session.\n");
---
> 						  "session.\n");
692c706
< 				          printer_lu);
---
> 				    printer_lu);
696,698c710,712
< 		           printer_lu != CN &&
< 		           !strcmp(printer_lu, ".") &&
< 		           printer_running()) {
---
> 			   printer_lu != CN &&
> 			   !strcmp(printer_lu, ".") &&
> 			   printer_running()) {
719c733,734
< printer_lu_dialog(void) {
---
> printer_lu_dialog(void)
> {
722c737
< 		                             lu_callback, (XtCallbackProc)NULL, FORM_NO_WHITE);
---
> 		    lu_callback, (XtCallbackProc)NULL, FORM_NO_WHITE);
728c743,744
< printer_running(void) {
---
> printer_running(void)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/boolean.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/boolean.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,19
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
6,14c21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
28,40c30,42
< /**
<  * @brief Implements the boolean properties.
<  *
<  */
< 
< #include <config.h>
< #include <internals.h>
< #include <string.h>
< #include <lib3270.h>
< #include <lib3270/properties.h>
< #include <lib3270/keyboard.h>
< #include <lib3270/selection.h>
< #include <lib3270/ssl.h>
---
>  /**
>   * @brief Implements the boolean properties.
>   *
>   */
> 
>  #include <config.h>
>  #include <internals.h>
>  #include <string.h>
>  #include <lib3270.h>
>  #include <lib3270/properties.h>
>  #include <lib3270/keyboard.h>
>  #include <lib3270/selection.h>
>  #include <lib3270/ssl.h>
42c44,45
< int lib3270_is_starting(const H3270 *hSession) {
---
>  int lib3270_is_starting(const H3270 *hSession)
>  {
44c47
< }
---
>  }
46c49,50
< LIB3270_EXPORT int lib3270_ssl_set_crl_download(H3270 *hSession, int enabled) {
---
>   LIB3270_EXPORT int lib3270_ssl_set_crl_download(H3270 *hSession, int enabled)
>   {
50c54
< }
---
>   }
52c56,57
< LIB3270_EXPORT int lib3270_ssl_get_crl_download(const H3270 *hSession) {
---
>  LIB3270_EXPORT int lib3270_ssl_get_crl_download(const H3270 *hSession)
>  {
54c59
< }
---
>  }
56c61,62
< const LIB3270_INT_PROPERTY * lib3270_get_boolean_properties_list(void) {
---
>  const LIB3270_INT_PROPERTY * lib3270_get_boolean_properties_list(void)
>  {
217c223
< }
---
>  }
219c225,228
< int lib3270_set_boolean_property(H3270 *hSession, const char *name, int value, int seconds) {
---
> int lib3270_set_boolean_property(H3270 *hSession, const char *name, int value, int seconds)
> {
> 	size_t ix;
> 	const LIB3270_INT_PROPERTY * properties;
221c230,231
< 	if(seconds) {
---
> 	if(seconds)
> 	{
225,230c235,240
< 	size_t ix;
< 	const LIB3270_INT_PROPERTY * properties = lib3270_get_boolean_properties_list();
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
< 			if(properties[ix].set) {
< 				lib3270_write_event_trace(hSession,"%s %s\n",(value ? "Enabling" : "Disabling"),properties[ix].name);
---
> 	properties = lib3270_get_boolean_properties_list();
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
> 			if(properties[ix].set)
232c242
< 			} else {
---
> 			else
234d243
< 			}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/get.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/get.c
30,35c30,35
< #include <config.h>
< #include <internals.h>
< #include <string.h>
< #include <lib3270.h>
< #include <lib3270/properties.h>
< #include <utilc.h>
---
>  #include <config.h>
>  #include <internals.h>
>  #include <string.h>
>  #include <lib3270.h>
>  #include <lib3270/properties.h>
>  #include <utilc.h>
37c37
< LIB3270_EXPORT const char * lib3270_property_get_name(const LIB3270_PROPERTY * property) {
---
>  LIB3270_EXPORT const char * lib3270_property_get_name(const LIB3270_PROPERTY * property) {
44c44
< }
---
>  }
46c46
< LIB3270_EXPORT const char * lib3270_property_get_tooltip(const LIB3270_PROPERTY * property) {
---
>  LIB3270_EXPORT const char * lib3270_property_get_tooltip(const LIB3270_PROPERTY * property) {
59c59
< }
---
>  }
61c61
< LIB3270_EXPORT const char * lib3270_property_get_label(const LIB3270_PROPERTY * property) {
---
>  LIB3270_EXPORT const char * lib3270_property_get_label(const LIB3270_PROPERTY * property) {
68c68
< }
---
>  }
70c70
< LIB3270_EXPORT const char * lib3270_property_get_description(const LIB3270_PROPERTY * property) {
---
>  LIB3270_EXPORT const char * lib3270_property_get_description(const LIB3270_PROPERTY * property) {
77c77
< }
---
>  }
79c79
< LIB3270_EXPORT const char * lib3270_property_get_summary(const LIB3270_PROPERTY * property) {
---
>  LIB3270_EXPORT const char * lib3270_property_get_summary(const LIB3270_PROPERTY * property) {
86c86
< }
---
>  }
88c88
< LIB3270_EXPORT const LIB3270_PROPERTY * lib3270_property_get_by_name(const char *name) {
---
>  LIB3270_EXPORT const LIB3270_PROPERTY * lib3270_property_get_by_name(const char *name) {
92c92
< 		const LIB3270_STRING_PROPERTY * property = lib3270_get_string_properties_list();
---
> 		 const LIB3270_STRING_PROPERTY * property = lib3270_get_string_properties_list();
94c94
< 		while(property->name) {
---
> 		 while(property->name) {
101c101
< 		}
---
> 		 }
109c109
< 		while(property->name) {
---
> 		 while(property->name) {
116c116
< 		}
---
> 		 }
123c123
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/signed.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/signed.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,14c6,21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
28,109c30,35
< /**
<  * @brief Signed int properties.
<  */
< 
< #include <config.h>
< #include <internals.h>
< #include <string.h>
< #include <lib3270.h>
< #include <lib3270/properties.h>
< #include <lib3270/keyboard.h>
< 
< LIB3270_EXPORT const char * lib3270_get_connection_state_as_string(const H3270 *hSession) {
< 
< 	static const char * values[] = {
< 		N_("Disconnected"),
< 		N_("Connecting to host"),
< 		N_("Connection pending"),
< 		N_("Connected, no mode yet"),
< 		N_("Connected in NVT ANSI mode"),
< 		N_("Connected in old-style 3270 mode"),
< 		N_("Connected in TN3270E mode, no negotiated"),
< 		N_("Connected in TN3270E mode, NVT mode"),
< 		N_("Connected in TN3270E mode, SSCP-LU mode"),
< 		N_("Connected in TN3270E mode, 3270 mode")
< 	};
< 
< 	size_t value = (size_t) lib3270_get_connection_state(hSession);
< 	if(value < (sizeof(value)/sizeof(values[0]))) {
< 		return dgettext(GETTEXT_PACKAGE,values[value]);
< 	}
< 
< 	return _( "Unknown" );
< 
< }
< 
< LIB3270_EXPORT const char * lib3270_get_program_message_as_string(const H3270 *hSession) {
< 
< 	static const char * values[] = {
< 		"",
< 		N_( "X System" ),
< 		N_( "X Wait" ),
< 		N_( "X Connected" ),
< 		N_( "X Not Connected" ),
< 		N_( "X" ),
< 		N_( "X -f" ),
< 		N_( "X Protected" ),
< 		N_( "X Numeric" ),
< 		N_( "X Overflow" ),
< 		N_( "X Inhibit" ),
< 		N_( "X" ),
< 		N_( "X" ),
< 		N_( "X Resolving" ),
< 		N_( "X Connecting" )
< 	};
< 
< 	size_t value = (size_t) lib3270_get_program_message(hSession);
< 	if(value < (sizeof(value)/sizeof(values[0]))) {
< 		return dgettext(GETTEXT_PACKAGE,values[value]);
< 	}
< 
< 	return _( "Unknown" );
< 
< }
< 
< LIB3270_EXPORT const char * lib3270_get_ssl_state_as_string(const H3270 * hSession) {
< 
< 	static const char * values[] = {
< 		N_("No secure connection"),
< 		N_("Connection secure with CA check"),
< 		N_("Connection secure, no CA, self-signed or expired CRL"),
< 		N_("Negotiating SSL"),
< 		N_("Verifying SSL (Getting CRL)"),
< 		N_("Undefined")
< 	};
< 
< 	size_t value = (size_t) lib3270_get_ssl_state(hSession);
< 	if(value < (sizeof(value)/sizeof(values[0]))) {
< 		return dgettext(GETTEXT_PACKAGE,values[value]);
< 	}
< 
< 	return _( "Unknown" );
< }
---
>  #include <config.h>
>  #include <internals.h>
>  #include <string.h>
>  #include <lib3270.h>
>  #include <lib3270/properties.h>
>  #include <lib3270/keyboard.h>
111c37,38
< static int lib3270_get_connection_state_as_int(const H3270 *hSession) {
---
>  static int lib3270_get_connection_state_as_int(const H3270 *hSession)
>  {
113,117c40
< }
< 
< static int lib3270_get_ssl_state_as_int(const H3270 * hSession) {
< 	return (int) lib3270_get_ssl_state(hSession);
< }
---
>  }
119c42,43
< static int lib3270_get_program_message_as_int(const H3270 *hSession) {
---
>  static int lib3270_get_program_message_as_int(const H3270 *hSession)
>  {
121c45,50
< }
---
>  }
> 
>  static int lib3270_get_ssl_state_as_int(const H3270 * hSession)
>  {
>  	return (int) lib3270_get_ssl_state(hSession);
>  }
123c52,53
< const LIB3270_INT_PROPERTY * lib3270_get_int_properties_list(void) {
---
>  const LIB3270_INT_PROPERTY * lib3270_get_int_properties_list(void)
>  {
131,132c61
< 			.set = NULL,										//  Set value.
< 			.describe = lib3270_get_connection_state_as_string
---
> 			.set = NULL											//  Set value.
140,141c69
< 			.set = lib3270_set_cursor_address,						// Set value.
< 			.describe = NULL
---
> 			.set = lib3270_set_cursor_address						// Set value.
145,149c73,76
< 			.name = "program_message",									//  Property name.
< 			.description = N_( "Latest program message" ),				//  Property description.
< 			.get = lib3270_get_program_message_as_int,					//  Get value.
< 			.set = NULL,												//  Set value.
< 			.describe = lib3270_get_program_message_as_string
---
> 			.name = "program_message",							//  Property name.
> 			.description = N_( "Latest program message" ),		//  Property description.
> 			.get = lib3270_get_program_message_as_int,			//  Get value.
> 			.set = NULL											//  Set value.
156,157c83
< 			.set = NULL,												//  Set value.
< 			.describe = lib3270_get_ssl_state_as_string
---
> 			.set = NULL													//  Set value.
164,165c90
< 			.set = NULL,										//  Set value.
< 			.describe = NULL
---
> 			.set = NULL
167c92
< 	};
---
> 	 };
169,170c94,95
< 	return properties;
< }
---
> 	 return properties;
>  }
173c98,99
< int lib3270_get_int_property(H3270 *hSession, const char *name, int seconds) {
---
> int lib3270_get_int_property(H3270 *hSession, const char *name, int seconds)
> {
177c103,104
< 	if(seconds) {
---
> 	if(seconds)
> 	{
183,185c110,115
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
< 			if(properties[ix].get) {
---
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
> 			if(properties[ix].get)
> 			{
187c117,119
< 			} else {
---
> 			}
> 			else
> 			{
198,200c130,135
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
< 			if(properties[ix].get) {
---
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
> 			if(properties[ix].get)
> 			{
202c137,139
< 			} else {
---
> 			}
> 			else
> 			{
215c152,153
< int lib3270_set_int_property(H3270 *hSession, const char *name, int value, int seconds) {
---
> int lib3270_set_int_property(H3270 *hSession, const char *name, int value, int seconds)
> {
224,225c162,165
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
---
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
236,237c176,179
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
---
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/string.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/string.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,9c6
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
11,14c8,21
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
28,37c30,38
< #include <config.h>
< #include <stdlib.h>
< #include <internals.h>
< #include <string.h>
< #include <lib3270.h>
< #include <lib3270/properties.h>
< #include <lib3270/keyboard.h>
< #include <lib3270/log.h>
< #include <lib3270/ssl.h>
< #include <lib3270/trace.h>
---
>  #include <config.h>
>  #include <stdlib.h>
>  #include <internals.h>
>  #include <string.h>
>  #include <lib3270.h>
>  #include <lib3270/properties.h>
>  #include <lib3270/keyboard.h>
>  #include <lib3270/log.h>
>  #include <lib3270/ssl.h>
39,47c40,41
< LIB3270_EXPORT const char * lib3270_get_termtype(const H3270 *hSession) {
< 	return hSession->termtype;
< }
< 
< LIB3270_EXPORT const char * lib3270_get_termname(const H3270 *hSession) {
< 	return hSession->termname;
< }
< 
< static const char * get_version(const H3270 GNUC_UNUSED(*hSession)) {
---
>  static const char * get_version(const H3270 GNUC_UNUSED(*hSession))
>  {
49c43
< }
---
>  }
51c45,46
< static const char * get_revision(const H3270 GNUC_UNUSED(*hSession)) {
---
>  static const char * get_revision(const H3270 GNUC_UNUSED(*hSession))
>  {
53c48
< }
---
>  }
55,58c50,62
< 
< LIB3270_EXPORT const LIB3270_STRING_PROPERTY * lib3270_get_string_properties_list(void) {
< 
< 	static const LIB3270_STRING_PROPERTY properties[] = {
---
>  static const char * lib3270_get_termtype(const H3270 *hSession)
>  {
>  	return hSession->termtype;
>  }
> 
>  static const char * lib3270_get_termname(const H3270 *hSession)
>  {
>  	return hSession->termname;
>  }
> 
>  LIB3270_EXPORT const LIB3270_STRING_PROPERTY * lib3270_get_string_properties_list(void)
>  {
> 	 static const LIB3270_STRING_PROPERTY properties[] = {
70c74
< 			.default_value = LIB3270_STRINGIZE_VALUE_OF(LIB3270_DEFAULT_HOST),		// Default value.
---
> 			.default_value = LIB3270_DEFAULT_HOST,									// Default value.
127c131
< 			.description = N_( "Protocol library version" ),		//  Property description.
---
> 			.description = N_( "lib3270 version" ),					//  Property description.
133,136c137,149
< 			.name = "revision",										// Property name.
< 			.description = N_( "Protocol library revision" ),		// Property description.
< 			.get = get_revision,									// Get value.
< 			.set = NULL												// Set value.
---
> 			.name = "revision",													// Property name.
> 			.description = N_( "lib3270 revision" ),							// Property description.
> 			.get = get_revision,												// Get value.
> 			.set = NULL															// Set value.
> 		},
> 
> 		/*
> 		{
> 			.name = "crl_url",													// Property name.
> 			.group = LIB3270_ACTION_GROUP_OFFLINE,								// Property group.
> 			.description = N_( "URL for the certificate revocation list" ),		// Property description.
> 			.get = lib3270_crl_get_url,											// Get value.
> 			.set = lib3270_crl_set_url,											// Set value.
137a151
> 		*/
177,192d190
< 			.name = "logfile",														//  Property name.
< 			.group = LIB3270_ACTION_GROUP_NONE,										// Property group.
< 			.description = N_( "The log file name"),								//  Property description.
< 			.get = lib3270_get_log_filename,										//  Get value.
< 			.set = lib3270_set_log_filename											//  Set value.
< 		},
< 
< 		{
< 			.name = "tracefile",													//  Property name.
< 			.group = LIB3270_ACTION_GROUP_NONE,										// Property group.
< 			.description = N_( "The trace file name"),								//  Property description.
< 			.get = lib3270_get_trace_filename,										//  Get value.
< 			.set = lib3270_set_trace_filename										//  Set value.
< 		},
< 
< 		{
199c197
< 	};
---
> 	 };
201c199
< 	return properties;
---
> 	 return properties;
203c201
< }
---
>  }
205c203,204
< int lib3270_set_string_property(H3270 *hSession, const char *name, const char * value, int seconds) {
---
> int lib3270_set_string_property(H3270 *hSession, const char *name, const char * value, int seconds)
> {
208c207,208
< 	if(seconds) {
---
> 	if(seconds)
> 	{
217,219c217,222
< 		for(ix = 0; properties[ix].name; ix++) {
< 			if(!strcasecmp(name,properties[ix].name)) {
< 				if(properties[ix].set) {
---
> 		for(ix = 0; properties[ix].name; ix++)
> 		{
> 			if(!strcasecmp(name,properties[ix].name))
> 			{
> 				if(properties[ix].set)
> 				{
221c224,226
< 				} else {
---
> 				}
> 				else
> 				{
232c237
< 	{
---
>     {
234,236c239,244
< 		for(ix = 0; properties[ix].name; ix++) {
< 			if(!strcasecmp(name,properties[ix].name)) {
< 				if(properties[ix].set) {
---
> 		for(ix = 0; properties[ix].name; ix++)
> 		{
> 			if(!strcasecmp(name,properties[ix].name))
> 			{
> 				if(properties[ix].set)
> 				{
238c246,248
< 				} else {
---
> 				}
> 				else
> 				{
244c254
< 	}
---
>     }
246,249c256,259
< 	//
< 	// Check for unsigned int property
< 	//
< 	{
---
>     //
>     // Check for unsigned int property
>     //
>     {
251,253c261,266
< 		for(ix = 0; properties[ix].name; ix++) {
< 			if(!strcasecmp(name,properties[ix].name)) {
< 				if(properties[ix].set) {
---
> 		for(ix = 0; properties[ix].name; ix++)
> 		{
> 			if(!strcasecmp(name,properties[ix].name))
> 			{
> 				if(properties[ix].set)
> 				{
255c268,270
< 				} else {
---
> 				}
> 				else
> 				{
261c276
< 	}
---
>     }
263,266c278,281
< 	//
< 	// Check for boolean property
< 	//
< 	{
---
>     //
>     // Check for boolean property
>     //
>     {
268,270c283,288
< 		for(ix = 0; properties[ix].name; ix++) {
< 			if(!strcasecmp(name,properties[ix].name)) {
< 				if(properties[ix].set) {
---
> 		for(ix = 0; properties[ix].name; ix++)
> 		{
> 			if(!strcasecmp(name,properties[ix].name))
> 			{
> 				if(properties[ix].set)
> 				{
272c290,292
< 				} else {
---
> 				}
> 				else
> 				{
278c298
< 	}
---
>     }
284,285c304,306
< LIB3270_EXPORT int lib3270_set_lunames(H3270 *hSession, const char *lunames) {
< 	FAIL_IF_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_set_lunames(H3270 *hSession, const char *lunames)
> {
>     FAIL_IF_ONLINE(hSession);
287c308,309
< 	if(hSession->lu.names) {
---
>     if(hSession->lu.names)
> 	{
305c327,328
< 	while ((comma = strchr(lu, ',')) != CN) {
---
> 	while ((comma = strchr(lu, ',')) != CN)
> 	{
321c344,345
< 	do {
---
> 	do
> 	{
324c348,349
< 		if (comma != CN) {
---
> 		if (comma != CN)
> 		{
332c357
< 	return 0;
---
>     return 0;
335c360,361
< LIB3270_EXPORT const char ** lib3270_get_lunames(H3270 *hSession) {
---
> LIB3270_EXPORT const char ** lib3270_get_lunames(H3270 *hSession)
> {
339c365,366
< LIB3270_EXPORT const char * lib3270_host_get_name(const H3270 *h) {
---
> LIB3270_EXPORT const char * lib3270_host_get_name(const H3270 *h)
> {
343c370,371
< LIB3270_EXPORT const char * lib3270_service_get_name(const H3270 *h) {
---
> LIB3270_EXPORT const char * lib3270_service_get_name(const H3270 *h)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/unsigned.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/properties/unsigned.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,14c6,21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
28,33c30,35
< #include <config.h>
< #include <internals.h>
< #include <string.h>
< #include <lib3270.h>
< #include <lib3270/properties.h>
< #include <lib3270/keyboard.h>
---
>  #include <config.h>
>  #include <internals.h>
>  #include <string.h>
>  #include <lib3270.h>
>  #include <lib3270/properties.h>
>  #include <lib3270/keyboard.h>
35,36c37,44
< const LIB3270_UINT_PROPERTY * lib3270_unsigned_property_get_by_name(const char *name) {
< 	size_t ix;
---
>  unsigned int lib3270_get_kybdlock_as_int(const H3270 *hSession)
>  {
> 	return (unsigned int) lib3270_get_keyboard_lock_state(hSession);
>  }
> 
>  const LIB3270_UINT_PROPERTY * lib3270_unsigned_property_get_by_name(const char *name)
>  {
>  	size_t ix;
39c47,48
< 	for(ix = 0; list[ix].name; ix++) {
---
>  	for(ix = 0;list[ix].name;ix++)
> 	{
45,46c54,55
< 	return NULL;
< }
---
>     return NULL;
>  }
48c57,58
< int lib3270_set_host_type_number(H3270 *hSession, unsigned int host_type) {
---
> int lib3270_set_host_type_number(H3270 *hSession, unsigned int host_type)
> {
54c64,65
< static unsigned int lib3270_get_host_type_number(const H3270 *hSession) {
---
> static unsigned int lib3270_get_host_type_number(const H3270 *hSession)
> {
58,71c69,70
< LIB3270_EXPORT unsigned int lib3270_get_auto_reconnect(const H3270 *hSession) {
< 	return hSession->connection.retry;
< }
< 
< LIB3270_EXPORT int lib3270_set_auto_reconnect(H3270 *hSession, unsigned int timer) {
< 	hSession->connection.retry = timer;
< 	return 0;
< }
< 
< static unsigned int lib3270_get_kybdlock_as_int(const H3270 *hSession) {
< 	return (unsigned int) lib3270_get_keyboard_lock_state(hSession);
< }
< 
< const LIB3270_UINT_PROPERTY * lib3270_get_unsigned_properties_list(void) {
---
>  const LIB3270_UINT_PROPERTY * lib3270_get_unsigned_properties_list(void)
>  {
142,149d140
< 			.name = "auto_reconnect",								// Property name.
< 			.default_value = 5000,									// Default value for the property.
< 			.description = N_( "Time for auto-reconnect" ),			// Property description.
< 			.get = lib3270_get_auto_reconnect,						// Get value.
< 			.set = lib3270_set_auto_reconnect						// Set value.
< 		},
< 
< 		{
181c172
< }
---
>  }
183c174,175
< int lib3270_set_uint_property(H3270 *hSession, const char *name, unsigned int value, int seconds) {
---
> int lib3270_set_uint_property(H3270 *hSession, const char *name, unsigned int value, int seconds)
> {
193,194c185,188
< 	for(ix = 0; properties[ix].name; ix++) {
< 		if(!strcasecmp(name,properties[ix].name)) {
---
> 	for(ix = 0; properties[ix].name; ix++)
> 	{
> 		if(!strcasecmp(name,properties[ix].name))
> 		{
205,208d198
< }
< 
< LIB3270_EXPORT unsigned int lib3270_get_task_count(const H3270 *h) {
< 	return h->tasks;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/rpq.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/rpq.c
33c33
< #pragma GCC diagnostic ignored "-Wsign-compare"
---
>  #pragma GCC diagnostic ignored "-Wsign-compare"
53c53
< #include <stdlib.h>
---
> 	#include <stdlib.h>
109c109,110
< static struct rpq_keyword {
---
> static struct rpq_keyword
> {
130,131c131,133
< void do_qr_rpqnames(H3270 *hSession) {
< #define TERM_PREFIX_SIZE 2	/* Each term has 1 byte length and 1 byte id */
---
> void do_qr_rpqnames(H3270 *hSession)
> {
> 	#define TERM_PREFIX_SIZE 2	/* Each term has 1 byte length and 1 byte id */
181c183,184
< 		switch (term_id) { /* build the term based on id */
---
> 		switch (term_id) /* build the term based on id */
> 		{
201,202c204,207
< 			if (!omit_due_space_limit) {
< 				for (i = 0; i < x; i++) {
---
> 			if (!omit_due_space_limit)
> 			{
> 				for (i = 0; i < x; i++)
> 				{
211,212c216,219
< 			if (!omit_due_space_limit) {
< 				for (i=0; i < x; i+=2) {
---
> 			if (!omit_due_space_limit)
> 			{
> 				for (i=0; i < x; i+=2)
> 				{
214c221
< 					                          + (*(RPQ_TIMESTAMP_VALUE+i+1) - '0');
---
> 						+ (*(RPQ_TIMESTAMP_VALUE+i+1) - '0');
221,224c228,231
< 			                        LIB3270_NOTIFY_ERROR,
< 			                        _( "RPQ Error" ),
< 			                        _( "Unsupported RPQ term" ),
< 			                        _( "RPQ term %d is unknown" ), term_id );
---
> 									LIB3270_NOTIFY_ERROR,
> 									_( "RPQ Error" ),
> 									_( "Unsupported RPQ term" ),
> 									_( "RPQ term %d is unknown" ), term_id );
270c277,278
< static Boolean select_rpq_terms(H3270 *hSession) {
---
> static Boolean select_rpq_terms(H3270 *hSession)
> {
370c378,379
< static int get_rpq_timezone(H3270 *hSession) {
---
> static int get_rpq_timezone(H3270 *hSession)
> {
423c432,433
< 		if ((here = time(NULL)) == (time_t)(-1)) {
---
> 		if ((here = time(NULL)) == (time_t)(-1))
> 		{
433c443,444
< 		if(gmtime_r(&here,&utc_tm) == NULL) {
---
> 		if(gmtime_r(&here,&utc_tm) == NULL)
> 		{
443c454,455
< 		if(_tm == NULL) {
---
> 		if(_tm == NULL)
> 		{
462c474
< #pragma GCC diagnostic ignored "-Wabsolute-value"
---
> 	#pragma GCC diagnostic ignored "-Wabsolute-value"
473c485,486
< static int get_rpq_user(H3270 *hSession, unsigned char buf[], const int buflen) {
---
> static int get_rpq_user(H3270 *hSession, unsigned char buf[], const int buflen)
> {
588c601,602
< static int get_rpq_address(H3270 *hSession, unsigned char *buf, const int maxlen) {
---
> static int get_rpq_address(H3270 *hSession, unsigned char *buf, const int maxlen)
> {
613c627
< 		for (p2=rpqtext; *p1; p2++) {
---
> 		for (p2=rpqtext;*p1; p2++) {
730c744,745
< static void rpq_warning(H3270 *hSession, const char *fmt, ...) {
---
> static void rpq_warning(H3270 *hSession, const char *fmt, ...)
> {
741c756,757
< 	if (!hSession->rpq_complained) {
---
> 	if (!hSession->rpq_complained)
> 	{
746c762,763
< 		if (hSession->rpq_wbcnt < RPQ_WARNBUF_SIZE) {
---
> 		if (hSession->rpq_wbcnt < RPQ_WARNBUF_SIZE)
> 		{
751c768,769
< 		if (hSession->rpq_wbcnt < RPQ_WARNBUF_SIZE) {
---
> 		if (hSession->rpq_wbcnt < RPQ_WARNBUF_SIZE)
> 		{
758c776,777
< static void rpq_dump_warnings(H3270 *hSession) {
---
> static void rpq_dump_warnings(H3270 *hSession)
> {
760c779,780
< 	if (!hSession->rpq_complained && hSession->rpq_wbcnt) {
---
> 	if (!hSession->rpq_complained && hSession->rpq_wbcnt)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/screen.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/screen.c
40c40
< //#include "resources.h"
---
> #include "resources.h"
58,60c58,60
< #include <windows.h>
< #include <wincon.h>
< #include "winversc.h"
---
> 	#include <windows.h>
> 	#include <wincon.h>
> 	#include "winversc.h"
62c62
< #include <stdarg.h>
---
> 	#include <stdarg.h>
77c77,78
< static void addch(H3270 *session, int baddr, unsigned char c, unsigned short attr, int *first, int *last) {
---
> static void addch(H3270 *session, int baddr, unsigned char c, unsigned short attr, int *first, int *last)
> {
96c97,98
< LIB3270_EXPORT LIB3270_ATTR lib3270_get_attribute_at_address(H3270 *hSession, unsigned int baddr) {
---
> LIB3270_EXPORT LIB3270_ATTR lib3270_get_attribute_at_address(H3270 *hSession, unsigned int baddr)
> {
100c102,103
< 	if(!hSession->text ||baddr > (hSession->view.rows*hSession->view.cols)) {
---
> 	if(!hSession->text ||baddr > (hSession->view.rows*hSession->view.cols))
> 	{
108,109c111,113
< LIB3270_EXPORT int lib3270_is_selected(H3270 *hSession, unsigned int baddr) {
< 	FAIL_IF_NOT_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_is_selected(H3270 *hSession, unsigned int baddr)
> {
>     FAIL_IF_NOT_ONLINE(hSession);
111c115,116
< 	if(!hSession->text || baddr > (hSession->view.rows * hSession->view.cols)) {
---
> 	if(!hSession->text || baddr > (hSession->view.rows * hSession->view.cols))
> 	{
119,120c124,126
< LIB3270_EXPORT int lib3270_get_element(H3270 *hSession, unsigned int baddr, unsigned char *c, unsigned short *attr) {
< 	FAIL_IF_NOT_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_get_element(H3270 *hSession, unsigned int baddr, unsigned char *c, unsigned short *attr)
> {
>     FAIL_IF_NOT_ONLINE(hSession);
122c128,129
< 	if(!hSession->text || baddr > (hSession->view.rows * hSession->view.cols)) {
---
> 	if(!hSession->text || baddr > (hSession->view.rows * hSession->view.cols))
> 	{
139c146,147
< int screen_init(H3270 *session) {
---
> int screen_init(H3270 *session)
> {
158c166,167
< static unsigned short color_from_fa(H3270 *hSession, unsigned char fa) {
---
> static unsigned short color_from_fa(H3270 *hSession, unsigned char fa)
> {
169c178,179
< static unsigned short calc_attrs(H3270 *session, int baddr, int fa_addr, int fa) {
---
> static unsigned short calc_attrs(H3270 *session, int baddr, int fa_addr, int fa)
> {
177,180c187,191
< 	        (!session->ea_buf[baddr].fg &&
< 	         !session->ea_buf[fa_addr].fg &&
< 	         !session->ea_buf[baddr].bg &&
< 	         !session->ea_buf[fa_addr].bg)) {
---
> 		(!session->ea_buf[baddr].fg &&
> 		 !session->ea_buf[fa_addr].fg &&
> 		 !session->ea_buf[baddr].bg &&
> 		 !session->ea_buf[fa_addr].bg))
> 	{
182c193,195
< 	} else {
---
> 	}
> 	else
> 	{
185c198,199
< 		if (session->ea_buf[baddr].fg) {
---
> 		if (session->ea_buf[baddr].fg)
> 		{
187c201,203
< 		} else if (session->ea_buf[fa_addr].fg) {
---
> 		}
> 		else if (session->ea_buf[fa_addr].fg)
> 		{
189c205,207
< 		} else {
---
> 		}
> 		else
> 		{
219c237
< 		a |= LIB3270_ATTR_BACKGROUND_INTENSITY;
---
>     	a |= LIB3270_ATTR_BACKGROUND_INTENSITY;
230c248,249
< LIB3270_EXPORT unsigned int lib3270_get_length(const H3270 *h) {
---
> LIB3270_EXPORT unsigned int lib3270_get_length(const H3270 *h)
> {
234c253,254
< LIB3270_EXPORT void lib3270_get_screen_size(const H3270 *h, unsigned int *r, unsigned int *c) {
---
> LIB3270_EXPORT void lib3270_get_screen_size(const H3270 *h, unsigned int *r, unsigned int *c)
> {
239c259,260
< LIB3270_EXPORT unsigned int lib3270_get_width(const H3270 *h) {
---
> LIB3270_EXPORT unsigned int lib3270_get_width(const H3270 *h)
> {
243c264,265
< LIB3270_EXPORT unsigned int lib3270_get_height(const H3270 *h) {
---
> LIB3270_EXPORT unsigned int lib3270_get_height(const H3270 *h)
> {
247c269,270
< LIB3270_EXPORT unsigned int lib3270_get_max_width(const H3270 *h) {
---
> LIB3270_EXPORT unsigned int lib3270_get_max_width(const H3270 *h)
> {
251c274,275
< LIB3270_EXPORT unsigned int lib3270_get_max_height(const H3270 *h) {
---
> LIB3270_EXPORT unsigned int lib3270_get_max_height(const H3270 *h)
> {
255c279,280
< void update_model_info(H3270 *hSession, unsigned int model, unsigned int cols, unsigned int rows) {
---
> void update_model_info(H3270 *hSession, unsigned int model, unsigned int cols, unsigned int rows)
> {
278c303,304
< LIB3270_EXPORT int lib3270_get_contents(H3270 *h, int first, int last, unsigned char *chr, unsigned short *attr) {
---
> LIB3270_EXPORT int lib3270_get_contents(H3270 *h, int first, int last, unsigned char *chr, unsigned short *attr)
> {
282c308
< 	CHECK_SESSION_HANDLE(h);
---
>     CHECK_SESSION_HANDLE(h);
289c315,316
< 	for(baddr = first; baddr <= last; baddr++) {
---
> 	for(baddr = first; baddr <= last;baddr++)
> 	{
298c325,326
< void screen_update(H3270 *session, int bstart, int bend) {
---
> void screen_update(H3270 *session, int bstart, int bend)
> {
311,312c339,342
< 	for(baddr = bstart; baddr < bend; baddr++) {
< 		if(session->ea_buf[baddr].fa) {
---
> 	for(baddr = bstart; baddr < bend; baddr++)
> 	{
> 		if(session->ea_buf[baddr].fa)
> 		{
318c348,350
< 		} else if (FA_IS_ZERO(fa)) {
---
> 		}
> 		else if (FA_IS_ZERO(fa))
> 		{
321c353,355
< 		} else {
---
> 		}
> 		else
> 		{
323c357,358
< 			if (!(session->ea_buf[baddr].gr || session->ea_buf[baddr].fg || session->ea_buf[baddr].bg)) {
---
> 			if (!(session->ea_buf[baddr].gr || session->ea_buf[baddr].fg || session->ea_buf[baddr].bg))
> 			{
325c360,362
< 			} else {
---
> 			}
> 			else
> 			{
329c366,367
< 			if (session->ea_buf[baddr].cs == CS_LINEDRAW) {
---
> 			if (session->ea_buf[baddr].cs == CS_LINEDRAW)
> 			{
331c369,371
< 			} else if (session->ea_buf[baddr].cs == CS_APL || (session->ea_buf[baddr].cs & CS_GE)) {
---
> 			}
> 			else if (session->ea_buf[baddr].cs == CS_APL || (session->ea_buf[baddr].cs & CS_GE))
> 			{
333c373,375
< 			} else {
---
> 			}
> 			else
> 			{
342c384,385
< 	if(first >= 0) {
---
> 	if(first >= 0)
> 	{
346c389,390
< 		for(f=first; f<last; f++) {
---
> 		for(f=first;f<last;f++)
> 		{
354c398,399
< 	if(session->starting && session->formatted && !session->kybdlock && lib3270_in_3270(session)) {
---
> 	if(session->starting && session->formatted && !session->kybdlock && lib3270_in_3270(session))
> 	{
374c419,420
< LIB3270_EXPORT int lib3270_get_cursor_address(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_get_cursor_address(const H3270 *hSession)
> {
376c422
< 	return state ? -state : hSession->cursor_addr;
---
>     return state ? -state : hSession->cursor_addr;
379c425,426
< LIB3270_EXPORT int lib3270_get_cursor_position(const H3270 *hSession, unsigned short *row, unsigned short *col) {
---
> LIB3270_EXPORT int lib3270_get_cursor_position(const H3270 *hSession, unsigned short *row, unsigned short *col)
> {
381c428,429
< 	if(state) {
---
> 	if(state)
> 	{
394c442
< 	return 0;
---
>     return 0;
408,409c456,458
< LIB3270_EXPORT int lib3270_translate_to_address(const H3270 *hSession, unsigned int row, unsigned int col) {
< 	FAIL_IF_NOT_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_translate_to_address(const H3270 *hSession, unsigned int row, unsigned int col)
> {
>     FAIL_IF_NOT_ONLINE(hSession);
421,422c470,472
< LIB3270_EXPORT int lib3270_set_cursor_address(H3270 *hSession, int baddr) {
< 	FAIL_IF_NOT_ONLINE(hSession);
---
> LIB3270_EXPORT int lib3270_set_cursor_address(H3270 *hSession, int baddr)
> {
>     FAIL_IF_NOT_ONLINE(hSession);
435c485,486
< LIB3270_EXPORT int lib3270_set_cursor_position(H3270 *hSession, unsigned int row, unsigned int col) {
---
> LIB3270_EXPORT int lib3270_set_cursor_position(H3270 *hSession, unsigned int row, unsigned int col)
> {
454,455c505,507
< int cursor_move(H3270 *hSession, int baddr) {
< 	int ret = hSession->cursor_addr;
---
> int cursor_move(H3270 *hSession, int baddr)
> {
>     int ret = hSession->cursor_addr;
457c509,510
< 	if(ret != baddr && baddr >= 0) {
---
> 	if(ret != baddr && baddr >= 0)
> 	{
460,464c513,517
< 		    hSession,
< 		    (unsigned short) (baddr/hSession->view.cols),
< 		    (unsigned short) (baddr%hSession->view.cols),
< 		    hSession->text[baddr].chr,
< 		    hSession->text[baddr].attr
---
> 			hSession,
> 			(unsigned short) (baddr/hSession->view.cols),
> 			(unsigned short) (baddr%hSession->view.cols),
> 			hSession->text[baddr].chr,
> 			hSession->text[baddr].attr
468c521
< 	return ret;
---
>     return ret;
474c527,528
< void set_status(H3270 *session, LIB3270_FLAG id, Boolean on) {
---
> void set_status(H3270 *session, LIB3270_FLAG id, Boolean on)
> {
479c533,534
< void status_ctlr_done(H3270 *session) {
---
> void status_ctlr_done(H3270 *session)
> {
485c540,541
< void status_oerr(H3270 *session, int error_type) {
---
> void status_oerr(H3270 *session, int error_type)
> {
490c546,547
< 	switch (error_type) {
---
> 	switch (error_type)
> 	{
513c570,571
< void status_resolving(H3270 *hSession) {
---
> void status_resolving(H3270 *hSession)
> {
522c580,581
< void status_connecting(H3270 *hSession) {
---
> void status_connecting(H3270 *hSession)
> {
531c590,591
< void status_reset(H3270 *session) {
---
> void status_reset(H3270 *session)
> {
534c594,595
< 	if (session->kybdlock & KL_ENTER_INHIBIT) {
---
> 	if (session->kybdlock & KL_ENTER_INHIBIT)
> 	{
537c598,600
< 	} else if (session->kybdlock & KL_DEFERRED_UNLOCK) {
---
> 	}
> 	else if (session->kybdlock & KL_DEFERRED_UNLOCK)
> 	{
540c603,605
< 	} else {
---
> 	}
> 	else
> 	{
557c622,623
< LIB3270_EXPORT LIB3270_MESSAGE lib3270_get_program_message(const H3270 *hSession) {
---
> LIB3270_EXPORT LIB3270_MESSAGE lib3270_get_program_message(const H3270 *hSession)
> {
573c639,640
< LIB3270_EXPORT LIB3270_MESSAGE lib3270_get_lock_status(const H3270 *hSession) {
---
> LIB3270_EXPORT LIB3270_MESSAGE lib3270_get_lock_status(const H3270 *hSession)
> {
592c659,660
< LIB3270_EXPORT int lib3270_is_ready(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_is_ready(const H3270 *hSession)
> {
597c665,666
< void status_changed(H3270 *hSession, LIB3270_MESSAGE id) {
---
> void status_changed(H3270 *hSession, LIB3270_MESSAGE id)
> {
601,605c670,674
< 	trace_dsn(
< 	    hSession,
< 	    "Status changed to %d.\n",
< 	    (int) id
< 	);
---
>     trace_dsn(
>         hSession,
>         "Status changed to %d.\n",
>             (int) id
>     );
611c680,681
< void status_twait(H3270 *session) {
---
> void status_twait(H3270 *session)
> {
617c687,688
< void set_viewsize(H3270 *session, unsigned int rows, unsigned int cols) {
---
> void set_viewsize(H3270 *session, unsigned int rows, unsigned int cols)
> {
633c704,705
< void status_lu(H3270 *session, const char *lu) {
---
> void status_lu(H3270 *session, const char *lu)
> {
641c713,714
< static void status_connect(H3270 *hSession, int connected, void GNUC_UNUSED(*dunno)) {
---
> static void status_connect(H3270 *hSession, int connected, void GNUC_UNUSED(*dunno))
> {
646c719,720
< 	if (connected) {
---
> 	if (connected)
> 	{
654c728,730
< 	} else {
---
> 	}
> 	else
> 	{
663c739,740
< static void status_3270_mode(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno)) {
---
> static void status_3270_mode(H3270 *hSession, int GNUC_UNUSED(ignored), void GNUC_UNUSED(*dunno))
> {
674,675c751,752
< void mcursor_set(H3270 *hSession,LIB3270_POINTER m) {
< 
---
> void mcursor_set(H3270 *hSession,LIB3270_POINTER m)
> {
688,689c765,768
< LIB3270_EXPORT int lib3270_testpattern(H3270 *hSession) {
< 	static const unsigned char text_pat[] = {
---
> LIB3270_EXPORT int lib3270_testpattern(H3270 *hSession)
> {
> 	static const unsigned char text_pat[] =
> 	{
708c787,788
< 	static const unsigned char cg_pat[] = {
---
> 	static const unsigned char cg_pat[] =
> 	{
747c827,828
< 	static const struct _pat {
---
> 	static const struct _pat
> 	{
750c831,832
< 	} pat[] = {
---
> 	} pat[] =
> 	{
767,769c849,854
< 	for(f=0; f<max; f++) {
< 		if(!pat[row].cc[pos]) {
< 			if(++row >= (sizeof(pat)/sizeof(struct _pat)) ) {
---
> 	for(f=0;f<max;f++)
> 	{
> 		if(!pat[row].cc[pos])
> 		{
> 			if(++row >= (sizeof(pat)/sizeof(struct _pat)) )
> 			{
771c856,857
< 				if(++fg > COLOR_WHITE) {
---
> 				if(++fg > COLOR_WHITE)
> 				{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/see.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/see.c
50,52c50,52
< //#if !defined(PR3287) /*[*/
< //#include "utf8c.h"
< //#endif /*]*/
---
> #if !defined(PR3287) /*[*/
> #include "utf8c.h"
> #endif /*]*/
56c56,57
< unknown(unsigned char value) {
---
> unknown(unsigned char value)
> {
63c64,65
< const char *see_ebc(H3270 *hSession, unsigned char ch) {
---
> const char *see_ebc(H3270 *hSession, unsigned char ch)
> {
67c69
< 	case FCORDER_NULL:
---
> 	    case FCORDER_NULL:
69c71
< 	case FCORDER_SUB:
---
> 	    case FCORDER_SUB:
71c73
< 	case FCORDER_DUP:
---
> 	    case FCORDER_DUP:
73c75
< 	case FCORDER_FM:
---
> 	    case FCORDER_FM:
75c77
< 	case FCORDER_FF:
---
> 	    case FCORDER_FF:
77c79
< 	case FCORDER_CR:
---
> 	    case FCORDER_CR:
79c81
< 	case FCORDER_NL:
---
> 	    case FCORDER_NL:
81c83
< 	case FCORDER_EM:
---
> 	    case FCORDER_EM:
83c85
< 	case FCORDER_EO:
---
> 	    case FCORDER_EO:
85c87
< 	case FCORDER_SI:
---
> 	    case FCORDER_SI:
87c89
< 	case FCORDER_SO:
---
> 	    case FCORDER_SO:
99c101,102
< const char * see_aid(unsigned char code) {
---
> const char * see_aid(unsigned char code)
> {
176c179,180
< const char * see_attr(unsigned char fa) {
---
> const char * see_attr(unsigned char fa)
> {
183,184c187,188
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "protected", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "protected");
187,188c191,192
< 			(void) strncat(buf, paren, 255);
< 			(void) strncat(buf, "skip", 255);
---
> 			(void) strcat(buf, paren);
> 			(void) strcat(buf, "skip");
192,193c196,197
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "numeric", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "numeric");
200,201c204,205
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "detectable", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "detectable");
205,206c209,210
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "intensified", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "intensified");
210,211c214,215
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "nondisplay", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "nondisplay");
216,217c220,221
< 		(void) strncat(buf, paren, 255);
< 		(void) strncat(buf, "modified", 255);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "modified");
221c225
< 		(void) strncat(buf, ")", 255);
---
> 		(void) strcat(buf, ")");
223c227
< 		(void) strncpy(buf, "(default)", 255);
---
> 		(void) strcpy(buf, "(default)");
228c232,233
< static const char * see_highlight(unsigned char setting) {
---
> static const char * see_highlight(unsigned char setting)
> {
230c235
< 	case XAH_DEFAULT:
---
> 	    case XAH_DEFAULT:
232c237
< 	case XAH_NORMAL:
---
> 	    case XAH_NORMAL:
234c239
< 	case XAH_BLINK:
---
> 	    case XAH_BLINK:
236c241
< 	case XAH_REVERSE:
---
> 	    case XAH_REVERSE:
238c243
< 	case XAH_UNDERSCORE:
---
> 	    case XAH_UNDERSCORE:
240c245
< 	case XAH_INTENSIFY:
---
> 	    case XAH_INTENSIFY:
242c247
< 	default:
---
> 	    default:
247c252,253
< const char * see_color(unsigned char setting) {
---
> const char * see_color(unsigned char setting)
> {
249,264c255,270
< 		"neutralBlack",
< 		"blue",
< 		"red",
< 		"pink",
< 		"green",
< 		"turquoise",
< 		"yellow",
< 		"neutralWhite",
< 		"black",
< 		"deepBlue",
< 		"orange",
< 		"purple",
< 		"paleGreen",
< 		"paleTurquoise",
< 		"grey",
< 		"white"
---
> 	    "neutralBlack",
> 	    "blue",
> 	    "red",
> 	    "pink",
> 	    "green",
> 	    "turquoise",
> 	    "yellow",
> 	    "neutralWhite",
> 	    "black",
> 	    "deepBlue",
> 	    "orange",
> 	    "purple",
> 	    "paleGreen",
> 	    "paleTurquoise",
> 	    "grey",
> 	    "white"
275c281,282
< static const char * see_transparency(unsigned char setting) {
---
> static const char * see_transparency(unsigned char setting)
> {
277c284
< 	case XAT_DEFAULT:
---
> 	    case XAT_DEFAULT:
279c286
< 	case XAT_OR:
---
> 	    case XAT_OR:
281c288
< 	case XAT_XOR:
---
> 	    case XAT_XOR:
283c290
< 	case XAT_OPAQUE:
---
> 	    case XAT_OPAQUE:
285c292
< 	default:
---
> 	    default:
290c297,298
< static const char * see_validation(unsigned char setting) {
---
> static const char * see_validation(unsigned char setting)
> {
296,297c304,305
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "fill", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "fill");
301,302c309,310
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "entry", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "entry");
306,307c314,315
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "trigger", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "trigger");
311c319
< 		(void) strncat(buf, ")", 63);
---
> 		(void) strcat(buf, ")");
313c321
< 		(void) strncpy(buf, "(none)", 63);
---
> 		(void) strcpy(buf, "(none)");
317c325,326
< static const char * see_outline(unsigned char setting) {
---
> static const char * see_outline(unsigned char setting)
> {
323,324c332,333
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "underline", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "underline");
328,329c337,338
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "right", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "right");
333,334c342,343
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "overline", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "overline");
338,339c347,348
< 		(void) strncat(buf, paren, 63);
< 		(void) strncat(buf, "left", 63);
---
> 		(void) strcat(buf, paren);
> 		(void) strcat(buf, "left");
343c352
< 		(void) strncat(buf, ")", 63);
---
> 		(void) strcat(buf, ")");
345c354
< 		(void) strncpy(buf, "(none)", 63);
---
> 		(void) strcpy(buf, "(none)");
349c358,359
< static const char * see_input_control(unsigned char setting) {
---
> static const char * see_input_control(unsigned char setting)
> {
351c361
< 	case XAI_DISABLED:
---
> 	    case XAI_DISABLED:
353c363
< 	case XAI_ENABLED:
---
> 	    case XAI_ENABLED:
355c365
< 	default:
---
> 	    default:
360c370,371
< const char * see_efa(unsigned char efa, unsigned char value) {
---
> const char * see_efa(unsigned char efa, unsigned char value)
> {
364c375
< 	case XA_ALL:
---
> 	    case XA_ALL:
367c378
< 	case XA_3270:
---
> 	    case XA_3270:
370c381
< 	case XA_VALIDATION:
---
> 	    case XA_VALIDATION:
373c384
< 	case XA_OUTLINING:
---
> 	    case XA_OUTLINING:
376c387
< 	case XA_HIGHLIGHTING:
---
> 	    case XA_HIGHLIGHTING:
379c390
< 	case XA_FOREGROUND:
---
> 	    case XA_FOREGROUND:
382c393
< 	case XA_CHARSET:
---
> 	    case XA_CHARSET:
385c396
< 	case XA_BACKGROUND:
---
> 	    case XA_BACKGROUND:
388c399
< 	case XA_TRANSPARENCY:
---
> 	    case XA_TRANSPARENCY:
390c401
< 		                see_transparency(value));
---
> 		    see_transparency(value));
392c403
< 	case XA_INPUT_CONTROL:
---
> 	    case XA_INPUT_CONTROL:
394c405
< 		                see_input_control(value));
---
> 		    see_input_control(value));
396c407
< 	default:
---
> 	    default:
403c414,415
< const char * see_efa_only(unsigned char efa) {
---
> const char * see_efa_only(unsigned char efa)
> {
405c417
< 	case XA_ALL:
---
> 	    case XA_ALL:
407c419
< 	case XA_3270:
---
> 	    case XA_3270:
409c421
< 	case XA_VALIDATION:
---
> 	    case XA_VALIDATION:
411c423
< 	case XA_OUTLINING:
---
> 	    case XA_OUTLINING:
413c425
< 	case XA_HIGHLIGHTING:
---
> 	    case XA_HIGHLIGHTING:
415c427
< 	case XA_FOREGROUND:
---
> 	    case XA_FOREGROUND:
417c429
< 	case XA_CHARSET:
---
> 	    case XA_CHARSET:
419c431
< 	case XA_BACKGROUND:
---
> 	    case XA_BACKGROUND:
421c433
< 	case XA_TRANSPARENCY:
---
> 	    case XA_TRANSPARENCY:
423c435
< 	default:
---
> 	    default:
428c440,441
< const char * see_qcode(unsigned char id) {
---
> const char * see_qcode(unsigned char id)
> {
431,456c444,470
< 	switch (id) {
< 	case QR_CHARSETS:
< 		return "CharacterSets";
< 	case QR_IMP_PART:
< 		return "ImplicitPartition";
< 	case QR_SUMMARY:
< 		return "Summary";
< 	case QR_USABLE_AREA:
< 		return "UsableArea";
< 	case QR_COLOR:
< 		return "Color";
< 	case QR_HIGHLIGHTING:
< 		return "Highlighting";
< 	case QR_REPLY_MODES:
< 		return "ReplyModes";
< 	case QR_DBCS_ASIA:
< 		return "DbcsAsia";
< 	case QR_ALPHA_PART:
< 		return "AlphanumericPartitions";
< 	case QR_DDM:
< 		return "DistributedDataManagement";
< 	case QR_RPQNAMES:
< 		return "RPQNames";
< 	default:
< 		(void) sprintf(buf, "unknown[0x%x]", id);
< 		return buf;
---
> 	switch (id)
> 	{
> 	    case QR_CHARSETS:
> 			return "CharacterSets";
> 	    case QR_IMP_PART:
> 			return "ImplicitPartition";
> 	    case QR_SUMMARY:
> 			return "Summary";
> 	    case QR_USABLE_AREA:
> 			return "UsableArea";
> 	    case QR_COLOR:
> 			return "Color";
> 	    case QR_HIGHLIGHTING:
> 			return "Highlighting";
> 	    case QR_REPLY_MODES:
> 			return "ReplyModes";
> 	    case QR_DBCS_ASIA:
> 			return "DbcsAsia";
> 	    case QR_ALPHA_PART:
> 			return "AlphanumericPartitions";
> 	    case QR_DDM:
> 			return "DistributedDataManagement";
> 	    case QR_RPQNAMES:
> 			return "RPQNames";
> 	    default:
> 			(void) sprintf(buf, "unknown[0x%x]", id);
> 			return buf;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/session.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/session.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob o nome G3270.
6,9c6
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
11,14c8,21
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como session.c e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
29c31
< #include <stdlib.h>
---
> 	#include <stdlib.h>
49c51
< static H3270 *default_session = NULL;
---
>  static H3270 *default_session = NULL;
61c63,64
< void lib3270_session_free(H3270 *h) {
---
> void lib3270_session_free(H3270 *h)
> {
67,72c70,71
< 	if(lib3270_is_connected(h)) {
< 		// Connected, disconnect
< 		lib3270_disconnect(h);
< 	} else if(lib3270_get_connection_state(h) == LIB3270_CONNECTING) {
< 		// Connecting, disconnect
< 		debug("%s: Stopping while connecting",__FUNCTION__);
---
> 	// Terminate session
> 	if(lib3270_is_connected(h))
75,81d73
< 	}
< 
< 	// Do we have pending tasks?
< 	if(h->tasks) {
< 		lib3270_write_log(h,LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),"Destroying session with %u active task(s)",h->tasks);
< 	}
< 
85c77,78
< 	if(h->network.module) {
---
> 	if(h->network.module)
> 	{
91c84
< 	for(f=0; f<LIB3270_STATE_USER; f++)
---
> 	for(f=0;f<LIB3270_STATE_USER;f++)
95c88
< 	for(f=0; f<LIB3270_TOGGLE_COUNT; f++)
---
> 	for(f=0;f<LIB3270_TOGGLE_COUNT;f++)
99c92
< 	for(f=0; f<LIB3270_ACTION_GROUP_CUSTOM; f++)
---
> 	for(f=0;f<LIB3270_ACTION_GROUP_CUSTOM;f++)
103c96,97
< 	if(h->lu.names) {
---
>     if(h->lu.names)
> 	{
118c112,113
< 	for(f=0; f<(sizeof(h->buffer)/sizeof(h->buffer[0])); f++) {
---
> 	for(f=0;f<(sizeof(h->buffer)/sizeof(h->buffer[0]));f++)
> 	{
148,150c143
< 	// Release logfile
< 	release_pointer(h->log.file);
< 	release_pointer(h->trace.file);
---
> 	trace("Releasing session %p",h);
155c148,149
< static void nop_void() {
---
> static void update_char(H3270 GNUC_UNUSED(*session), int GNUC_UNUSED(addr), unsigned char GNUC_UNUSED(chr), unsigned short GNUC_UNUSED(attr), unsigned char GNUC_UNUSED(cursor))
> {
158,159c152,153
< static int default_action(H3270 GNUC_UNUSED(*hSession), const char GNUC_UNUSED(*name)) {
< 	return errno = ENOENT;
---
> static void nop_char(H3270 GNUC_UNUSED(*session), unsigned char GNUC_UNUSED(chr))
> {
162c156,185
< static int print(H3270 *session, LIB3270_CONTENT_OPTION GNUC_UNUSED(mode)) {
---
> static void nop(H3270 GNUC_UNUSED(*session))
> {
> }
> 
> static void update_model(H3270 GNUC_UNUSED(*session), const char GNUC_UNUSED(*name), int GNUC_UNUSED(model), int GNUC_UNUSED(rows), int GNUC_UNUSED(cols))
> {
> }
> 
> static void changed(H3270 GNUC_UNUSED(*session), int GNUC_UNUSED(bstart), int GNUC_UNUSED(bend))
> {
> }
> 
> static void update_cursor(H3270 GNUC_UNUSED(*session), unsigned short GNUC_UNUSED(row), unsigned short GNUC_UNUSED(col), unsigned char GNUC_UNUSED(c), unsigned short GNUC_UNUSED(attr))
> {
> }
> 
> static void update_oia(H3270 GNUC_UNUSED(*session), LIB3270_FLAG GNUC_UNUSED(id), unsigned char GNUC_UNUSED(on))
> {
> }
> 
> static void update_selection(H3270 GNUC_UNUSED(*session), int GNUC_UNUSED(start), int GNUC_UNUSED(end))
> {
> }
> 
> static void set_cursor(H3270 GNUC_UNUSED(*session), LIB3270_POINTER GNUC_UNUSED(id))
> {
> }
> 
> static int print(H3270 *session, LIB3270_CONTENT_OPTION GNUC_UNUSED(mode))
> {
168c191,192
< static int save(H3270 *session, LIB3270_CONTENT_OPTION GNUC_UNUSED(mode), const char GNUC_UNUSED(*filename)) {
---
> static int save(H3270 *session, LIB3270_CONTENT_OPTION GNUC_UNUSED(mode), const char GNUC_UNUSED(*filename))
> {
174c198,199
< static int load(H3270 *session, const char GNUC_UNUSED(*filename)) {
---
> static int load(H3270 *session, const char GNUC_UNUSED(*filename))
> {
180c205,242
< static void screen_disp(H3270 *session) {
---
> /*
> static void def_message(H3270 *session, LIB3270_NOTIFY GNUC_UNUSED(id), const char *title, const char *msg, const char *text)
> {
> #ifdef ANDROID
> 	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, "%s\n",title);
> 	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, "%s\n",msg);
> 	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, "%s\n",text);
> #else
> 	lib3270_write_log(session,"lib3270","%s",title);
> 	lib3270_write_log(session,"lib3270","%s",msg);
> 	lib3270_write_log(session,"lib3270","%s",text);
> #endif // ANDROID
> }
> */
> 
> /*
> static void def_popup(H3270 *hSession, LIB3270_NOTIFY type, const char *title, const char *msg, const char *fmt, va_list args)
> {
> 	lib3270_popup_va(hSession,type,title,msg,fmt,args);
> }
> */
> 
> static void def_trace(H3270 GNUC_UNUSED(*session), void GNUC_UNUSED(*userdata), const char *fmt, va_list args)
> {
> 	vfprintf(stdout,fmt,args);
> 	fflush(stdout);
> }
> 
> static void update_ssl(H3270 GNUC_UNUSED(*session), LIB3270_SSL_STATE GNUC_UNUSED(state))
> {
> }
> 
> static void set_timer(H3270 GNUC_UNUSED(*session), unsigned char GNUC_UNUSED(on))
> {
> }
> 
> static void screen_disp(H3270 *session)
> {
185c247,265
< void lib3270_reset_callbacks(H3270 *hSession) {
---
> static void nop_int(H3270 GNUC_UNUSED(*session), int GNUC_UNUSED(width))
> {
> 	return;
> }
> 
> static void default_update_luname(H3270 GNUC_UNUSED(*session), const char GNUC_UNUSED(*name))
> {
> }
> 
> static void default_update_url(H3270 GNUC_UNUSED(*session), const char GNUC_UNUSED(*url))
> {
> }
> 
> static int default_action(H3270 GNUC_UNUSED(*hSession), const char GNUC_UNUSED(*name)) {
> 	return ENOENT;
> }
> 
> void lib3270_reset_callbacks(H3270 *hSession)
> {
189,197c269,274
< 	#pragma GCC diagnostic push
< 	#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
< 
< 	hSession->cbk.update 				= nop_void;
< 	hSession->cbk.update_model			= nop_void;
< 	hSession->cbk.update_cursor			= nop_void;
< 	hSession->cbk.set_selection 		= nop_void;
< 	hSession->cbk.ctlr_done				= nop_void;
< 	hSession->cbk.changed				= nop_void;
---
> 	hSession->cbk.update 				= update_char;
> 	hSession->cbk.update_model			= update_model;
> 	hSession->cbk.update_cursor			= update_cursor;
> 	hSession->cbk.set_selection 		= nop_char;
> 	hSession->cbk.ctlr_done				= nop;
> 	hSession->cbk.changed				= changed;
199c276
< 	hSession->cbk.suspend				= nop_void;
---
> 	hSession->cbk.suspend				= nop;
201,204c278,281
< 	hSession->cbk.update_oia			= nop_void;
< 	hSession->cbk.update_selection		= nop_void;
< 	hSession->cbk.cursor 				= nop_void;
< 	hSession->cbk.update_ssl			= nop_void;
---
> 	hSession->cbk.update_oia			= update_oia;
> 	hSession->cbk.update_selection		= update_selection;
> 	hSession->cbk.cursor 				= set_cursor;
> 	hSession->cbk.update_ssl			= update_ssl;
206,209c283,286
< 	hSession->cbk.set_width				= nop_void;
< 	hSession->cbk.update_status			= nop_void;
< 	hSession->cbk.autostart				= nop_void;
< 	hSession->cbk.set_timer				= nop_void;
---
> 	hSession->cbk.set_width				= nop_int;
> 	hSession->cbk.update_status			= (void (*)(H3270 *, LIB3270_MESSAGE)) nop_int;
> 	hSession->cbk.autostart				= nop;
> 	hSession->cbk.set_timer				= set_timer;
213,214c290,291
< 	hSession->cbk.update_luname			= nop_void;
< 	hSession->cbk.update_url			= nop_void;
---
> 	hSession->cbk.update_luname			= default_update_luname;
> 	hSession->cbk.update_url			= default_update_url;
216,219d292
< 	hSession->cbk.reconnect				= lib3270_reconnect;
< 	hSession->cbk.word_selected			= nop_void;
< 
< 	#pragma GCC diagnostic pop
222,223d294
< 	lib3270_set_log_handler(hSession,NULL,NULL);
< 	lib3270_set_trace_handler(hSession,NULL,NULL);
227c298,299
< static void lib3270_session_init(H3270 *hSession, const char *model, const char *charset) {
---
> static void lib3270_session_init(H3270 *hSession, const char *model, const char *charset)
> {
239a312,314
> 	// Trace management.
> 	hSession->trace.handler			= def_trace;
> 
250d324
< 	hSession->connection.retry		= 5000;
275c349
< 	for(f=0; f<4; f++)
---
> 	for(f=0;f<4;f++)
284,292c358,366
< 		                 HKEY_LOCAL_MACHINE,
< 		                 "Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME) "\\protocol",
< 		                 0,
< 		                 NULL,
< 		                 REG_OPTION_NON_VOLATILE,
< 		                 KEY_QUERY_VALUE|KEY_READ,
< 		                 NULL,
< 		                 &hKey,
< 		                 &disp);
---
> 						HKEY_LOCAL_MACHINE,
> 						"Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME) "\\protocol",
> 						0,
> 						NULL,
> 						REG_OPTION_NON_VOLATILE,
> 						KEY_QUERY_VALUE|KEY_READ,
> 						NULL,
> 						&hKey,
> 						&disp);
294c368,369
< 		if(rc == ERROR_SUCCESS) {
---
> 		if(rc == ERROR_SUCCESS)
> 		{
298c373,374
< 			for(property = 0; uiProps[property].name; property++) {
---
> 			for(property = 0; uiProps[property].name;property++)
> 			{
306c382,383
< 				if(dwRet == ERROR_SUCCESS) {
---
> 				if(dwRet == ERROR_SUCCESS)
> 				{
309c386,388
< 				} else {
---
> 				}
> 				else
> 				{
326c405,423
< H3270 * lib3270_session_new(const char *model) {
---
> LIB3270_EXPORT void lib3270_set_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER handler, void *userdata)
> {
> 	CHECK_SESSION_HANDLE(hSession);
> 
> 	hSession->trace.handler		= handler ? handler : def_trace;
> 	hSession->trace.userdata	= userdata;
> }
> 
> LIB3270_EXPORT void lib3270_get_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER *handler, void **userdata)
> {
> 	CHECK_SESSION_HANDLE(hSession);
> 
> 	*handler	= hSession->trace.handler;
> 	*userdata	= hSession->trace.userdata;
> 
> }
> 
> H3270 * lib3270_session_new(const char *model)
> {
371c468
< //	*hSession = lib3270_get_default_session_handle();
---
> 	*hSession = lib3270_get_default_session_handle();
373,374c470,473
< #if defined(DEBUG)
< 	lib3270_write_log(NULL, "lib3270", "%s called with empty session from %s",__FUNCTION__,fname);
---
> #if defined(ANDROID)
> 	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, "%s called with empty session\n", __FUNCTION__);
> #elif defined(DEBUG)
> 	lib3270_write_log(*hSession, "lib3270", "%s called with empty session from %s",__FUNCTION__,fname);
376c475
< 	lib3270_write_log(NULL, "lib3270", "%s called with empty session",__FUNCTION__);
---
> 	lib3270_write_log(*hSession, "lib3270", "%s called with empty session",__FUNCTION__);
406c505,506
< LIB3270_EXPORT H3270 * lib3270_get_default_session_handle(void) {
---
> LIB3270_EXPORT H3270 * lib3270_get_default_session_handle(void)
> {
413c513,514
< LIB3270_EXPORT void lib3270_set_user_data(H3270 *h, void *ptr) {
---
> LIB3270_EXPORT void lib3270_set_user_data(H3270 *h, void *ptr)
> {
418c519,520
< LIB3270_EXPORT void * lib3270_get_user_data(H3270 *h) {
---
> LIB3270_EXPORT void * lib3270_get_user_data(H3270 *h)
> {
423c525,526
< LIB3270_EXPORT void lib3270_set_session_id(H3270 *hSession, char id) {
---
> LIB3270_EXPORT void lib3270_set_session_id(H3270 *hSession, char id)
> {
428c531,532
< LIB3270_EXPORT char lib3270_get_session_id(H3270 *hSession) {
---
> LIB3270_EXPORT char lib3270_get_session_id(H3270 *hSession)
> {
433,437c537,541
< struct lib3270_session_callbacks * lib3270_get_session_callbacks(H3270 *hSession, const char *revision, unsigned short sz) {
< 
< 	#define REQUIRED_REVISION "20211118"
< 
< 	if(revision && strcasecmp(revision,REQUIRED_REVISION) < 0) {
---
> struct lib3270_session_callbacks * lib3270_get_session_callbacks(H3270 *hSession, const char *revision, unsigned short sz)
> {
> 	if(revision && strcasecmp(revision,"20200803") < 0)
> 	{
> 		debug("%s: Revision test was %d",__FUNCTION__,strcasecmp(revision,"20200803"));
439d542
< 		lib3270_write_log(hSession,PACKAGE_NAME,"Invalid revision %s when setting callback table",revision);
443,445c546,547
< 	if(sz != sizeof(struct lib3270_session_callbacks)) {
< 
< 		lib3270_write_log(hSession,PACKAGE_NAME,"Invalid callback table (sz=%u expected=%u)",sz,(unsigned int) sizeof(struct lib3270_session_callbacks));
---
> 	if(sz != sizeof(struct lib3270_session_callbacks))
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/sf.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/sf.c
40d39
< #include <lib3270/filetransfer.h>
45c44
< #include <netinet/in.h>
---
> 	#include <netinet/in.h>
54c53
< #include "ft_dftc.h"
---
> 	#include "ft_dftc.h"
121,127c120,126
< 	{ QR_SUMMARY,      do_qr_summary,      NULL },		/* 0x80 */
< 	{ QR_USABLE_AREA,  do_qr_usable_area,  NULL },		/* 0x81 */
< 	{ QR_ALPHA_PART,   do_qr_alpha_part,   NULL },		/* 0x84 */
< 	{ QR_CHARSETS,     do_qr_charsets,     NULL },		/* 0x85 */
< 	{ QR_COLOR,        do_qr_color,        NULL },		/* 0x86 */
< 	{ QR_HIGHLIGHTING, do_qr_highlighting, NULL },		/* 0x87 */
< 	{ QR_REPLY_MODES,  do_qr_reply_modes,  NULL },		/* 0x88 */
---
>     { QR_SUMMARY,      do_qr_summary,      NULL },		/* 0x80 */
>     { QR_USABLE_AREA,  do_qr_usable_area,  NULL },		/* 0x81 */
>     { QR_ALPHA_PART,   do_qr_alpha_part,   NULL },		/* 0x84 */
>     { QR_CHARSETS,     do_qr_charsets,     NULL },		/* 0x85 */
>     { QR_COLOR,        do_qr_color,        NULL },		/* 0x86 */
>     { QR_HIGHLIGHTING, do_qr_highlighting, NULL },		/* 0x87 */
>     { QR_REPLY_MODES,  do_qr_reply_modes,  NULL },		/* 0x88 */
129c128
< 	{ QR_DBCS_ASIA,    do_qr_dbcs_asia,    NULL },		/* 0x91 */
---
>     { QR_DBCS_ASIA,    do_qr_dbcs_asia,    NULL },		/* 0x91 */
133c132
< 	{ QR_DDM,          do_qr_ddm,          NULL },		/* 0x95 */
---
>     { QR_DDM,          do_qr_ddm,          NULL },		/* 0x95 */
137c136
< 	{ QR_RPQNAMES,     do_qr_rpqnames,     NULL },		/* 0xa1 */
---
>     { QR_RPQNAMES,     do_qr_rpqnames,     NULL },		/* 0xa1 */
140c139
< 	{ QR_IMP_PART,     do_qr_imp_part,     NULL },		/* 0xa6 */
---
>     { QR_IMP_PART,     do_qr_imp_part,     NULL },		/* 0xa6 */
142,143c141,142
< 	/* QR_NULL must be last in the table */
< 	{ QR_NULL,         do_qr_null,         NULL },		/* 0xff */
---
>     /* QR_NULL must be last in the table */
>     { QR_NULL,         do_qr_null,         NULL },		/* 0xff */
156c155,156
< enum pds write_structured_field(H3270 *hSession, unsigned char buf[], int buflen) {
---
> enum pds write_structured_field(H3270 *hSession, unsigned char buf[], int buflen)
> {
169c169,170
< 	while (buflen > 0) {
---
> 	while (buflen > 0)
> 	{
178c179,180
< 		if (buflen < 2) {
---
> 		if (buflen < 2)
> 		{
185c187,188
< 		if (fieldlen < 3) {
---
> 		if (fieldlen < 3)
> 		{
189c192,193
< 		if ((int)fieldlen > buflen) {
---
> 		if ((int)fieldlen > buflen)
> 		{
195,196c199,201
< 		switch (cp[2]) {
< 		case SF_READ_PART:
---
> 		switch (cp[2])
> 		{
> 	    case SF_READ_PART:
201c206
< 		case SF_ERASE_RESET:
---
> 	    case SF_ERASE_RESET:
206c211
< 		case SF_SET_REPLY_MODE:
---
> 	    case SF_SET_REPLY_MODE:
211c216
< 		case SF_CREATE_PART:
---
> 	    case SF_CREATE_PART:
216c221
< 		case SF_OUTBOUND_DS:
---
> 	    case SF_OUTBOUND_DS:
222c227
< 		case SF_TRANSFER_DATA:   /* File transfer data         */
---
> 	    case SF_TRANSFER_DATA:   /* File transfer data         */
228c233
< 		default:
---
> 	    default:
259c264,265
< static enum pds sf_read_part(H3270 *hSession, unsigned char buf[], unsigned buflen) {
---
> static enum pds sf_read_part(H3270 *hSession, unsigned char buf[], unsigned buflen)
> {
265c271,272
< 	if (buflen < 5) {
---
> 	if (buflen < 5)
> 	{
274c281
< 	case SF_RP_QUERY:
---
> 	    case SF_RP_QUERY:
288c295
< 		query_reply_end(hSession);
---
>  		query_reply_end(hSession);
290c297
< 	case SF_RP_QLIST:
---
> 	    case SF_RP_QLIST:
302c309
< 		case SF_RPQ_LIST:
---
> 		    case SF_RPQ_LIST:
315,316c322,323
< 					           (char)replies[i].code,
< 					           buflen-6)
---
> 						   (char)replies[i].code,
> 						   buflen-6)
318,319c325,326
< 					        && (dbcs ||
< 					            replies[i].code != QR_DBCS_ASIA)
---
> 						   && (dbcs ||
> 						       replies[i].code != QR_DBCS_ASIA)
321c328
< 					   ) {
---
> 						   ) {
331c338
< 		case SF_RPQ_EQUIV:
---
> 		    case SF_RPQ_EQUIV:
344c351
< 		case SF_RPQ_ALL:
---
> 		    case SF_RPQ_ALL:
352c359
< 		default:
---
> 		    default:
358c365
< 	case SNA_CMD_RMA:
---
> 	    case SNA_CMD_RMA:
367c374
< 	case SNA_CMD_RB:
---
> 	    case SNA_CMD_RB:
376c383
< 	case SNA_CMD_RM:
---
> 	    case SNA_CMD_RM:
385c392
< 	default:
---
> 	    default:
392,393c399,402
< static enum pds sf_erase_reset(H3270 *hSession, unsigned char buf[], int buflen) {
< 	if (buflen != 4) {
---
> static enum pds sf_erase_reset(H3270 *hSession, unsigned char buf[], int buflen)
> {
> 	if (buflen != 4)
> 	{
398c407,408
< 	switch (buf[3]) {
---
> 	switch (buf[3])
> 	{
416c426,427
< static enum pds sf_set_reply_mode(H3270 *hSession, unsigned char buf[], int buflen) {
---
> static enum pds sf_set_reply_mode(H3270 *hSession, unsigned char buf[], int buflen)
> {
421c432,433
< 	if (buflen < 5) {
---
> 	if (buflen < 5)
> 	{
428c440,441
< 	if (partition != 0x00) {
---
> 	if (partition != 0x00)
> 	{
433,434c446,448
< 	switch (buf[4]) {
< 	case SF_SRM_FIELD:
---
> 	switch (buf[4])
> 	{
>     case SF_SRM_FIELD:
438c452
< 	case SF_SRM_XFIELD:
---
>     case SF_SRM_XFIELD:
442c456
< 	case SF_SRM_CHAR:
---
>     case SF_SRM_CHAR:
446c460
< 	default:
---
>     default:
453c467,468
< 	if (buf[4] == SF_SRM_CHAR) {
---
> 	if (buf[4] == SF_SRM_CHAR)
> 	{
455c470,471
< 		for (i = 5; i < buflen; i++) {
---
> 		for (i = 5; i < buflen; i++)
> 		{
465c481,482
< static enum pds sf_create_partition(H3270 *hSession, unsigned char buf[], int buflen) {
---
> static enum pds sf_create_partition(H3270 *hSession, unsigned char buf[], int buflen)
> {
484,488c501,506
< 	static const char *bit4[16] = {
< 		"0000", "0001", "0010", "0011",
< 		"0100", "0101", "0110", "0111",
< 		"1000", "1001", "1010", "1011",
< 		"1100", "1101", "1110", "1111"
---
> 	static const char *bit4[16] =
> 	{
> 	    "0000", "0001", "0010", "0011",
> 	    "0100", "0101", "0110", "0111",
> 	    "1000", "1001", "1010", "1011",
> 	    "1100", "1101", "1110", "1111"
492c510,511
< 	if (buflen > 3) {
---
> 	if (buflen > 3)
> 	{
498c517,518
< 		if (pid != 0x00) {
---
> 		if (pid != 0x00)
> 		{
502c522,523
< 	} else
---
> 	}
> 	else
505c526,527
< 	if (buflen > 4) {
---
> 	if (buflen > 4)
> 	{
514c536,537
< 		if (am > 0x2) {
---
> 		if (am > 0x2)
> 		{
518c541,543
< 	} else {
---
> 	}
> 	else
> 	{
523c548,549
< 	if (buflen > 5) {
---
> 	if (buflen > 5)
> 	{
529c555,556
< 	if (buflen > 7) {
---
> 	if (buflen > 7)
> 	{
535c562,563
< 	if (buflen > 9) {
---
> 	if (buflen > 9)
> 	{
541c569,570
< 	if (buflen > 11) {
---
> 	if (buflen > 11)
> 	{
547c576,577
< 	if (buflen > 13) {
---
> 	if (buflen > 13)
> 	{
559c589,590
< 	if (buflen > 17) {
---
> 	if (buflen > 17)
> 	{
565c596,597
< 	if (buflen > 19) {
---
> 	if (buflen > 19)
> 	{
571c603,604
< 	if (buflen > 21) {
---
> 	if (buflen > 21)
> 	{
603c636,637
< static enum pds sf_outbound_ds(H3270 *hSession, unsigned char buf[], int buflen) {
---
> static enum pds sf_outbound_ds(H3270 *hSession, unsigned char buf[], int buflen)
> {
606c640,641
< 	if (buflen < 5) {
---
> 	if (buflen < 5)
> 	{
612c647,648
< 	if (buf[3] != 0x00) {
---
> 	if (buf[3] != 0x00)
> 	{
617c653,654
< 	switch (buf[4]) {
---
> 	switch (buf[4])
> 	{
620c657,658
< 		if (buflen > 5) {
---
> 		if (buflen > 5)
> 		{
630c668,669
< 		if (buflen > 5) {
---
> 		if (buflen > 5)
> 		{
634c673
< 			trace_ds(hSession,"\n");
---
> 		trace_ds(hSession,"\n");
640c679,680
< 		if (buflen > 5) {
---
> 		if (buflen > 5)
> 		{
659c699,700
< static void query_reply_start(H3270 *hSession) {
---
> static void query_reply_start(H3270 *hSession)
> {
666c707,708
< static void do_query_reply(H3270 *hSession, unsigned char code) {
---
> static void do_query_reply(H3270 *hSession, unsigned char code)
> {
677c719
< 	        (replies[i].single_fn == NULL && replies[i].multi_fn == NULL))
---
> 	    (replies[i].single_fn == NULL && replies[i].multi_fn == NULL))
680c722,723
< 	if (qr_in_progress) {
---
> 	if (qr_in_progress)
> 	{
685c728,729
< 	do {
---
> 	do
> 	{
700c744,745
< 		if (full) {
---
> 		if (full)
> 		{
710c755,756
< 			if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_DS_TRACE)) {
---
> 			if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_DS_TRACE))
> 			{
712,715c758,761
< 				    hSession,
< 				    see_qcode(replies[i].code),
< 				    hSession->output.buf + obptr0,
< 				    len
---
> 					hSession,
> 					see_qcode(replies[i].code),
> 					hSession->output.buf + obptr0,
> 					len
727c773,774
< static void do_qr_null(H3270 *hSession) {
---
> static void do_qr_null(H3270 *hSession)
> {
731c778,779
< static void do_qr_summary(H3270 *hSession) {
---
> static void do_qr_summary(H3270 *hSession)
> {
737c785,786
< 	for (i = 0; i < NSR; i++) {
---
> 	for (i = 0; i < NSR; i++)
> 	{
739c788,789
< 		if (dbcs || replies[i].code != QR_DBCS_ASIA) {
---
> 		if (dbcs || replies[i].code != QR_DBCS_ASIA)
> 		{
751c801,802
< static void do_qr_usable_area(H3270 *hSession) {
---
> static void do_qr_usable_area(H3270 *hSession)
> {
775c826,827
< static void do_qr_color(H3270 *hSession) {
---
> static void do_qr_color(H3270 *hSession)
> {
788c840,841
< 	for (i = 0xf1; i < 0xf1 + color_max - 1; i++) {
---
> 	for (i = 0xf1; i < 0xf1 + color_max - 1; i++)
> 	{
796,807c849,860
< 	/*
< 	#if !defined(X3270_DISPLAY)
< 		// Add background color.
< 		if (hSession->m3279) {
< 			space3270out(4);
< 			*hSession->output.ptr++ = 4;		// length
< 			*hSession->output.ptr++ = 0x02;	// background color
< 			*hSession->output.ptr++ = 0x00;	// attribute
< 			*hSession->output.ptr++ = 0xf0;	// default color
< 		}
< 	#endif
< 	*/
---
> /*
> #if !defined(X3270_DISPLAY)
> 	// Add background color.
> 	if (hSession->m3279) {
> 		space3270out(4);
> 		*hSession->output.ptr++ = 4;		// length
> 		*hSession->output.ptr++ = 0x02;	// background color
> 		*hSession->output.ptr++ = 0x00;	// attribute
> 		*hSession->output.ptr++ = 0xf0;	// default color
> 	}
> #endif
> */
810c863,864
< static void do_qr_highlighting(H3270 *hSession) {
---
> static void do_qr_highlighting(H3270 *hSession)
> {
826c880,881
< static void do_qr_reply_modes(H3270 *hSession) {
---
> static void do_qr_reply_modes(H3270 *hSession)
> {
835c890,891
< static void do_qr_dbcs_asia(H3270 *hSession) {
---
> static void do_qr_dbcs_asia(H3270 *hSession)
> {
849c905,906
< static void do_qr_alpha_part(H3270 *hSession) {
---
> static void do_qr_alpha_part(H3270 *hSession)
> {
857c914,915
< static void do_qr_charsets(H3270 *hSession) {
---
> static void do_qr_charsets(H3270 *hSession)
> {
901c959,960
< 	if (!*standard_font) {
---
> 	if (!*standard_font)
> 	{
905c964
< 			*hSession->output.ptr++ = 0x00;/*  FLAGS: non-loadable, single-plane, single-byte, no compare */
---
> 		    *hSession->output.ptr++ = 0x00;/*  FLAGS: non-loadable, single-plane, single-byte, no compare */
907c966
< 			*hSession->output.ptr++ = 0x10;/*  FLAGS: non-loadable, single-plane, single-byte, no compare */
---
> 		    *hSession->output.ptr++ = 0x10;/*  FLAGS: non-loadable, single-plane, single-byte, no compare */
910c969,970
< 		if (dbcs) {
---
> 		if (dbcs)
> 		{
923c983,984
< 	if (dbcs) {
---
> 	if (dbcs)
> 	{
937,938c998,1000
< static void do_qr_ddm(H3270 *hSession) {
< 	lib3270_set_dft_buffersize(hSession,hSession->dft_buffersize);
---
> static void do_qr_ddm(H3270 *hSession)
> {
> 	set_dft_buffersize(hSession);
949c1011,1012
< static void do_qr_imp_part(H3270 *hSession) {
---
> static void do_qr_imp_part(H3270 *hSession)
> {
963c1026,1027
< static void query_reply_end(H3270 *hSession) {
---
> static void query_reply_end(H3270 *hSession)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/state.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/state.c
34c34,35
< LIB3270_EXPORT LIB3270_CSTATE lib3270_get_connection_state(const H3270 *h) {
---
> LIB3270_EXPORT LIB3270_CSTATE lib3270_get_connection_state(const H3270 *h)
> {
38c39,40
< LIB3270_EXPORT int lib3270_pconnected(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_pconnected(const H3270 *h)
> {
42c44,45
< LIB3270_EXPORT int lib3270_half_connected(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_half_connected(const H3270 *h)
> {
46c49,50
< LIB3270_EXPORT int lib3270_is_disconnected(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_is_disconnected(const H3270 *h)
> {
50c54,55
< LIB3270_EXPORT int lib3270_in_neither(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_neither(const H3270 *h)
> {
54c59,60
< LIB3270_EXPORT int lib3270_in_ansi(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_ansi(const H3270 *h)
> {
58c64,65
< LIB3270_EXPORT int lib3270_in_3270(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_3270(const H3270 *h)
> {
62c69,70
< LIB3270_EXPORT int lib3270_in_sscp(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_sscp(const H3270 *h)
> {
66c74,75
< LIB3270_EXPORT int lib3270_in_tn3270e(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_tn3270e(const H3270 *h)
> {
70c79,80
< LIB3270_EXPORT int lib3270_is_connected(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_is_connected(const H3270 *h)
> {
74c84,85
< LIB3270_EXPORT int lib3270_in_e(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_in_e(const H3270 *h)
> {
78c89,90
< LIB3270_EXPORT int lib3270_is_unlocked(const H3270 *h) {
---
> LIB3270_EXPORT int lib3270_is_unlocked(const H3270 *h)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/telnet.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/telnet.c
32c32
< #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
---
>  #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
40,41c40,41
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
45c45
< #include <sys/time.h>
---
> 	#include <sys/time.h>
49c49
< #include <stdlib.h>
---
> 	#include <stdlib.h>
58c58
< #include <ws2tcpip.h>
---
> 	#include <ws2tcpip.h>
60,62c60,62
< #include <sys/socket.h>
< #include <sys/ioctl.h>
< #include <netinet/in.h>
---
> 	#include <sys/socket.h>
> 	#include <sys/ioctl.h>
> 	#include <netinet/in.h>
70c70
< #include <arpa/inet.h>
---
> 	#include <arpa/inet.h>
77c77
< #include <lib3270/win32.h>
---
> 	#include <lib3270/win32.h>
79c79
< #include <netdb.h>
---
> 	#include <netdb.h>
95,96c95,96
< // #include "proxyc.h"
< //#include "resolverc.h"
---
> #include "proxyc.h"
> #include "resolverc.h"
124c124
< #define E_OPT(n)	(1 << (n))
---
> 	#define E_OPT(n)	(1 << (n))
126a127,139
> /*
> #if defined(X3270_ANSI)
> static char     vintr;
> static char     vquit;
> static char     verase;
> static char     vkill;
> static char     veof;
> static char     vwerase;
> static char     vrprnt;
> static char     vlnext;
> #endif
> */
> 
206,208c219,220
<                                       "INV-ASSOCIATE", "INV-NAME", "INV-DEVICE-TYPE", "TYPE-NAME-ERROR",
<                                       "UNKNOWN-ERROR", "UNSUPPORTED-REQ"
<                                     };
---
> 	"INV-ASSOCIATE", "INV-NAME", "INV-DEVICE-TYPE", "TYPE-NAME-ERROR",
> 	"UNKNOWN-ERROR", "UNSUPPORTED-REQ" };
213,214c225
<                                         "RESPONSES", "SCS-CTL-CODES", "SYSREQ"
<                                       };
---
> 	"RESPONSES", "SCS-CTL-CODES", "SYSREQ" };
219,221c230,231
<                                     "BIND-IMAGE", "UNBIND", "NVT-DATA", "REQUEST", "SSCP-LU-DATA",
<                                     "PRINT-EOJ"
<                                   };
---
> 	"BIND-IMAGE", "UNBIND", "NVT-DATA", "REQUEST", "SSCP-LU-DATA",
> 	"PRINT-EOJ" };
229,230c239
<                                     "ALWAYS-RESPONSE"
<                                   };
---
> 	"ALWAYS-RESPONSE" };
244,251c253,260
< #define socket_errno()	WSAGetLastError()
< #define SE_EWOULDBLOCK	WSAEWOULDBLOCK
< #define SE_ECONNRESET	WSAECONNRESET
< #define SE_EINTR	WSAEINTR
< #define SE_EAGAIN	WSAEINPROGRESS
< #define SE_EPIPE	WSAECONNABORTED
< #define SE_EINPROGRESS	WSAEINPROGRESS
< #define SOCK_IOCTL(s, f, v)	ioctlsocket(s, f, (void *)v)
---
> 	#define socket_errno()	WSAGetLastError()
> 	#define SE_EWOULDBLOCK	WSAEWOULDBLOCK
> 	#define SE_ECONNRESET	WSAECONNRESET
> 	#define SE_EINTR	WSAEINTR
> 	#define SE_EAGAIN	WSAEINPROGRESS
> 	#define SE_EPIPE	WSAECONNABORTED
> 	#define SE_EINPROGRESS	WSAEINPROGRESS
> 	#define SOCK_IOCTL(s, f, v)	ioctlsocket(s, f, (void *)v)
253,262c262,271
< #define socket_errno()	errno
< #define SE_EWOULDBLOCK	EWOULDBLOCK
< #define SE_ECONNRESET	ECONNRESET
< #define SE_EINTR	EINTR
< #define SE_EAGAIN	EAGAIN
< #define SE_EPIPE	EPIPE
< 
< #if defined(EINPROGRESS) /*[*/
< #define SE_EINPROGRESS	EINPROGRESS
< #endif /*]*/
---
> 	#define socket_errno()	errno
> 	#define SE_EWOULDBLOCK	EWOULDBLOCK
> 	#define SE_ECONNRESET	ECONNRESET
> 	#define SE_EINTR	EINTR
> 	#define SE_EAGAIN	EAGAIN
> 	#define SE_EPIPE	EPIPE
> 
> 	#if defined(EINPROGRESS) /*[*/
> 		#define SE_EINPROGRESS	EINPROGRESS
> 	#endif /*]*/
264c273
< #define SOCK_IOCTL	ioctl
---
> 	#define SOCK_IOCTL	ioctl
279c288,289
< void popup_a_sockerr(H3270 *hSession, char *fmt, ...) {
---
> void popup_a_sockerr(H3270 *hSession, char *fmt, ...)
> {
294,298c304,308
< 	    hSession,
< 	    "3270",
< 	    "Network error:\n%s\n%s",
< 	    text,
< 	    msg
---
> 			hSession,
> 			"3270",
> 			"Network error:\n%s\n%s",
> 			text,
> 			msg
302,307c312,317
< 	    hSession,
< 	    LIB3270_NOTIFY_ERROR,
< 	    _( "Network error" ),
< 	    text,
< 	    "%s",
< 	    msg
---
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Network error" ),
> 			text,
> 			"%s",
> 			msg
315c325,326
< static void setup_lus(H3270 *hSession) {
---
> static void setup_lus(H3270 *hSession)
> {
319c330,331
< 	if(hSession->lu.names) {
---
> 	if(hSession->lu.names)
> 	{
322c334,336
< 	} else {
---
> 	}
> 	else
> 	{
380c394,395
< static int net_connected(H3270 *hSession) {
---
> static int net_connected(H3270 *hSession)
> {
385c400,401
< 	if(hSession->ssl.host && hSession->ssl.state == LIB3270_SSL_UNDEFINED) {
---
> 	if(hSession->ssl.host && hSession->ssl.state == LIB3270_SSL_UNDEFINED)
> 	{
404c420,421
< LIB3270_EXPORT void lib3270_setup_session(H3270 *hSession) {
---
> LIB3270_EXPORT void lib3270_setup_session(H3270 *hSession)
> {
455,456c472,475
< static void connection_complete(H3270 *session) {
< 	if (non_blocking(session,False) < 0) {
---
> static void connection_complete(H3270 *session)
> {
> 	if (non_blocking(session,False) < 0)
> 	{
465,466c484,487
< void net_disconnect(H3270 *hSession) {
< 	if(hSession->xio.write) {
---
> void net_disconnect(H3270 *hSession)
> {
> 	if(hSession->xio.write)
> 	{
481c502,503
< LIB3270_EXPORT void lib3270_data_recv(H3270 *hSession, size_t nr, const unsigned char *netrbuf) {
---
> LIB3270_EXPORT void lib3270_data_recv(H3270 *hSession, size_t nr, const unsigned char *netrbuf)
> {
489,490c511,514
< 	for (cp = netrbuf; cp < (netrbuf + nr); cp++) {
< 		if(telnet_fsm(hSession,*cp)) {
---
> 	for (cp = netrbuf; cp < (netrbuf + nr); cp++)
> 	{
> 		if(telnet_fsm(hSession,*cp))
> 		{
498c522,523
< 	if (IN_ANSI) {
---
> 	if (IN_ANSI)
> 	{
502c527,528
< 	if (hSession->ansi_data) {
---
> 	if (hSession->ansi_data)
> 	{
519c545,546
< void net_input(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno)) {
---
> void net_input(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno))
> {
529c556
< 	for (;;)
---
>  	for (;;)
539,544c566,571
< 		/*
< 				if (hSession->ssl.con != NULL)
< 					nr = SSL_read(hSession->ssl.con, (char *) buffer, BUFSZ);
< 				else
< 					nr = hSession->network.module->recv(hSession, buffer, BUFSZ);
< 		*/
---
> /*
> 		if (hSession->ssl.con != NULL)
> 			nr = SSL_read(hSession->ssl.con, (char *) buffer, BUFSZ);
> 		else
> 			nr = hSession->network.module->recv(hSession, buffer, BUFSZ);
> */
550,551c577,580
< 		if (nr < 0) {
< 			if (nr == -EWOULDBLOCK) {
---
> 		if (nr < 0)
> 		{
> 			if (nr == -EWOULDBLOCK)
> 			{
555c584,585
< 			if(HALF_CONNECTED && nr == -EAGAIN) {
---
> 			if(HALF_CONNECTED && nr == -EAGAIN)
> 			{
565c595,597
< 		} else if (nr == 0) {
---
> 		}
> 		else if (nr == 0)
> 		{
573c605,606
< 		if (HALF_CONNECTED) {
---
> 		if (HALF_CONNECTED)
> 		{
575c608,609
< 			if (non_blocking(hSession,False) < 0) {
---
> 			if (non_blocking(hSession,False) < 0)
> 			{
612c646,647
< static void send_naws(H3270 *hSession) {
---
> static void send_naws(H3270 *hSession)
> {
629c664,665
< static void next_lu(H3270 *hSession) {
---
> static void next_lu(H3270 *hSession)
> {
639c675,676
< static int telnet_fsm(H3270 *hSession, unsigned char c) {
---
> static int telnet_fsm(H3270 *hSession, unsigned char c)
> {
645,646c682,684
< 	switch (hSession->telnet_state) {
< 	case TNS_DATA:	/* normal data processing */
---
> 	switch (hSession->telnet_state)
> 	{
> 	    case TNS_DATA:	/* normal data processing */
680c718,719
< 			if (!hSession->syncing) {
---
> 			if (!hSession->syncing)
> 			{
690,691c729,731
< 	case TNS_IAC:	/* process a telnet command */
< 		if (c != EOR && c != IAC) {
---
> 	    case TNS_IAC:	/* process a telnet command */
> 		if (c != EOR && c != IAC)
> 		{
695,697c735,739
< 		switch (c) {
< 		case IAC:	/* escaped IAC, insert it */
< 			if (IN_ANSI && !IN_E) {
---
> 		switch (c)
> 		{
> 	    case IAC:	/* escaped IAC, insert it */
> 			if (IN_ANSI && !IN_E)
> 			{
699c741,742
< 				if (!hSession->ansi_data) {
---
> 				if (!hSession->ansi_data)
> 				{
705c748,749
< 				if (hSession->ansi_data >= TRACELINE) {
---
> 				if (hSession->ansi_data >= TRACELINE)
> 				{
712c756,758
< 			} else {
---
> 			}
> 			else
> 			{
718c764
< 		case EOR:	/* eor, process accumulated input */
---
> 	    case EOR:	/* eor, process accumulated input */
720c766,767
< 			if (IN_3270 || (IN_E && hSession->tn3270e_negotiated)) {
---
> 			if (IN_3270 || (IN_E && hSession->tn3270e_negotiated))
> 			{
724c771,773
< 			} else {
---
> 			}
> 			else
> 			{
726,729c775,778
< 				    hSession,
< 				    LIB3270_NOTIFY_WARNING,_("Warning"),
< 				    _( "EOR received when not in 3270 mode, ignored." ),
< 				    NULL
---
> 					hSession,
> 					LIB3270_NOTIFY_WARNING,_("Warning"),
> 					_( "EOR received when not in 3270 mode, ignored." ),
> 					NULL
737c786
< 		case WILL:
---
> 	    case WILL:
741c790
< 		case WONT:
---
> 	    case WONT:
745c794
< 		case DO:
---
> 	    case DO:
749c798
< 		case DONT:
---
> 	    case DONT:
753c802
< 		case SB:
---
> 	    case SB:
760c809
< 		case DM:
---
> 	    case DM:
762c811,812
< 			if (hSession->syncing) {
---
> 			if (hSession->syncing)
> 			{
769,770c819,820
< 		case GA:
< 		case NOP:
---
> 	    case GA:
> 	    case NOP:
775c825
< 		default:
---
> 	    default:
781c831
< 	case TNS_WILL:	/* telnet WILL DO OPTION command */
---
> 	    case TNS_WILL:	/* telnet WILL DO OPTION command */
784,788c834,838
< 		case TELOPT_SGA:
< 		case TELOPT_BINARY:
< 		case TELOPT_EOR:
< 		case TELOPT_TTYPE:
< 		case TELOPT_ECHO:
---
> 		    case TELOPT_SGA:
> 		    case TELOPT_BINARY:
> 		    case TELOPT_EOR:
> 		    case TELOPT_TTYPE:
> 		    case TELOPT_ECHO:
790c840
< 		case TELOPT_TN3270E:
---
> 		    case TELOPT_TN3270E:
798c848
< 					          cmd(DO), opt(c));
---
> 						cmd(DO), opt(c));
817c867
< 		default:
---
> 		    default:
825c875
< 	case TNS_WONT:	/* telnet WONT DO OPTION command */
---
> 	    case TNS_WONT:	/* telnet WONT DO OPTION command */
827c877,878
< 		if (hSession->hisopts[c]) {
---
> 		if (hSession->hisopts[c])
> 		{
838c889
< 	case TNS_DO:	/* telnet PLEASE DO OPTION command */
---
> 	    case TNS_DO:	/* telnet PLEASE DO OPTION command */
841,846c892,897
< 		case TELOPT_BINARY:
< 		case TELOPT_EOR:
< 		case TELOPT_TTYPE:
< 		case TELOPT_SGA:
< 		case TELOPT_NAWS:
< 		case TELOPT_TM:
---
> 		    case TELOPT_BINARY:
> 		    case TELOPT_EOR:
> 		    case TELOPT_TTYPE:
> 		    case TELOPT_SGA:
> 		    case TELOPT_NAWS:
> 		    case TELOPT_TM:
848c899
< 		case TELOPT_TN3270E:
---
> 		    case TELOPT_TN3270E:
850,882c901,934
< 		case TELOPT_STARTTLS:
< 			if (c == TELOPT_TN3270E && hSession->non_tn3270e_host)
< 				goto wont;
< 			if (c == TELOPT_TM && !hSession->bsd_tm)
< 				goto wont;
< 
< 			trace("hSession->myopts[c]=%d",hSession->myopts[c]);
< 			if (!hSession->myopts[c]) {
< 				if (c != TELOPT_TM)
< 					hSession->myopts[c] = 1;
< 				will_opt[2] = c;
< 				net_rawout(hSession, will_opt, sizeof(will_opt));
< 				trace_dsn(hSession,"SENT %s %s\n", cmd(WILL), opt(c));
< 				check_in3270(hSession);
< 				check_linemode(hSession,False);
< 			}
< 			if (c == TELOPT_NAWS)
< 				send_naws(hSession);
< 			if (c == TELOPT_STARTTLS) {
< 				static unsigned char follows_msg[] = {
< 					IAC, SB, TELOPT_STARTTLS,
< 					TLS_FOLLOWS, IAC, SE
< 				};
< 
< 				//
< 				// Send IAC SB STARTTLS FOLLOWS IAC SE
< 				// to announce that what follows is TLS.
< 				//
< 				net_rawout(hSession, follows_msg, sizeof(follows_msg));
< 				trace_dsn(hSession,"SENT %s %s FOLLOWS %s\n",
< 				          cmd(SB),
< 				          opt(TELOPT_STARTTLS),
< 				          cmd(SE));
---
> 		    case TELOPT_STARTTLS:
> 				if (c == TELOPT_TN3270E && hSession->non_tn3270e_host)
> 					goto wont;
> 				if (c == TELOPT_TM && !hSession->bsd_tm)
> 					goto wont;
> 
> 				trace("hSession->myopts[c]=%d",hSession->myopts[c]);
> 				if (!hSession->myopts[c])
> 				{
> 					if (c != TELOPT_TM)
> 						hSession->myopts[c] = 1;
> 					will_opt[2] = c;
> 					net_rawout(hSession, will_opt, sizeof(will_opt));
> 					trace_dsn(hSession,"SENT %s %s\n", cmd(WILL), opt(c));
> 					check_in3270(hSession);
> 					check_linemode(hSession,False);
> 				}
> 				if (c == TELOPT_NAWS)
> 					send_naws(hSession);
> 				if (c == TELOPT_STARTTLS) {
> 					static unsigned char follows_msg[] = {
> 						IAC, SB, TELOPT_STARTTLS,
> 						TLS_FOLLOWS, IAC, SE
> 					};
> 
> 					//
> 					// Send IAC SB STARTTLS FOLLOWS IAC SE
> 					// to announce that what follows is TLS.
> 					//
> 					net_rawout(hSession, follows_msg, sizeof(follows_msg));
> 					trace_dsn(hSession,"SENT %s %s FOLLOWS %s\n",
> 							cmd(SB),
> 							opt(TELOPT_STARTTLS),
> 							cmd(SE));
884,887c936,939
< 				debug("%s: %s requires TLS/SSL",__FUNCTION__,opt(TELOPT_STARTTLS));
< 				hSession->need_tls_follows = 1;
< 			}
< 			break;
---
> 					debug("%s: %s requires TLS/SSL",__FUNCTION__,opt(TELOPT_STARTTLS));
> 					hSession->need_tls_follows = 1;
> 				}
> 				break;
889,894c941,946
< 		default:
< wont:
< 			wont_opt[2] = c;
< 			net_rawout(hSession, wont_opt, sizeof(wont_opt));
< 			trace_dsn(hSession,"SENT %s %s\n", cmd(WONT), opt(c));
< 			break;
---
> 		    default:
> 				wont:
> 				wont_opt[2] = c;
> 				net_rawout(hSession, wont_opt, sizeof(wont_opt));
> 				trace_dsn(hSession,"SENT %s %s\n", cmd(WONT), opt(c));
> 				break;
898c950
< 	case TNS_DONT:	/* telnet PLEASE DON'T DO OPTION command */
---
> 	    case TNS_DONT:	/* telnet PLEASE DON'T DO OPTION command */
910c962
< 	case TNS_SB:	// telnet sub-option string command
---
> 	    case TNS_SB:	// telnet sub-option string command
916c968
< 	case TNS_SB_IAC:	// telnet sub-option string command
---
> 	    case TNS_SB_IAC:	// telnet sub-option string command
920c972,973
< 			if (hSession->sbbuf[0] == TELOPT_TTYPE && hSession->sbbuf[1] == TELQUAL_SEND) {
---
> 			if (hSession->sbbuf[0] == TELOPT_TTYPE && hSession->sbbuf[1] == TELQUAL_SEND)
> 			{
926c979,980
< 				if (hSession->lu.names != (char **)NULL && hSession->lu.try == CN) {
---
> 				if (hSession->lu.names != (char **)NULL && hSession->lu.try == CN)
> 				{
933c987,988
< 				if (hSession->lu.try != CN && *hSession->lu.try) {
---
> 				if (hSession->lu.try != CN && *hSession->lu.try)
> 				{
936c991,993
< 				} else {
---
> 				}
> 				else
> 				{
945,949c1002,1006
< 				               IAC, SB, TELOPT_TTYPE, TELQUAL_IS,
< 				               hSession->termtype,
< 				               (hSession->lu.try != CN && *hSession->lu.try) ? "@" : "",
< 				               (hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : "",
< 				               IAC, SE);
---
> 				    IAC, SB, TELOPT_TTYPE, TELQUAL_IS,
> 				    hSession->termtype,
> 				    (hSession->lu.try != CN && *hSession->lu.try) ? "@" : "",
> 				    (hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : "",
> 				    IAC, SE);
953,956c1010,1013
< 				      hSession->termtype,
< 				      (hSession->lu.try != CN && *hSession->lu.try) ? "@" : "",
< 				      (hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : ""
< 				     );
---
> 				    hSession->termtype,
> 				    (hSession->lu.try != CN && *hSession->lu.try) ? "@" : "",
> 				    (hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : ""
> 				);
959,962c1016,1019
< 				          cmd(SB), opt(TELOPT_TTYPE),
< 				          telquals[TELQUAL_IS],
< 				          tt_len, tt_out + 4,
< 				          cmd(SE));
---
> 				    cmd(SB), opt(TELOPT_TTYPE),
> 				    telquals[TELQUAL_IS],
> 				    tt_len, tt_out + 4,
> 				    cmd(SE));
969c1026,1027
< 			else if (hSession->myopts[TELOPT_TN3270E] && hSession->sbbuf[0] == TELOPT_TN3270E) {
---
> 			else if (hSession->myopts[TELOPT_TN3270E] && hSession->sbbuf[0] == TELOPT_TN3270E)
> 			{
974c1032,1033
< 			else if (hSession->need_tls_follows && hSession->myopts[TELOPT_STARTTLS] && hSession->sbbuf[0] == TELOPT_STARTTLS) {
---
> 			else if (hSession->need_tls_follows && hSession->myopts[TELOPT_STARTTLS] && hSession->sbbuf[0] == TELOPT_STARTTLS)
> 			{
987c1046,1047
< static void continue_tls(H3270 *hSession, unsigned char *sbbuf, int len) {
---
> static void continue_tls(H3270 *hSession, unsigned char *sbbuf, int len)
> {
992c1052,1053
< 	if (len < 2 || sbbuf[1] != TLS_FOLLOWS) {
---
> 	if (len < 2 || sbbuf[1] != TLS_FOLLOWS)
> 	{
1015c1076,1077
< static void tn3270e_request(H3270 *hSession) {
---
> static void tn3270e_request(H3270 *hSession)
> {
1028,1029c1090,1091
< 	             IAC, SB, TELOPT_TN3270E, TN3270E_OP_DEVICE_TYPE,
< 	             TN3270E_OP_REQUEST, hSession->termtype);
---
> 	    IAC, SB, TELOPT_TN3270E, TN3270E_OP_DEVICE_TYPE,
> 	    TN3270E_OP_REQUEST, hSession->termtype);
1043,1050c1105,1112
< 	    hSession,"SENT %s %s DEVICE-TYPE REQUEST %.*s%s%s %s\n",
< 	    cmd(SB),
< 	    opt(TELOPT_TN3270E),
< 	    (int) strlen(hSession->termtype),
< 	    tt_out + 5,
< 	    (hSession->lu.try != CN && *hSession->lu.try) ? " CONNECT " : "",
< 	    (hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : "",
< 	    cmd(SE)
---
> 		hSession,"SENT %s %s DEVICE-TYPE REQUEST %.*s%s%s %s\n",
> 			cmd(SB),
> 			opt(TELOPT_TN3270E),
> 			(int) strlen(hSession->termtype),
> 			tt_out + 5,
> 			(hSession->lu.try != CN && *hSession->lu.try) ? " CONNECT " : "",
> 			(hSession->lu.try != CN && *hSession->lu.try) ? hSession->lu.try : "",
> 			cmd(SE)
1059c1121,1122
< static void backoff_tn3270e(H3270 *hSession, const char *why) {
---
> static void backoff_tn3270e(H3270 *hSession, const char *why)
> {
1079c1142,1143
< static int tn3270e_negotiate(H3270 *hSession) {
---
> static int tn3270e_negotiate(H3270 *hSession)
> {
1124c1188
< 			        hSession->sbbuf[3+tnlen] != TN3270E_OP_CONNECT)
---
> 			       hSession->sbbuf[3+tnlen] != TN3270E_OP_CONNECT)
1132,1133c1196,1197
< 			          tnlen, &hSession->sbbuf[3],
< 			          snlen, &hSession->sbbuf[3+tnlen+1]);
---
> 				tnlen, &hSession->sbbuf[3],
> 				snlen, &hSession->sbbuf[3+tnlen+1]);
1162c1226
< 			        hSession->sbbuf[4] == TN3270E_REASON_UNSUPPORTED_REQ) {
---
> 			    hSession->sbbuf[4] == TN3270E_REASON_UNSUPPORTED_REQ) {
1168c1232,1233
< 			if (hSession->lu.try != CN) {
---
> 			if (hSession->lu.try != CN)
> 			{
1171c1236,1238
< 			} else if (hSession->lu.names != (char **)NULL) {
---
> 			}
> 			else if (hSession->lu.names != (char **)NULL)
> 			{
1174c1241,1243
< 			} else {
---
> 			}
> 			else
> 			{
1259c1328,1329
< tn3270e_function_names(const unsigned char *buf, int len) {
---
> tn3270e_function_names(const unsigned char *buf, int len)
> {
1268c1338
< 		             fnn(buf[i]));
---
> 		    fnn(buf[i]));
1275c1345,1346
< static void tn3270e_subneg_send(H3270 *hSession, unsigned char op, unsigned long funcs) {
---
> static void tn3270e_subneg_send(H3270 *hSession, unsigned char op, unsigned long funcs)
> {
1296,1299c1367,1370
< 	          cmd(SB), opt(TELOPT_TN3270E),
< 	          (op == TN3270E_OP_REQUEST)? "REQUEST": "IS",
< 	          tn3270e_function_names(proto_buf + 5, proto_len - 7),
< 	          cmd(SE));
---
> 	    cmd(SB), opt(TELOPT_TN3270E),
> 	    (op == TN3270E_OP_REQUEST)? "REQUEST": "IS",
> 	    tn3270e_function_names(proto_buf + 5, proto_len - 7),
> 	    cmd(SE));
1304c1375,1376
< tn3270e_fdecode(const unsigned char *buf, int len) {
---
> tn3270e_fdecode(const unsigned char *buf, int len)
> {
1318c1390,1391
< static void process_bind(H3270 *hSession, unsigned char *buf, int buflen) {
---
> static void process_bind(H3270 *hSession, unsigned char *buf, int buflen)
> {
1342c1415,1416
< static int process_eor(H3270 *hSession) {
---
> static int process_eor(H3270 *hSession)
> {
1356,1359c1430,1433
< 		          e_dt(h->data_type),
< 		          e_rq(h->data_type, h->request_flag),
< 		          e_rsp(h->data_type, h->response_flag),
< 		          h->seq_number[0] << 8 | h->seq_number[1]);
---
> 		    e_dt(h->data_type),
> 		    e_rq(h->data_type, h->request_flag),
> 		    e_rsp(h->data_type, h->response_flag),
> 		    h->seq_number[0] << 8 | h->seq_number[1]);
1364c1438
< 			        !hSession->tn3270e_bound)
---
> 			    !hSession->tn3270e_bound)
1371c1445
< 			        hSession->response_required != TN3270E_RSF_NO_RESPONSE)
---
> 			    hSession->response_required != TN3270E_RSF_NO_RESPONSE)
1374c1448
< 			         hSession->response_required == TN3270E_RSF_ALWAYS_RESPONSE)
---
> 			    hSession->response_required == TN3270E_RSF_ALWAYS_RESPONSE)
1422c1496,1497
< void net_exception(H3270 *session, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno)) {
---
> void net_exception(H3270 *session, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno))
> {
1426c1501,1502
< 	if (!session->syncing) {
---
> 	if (!session->syncing)
> 	{
1429c1505,1506
< 		if(session->xio.except) {
---
> 		if(session->xio.except)
> 		{
1452c1529,1530
< LIB3270_INTERNAL int lib3270_sock_send(H3270 *hSession, unsigned const char *buf, int len) {
---
> LIB3270_INTERNAL int lib3270_sock_send(H3270 *hSession, unsigned const char *buf, int len)
> {
1475c1553,1554
< static void net_rawout(H3270 *hSession, unsigned const char *buf, size_t len) {
---
> static void net_rawout(H3270 *hSession, unsigned const char *buf, size_t len)
> {
1478c1557,1558
< 	while (len) {
---
> 	while (len)
> 	{
1481,1482c1561,1563
< 		if (nw > 0) {
< 			// Data sent
---
> 		if (nw > 0)
> 		{
> 			// Data received
1486c1567,1569
< 		} else if(nw < 0) {
---
> 		}
> 		else if(nw < 0)
> 		{
1515c1598,1599
< static void net_cookout(H3270 *hSession, const char *buf, int len) {
---
> static void net_cookout(H3270 *hSession, const char *buf, int len)
> {
1580c1664,1665
< static void ansi_process_s(H3270 *hSession, const char *data) {
---
> static void ansi_process_s(H3270 *hSession, const char *data)
> {
1585c1670,1671
< static void forward_data(H3270 *hSession) {
---
> static void forward_data(H3270 *hSession)
> {
1590,1591c1676,1679
< static void do_data(H3270 *hSession, char c) {
< 	if (hSession->lbptr+1 < hSession->lbuf + BUFSZ) {
---
> static void do_data(H3270 *hSession, char c)
> {
> 	if (hSession->lbptr+1 < hSession->lbuf + BUFSZ)
> 	{
1599c1687,1688
< 	} else
---
> 	}
> 	else
1606,1607c1695,1698
< static void do_intr(H3270 *hSession, char c) {
< 	if (hSession->lnext) {
---
> static void do_intr(H3270 *hSession, char c)
> {
> 	if (hSession->lnext)
> 	{
1616,1617c1707,1710
< static void do_quit(H3270 *hSession, char c) {
< 	if (hSession->lnext) {
---
> static void do_quit(H3270 *hSession, char c)
> {
> 	if (hSession->lnext)
> 	{
1626c1719,1720
< static void do_cerase(H3270 *hSession, char c) {
---
> static void do_cerase(H3270 *hSession, char c)
> {
1629c1723,1724
< 	if (hSession->backslashed) {
---
> 	if (hSession->backslashed)
> 	{
1636c1731,1732
< 	if (hSession->lnext) {
---
> 	if (hSession->lnext)
> 	{
1641c1737,1738
< 	if (hSession->lbptr > hSession->lbuf) {
---
> 	if (hSession->lbptr > hSession->lbuf)
> 	{
1649c1746,1747
< static void do_werase(H3270 *hSession, char c) {
---
> static void do_werase(H3270 *hSession, char c)
> {
1653c1751,1752
< 	if (hSession->lnext) {
---
> 	if (hSession->lnext)
> 	{
1677c1776,1777
< static void do_kill(H3270 *hSession, char c) {
---
> static void do_kill(H3270 *hSession, char c)
> {
1680c1780,1781
< 	if (hSession->backslashed) {
---
> 	if (hSession->backslashed)
> 	{
1687c1788,1789
< 	if (hSession->lnext) {
---
> 	if (hSession->lnext)
> 	{
1692c1794,1795
< 	while (hSession->lbptr > hSession->lbuf) {
---
> 	while (hSession->lbptr > hSession->lbuf)
> 	{
1700c1803,1804
< static void do_rprnt(H3270 *hSession, char c) {
---
> static void do_rprnt(H3270 *hSession, char c)
> {
1703c1807,1808
< 	if (hSession->lnext) {
---
> 	if (hSession->lnext)
> 	{
1714,1715c1819,1822
< static void do_eof(H3270 *hSession, char c) {
< 	if (hSession->backslashed) {
---
> static void do_eof(H3270 *hSession, char c)
> {
> 	if (hSession->backslashed)
> 	{
1722c1829,1830
< 	if (hSession->lnext) {
---
> 	if (hSession->lnext)
> 	{
1731,1732c1839,1842
< static void do_eol(H3270 *hSession, char c) {
< 	if (hSession->lnext) {
---
> static void do_eol(H3270 *hSession, char c)
> {
> 	if (hSession->lnext)
> 	{
1737c1847,1848
< 	if (hSession->lbptr+2 >= hSession->lbuf + BUFSZ) {
---
> 	if (hSession->lbptr+2 >= hSession->lbuf + BUFSZ)
> 	{
1748,1749c1859,1862
< static void do_lnext(H3270 *hSession, char c) {
< 	if (hSession->lnext) {
---
> static void do_lnext(H3270 *hSession, char c)
> {
> 	if (hSession->lnext)
> 	{
1759,1760c1872,1875
< const char * lib3270_connection_state_get_name(const LIB3270_CSTATE cstate) {
< 	static const char *state_names[] = {
---
> const char * lib3270_connection_state_get_name(const LIB3270_CSTATE cstate)
> {
> 	static const char *state_names[] =
> 	{
1779,1780c1894,1897
< LIB3270_EXPORT const char * lib3270_state_get_name(const LIB3270_STATE state) {
< 	static const char *state_names[] = {
---
> LIB3270_EXPORT const char * lib3270_state_get_name(const LIB3270_STATE state)
> {
> 	static const char *state_names[] =
> 	{
1807c1924,1925
< static void check_in3270(H3270 *hSession) {
---
> static void check_in3270(H3270 *hSession)
> {
1816,1828c1934,1946
< 			case E_NONE:
< 				new_cstate = LIB3270_CONNECTED_INITIAL_E;
< 				break;
< 			case E_NVT:
< 				new_cstate = LIB3270_CONNECTED_NVT;
< 				break;
< 			case E_3270:
< 				new_cstate = LIB3270_CONNECTED_TN3270E;
< 				break;
< 			case E_SSCP:
< 				new_cstate = LIB3270_CONNECTED_SSCP;
< 				break;
< 			}
---
> 		case E_NONE:
> 			new_cstate = LIB3270_CONNECTED_INITIAL_E;
> 			break;
> 		case E_NVT:
> 			new_cstate = LIB3270_CONNECTED_NVT;
> 			break;
> 		case E_3270:
> 			new_cstate = LIB3270_CONNECTED_TN3270E;
> 			break;
> 		case E_SSCP:
> 			new_cstate = LIB3270_CONNECTED_SSCP;
> 			break;
> 		}
1831,1842c1949,1960
< 		if (hSession->myopts[TELOPT_BINARY] &&
< 		        hSession->myopts[TELOPT_EOR] &&
< 		        hSession->myopts[TELOPT_TTYPE] &&
< 		        hSession->hisopts[TELOPT_BINARY] &&
< 		        hSession->hisopts[TELOPT_EOR]) {
< 			new_cstate = LIB3270_CONNECTED_3270;
< 		} else if (hSession->connection.state == LIB3270_CONNECTED_INITIAL) {
< 			/* Nothing has happened, yet. */
< 			return;
< 		} else {
< 			new_cstate = LIB3270_CONNECTED_ANSI;
< 		}
---
> 	if (hSession->myopts[TELOPT_BINARY] &&
> 	           hSession->myopts[TELOPT_EOR] &&
> 	           hSession->myopts[TELOPT_TTYPE] &&
> 	           hSession->hisopts[TELOPT_BINARY] &&
> 	           hSession->hisopts[TELOPT_EOR]) {
> 		new_cstate = LIB3270_CONNECTED_3270;
> 	} else if (hSession->connection.state == LIB3270_CONNECTED_INITIAL) {
> 		/* Nothing has happened, yet. */
> 		return;
> 	} else {
> 		new_cstate = LIB3270_CONNECTED_ANSI;
> 	}
1862c1980,1981
< 		if(new_cstate >= LIB3270_CONNECTED_INITIAL && !(hSession->ibuf_size && hSession->ibuf)) {
---
> 		if(new_cstate >= LIB3270_CONNECTED_INITIAL && !(hSession->ibuf_size && hSession->ibuf))
> 		{
1871c1990
< 		        new_cstate == LIB3270_CONNECTED_NVT)
---
> 		    new_cstate == LIB3270_CONNECTED_NVT)
1893,1894c2012,2015
< static void store3270in(H3270 *hSession, unsigned char c) {
< 	if(hSession->ibptr - hSession->ibuf >= hSession->ibuf_size) {
---
> static void store3270in(H3270 *hSession, unsigned char c)
> {
> 	if(hSession->ibptr - hSession->ibuf >= hSession->ibuf_size)
> 	{
1911c2032,2033
< void space3270out(H3270 *hSession, int n) {
---
> void space3270out(H3270 *hSession, int n)
> {
1918c2040,2041
< 	while ((nc + n + EH_SIZE) > (hSession->output.length + more)) {
---
> 	while ((nc + n + EH_SIZE) > (hSession->output.length + more))
> 	{
1922c2045,2046
< 	if (more) {
---
> 	if (more)
> 	{
1935c2059,2060
< static void check_linemode(H3270 *hSession, Boolean init) {
---
> static void check_linemode(H3270 *hSession, Boolean init)
> {
1954c2079,2080
< 	if (init || hSession->linemode != wasline) {
---
> 	if (init || hSession->linemode != wasline)
> 	{
1956c2082,2083
< 		if (!init) {
---
> 		if (!init)
> 		{
1965a2093
> 
1968,1970c2096,2100
< ///
< /// @brief Expands a number to a character string, for displaying unknown telnet commands and options.
< ///
---
> /*
>  * nnn
>  *	Expands a number to a character string, for displaying unknown telnet
>  *	commands and options.
>  */
1972c2102,2103
< nnn(int c) {
---
> nnn(int c)
> {
1974,1975c2105,2106
< 	memset(buf,0,sizeof(buf));
< 	(void) snprintf(buf, 63, "%d", c);
---
> 
> 	(void) sprintf(buf, "%d", c);
1979,1982c2110,2115
< ///
< /// @brief Expands a TELNET command into a character string.
< ///
< static const char * cmd(int c) {
---
> /*
>  * cmd
>  *	Expands a TELNET command into a character string.
>  */
> static const char * cmd(int c)
> {
1989,1993c2122,2130
< ///
< /// @brief Expands a TELNET option into a character string.
< ///
< static const char * opt(unsigned char c) {
< 	if (c == TELOPT_TN3270E)
---
> /***
>  *
>  * @brief Expands a TELNET option into a character string.
>  */
> static const char * opt(unsigned char c)
> {
> 	if (TELOPT_OK(c))
> 		return TELOPT(c);
> 	else if (c == TELOPT_TN3270E)
1994a2132
> #if defined(HAVE_LIBSSL) /*[*/
1997,1998c2135
< 	else if (TELOPT_OK(c))
< 		return TELOPT(c);
---
> #endif /*]*/
2005,2006c2142,2144
< void trace_netdata(H3270 *hSession, char direction, unsigned const char *buf, int len) {
< #define NETDUMP_MAX 121
---
> void trace_netdata(H3270 *hSession, char direction, unsigned const char *buf, int len)
> {
> 	#define NETDUMP_MAX 121
2008c2146,2147
< 	if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_NETWORK_TRACE)) {
---
> 	if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_NETWORK_TRACE))
> 	{
2030c2169,2170
< 		for (offset = 0; offset < len; offset++) {
---
> 		for (offset = 0; offset < len; offset++)
> 		{
2040c2180,2181
< 			if(++col >= NETDUMP_MAX) {
---
> 			if(++col >= NETDUMP_MAX)
> 			{
2047c2188,2189
< 		if(col) {
---
> 		if(col)
> 		{
2052c2194,2196
< 	} else if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_DS_TRACE)) {
---
> 	}
> 	else if (lib3270_get_toggle(hSession,LIB3270_TOGGLE_DS_TRACE))
> 	{
2059c2203,2204
< 		if (IN_3270) {
---
> 		if (IN_3270)
> 		{
2061c2206
< 			         (double)(ts.tv_usec - hSession->ds_ts.tv_usec)) / 1.0e6;
---
> 				(double)(ts.tv_usec - hSession->ds_ts.tv_usec)) / 1.0e6;
2066c2211,2212
< 		for (offset = 0; offset < len; offset++) {
---
> 		for (offset = 0; offset < len; offset++)
> 		{
2089c2235,2236
< void net_output(H3270 *hSession) {
---
> void net_output(H3270 *hSession)
> {
2096c2243
< #define BSTART	((IN_TN3270E || IN_SSCP) ? hSession->output.base : hSession->output.buf)
---
> 	#define BSTART	((IN_TN3270E || IN_SSCP) ? hSession->output.base : hSession->output.buf)
2098c2245
< #define BSTART	obuf
---
> 	#define BSTART	obuf
2103c2250,2251
< 	if (IN_TN3270E || IN_SSCP) {
---
> 	if (IN_TN3270E || IN_SSCP)
> 	{
2107c2255,2256
< 		if (hSession->response_required == TN3270E_RSF_ALWAYS_RESPONSE) {
---
> 		if (hSession->response_required == TN3270E_RSF_ALWAYS_RESPONSE)
> 		{
2126c2275,2276
< 	while (xobuf_len <  (hSession->output.ptr - BSTART + 1) * 2) {
---
> 	while (xobuf_len <  (hSession->output.ptr - BSTART + 1) * 2)
> 	{
2131c2281,2282
< 	if (need_resize) {
---
> 	if (need_resize)
> 	{
2138,2139c2289,2292
< 	while (nxoptr < hSession->output.ptr) {
< 		if ((*xoptr++ = *nxoptr++) == IAC) {
---
> 	while (nxoptr < hSession->output.ptr)
> 	{
> 		if ((*xoptr++ = *nxoptr++) == IAC)
> 		{
2156c2309,2310
< static void tn3270e_ack(H3270 *hSession) {
---
> static void tn3270e_ack(H3270 *hSession)
> {
2183c2337,2338
< static void tn3270e_nak(H3270 *hSession, enum pds rv) {
---
> static void tn3270e_nak(H3270 *hSession, enum pds rv)
> {
2221c2376,2377
< net_add_eor(unsigned char *buf, int len) {
---
> net_add_eor(unsigned char *buf, int len)
> {
2237,2238c2393,2396
< net_sendc(H3270 *hSession, char c) {
< 	if (c == '\r' && !hSession->linemode) {
---
> net_sendc(H3270 *hSession, char c)
> {
> 	if (c == '\r' && !hSession->linemode)
> 	{
2241c2399,2401
< 	} else {
---
> 	}
> 	else
> 	{
2252c2412,2413
< void net_sends(H3270 *hSession,const char *s) {
---
> void net_sends(H3270 *hSession,const char *s)
> {
2260c2421,2422
< void net_send_erase(H3270 *hSession) {
---
> void net_send_erase(H3270 *hSession)
> {
2267c2429,2430
< void net_send_kill(H3270 *hSession) {
---
> void net_send_kill(H3270 *hSession)
> {
2274c2437,2438
< void net_send_werase(H3270 *hSession) {
---
> void net_send_werase(H3270 *hSession)
> {
2309c2473,2474
< void net_break(H3270 *hSession) {
---
> void net_break(H3270 *hSession)
> {
2322c2487,2488
< void net_interrupt(H3270 *hSession) {
---
> void net_interrupt(H3270 *hSession)
> {
2336c2502,2503
< void net_abort(H3270 *hSession) {
---
> void net_abort(H3270 *hSession)
> {
2339c2506,2507
< 	if (hSession->e_funcs & E_OPT(TN3270E_FUNC_SYSREQ)) {
---
> 	if (hSession->e_funcs & E_OPT(TN3270E_FUNC_SYSREQ))
> 	{
2346c2514,2515
< 		switch (hSession->tn3270e_submode) {
---
> 		switch (hSession->tn3270e_submode)
> 		{
2354c2523,2524
< 			if (hSession->tn3270e_bound || !(hSession->e_funcs & E_OPT(TN3270E_FUNC_BIND_IMAGE))) {
---
> 			if (hSession->tn3270e_bound || !(hSession->e_funcs & E_OPT(TN3270E_FUNC_BIND_IMAGE)))
> 			{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/getset.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/getset.c
67c67,68
< 	for(node = session->listeners.toggle[ix].first; node; node = node->next) {
---
> 	for(node = session->listeners.toggle[ix].first; node; node = node->next)
> 	{
69a71,77
> 
> 	/*
> 	for(st = session->listeners.toggle.callbacks[ix]; st != (struct lib3270_toggle_callback *) NULL; st = (struct lib3270_toggle_callback *) st->next)
> 	{
> 		st->func(session, ix, t->value, st->data);
> 	}
> 	*/
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/init.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/init.c
40,42c40,42
< #include <winsock2.h>
< #include <windows.h>
< #include <ws2tcpip.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
> 	#include <ws2tcpip.h>
44c44
< #include <sys/socket.h>
---
> 	#include <sys/socket.h>
62c62,63
< static void toggle_altscreen(H3270 *session, const struct lib3270_toggle *t, LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt)) {
---
> static void toggle_altscreen(H3270 *session, const struct lib3270_toggle *t, LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt))
> {
67c68,69
< static void toggle_redraw(H3270 *session, const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt)) {
---
> static void toggle_redraw(H3270 *session, const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt))
> {
74c76,77
< static void toggle_nop(H3270 GNUC_UNUSED(*session), const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt)) {
---
> static void toggle_nop(H3270 GNUC_UNUSED(*session), const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt))
> {
77,78c80,83
< static void toggle_keepalive(H3270 *hSession, const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt)) {
< 	if(hSession->network.module->is_connected(hSession)) {
---
> static void toggle_keepalive(H3270 *hSession, const struct lib3270_toggle GNUC_UNUSED(*t), LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt))
> {
> 	if(hSession->network.module->is_connected(hSession))
> 	{
82c87,88
< 		if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
---
> 		if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0)
> 		{
84c90,92
< 		} else {
---
> 		}
> 		else
> 		{
91,93c99,103
< static void toggle_connect(H3270 *hSession, const struct lib3270_toggle *toggle, LIB3270_TOGGLE_TYPE tt) {
< 	if(tt != LIB3270_TOGGLE_TYPE_INITIAL && lib3270_is_disconnected(hSession) && toggle->value) {
< 		if(hSession->cbk.reconnect(hSession,0))
---
> static void toggle_connect(H3270 *hSession, const struct lib3270_toggle *toggle, LIB3270_TOGGLE_TYPE tt)
> {
> 	if(tt != LIB3270_TOGGLE_TYPE_INITIAL && lib3270_is_disconnected(hSession) && toggle->value)
> 	{
> 		if(lib3270_reconnect(hSession,0))
99,139d108
< static void toggle_ssl_trace(H3270 *hSession, const struct lib3270_toggle *toggle, LIB3270_TOGGLE_TYPE tt) {
< 
< 	if(tt != LIB3270_TOGGLE_TYPE_INITIAL && toggle->value) {
< 
< 		trace_ssl(hSession,
< 					"SSL build options:\n" \
< 					"  self signed cert check is %s" \
< 					"\n  CRL check is %s" \
< 					"\n  CRL expiration check is %s" \
< 					"\n  Notify when failed is %s\n",
< 
< #ifdef SSL_ENABLE_SELF_SIGNED_CERT_CHECK
< 					"on",
< #else
< 					"off",
< #endif
< 
< #ifdef SSL_ENABLE_CRL_CHECK
< 					"on",
< #else
< 					"off",
< #endif
< 
< #ifdef SSL_ENABLE_CRL_EXPIRATION_CHECK
< 					"on",
< #else
< 					"off",
< #endif
< 
< #ifdef SSL_ENABLE_NOTIFICATION_WHEN_FAILED
< 					"on"
< #else
< 					"off"
< #endif
< 		);
< 
< 	}
< 
< }
< 
< 
143,144c112,115
< void initialize_toggles(H3270 *session) {
< 	static const struct _upcalls {
---
> void initialize_toggles(H3270 *session)
> {
> 	static const struct _upcalls
> 	{
148c119,120
< 	upcalls[LIB3270_TOGGLE_COUNT] = {
---
> 	upcalls[LIB3270_TOGGLE_COUNT] =
> 	{
175,178d146
< 		},
< 		{
< 			LIB3270_TOGGLE_SSL_TRACE,
< 			toggle_ssl_trace
186c154,155
< 	for(f=0; f<LIB3270_TOGGLE_COUNT; f++) {
---
> 	for(f=0;f<LIB3270_TOGGLE_COUNT;f++)
> 	{
192c161
< 	for(f=0; f<(sizeof(upcalls)/sizeof(upcalls[0])); f++)
---
> 	for(f=0;f<(sizeof(upcalls)/sizeof(upcalls[0]));f++)
200,208c169,177
< 		                 HKEY_LOCAL_MACHINE,
< 		                 "Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME) "\\toggles",
< 		                 0,
< 		                 NULL,
< 		                 REG_OPTION_NON_VOLATILE,
< 		                 KEY_QUERY_VALUE|KEY_READ,
< 		                 NULL,
< 		                 &hKey,
< 		                 &disp);
---
> 						HKEY_LOCAL_MACHINE,
> 						"Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME) "\\toggles",
> 						0,
> 						NULL,
> 						REG_OPTION_NON_VOLATILE,
> 						KEY_QUERY_VALUE|KEY_READ,
> 						NULL,
> 						&hKey,
> 						&disp);
210c179,180
< 		if(rc == ERROR_SUCCESS) {
---
> 		if(rc == ERROR_SUCCESS)
> 		{
212c182,183
< 			for(f=0; f<LIB3270_TOGGLE_COUNT; f++) {
---
> 			for(f=0;f<LIB3270_TOGGLE_COUNT;f++)
> 			{
217,223c188,194
< 				                  hKey,
< 				                  lib3270_toggle_get_from_id(f)->name,
< 				                  NULL,
< 				                  NULL,
< 				                  (LPBYTE) &val,
< 				                  &cbData
< 				              );
---
> 										hKey,
> 										lib3270_toggle_get_from_id(f)->name,
> 										NULL,
> 										NULL,
> 										(LPBYTE) &val,
> 										&cbData
> 								);
226c197,198
< 				if(dwRet == ERROR_SUCCESS) {
---
> 				if(dwRet == ERROR_SUCCESS)
> 				{
238c210,211
< 	for(f=0; f<LIB3270_TOGGLE_COUNT; f++) {
---
> 	for(f=0;f<LIB3270_TOGGLE_COUNT;f++)
> 	{
248c221,222
< void shutdown_toggles(H3270 *session) {
---
> void shutdown_toggles(H3270 *session)
> {
254c228
< 	for(f=0; f< (sizeof(disable_on_shutdown)/sizeof(disable_on_shutdown[0])); f++)
---
> 	for(f=0;f< (sizeof(disable_on_shutdown)/sizeof(disable_on_shutdown[0])); f++)
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/listener.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/listener.c
47c47,48
< LIB3270_EXPORT const void * lib3270_register_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, void (*func)(H3270 *, LIB3270_TOGGLE_ID, char, void *),void *data) {
---
> LIB3270_EXPORT const void * lib3270_register_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, void (*func)(H3270 *, LIB3270_TOGGLE_ID, char, void *),void *data)
> {
56c57,58
< LIB3270_EXPORT int lib3270_unregister_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, const void *id) {
---
> LIB3270_EXPORT int lib3270_unregister_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, const void *id)
> {
71c73,74
< LIB3270_EXPORT const void * lib3270_register_schange(H3270 *hSession, LIB3270_STATE tx, void (*func)(H3270 *, int, void *),void *data) {
---
> LIB3270_EXPORT const void * lib3270_register_schange(H3270 *hSession, LIB3270_STATE tx, void (*func)(H3270 *, int, void *),void *data)
> {
79c82,83
< LIB3270_EXPORT int lib3270_unregister_schange(H3270 *hSession, LIB3270_STATE tx, const void * id) {
---
> LIB3270_EXPORT int lib3270_unregister_schange(H3270 *hSession, LIB3270_STATE tx, const void * id)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/table.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/toggles/table.c
44c44,45
< const LIB3270_TOGGLE toggle_descriptor[LIB3270_TOGGLE_COUNT+1] = {
---
> const LIB3270_TOGGLE toggle_descriptor[LIB3270_TOGGLE_COUNT+1] =
> {
89d89
< 		.nick = "ds",
120d119
< 		.nick = "sc",
131d129
< 		.nick = "ev",
179a178,187
> 		.id = LIB3270_TOGGLE_RECONNECT,
> 		.name = "autoreconnect",
> 		.def = False,
> 		.key = NULL,		// Default keycode
> 		.icon = NULL,		// Icon name
> 		.label = N_( "Auto-Reconnect" ),
> 		.summary = N_( "Auto-Reconnect" ),
> 		.description = N_( "Automatically reconnect to the host if it ever disconnects" )
> 	},
> 	{
292d299
< 		.nick = "net",
303d309
< 		.nick = "ssl",
313,323d318
< 		.id = LIB3270_TOGGLE_RECONNECT,
< 		.name = "autoreconnect",
< 		.def = False,
< 		.key = NULL,		// Default keycode
< 		.icon = NULL,		// Icon name
< 		.label = N_( "Auto-Reconnect" ),
< 		.summary = N_( "Auto-Reconnect" ),
< 		.description = N_( "Automatically reconnect to the host if it ever disconnects" )
< 	},
< 
< 	{
337c332,333
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggles() {
---
> LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggles()
> {
341c337,338
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggle_list() {
---
> LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggle_list()
> {
345c342,343
< LIB3270_EXPORT const char * lib3270_get_toggle_summary(LIB3270_TOGGLE_ID ix) {
---
> LIB3270_EXPORT const char * lib3270_get_toggle_summary(LIB3270_TOGGLE_ID ix)
> {
351c349,350
< LIB3270_EXPORT const char * lib3270_get_toggle_label(LIB3270_TOGGLE_ID ix) {
---
> LIB3270_EXPORT const char * lib3270_get_toggle_label(LIB3270_TOGGLE_ID ix)
> {
358c357,358
< LIB3270_EXPORT const char * lib3270_get_toggle_description(LIB3270_TOGGLE_ID ix) {
---
> LIB3270_EXPORT const char * lib3270_get_toggle_description(LIB3270_TOGGLE_ID ix)
> {
370,371c370,373
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_by_name(const char *name) {
< 	if(name) {
---
> LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_by_name(const char *name)
> {
> 	if(name)
> 	{
373c375,376
< 		for(ix=0; ix<LIB3270_TOGGLE_COUNT; ix++) {
---
> 		for(ix=0;ix<LIB3270_TOGGLE_COUNT;ix++)
> 		{
381,382c384,387
< LIB3270_EXPORT LIB3270_TOGGLE_ID lib3270_get_toggle_id(const char *name) {
< 	if(name) {
---
> LIB3270_EXPORT LIB3270_TOGGLE_ID lib3270_get_toggle_id(const char *name)
> {
> 	if(name)
> 	{
384c389,390
< 		for(f=0; f<LIB3270_TOGGLE_COUNT; f++) {
---
> 		for(f=0;f<LIB3270_TOGGLE_COUNT;f++)
> 		{
392c398,399
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_from_id(LIB3270_TOGGLE_ID id) {
---
> LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_from_id(LIB3270_TOGGLE_ID id)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/trace_ds.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/trace_ds.c
41a42,43
> #if defined(X3270_TRACE) /*[*/
> 
54c56
< //#include "resources.h"
---
> #include "resources.h"
74,107d75
< static void write_trace(const H3270 *session, const char *fmt, va_list args) {
< 
< 	// 'mount' message.
< 	char *message = lib3270_vsprintf(fmt,args);
< 
< 	if(session->trace.file) {
< 
< 		// Has log file. Use it if possible.
< 		FILE *f = fopen(session->trace.file, "a");
< 
< 		if(f) {
< 			fprintf(f,"%s",message);
< 			fclose(f);
< 		}
< 
< 	}
< 
< 	session->trace.handler(session,session->trace.userdata,message);
< 
< 	lib3270_free(message);
< 
< }
< 
< /**
<  * @brief Write to the trace file.
<  */
< static void wtrace(H3270 *session, const char *fmt, ...) {
< 	va_list args;
< 	va_start(args, fmt);
< 	write_trace(session, fmt, args);
< 	va_end(args);
< }
< 
< 
109c77,78
< const char * rcba(H3270 *hSession, int baddr) {
---
> const char * rcba(H3270 *hSession, int baddr)
> {
116c85,86
< static void trace_ds_s(H3270 *hSession, char *s, Boolean can_break) {
---
> static void trace_ds_s(H3270 *hSession, char *s, Boolean can_break)
> {
124c94,95
< 	if (s && s[len-1] == '\n') {
---
> 	if (s && s[len-1] == '\n')
> 	{
129c100,101
< 	if (!can_break && dscnt + len >= 75) {
---
> 	if (!can_break && dscnt + len >= 75)
> 	{
134c106,107
< 	while (dscnt + len >= 75) {
---
> 	while (dscnt + len >= 75)
> 	{
143c116,117
< 	if (len) {
---
> 	if (len)
> 	{
148c122,123
< 	if (nl) {
---
> 	if (nl)
> 	{
154c129,130
< void trace_ds(H3270 *hSession, const char *fmt, ...) {
---
> void trace_ds(H3270 *hSession, const char *fmt, ...)
> {
170c146,147
< void trace_ds_nb(H3270 *hSession, const char *fmt, ...) {
---
> void trace_ds_nb(H3270 *hSession, const char *fmt, ...)
> {
188c165,166
< void trace_dsn(H3270 *session, const char *fmt, ...) {
---
> void trace_dsn(H3270 *session, const char *fmt, ...)
> {
196c174
< 	write_trace(session,fmt,args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
203c181,182
< void trace_ssl(H3270 *session, const char *fmt, ...) {
---
> void trace_ssl(H3270 *session, const char *fmt, ...)
> {
211c190,202
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
> 	va_end(args);
> }
> 
> 
> /**
>  * @brief Write to the trace file.
>  */
> static void wtrace(H3270 *session, const char *fmt, ...)
> {
> 	va_list args;
> 	va_start(args, fmt);
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
215c206,207
< LIB3270_EXPORT void lib3270_write_trace(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_write_trace(H3270 *session, const char *fmt, ...)
> {
219c211
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
223c215,216
< LIB3270_EXPORT void lib3270_write_dstrace(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_write_dstrace(H3270 *session, const char *fmt, ...)
> {
230c223
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
234c227,228
< LIB3270_EXPORT void lib3270_write_nettrace(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_write_nettrace(H3270 *session, const char *fmt, ...)
> {
241c235
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
245c239,240
< LIB3270_EXPORT void lib3270_write_screen_trace(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_write_screen_trace(H3270 *session, const char *fmt, ...)
> {
252c247
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
256c251,252
< LIB3270_EXPORT void lib3270_write_event_trace(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_write_event_trace(H3270 *session, const char *fmt, ...)
> {
263c259
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
267c263,264
< LIB3270_EXPORT void lib3270_trace_event(H3270 *session, const char *fmt, ...) {
---
> LIB3270_EXPORT void lib3270_trace_event(H3270 *session, const char *fmt, ...)
> {
274c271
< 	write_trace(session, fmt, args);
---
> 	session->trace.handler(session,session->trace.userdata,fmt, args);
284c281,282
< void trace_screen(H3270 *session) {
---
> void trace_screen(H3270 *session)
> {
287c285,286
< 	if (lib3270_get_toggle(session,LIB3270_TOGGLE_SCREEN_TRACE)) {
---
> 	if (lib3270_get_toggle(session,LIB3270_TOGGLE_SCREEN_TRACE))
> 	{
290c289,290
< 		for(row=baddr=0; row < session->view.rows; row++) {
---
> 		for(row=baddr=0;row < session->view.rows;row++)
> 		{
294c294,295
< 			for(col = 0; col < session->view.cols; col++) {
---
> 			for(col = 0; col < session->view.cols;col++)
> 			{
309c310,311
< void trace_char(H3270 *hSession, char c) {
---
> void trace_char(H3270 *hSession, char c)
> {
325c327,328
< void trace_ansi_disc(H3270 *hSession) {
---
> void trace_ansi_disc(H3270 *hSession)
> {
336c339,340
< void lib3270_trace_data(H3270 *hSession, const char *msg, const unsigned char *data, size_t datalen) {
---
> void lib3270_trace_data(H3270 *hSession, const char *msg, const unsigned char *data, size_t datalen)
> {
349c353,354
< 	for(ix = 0; ix < datalen; ix++) {
---
> 	for(ix = 0; ix < datalen; ix++)
> 	{
352c357,358
< 		if(col == 0) {
---
> 		if(col == 0)
> 		{
372,424c378
< LIB3270_EXPORT const char * lib3270_get_trace_filename(const H3270 * hSession) {
< 	return hSession->trace.file;
< }
< 
< LIB3270_EXPORT int lib3270_set_trace_filename(H3270 * hSession, const char *filename) {
< 
< 	if(hSession->trace.file) {
< 		lib3270_free(hSession->trace.file);
< 	}
< 	hSession->trace.file = NULL;
< 
< 	if(filename && *filename) {
< 		hSession->trace.file = lib3270_strdup(filename);
< 	}
< 
< 	return 0;
< 
< }
< 
< static int def_trace(const H3270 *session, void GNUC_UNUSED(*userdata), const char *message) {
< 
< 	if(session->log.file) {
< 
< 		// Has log file. Use it if possible.
< 		FILE *f = fopen(session->log.file, "a");
< 
< 		if(f) {
< 			fprintf(f,"%s",message);
< 			fclose(f);
< 		}
< 
< 		return 0;
< 
< 	}
< 
< 	return -1;
< }
< 
< LIB3270_EXPORT void lib3270_set_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER handler, void *userdata) {
< 	CHECK_SESSION_HANDLE(hSession);
< 
< 	hSession->trace.handler		= handler ? handler : def_trace;
< 	hSession->trace.userdata	= userdata;
< }
< 
< LIB3270_EXPORT void lib3270_get_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER *handler, void **userdata) {
< 	CHECK_SESSION_HANDLE(hSession);
< 
< 	*handler	= hSession->trace.handler;
< 	*userdata	= hSession->trace.userdata;
< 
< }
< 
---
> #endif
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/util.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/util.c
46c46
< #include <openssl/opensslv.h>
---
> 	#include <openssl/opensslv.h>
50c50
< #include <malloc.h>
---
> 	#include <malloc.h>
53,54d52
< #include <stdlib.h>
< 
58c56,57
< char * lib3270_vsprintf(const char *fmt, va_list args) {
---
> char * lib3270_vsprintf(const char *fmt, va_list args)
> {
64c63
< 		lib3270_write_log(NULL, "lib3270", "Error in vasprintf");
---
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
72,74c71,76
< 	if(nc < 0) {
< 		lib3270_write_log(NULL, "lib3270", "Error on vsnprintf");
< 	} else if (nc < sizeof(buf)) {
---
> 	if(nc < 0)
> 	{
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
> 	}
> 	else if (nc < sizeof(buf))
> 	{
78c80,82
< 	} else {
---
> 	}
> 	else
> 	{
80,84c84,85
< 		if(vsnprintf(r, nc, fmt, args) < 0) {
< 			lib3270_write_log(NULL, "lib3270", "Error on vsnprintf");
< 			free(r);
< 			return NULL;
< 		}
---
> 		if(vsnprintf(r, nc, fmt, args) < 0)
> 			lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
93c94,95
< LIB3270_EXPORT char * lib3270_strdup_printf(const char *fmt, ...) {
---
> LIB3270_EXPORT char * lib3270_strdup_printf(const char *fmt, ...)
> {
109c111,112
< char * xs_buffer(const char *fmt, ...) {
---
> char * xs_buffer(const char *fmt, ...)
> {
123c126,127
< ctl_see(int c) {
---
> ctl_see(int c)
> {
147c151,152
< LIB3270_EXPORT void * lib3270_free(void *p) {
---
> LIB3270_EXPORT void * lib3270_free(void *p)
> {
153,154c158,161
< LIB3270_EXPORT void lib3270_autoptr_cleanup_char(char **ptr) {
< 	if(ptr && *ptr) {
---
> LIB3270_EXPORT void lib3270_autoptr_cleanup_char(char **ptr)
> {
> 	if(ptr && *ptr)
> 	{
160,161c167,170
< LIB3270_EXPORT void lib3270_autoptr_cleanup_LIB3270_POPUP(LIB3270_POPUP **ptr) {
< 	if(ptr && *ptr) {
---
> LIB3270_EXPORT void lib3270_autoptr_cleanup_LIB3270_POPUP(LIB3270_POPUP **ptr)
> {
> 	if(ptr && *ptr)
> 	{
167c176,177
< LIB3270_EXPORT void * lib3270_realloc(void *p, int len) {
---
> LIB3270_EXPORT void * lib3270_realloc(void *p, int len)
> {
169,170c179,180
< 	if(p == NULL)
< 		perror("realloc");
---
> 	if(!p)
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
174c184,185
< LIB3270_EXPORT void * lib3270_calloc(int elsize, int nelem, void *ptr) {
---
> LIB3270_EXPORT void * lib3270_calloc(int elsize, int nelem, void *ptr)
> {
182,183c193,196
< 	if(!ptr)
< 		perror("calloc");
---
> 	if(ptr)
> 		memset(ptr,0,sz);
> 	else
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
185d197
< 	memset(ptr,0,sz);
189,205c201,203
< LIB3270_EXPORT void * lib3270_malloc(int len) {
< 	char *r = malloc(len);
< 	if(r)
< 		memset(r,0,len);
< 
< 	return r;
< }
< 
< LIB3270_EXPORT void * lib3270_strdup(const char *str) {
< 	return strdup(str);
< }
< 
< LIB3270_EXPORT char * lib3270_chomp(char *str) {
< 
< 	size_t len = strlen(str);
< 
< 	while(len--) {
---
> LIB3270_EXPORT void * lib3270_malloc(int len)
> {
> 	char *r;
207,211c205,209
< 		if(isspace(str[len])) {
< 			str[len] = 0;
< 		} else {
< 			break;
< 		}
---
> 	r = malloc(len);
> 	if (r == (char *)NULL)
> 	{
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
> 		return 0;
214,215c212,213
< 	return str;
< 
---
> 	memset(r,0,len);
> 	return r;
218,224c216,218
< LIB3270_EXPORT char * lib3270_chug(char *str) {
< 
< 	char *start;
< 
< 	for (start = (char*) str; *start && isspace(*start); start++);
< 
< 	memmove(str, start, strlen ((char *) start) + 1);
---
> LIB3270_EXPORT void * lib3270_strdup(const char *str)
> {
> 	char *r;
226,227c220,225
< 	return str;
< }
---
> 	r = strdup(str);
> 	if (r == (char *)NULL)
> 	{
> 		lib3270_popup_dialog(lib3270_get_default_session_handle(),LIB3270_NOTIFY_ERROR,_("Internal error"),"Out of memory",NULL);
> 		return 0;
> 	}
229,230c227
< LIB3270_EXPORT char * lib3270_strip(char *str) {
< 	return lib3270_chomp(lib3270_chug(str));
---
> 	return r;
233,234c230,231
< 
< LIB3270_EXPORT const char * lib3270_get_version(void) {
---
> LIB3270_EXPORT const char * lib3270_get_version(void)
> {
238c235,236
< LIB3270_EXPORT const char * lib3270_get_revision(void) {
---
> LIB3270_EXPORT const char * lib3270_get_revision(void)
> {
242,250c240,241
< LIB3270_EXPORT int lib3270_check_revision(const char GNUC_UNUSED(*revision)) {
< 	return 0;
< }
< 
< LIB3270_EXPORT const char * lib3270_get_product_name(void) {
< 	return LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME);
< }
< 
< LIB3270_EXPORT char * lib3270_get_version_info(void) {
---
> LIB3270_EXPORT char * lib3270_get_version_info(void)
> {
253,259c244,250
< 	           "%s version %s-%s build %s (%s)",
< 	           PACKAGE_NAME,
< 	           PACKAGE_VERSION,
< 	           PACKAGE_RELEASE,
< 	           RPQ_TIMESTAMP_VALUE,
< 	           OPENSSL_VERSION_TEXT
< 	       );
---
> 				"%s version %s-%s build %s (%s)",
> 				PACKAGE_NAME,
> 				PACKAGE_VERSION,
> 				PACKAGE_RELEASE,
> 				RPQ_TIMESTAMP_VALUE,
> 				OPENSSL_VERSION_TEXT
> 			);
265c256,257
< void lib3270_popup_an_errno(H3270 *hSession, int errn, const char *fmt, ...) {
---
> void lib3270_popup_an_errno(H3270 *hSession, int errn, const char *fmt, ...)
> {
266a259
> 	char	* text;
269,270c262
< 	lib3270_autoptr(char) summary = lib3270_vsprintf(fmt, args);
< 	lib3270_autoptr(char) body = lib3270_strdup_printf( _( "The system error was '%s' (rc=%d)" ),strerror(errn),errn);
---
> 	text = lib3270_vsprintf(fmt, args);
273,277c265
< 	LIB3270_POPUP popup = {
< 		.type = LIB3270_NOTIFY_ERROR,
< 		.summary = summary,
< 		.body = body
< 	};
---
> 	lib3270_write_log(hSession, "3270", "Error Popup:\n%s\nrc=%d (%s)",text,errn,strerror(errn));
279c267,277
< 	lib3270_popup(hSession,&popup,0);
---
> 	lib3270_popup_dialog(
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Error" ),
> 			text,
> 			"%s (rc=%d)",
> 				strerror(errn),
> 				errn
> 			);
> 
> 	lib3270_free(text);
283c281,282
< LIB3270_EXPORT int lib3270_print(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_print(H3270 *hSession)
> {
290c289,290
< LIB3270_EXPORT int lib3270_print_all(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_print_all(H3270 *hSession)
> {
297c297,298
< LIB3270_EXPORT int lib3270_print_selected(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_print_selected(H3270 *hSession)
> {
307c308,309
< LIB3270_EXPORT int lib3270_print_copy(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_print_copy(H3270 *hSession)
> {
314c316,317
< LIB3270_EXPORT int lib3270_load(H3270 *hSession, const char *filename) {
---
> LIB3270_EXPORT int lib3270_load(H3270 *hSession, const char *filename)
> {
321c324,325
< LIB3270_EXPORT int lib3270_save(H3270 *hSession, LIB3270_CONTENT_OPTION mode, const char *filename) {
---
> LIB3270_EXPORT int lib3270_save(H3270 *hSession, LIB3270_CONTENT_OPTION mode, const char *filename)
> {
325c329,330
< LIB3270_EXPORT int lib3270_save_all(H3270 *hSession, const char *filename) {
---
> LIB3270_EXPORT int lib3270_save_all(H3270 *hSession, const char *filename)
> {
332c337,338
< LIB3270_EXPORT int lib3270_save_selected(H3270 *hSession, const char *filename) {
---
> LIB3270_EXPORT int lib3270_save_selected(H3270 *hSession, const char *filename)
> {
339c345,346
< LIB3270_EXPORT int lib3270_save_copy(H3270 *hSession, const char *filename) {
---
> LIB3270_EXPORT int lib3270_save_copy(H3270 *hSession, const char *filename)
> {
343c350,351
< LIB3270_EXPORT LIB3270_POINTER lib3270_get_pointer(H3270 *hSession, int baddr) {
---
> LIB3270_EXPORT LIB3270_POINTER lib3270_get_pointer(H3270 *hSession, int baddr)
> {
365,366c373,376
< 	for(f = 0; f < (sizeof(ptr)/sizeof(ptr[0])); f++) {
< 		if(ptr[f].id == id) {
---
> 	for(f = 0; f < (sizeof(ptr)/sizeof(ptr[0]));f++)
> 	{
> 		if(ptr[f].id == id)
> 		{
375c385,386
< static int xdigit_value(const char scanner) {
---
> static int xdigit_value(const char scanner)
> {
392c403,404
< static int unescape_character(const char *scanner) {
---
> static int unescape_character(const char *scanner)
> {
394,395c406,407
< 	int first_digit 	= xdigit_value(*scanner++);
< 	int second_digit 	= xdigit_value(*scanner++);
---
> 		int first_digit 	= xdigit_value(*scanner++);
> 		int second_digit 	= xdigit_value(*scanner++);
397,398c409,410
< 	if (first_digit < 0)
< 		return -1;
---
> 		if (first_digit < 0)
> 				return -1;
400,401c412,413
< 	if (second_digit < 0)
< 		return -1;
---
> 		if (second_digit < 0)
> 				return -1;
403c415
< 	return (first_digit << 4) | second_digit;
---
> 		return (first_digit << 4) | second_digit;
407c419,420
< char * lib3270_unescape(const char *text) {
---
> char * lib3270_unescape(const char *text)
> {
419,420c432,435
< 	while(ptr) {
< 		if(ptr[1] == '%') {
---
> 	while(ptr)
> 	{
> 		if(ptr[1] == '%')
> 		{
422c437,439
< 		} else {
---
> 		}
> 		else
> 		{
428c445,446
< 			if(chr < 0) {
---
> 			if(chr < 0)
> 			{
430c448,450
< 			} else {
---
> 			}
> 			else
> 			{
445c465,466
< int lib3270_compare_alnum(const char *s1, const char *s2) {
---
> int lib3270_compare_alnum(const char *s1, const char *s2)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/wait.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/wait.c
39c39,40
< static int timer_expired(H3270 GNUC_UNUSED(*hSession), void *userdata) {
---
> static int timer_expired(H3270 GNUC_UNUSED(*hSession), void *userdata)
> {
44c45,46
< LIB3270_EXPORT int lib3270_wait_for_update(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(seconds)) {
---
> LIB3270_EXPORT int lib3270_wait_for_update(H3270 GNUC_UNUSED(*hSession), int GNUC_UNUSED(seconds))
> {
48,49c50,51
< LIB3270_EXPORT int lib3270_wait_for_ready(H3270 *hSession, int seconds) {
< 
---
> LIB3270_EXPORT int lib3270_wait_for_ready(H3270 *hSession, int seconds)
> {
57c59,60
< 	while(!rc) {
---
> 	while(!rc)
> 	{
64c67,68
< 		if(lib3270_get_lock_status(hSession) == LIB3270_MESSAGE_NONE) {
---
> 		if(lib3270_get_lock_status(hSession) == LIB3270_MESSAGE_NONE)
> 		{
70c74,75
< 		if(lib3270_is_disconnected(hSession)) {
---
> 		if(lib3270_is_disconnected(hSession))
> 		{
75c80,81
< 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession)) {
---
> 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession))
> 		{
90,91c96,97
< int lib3270_wait_for_string(H3270 *hSession, const char *key, int seconds) {
< 
---
> int lib3270_wait_for_string(H3270 *hSession, const char *key, int seconds)
> {
98c104,105
< 	while(!rc) {
---
> 	while(!rc)
> 	{
105c112,113
< 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession)) {
---
> 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession))
> 		{
110c118,119
< 		if(!lib3270_is_connected(hSession)) {
---
> 		if(!lib3270_is_connected(hSession))
> 		{
116c125,126
< 		if(!contents) {
---
> 		if(!contents)
> 		{
137c147,148
< int lib3270_wait_for_string_at_address(H3270 *hSession, int baddr, const char *key, int seconds) {
---
> int lib3270_wait_for_string_at_address(H3270 *hSession, int baddr, const char *key, int seconds)
> {
147c158,159
< 	while(!rc) {
---
> 	while(!rc)
> 	{
154c166,167
< 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession)) {
---
> 		if(hSession->kybdlock && KYBDLOCK_IS_OERR(hSession))
> 		{
159c172,173
< 		if(!lib3270_is_connected(hSession)) {
---
> 		if(!lib3270_is_connected(hSession))
> 		{
164c178,179
< 		if(lib3270_cmp_string_at_address(hSession, baddr, key, 0) == 0) {
---
> 		if(lib3270_cmp_string_at_address(hSession, baddr, key, 0) == 0)
> 		{
177c192,193
< LIB3270_EXPORT int lib3270_wait_for_string_at(H3270 *hSession, unsigned int row, unsigned int col, const char *key, int seconds) {
---
> LIB3270_EXPORT int lib3270_wait_for_string_at(H3270 *hSession, unsigned int row, unsigned int col, const char *key, int seconds)
> {
185,216c201,202
< LIB3270_EXPORT int lib3270_wait_for_connected(H3270 *hSession, int seconds) {
< 
< 	int rc = -1;
< 	int timeout = 0;
< 	void * timer = AddTimer(seconds * 1000, hSession, timer_expired, &timeout);
< 
< 	while(rc == -1) {
< 		if(timeout) {
< 			// Timeout! The timer was destroyed.
< 			return errno = ETIMEDOUT;
< 		}
< 
< 		if(hSession->connection.state == LIB3270_NOT_CONNECTED) {
< 			rc = ENOTCONN;
< 			break;
< 		}
< 
< 		if(!hSession->starting && hSession->connection.state >= (int)LIB3270_CONNECTED_INITIAL) {
< 			rc = 0;
< 			break;
< 		}
< 
< 		lib3270_main_iterate(hSession,1);
< 
< 	}
< 	RemoveTimer(hSession,timer);
< 
< 	return errno = rc;
< }
< 
< 
< LIB3270_EXPORT int lib3270_wait_for_cstate(H3270 *hSession, LIB3270_CSTATE cstate, int seconds) {
---
> LIB3270_EXPORT int lib3270_wait_for_cstate(H3270 *hSession, LIB3270_CSTATE cstate, int seconds)
> {
222c208,209
< 	while(rc == -1) {
---
> 	while(rc == -1)
> 	{
228c215,216
< 		if(hSession->connection.state == LIB3270_NOT_CONNECTED) {
---
> 		if(hSession->connection.state == LIB3270_NOT_CONNECTED)
> 		{
233c221,222
< 		if(!hSession->starting && hSession->connection.state == cstate) {
---
> 		if(!hSession->starting && hSession->connection.state == cstate)
> 		{
246c235,236
< LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_wait_for_keyboard_unlock(H3270 *hSession, int seconds) {
---
> LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_wait_for_keyboard_unlock(H3270 *hSession, int seconds)
> {
253c243,244
< 	while(!rc) {
---
> 	while(!rc)
> 	{
261c252,253
< 		if(hSession->kybdlock == LIB3270_KL_NOT_CONNECTED) {
---
> 		if(hSession->kybdlock == LIB3270_KL_NOT_CONNECTED)
> 		{
266c258,259
< 		if(KYBDLOCK_IS_OERR(hSession)) {
---
> 		if(KYBDLOCK_IS_OERR(hSession))
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/connect.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/connect.c
48c48
< static int sock_connect(H3270 *hSession, int sock, const struct sockaddr *address, socklen_t address_len) {
---
>  static int sock_connect(H3270 *hSession, int sock, const struct sockaddr *address, socklen_t address_len) {
57c57
< 	/*
---
> 		/*
59,61c59,61
< 	debug("Can't connect WSAGetLastError=%d",(int) WSAGetLastError());
< 	errno = ENOTCONN;
< 	return -1;
---
> 		debug("Can't connect WSAGetLastError=%d",(int) WSAGetLastError());
> 		errno = ENOTCONN;
> 		return -1;
63c63
< 	*/
---
> 		*/
94c94
< }
---
>  }
97c97
< int lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state) {
---
>  int lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state) {
108c108,109
< 		if (WSAStartup(wVersionRequested, &wsaData) != 0) {
---
> 		if (WSAStartup(wVersionRequested, &wsaData) != 0)
> 		{
120c121,122
< 		if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
---
> 		if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2)
> 		{
143c145
< 	struct addrinfo * result	= NULL;
---
>  	struct addrinfo * result	= NULL;
152,153c154,156
< 	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
< 	if(rc) {
---
>  	int rc = getaddrinfo(hSession->host.current, hSession->host.srvc, &hints, &result);
>  	if(rc)
> 	{
166c169,170
< 	for(rp = result; sock < 0 && rp != NULL && state->syserror != ECANCELED; rp = rp->ai_next) {
---
> 	for(rp = result; sock < 0 && rp != NULL && state->syserror != ECANCELED; rp = rp->ai_next)
> 	{
169c173,174
< 		if(sock < 0) {
---
> 		if(sock < 0)
> 		{
176c181,182
< 		if(sock_connect(hSession, sock, rp->ai_addr, rp->ai_addrlen)) {
---
> 		if(sock_connect(hSession, sock, rp->ai_addr, rp->ai_addrlen))
> 		{
193c199,200
< 	if(sock < 0) {
---
> 	if(sock < 0)
> 	{
206c213
< }
---
>  }
208c215,216
< static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno)) {
---
>  static void net_connected(H3270 *hSession, int GNUC_UNUSED(fd), LIB3270_IO_FLAG GNUC_UNUSED(flag), void GNUC_UNUSED(*dunno))
>  {
218c226,227
< 	if(hSession->network.module->getsockopt(hSession, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0) {
---
> 	if(hSession->network.module->getsockopt(hSession, SOL_SOCKET, SO_ERROR, (char *) &err, &len) < 0)
> 	{
221,225c230,234
< 		    hSession,
< 		    LIB3270_NOTIFY_ERROR,
< 		    _( "Network error" ),
< 		    _( "Unable to get connection state." ),
< 		    _( "The system error was %s" ), lib3270_win32_strerror(WSAGetLastError())
---
> 			hSession,
> 			LIB3270_NOTIFY_ERROR,
> 			_( "Network error" ),
> 			_( "Unable to get connection state." ),
> 			_( "The system error was %s" ), lib3270_win32_strerror(WSAGetLastError())
228c237,239
< 	} else if(err) {
---
> 	}
> 	else if(err)
> 	{
230,235c241,246
< 		    lib3270_popup_clone_printf(
< 		        NULL,
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
---
> 			lib3270_popup_clone_printf(
> 				NULL,
> 				_( "Can't connect to %s:%s"),
> 				hSession->host.current,
> 				hSession->host.srvc
> 			);
238,241c249,252
< 		    lib3270_strdup_printf(
< 		        _("The system error was \"%s\""),
< 		        lib3270_win32_strerror(WSAGetLastError())
< 		    );
---
> 						lib3270_strdup_printf(
> 							_("The system error was \"%s\""),
> 							lib3270_win32_strerror(WSAGetLastError())
> 						);
262c273
< }
---
>  }
264c275,276
< int net_reconnect(H3270 *hSession, int seconds) {
---
>  int net_reconnect(H3270 *hSession, int seconds)
>  {
268c280
< 	// Initialize and connect to host
---
>  	// Initialize and connect to host
272c284,285
< 	if(lib3270_run_task(hSession, (int(*)(H3270 *, void *)) hSession->network.module->connect, &state)) {
---
> 	if(lib3270_run_task(hSession, (int(*)(H3270 *, void *)) hSession->network.module->connect, &state))
> 	{
274,279c287,292
< 		    lib3270_popup_clone_printf(
< 		        NULL,
< 		        _( "Can't connect to %s:%s"),
< 		        hSession->host.current,
< 		        hSession->host.srvc
< 		    );
---
> 			lib3270_popup_clone_printf(
> 				NULL,
> 				_( "Can't connect to %s:%s"),
> 				hSession->host.current,
> 				hSession->host.srvc
> 			);
281c294,295
< 		if(!popup->summary) {
---
> 		if(!popup->summary)
> 		{
289c303,304
< 		if(state.winerror) {
---
> 		if(state.winerror)
> 		{
291,294c306,309
< 			               "%s (Windows error %u)",
< 			               lib3270_win32_strerror(state.winerror),
< 			               (unsigned int) state.winerror
< 			           );
---
> 							"%s (Windows error %u)",
> 							lib3270_win32_strerror(state.winerror),
> 							(unsigned int) state.winerror
> 						);
298,301c313,316
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               _("Timeout conneting to host"),
< 			               state.syserror
< 			           );
---
> 							_("The system error was \"%s\" (rc=%d)"),
> 							_("Timeout conneting to host"),
> 							state.syserror
> 						);
306,309c321,324
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               _("Not connected to host"),
< 			               state.syserror
< 			           );
---
> 							_("The system error was \"%s\" (rc=%d)"),
> 							_("Not connected to host"),
> 							state.syserror
> 						);
314,317c329,332
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               strerror(state.syserror),
< 			               state.syserror
< 			           );
---
> 							_("The system error was \"%s\" (rc=%d)"),
> 							strerror(state.syserror),
> 							state.syserror
> 						);
322c337,338
< 		if(state.syserror) {
---
> 		if(state.syserror)
> 		{
324,327c340,343
< 			               _("The system error was \"%s\" (rc=%d)"),
< 			               strerror(state.syserror),
< 			               state.syserror
< 			           );
---
> 							_("The system error was \"%s\" (rc=%d)"),
> 							strerror(state.syserror),
> 							state.syserror
> 						);
331c347,348
< 		if(!popup->body) {
---
> 		if(!popup->body)
> 		{
354c371,372
< 	if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_OOBINLINE, &optval, sizeof(optval)) < 0) {
---
> 	if(hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_OOBINLINE, &optval, sizeof(optval)) < 0)
> 	{
357,362c375,380
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        _( "setsockopt(SO_OOBINLINE) has failed" ),
< 		                        _( "The system error was %s" ),
< 		                        lib3270_win32_strerror(WSAGetLastError())
< 		                    );
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								_( "setsockopt(SO_OOBINLINE) has failed" ),
> 								_( "The system error was %s" ),
> 								lib3270_win32_strerror(WSAGetLastError())
> 							);
368c386,387
< 	if (hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
---
> 	if (hSession->network.module->setsockopt(hSession, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0)
> 	{
375,380c394,399
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        buffer,
< 		                        _( "The system error was %s" ),
< 		                        lib3270_win32_strerror(WSAGetLastError())
< 		                    );
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Connection error" ),
> 								buffer,
> 								_( "The system error was %s" ),
> 								lib3270_win32_strerror(WSAGetLastError())
> 							);
384c403,405
< 	} else {
---
> 	}
> 	else
> 	{
396c417,418
< 	if(seconds) {
---
> 	if(seconds)
> 	{
398c420,421
< 		if(rc) {
---
> 		if(rc)
> 		{
408c431
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/download.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/download.c
35c35
< char * lib3270_url_get(H3270 *hSession, const char *u, const char **error) {
---
>  char * lib3270_url_get(H3270 *hSession, const char *u, const char **error) {
70c70
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/event_dispatcher.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/event_dispatcher.c
30,33c30,33
< /**
<  * @brief Implements the default event dispatcher for windows.
<  *
<  */
---
>  /**
>   * @brief Implements the default event dispatcher for windows.
>   *
>   */
45c45,46
< static void ms_ts(unsigned long long *u) {
---
> static void ms_ts(unsigned long long *u)
> {
63c64,65
< int lib3270_default_event_dispatcher(H3270 *hSession, int block) {
---
> int lib3270_default_event_dispatcher(H3270 *hSession, int block)
> {
87,88c89,92
< 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next) {
< 		if(!ip->enabled) {
---
> 	for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next)
> 	{
> 		if(!ip->enabled)
> 		{
93c97,98
< 		if(ip->flag & LIB3270_IO_FLAG_READ) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_READ)
> 		{
98c103,104
< 		if(ip->flag & LIB3270_IO_FLAG_WRITE) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_WRITE)
> 		{
103c109,110
< 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION) {
---
> 		if(ip->flag & LIB3270_IO_FLAG_EXCEPTION)
> 		{
109,110c116,119
< 	if (block) {
< 		if (hSession->timeouts.first) {
---
> 	if (block)
> 	{
> 		if (hSession->timeouts.first)
> 		{
116c125,127
< 		} else {
---
> 		}
> 		else
> 		{
120c131,133
< 	} else {
---
> 	}
> 	else
> 	{
124c137,138
< 	if(maxSock) {
---
> 	if(maxSock)
> 	{
132c146,147
< 		if (ns < 0 && errno != EINTR) {
---
> 		if (ns < 0 && errno != EINTR)
> 		{
134,140c149,159
< 			                        LIB3270_NOTIFY_ERROR,
< 			                        _( "Network error" ),
< 			                        _( "Select() failed when processing for events." ),
< 			                        lib3270_win32_strerror(WSAGetLastError()));
< 		} else {
< 			for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next) {
< 				if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds)) {
---
> 									LIB3270_NOTIFY_ERROR,
> 									_( "Network error" ),
> 									_( "Select() failed when processing for events." ),
> 									lib3270_win32_strerror(WSAGetLastError()));
> 		}
> 		else
> 		{
> 			for (ip = (input_t *) hSession->input.list.first; ip != (input_t *)NULL; ip = (input_t *) ip->next)
> 			{
> 				if((ip->flag & LIB3270_IO_FLAG_READ) && FD_ISSET(ip->fd, &rfds))
> 				{
147c166,167
< 				if ((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds)) {
---
> 				if ((ip->flag & LIB3270_IO_FLAG_WRITE) && FD_ISSET(ip->fd, &wfds))
> 				{
154c174,175
< 				if ((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds)) {
---
> 				if ((ip->flag & LIB3270_IO_FLAG_EXCEPTION) && FD_ISSET(ip->fd, &xfds))
> 				{
162c183,185
< 	} else if(block) {
---
> 	}
> 	else if(block)
> 	{
167c190,191
< 	if (hSession->timeouts.first) {
---
> 	if (hSession->timeouts.first)
> 	{
171,172c195,197
< 		while(hSession->timeouts.first) {
< 			t = (struct timeout *) hSession->timeouts.first;
---
> 		while(hSession->timeouts.first)
> 		{
>             t = (struct timeout *) hSession->timeouts.first;
174c199,200
< 			if (t->ts <= now) {
---
> 			if (t->ts <= now)
> 			{
182c208,210
< 			} else {
---
> 			}
> 			else
> 			{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/http.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/http.c
49c49,50
< static void lib3270_autoptr_cleanup_HINTERNET(HINTERNET **hInternet) {
---
> static void lib3270_autoptr_cleanup_HINTERNET(HINTERNET **hInternet)
> {
55c56,57
< char * lib3270_url_get_using_http(H3270 *hSession, const char *url, const char **error_message) {
---
> char * lib3270_url_get_using_http(H3270 *hSession, const char *url, const char **error_message)
> {
95c97,98
< 	if(!httpSession) {
---
> 	if(!httpSession)
> 	{
106c109,110
< 	if(!hConnect) {
---
> 	if(!hConnect)
> 	{
117c121,122
< 	if(!hConnect) {
---
> 	if(!hConnect)
> 	{
130c135,136
< 	if(!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0)) {
---
> 	if(!WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0))
> 	{
141c147,148
< 	if(!WinHttpReceiveResponse(hRequest, NULL)) {
---
> 	if(!WinHttpReceiveResponse(hRequest, NULL))
> 	{
153c160,161
< 	if(!WinHttpQueryDataAvailable(hRequest, &szResponse)) {
---
> 	if(!WinHttpQueryDataAvailable(hRequest, &szResponse))
> 	{
169c177
< 	if(!WinHttpReadData(hRequest,httpText,szResponse,&szResponse)) {
---
> 	if(!WinHttpReadData(hRequest,httpText,szResponse,&szResponse)){
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/ldap.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/ldap.c
49c49
< Update your Platform SDK, or disable LDAP support!
---
>          Update your Platform SDK, or disable LDAP support!
56c56,57
< static inline void lib3270_autoptr_cleanup_LDAP(LDAP **ptr) {
---
> static inline void lib3270_autoptr_cleanup_LDAP(LDAP **ptr)
> {
58c59,60
< 	if(*ptr) {
---
> 	if(*ptr)
> 	{
65c67,68
< static inline void lib3270_autoptr_cleanup_LDAPMessage(LDAPMessage **message) {
---
> static inline void lib3270_autoptr_cleanup_LDAPMessage(LDAPMessage **message)
> {
72c75,76
< static inline void lib3270_autoptr_cleanup_LDAPPTR(char **ptr) {
---
> static inline void lib3270_autoptr_cleanup_LDAPPTR(char **ptr)
> {
79c83,84
< static inline void lib3270_autoptr_cleanup_BerElement(BerElement **ber) {
---
> static inline void lib3270_autoptr_cleanup_BerElement(BerElement **ber)
> {
87c92,93
< X509_CRL * lib3270_crl_get_using_ldap(H3270 *hSession, const char *consturl, const char **error) {
---
> X509_CRL * lib3270_crl_get_using_ldap(H3270 *hSession, const char *consturl, const char **error)
> {
100c106,107
< 	if(!base) {
---
> 	if(!base)
> 	{
109c116,117
< 	if(!base) {
---
> 	if(!base)
> 	{
118c126,127
< 	if(port) {
---
> 	if(port)
> 	{
132c141,142
< 	if(!ld) {
---
> 	if(!ld)
> 	{
140c150,151
< 	if(rc != LDAP_SUCCESS) {
---
> 	if(rc != LDAP_SUCCESS)
> 	{
148c159,160
< 	if(rc != LDAP_SUCCESS) {
---
> 	if(rc != LDAP_SUCCESS)
> 	{
157,168c169,180
< 	         ld,						// Specifies the LDAP pointer returned by a previous call to ldap_init(), ldap_ssl_init(), or ldap_open().
< 	         base,					// Specifies the DN of the entry at which to start the search.
< 	         LDAP_SCOPE_BASE,		// Specifies the scope of the search.
< 	         NULL,					// Specifies a string representation of the filter to apply in the search.
< 	         (char **)  &attrs,		// Specifies a null-terminated array of character string attribute types to return from entries that match filter.
< 	         0,						// Should be set to 1 to request attribute types only. Set to 0 to request both attributes types and attribute values.
< 	         NULL,
< 	         NULL,
< 	         NULL,
< 	         0,
< 	         &results
< 	     );
---
> 				ld,						// Specifies the LDAP pointer returned by a previous call to ldap_init(), ldap_ssl_init(), or ldap_open().
> 				base,					// Specifies the DN of the entry at which to start the search.
> 				LDAP_SCOPE_BASE,		// Specifies the scope of the search.
> 				NULL,					// Specifies a string representation of the filter to apply in the search.
> 				(char **)  &attrs,		// Specifies a null-terminated array of character string attribute types to return from entries that match filter.
> 				0,						// Should be set to 1 to request attribute types only. Set to 0 to request both attributes types and attribute values.
> 				NULL,
> 				NULL,
> 				NULL,
> 				0,
> 				&results
> 			);
171c183,184
< 	if(rc != LDAP_SUCCESS) {
---
> 	if(rc != LDAP_SUCCESS)
> 	{
178c191,192
< 	if(!attr) {
---
> 	if(!attr)
> 	{
185c199,200
< 	if(!value) {
---
> 	if(!value)
> 	{
191c206,207
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
193,196c209,212
< 		    hSession,
< 		    "CRL Data received from LDAP server",
< 		    (const unsigned char *) value[0]->bv_val,
< 		    value[0]->bv_len
---
> 			hSession,
> 			"CRL Data received from LDAP server",
> 			(const unsigned char *) value[0]->bv_val,
> 			value[0]->bv_len
203c219,220
< 	if(!d2i_X509_CRL(&x509_crl, &crl_data, value[0]->bv_len)) {
---
> 	if(!d2i_X509_CRL(&x509_crl, &crl_data, value[0]->bv_len))
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/log.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/log.c
44c44,46
< int default_loghandler(const H3270 GNUC_UNUSED(*session), void GNUC_UNUSED(*userdata), const char *module, int rc, const char *msg) {
---
>  void default_log_writer(H3270 GNUC_UNUSED(*session), const char *module, int rc, const char *fmt, va_list arg_ptr)
>  {
> 	lib3270_autoptr(char) msg = lib3270_vsprintf(fmt,arg_ptr);
46c48
< 	if(hEventLog) {
---
> 	debug("%s",msg);
47a50,51
>  	if(hEventLog)
> 	{
56c60
< #ifdef DEBUG
---
> 	#ifdef DEBUG
59c63
< #endif // DEBUG
---
> 	#endif // DEBUG
62,70c66,74
< 		    hEventLog,
< 		    (rc == 0 ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_ERROR_TYPE),
< 		    1,
< 		    0,
< 		    NULL,
< 		    3,
< 		    0,
< 		    outMsg,
< 		    NULL
---
> 			hEventLog,
> 			(rc == 0 ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_ERROR_TYPE),
> 			1,
> 			0,
> 			NULL,
> 			3,
> 			0,
> 			outMsg,
> 			NULL
75,76c79
< 	return 0;
< }
---
>  }
78,80c81,84
< LIB3270_EXPORT int lib3270_set_syslog(int GNUC_UNUSED(flag)) {
< 	return errno  = ENOENT;
< }
---
>  LIB3270_EXPORT int lib3270_set_syslog(int GNUC_UNUSED(flag))
>  {
>  	return errno  = ENOENT;
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/private.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/private.h
32c32
< #define PRIVATE_H_INCLUDED
---
> 	#define PRIVATE_H_INCLUDED
34c34
< #include <config.h>
---
> 	#include <config.h>
36,37c36,37
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
39c39
< #include <internals.h>
---
> 	#include <internals.h>
41,42c41,42
< #include <lib3270.h>
< #include <lib3270/log.h>
---
> 	#include <lib3270.h>
>  	#include <lib3270/log.h>
44,45c44,45
< LIB3270_INTERNAL char * lib3270_url_get_using_ldap(H3270 *hSession, const char *u, const char **error);
< LIB3270_INTERNAL char * lib3270_url_get_using_http(H3270 *hSession, const char *url, const char **error);
---
> 	LIB3270_INTERNAL char * lib3270_url_get_using_ldap(H3270 *hSession, const char *u, const char **error);
> 	LIB3270_INTERNAL char * lib3270_url_get_using_http(H3270 *hSession, const char *url, const char **error);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/registry.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/registry.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,5
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob
>  * o nome G3270.
6,14c7,22
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d23
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
32d34
< #include <config.h>
57c59,60
< LIB3270_EXPORT DWORD lib3270_win32_get_dword(HKEY hKey, const char *name, DWORD def) {
---
> LIB3270_EXPORT DWORD lib3270_win32_get_dword(HKEY hKey, const char *name, DWORD def)
> {
67,81d69
< }
< 
< LIB3270_EXPORT LSTATUS lib3270_win32_set_string(LPCSTR module, LPCSTR keyname, LPCSTR value) {
< 
< 	HKEY hKey = 0;
< 	LSTATUS status = lib3270_win32_create_regkey(module, KEY_CREATE_SUB_KEY|KEY_SET_VALUE, &hKey);
< 
< 	if(status != ERROR_SUCCESS)
< 		return status;
< 
< 	status = RegSetValueEx(hKey,keyname,0,REG_SZ,(const BYTE *) value,strlen(value)+1);
< 
< 	RegCloseKey(hKey);
< 
< 	return status;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/util.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/core/windows/util.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,5
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270. Registro no INPI sob
>  * o nome G3270.
6,9c7
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
11,14c9,22
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d23
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
36d38
< #include <io.h>
46c48
< #include <iconv.h>
---
> 	#include <iconv.h>
57c59,60
< int get_version_info(void) {
---
> int get_version_info(void)
> {
63c66,67
< 	if(GetVersionEx(&info) == 0) {
---
> 	if(GetVersionEx(&info) == 0)
> 	{
73c77,78
< 	if (!is_nt || info.dwMajorVersion < 5 || (info.dwMajorVersion == 5 && info.dwMinorVersion < 1)) {
---
> 	if (!is_nt || info.dwMajorVersion < 5 || (info.dwMajorVersion == 5 && info.dwMinorVersion < 1))
> 	{
82,84c87,90
< const char * inet_ntop(int af, const void *src, char *dst, socklen_t cnt) {
< 	union {
< 		struct sockaddr sa;
---
> const char * inet_ntop(int af, const void *src, char *dst, socklen_t cnt)
> {
>     	union {
> 	    	struct sockaddr sa;
95c101
< 		sa.sin = *(struct sockaddr_in *)src;	// struct copy
---
> 	    	sa.sin = *(struct sockaddr_in *)src;	// struct copy
99c105
< 		sa.sin6 = *(struct sockaddr_in6 *)src;	// struct copy
---
> 	    	sa.sin6 = *(struct sockaddr_in6 *)src;	// struct copy
103c109
< 		if (cnt > 0)
---
> 	    	if (cnt > 0)
111c117
< 		if (cnt > 0)
---
> 	    	if (cnt > 0)
120c126,127
< LIB3270_EXPORT char * lib3270_win32_translate_error_code(int lasterror) {
---
> LIB3270_EXPORT char * lib3270_win32_translate_error_code(int lasterror)
> {
123,124c130,132
< 	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,lasterror,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),buffer,4096,NULL) == 0) {
< 		snprintf(buffer, 4095, _( "Windows error %d" ), lasterror);
---
> 	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,lasterror,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),buffer,4096,NULL) == 0)
> 	{
> 	    snprintf(buffer, 4095, _( "Windows error %d" ), lasterror);
134c142,143
< 		if(hConv == (iconv_t) -1) {
---
> 		if(hConv == (iconv_t) -1)
> 		{
136c145,147
< 		} else {
---
> 		}
> 		else
> 		{
147c158,159
< 			if(iconv(hConv,&inBuffer,&in,&ptr,&out) != ((size_t) -1)) {
---
> 			if(iconv(hConv,&inBuffer,&in,&ptr,&out) != ((size_t) -1))
> 			{
163c175,176
< LIB3270_EXPORT const char * lib3270_win32_strerror(int e) {
---
> LIB3270_EXPORT const char * lib3270_win32_strerror(int e)
> {
166,167c179,181
< 	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,e,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),buffer,sizeof(buffer),NULL) == 0) {
< 		snprintf(buffer, 4095, _( "Windows error %d" ), e);
---
> 	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,e,MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),buffer,sizeof(buffer),NULL) == 0)
> 	{
> 	    snprintf(buffer, 4095, _( "Windows error %d" ), e);
178c192,193
< 		if(hConv == (iconv_t) -1) {
---
> 		if(hConv == (iconv_t) -1)
> 		{
180c195,197
< 		} else {
---
> 		}
> 		else
> 		{
191c208,209
< 			if(iconv(hConv,&inBuffer,&in,&ptr,&out) != ((size_t) -1)) {
---
> 			if(iconv(hConv,&inBuffer,&in,&ptr,&out) != ((size_t) -1))
> 			{
202c220
< #error NO-ICONV
---
> 	#error NO-ICONV
208c226,227
< LIB3270_EXPORT const char * lib3270_win32_local_charset(void) {
---
> LIB3270_EXPORT const char * lib3270_win32_local_charset(void)
> {
222,223c241,259
< LIB3270_EXPORT char	* lib3270_get_installation_path() {
< 	char lpFilename[MAX_PATH+1];
---
> /*
> int gettimeofday(struct timeval *tv, struct timezone GNUC_UNUSED(*ignored))
> {
> 	FILETIME t;
> 	ULARGE_INTEGER u;
> 
> 	GetSystemTimeAsFileTime(&t);
> 	memcpy(&u, &t, sizeof(ULARGE_INTEGER));
> 
> 	// Isolate seconds and move epochs.
> 	tv->tv_sec = (DWORD)((u.QuadPart / SECS_TO_100NS) - SECS_BETWEEN_EPOCHS);
> 	tv->tv_usec = (u.QuadPart % SECS_TO_100NS) / 10ULL;
> 	return 0;
> }
> */
> 
> LIB3270_EXPORT char	* lib3270_get_installation_path()
> {
> 	char lpFilename[4096];
226c262
< 	DWORD szPath = GetModuleFileName(hModule,lpFilename,MAX_PATH);
---
> 	DWORD szPath = GetModuleFileName(hModule,lpFilename,sizeof(lpFilename));
229,239c265,267
< 	char *ptr = strrchr(lpFilename,'\\');
< 	if(ptr) {
< 		ptr[0] = 0;
< 
< 		ptr = strrchr(lpFilename,'\\');
< 		if(ptr && !(strcasecmp(ptr,"\\bin") && strcasecmp(ptr,"\\lib"))) {
< 			*ptr = 0;
< 		}
< 
< 		strncat(lpFilename,"\\",MAX_PATH);
< 	}
---
> 	char * ptr = strrchr(lpFilename,'\\');
> 	if(ptr)
> 		ptr[1] = 0;
244c272,273
< char * lib3270_get_user_name() {
---
> char * lib3270_get_user_name()
> {
255c284,285
< static char * concat(char *path, const char *name, size_t *length) {
---
> static char * concat(char *path, const char *name, size_t *length)
> {
257c287
< 	size_t szCurrent = strlen(path);
---
>     size_t szCurrent = strlen(path);
259c289,290
< 	for(ptr=path; *ptr; ptr++) {
---
> 	for(ptr=path;*ptr;ptr++)
> 	{
269c300,301
< 	if(szCurrent >= *length) {
---
> 	if(szCurrent >= *length)
> 	{
279c311,312
< static char * build_filename(const char *str, va_list args) {
---
> static char * build_filename(const char *str, va_list args)
> {
285a319,322
> #ifdef DEBUG
> 	filename[0] = '.';
> 	filename[1] = '\\';
> #else
287a325
> #endif // DEBUG
290,299c328,329
< 	if(ptr) {
< 		ptr[0] = 0;
< 
< 		ptr = strrchr(filename,'\\');
< 		if(ptr && !(strcasecmp(ptr,"\\bin") && strcasecmp(ptr,"\\lib"))) {
< 			*ptr = 0;
< 		}
< 
< 		strncat(filename,"\\",szFilename);
< 	}
---
> 	if(ptr)
> 		ptr[1] = 0;
309,367c339,342
< char * lib3270_build_data_filename(const char *str, ...) {
< 
< 	char *ptr;
< 	lib3270_autoptr(char) instpath = lib3270_get_installation_path();
< 
< 	for(ptr = instpath; *ptr; ptr++) {
< 		if(*ptr == '/') {
< 			*ptr = '\\';
< 		}
< 	}
< 
< 	if( *(instpath+strlen(instpath)-1) == '\\') {
< 		instpath[strlen(instpath)-1] = 0;
< 	}
< 
< 	char relative[MAX_PATH+1];
< 	memset(relative,0,MAX_PATH);
< 
< 	{
< 		va_list args;
< 		va_start (args, str);
< 
< 		while(str) {
< 
< 			if(str[0] == '\\' || str[0] == '/') {
< 				strncat(relative,str,MAX_PATH);
< 			} else {
< 				strncat(relative,"\\",MAX_PATH);
< 				strncat(relative,str,MAX_PATH);
< 			}
< 
< 			str = va_arg(args, const char *);
< 		}
< 
< 		va_end (args);
< 	}
< 
< 	for(ptr = relative; *ptr; ptr++) {
< 		if(*ptr == '/') {
< 			*ptr = '\\';
< 		}
< 	}
< 
< 	char filename[MAX_PATH+1];
< 	memset(filename,0,MAX_PATH+1);
< 
< 	// Check instdir
< 	strncpy(filename,instpath,MAX_PATH);
< 	strncat(filename,"\\share",MAX_PATH);
< 	strncat(filename,relative,MAX_PATH);
< 
< 	if(access(filename,0) == 0) {
< 		return strdup(filename);
< 	}
< 
< 	strncpy(filename,instpath,MAX_PATH);
< 	strncat(filename,"\\share\\",MAX_PATH);
< 	strncat(filename,LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME),MAX_PATH);
< 	strncat(filename,relative,MAX_PATH);
---
> char * lib3270_build_data_filename(const char *str, ...)
> {
> 	va_list args;
> 	va_start (args, str);
369,371c344
< 	if(access(filename,0) == 0) {
< 		return strdup(filename);
< 	}
---
> 	char *filename = build_filename(str, args);
373,375c346
< 	// Default behavior.
< 	strncpy(filename,instpath,MAX_PATH);
< 	strncat(filename,relative,MAX_PATH);
---
> 	va_end (args);
377c348
< 	return strdup(filename);
---
> 	return filename;
380c351,352
< char * lib3270_build_config_filename(const char *str, ...) {
---
> char * lib3270_build_config_filename(const char *str, ...)
> {
391c363,364
< char * lib3270_build_filename(const char *str, ...) {
---
> char * lib3270_build_filename(const char *str, ...)
> {
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include: action_table.h
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/array.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/array.h
37c37
< #define LIB3270_ARRAY_H_INCLUDED
---
> 	#define LIB3270_ARRAY_H_INCLUDED
39,40c39,40
< #include <stddef.h>
< #include <lib3270.h>
---
> 	#include <stddef.h>
> 	#include <lib3270.h>
42,45c42,46
< typedef struct _lib3270_string_array {
< 	size_t length;	///< @brief Number of elements.
< 	const char **str;
< } LIB3270_STRING_ARRAY;
---
> 	typedef struct _lib3270_string_array
> 	{
> 		size_t length;	///< @brief Number of elements.
> 		const char **str;
> 	} LIB3270_STRING_ARRAY;
47,50c48,51
< LIB3270_INTERNAL LIB3270_STRING_ARRAY * lib3270_string_array_new(void);
< LIB3270_INTERNAL void lib3270_string_array_free(LIB3270_STRING_ARRAY *object);
< LIB3270_INTERNAL void lib3270_string_array_append(LIB3270_STRING_ARRAY *object, const char *str);
< LIB3270_INTERNAL void lib3270_string_array_append_with_length(LIB3270_STRING_ARRAY *array, const char *str, size_t length);
---
> 	LIB3270_INTERNAL LIB3270_STRING_ARRAY * lib3270_string_array_new(void);
> 	LIB3270_INTERNAL void lib3270_string_array_free(LIB3270_STRING_ARRAY *object);
> 	LIB3270_INTERNAL void lib3270_string_array_append(LIB3270_STRING_ARRAY *object, const char *str);
> 	LIB3270_INTERNAL void lib3270_string_array_append_with_length(LIB3270_STRING_ARRAY *array, const char *str, size_t length);
52c53
< LIB3270_INTERNAL void lib3270_autoptr_cleanup_LIB3270_STRING_ARRAY(LIB3270_STRING_ARRAY **ptr);
---
> 	LIB3270_INTERNAL void lib3270_autoptr_cleanup_LIB3270_STRING_ARRAY(LIB3270_STRING_ARRAY **ptr);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/cg.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/cg.h
219c219
< /* codes 0xc0 through 0xcf are for field attributes */
---
>     /* codes 0xc0 through 0xcf are for field attributes */
238c238
< /* codes 0xe0 through 0xef are for field attributes */
---
>     /* codes 0xe0 through 0xef are for field attributes */
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ctlrc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ctlrc.h
94,96c94,96
< LIB3270_INTERNAL enum dbcs_state ctlr_dbcs_state(int baddr);
< LIB3270_INTERNAL enum dbcs_state ctlr_lookleft_state(int baddr, enum dbcs_why *why);
< LIB3270_INTERNAL int ctlr_dbcs_postprocess(H3270 *hSession);
---
> 	LIB3270_INTERNAL enum dbcs_state ctlr_dbcs_state(int baddr);
> 	LIB3270_INTERNAL enum dbcs_state ctlr_lookleft_state(int baddr, enum dbcs_why *why);
> 	LIB3270_INTERNAL int ctlr_dbcs_postprocess(H3270 *hSession);
98,100c98,100
< #define ctlr_dbcs_state(b)		DBCS_NONE
< #define ctlr_lookleft_state(b, w)	DBCS_NONE
< #define ctlr_dbcs_postprocess(hSession)		0
---
> 	#define ctlr_dbcs_state(b)		DBCS_NONE
> 	#define ctlr_lookleft_state(b, w)	DBCS_NONE
> 	#define ctlr_dbcs_postprocess(hSession)		0
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ftc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ftc.h
23c23
< #include <lib3270/filetransfer.h>
---
> 	#include <lib3270/filetransfer.h>
27,29c27,29
< LIB3270_INTERNAL Boolean ascii_flag;
< LIB3270_INTERNAL Boolean cr_flag;
< LIB3270_INTERNAL unsigned long ft_length;
---
> 	LIB3270_INTERNAL Boolean ascii_flag;
> 	LIB3270_INTERNAL Boolean cr_flag;
> 	LIB3270_INTERNAL unsigned long ft_length;
31c31
< LIB3270_INTERNAL H3270FT	* get_ft_handle(H3270 *hSession);
---
> 	LIB3270_INTERNAL H3270FT	* get_ft_handle(H3270 *hSession);
33c33
< LIB3270_INTERNAL void		  ft_init(H3270 *hSession);
---
> 	LIB3270_INTERNAL void		  ft_init(H3270 *hSession);
35,40c35,40
< LIB3270_INTERNAL void		  ft_aborting(H3270FT *h, const char *reason);
< LIB3270_INTERNAL void		  ft_complete(H3270FT *h, const char *errmsg);
< LIB3270_INTERNAL void		  ft_failed(H3270FT *h, const char *errmsg);
< LIB3270_INTERNAL void		  ft_message(H3270FT *h, const char *msg);
< LIB3270_INTERNAL void		  ft_running(H3270FT *h, Boolean is_cut);
< LIB3270_INTERNAL void		  ft_update_length(H3270FT *h);
---
> 	LIB3270_INTERNAL void		  ft_aborting(H3270FT *h, const char *reason);
> 	LIB3270_INTERNAL void		  ft_complete(H3270FT *h, const char *errmsg);
> 	LIB3270_INTERNAL void		  ft_failed(H3270FT *h, const char *errmsg);
> 	LIB3270_INTERNAL void		  ft_message(H3270FT *h, const char *msg);
> 	LIB3270_INTERNAL void		  ft_running(H3270FT *h, Boolean is_cut);
> 	LIB3270_INTERNAL void		  ft_update_length(H3270FT *h);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ft_dftc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/ft_dftc.h
19c19
< //LIB3270_INTERNAL void set_dft_buffersize(H3270 *hSession);
---
> LIB3270_INTERNAL void set_dft_buffersize(H3270 *hSession);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/hostc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/hostc.h
38,39c38
< /// @brief Signal a state change.
< LIB3270_INTERNAL void lib3270_st_changed(H3270 *h, LIB3270_STATE tx, int mode);
---
> // #include "api.h"
41d39
< LIB3270_INTERNAL void host_in3270(H3270 *session, LIB3270_CSTATE);
43c41,48
< LIB3270_INTERNAL int host_disconnect(H3270 *h, int failed);
---
> /**
>  * @brief Signal a state change.
>  */
>  LIB3270_INTERNAL void lib3270_st_changed(H3270 *h, LIB3270_STATE tx, int mode);
> 
>  LIB3270_INTERNAL void host_in3270(H3270 *session, LIB3270_CSTATE);
> 
>  LIB3270_INTERNAL int host_disconnect(H3270 *h, int failed);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/internals.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/internals.h
31,32c31,32
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
44,45d43
< #include <lib3270/log.h>
< #include <lib3270/trace.h>
48c46
< #include <openssl/x509.h>
---
> 	#include <openssl/x509.h>
52c50
< #define X3270_ANSI	1	// RFC2355 requires NVT mode
---
> 		#define X3270_ANSI	1	// RFC2355 requires NVT mode
56c54
< #define _GNU_SOURCE		// vasprintf isn't POSIX
---
> 	#define _GNU_SOURCE		// vasprintf isn't POSIX
61,64c59,62
< #include <locale.h>
< #include <libintl.h>
< #define _( x ) 			dgettext(GETTEXT_PACKAGE,x)
< #define N_( x ) 		x
---
> 	#include <locale.h>
> 	#include <libintl.h>
> 	#define _( x ) 			dgettext(GETTEXT_PACKAGE,x)
> 	#define N_( x ) 		x
66,67c64,65
< #define _( x ) 			x
< #define N_( x ) 		x
---
> 	#define _( x ) 			x
> 	#define N_( x ) 		x
79c77
< #define GNUC_UNUSED \
---
> 	#define GNUC_UNUSED \
84,86c82,84
< #define unused
< #define GNUC_UNUSED
< #define printflike(s, f)
---
> 	#define unused
> 	#define GNUC_UNUSED
> 	#define printflike(s, f)
92,93c90,91
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
97c95
< #include <sys/time.h>			/* System time-related data types */
---
> 	#include <sys/time.h>			/* System time-related data types */
115,116c113,114
< #undef X3270_KEYPAD
< #undef X3270_MENUS
---
> 	#undef X3270_KEYPAD
> 	#undef X3270_MENUS
119,120c117,118
< //#define RECONNECT_MS		2000	/**< @brief 2 sec before reconnecting to host. */
< //#define RECONNECT_ERR_MS	5000	/**< @brief 5 sec before reconnecting to host when failed */
---
> #define RECONNECT_MS		2000	/**< @brief 2 sec before reconnecting to host. */
> #define RECONNECT_ERR_MS	5000	/**< @brief 5 sec before reconnecting to host when failed */
132a131,140
> // Version strings
> /*
> LIB3270_INTERNAL const char * build;
> LIB3270_INTERNAL const char * app_defaults_version;
> LIB3270_INTERNAL const char * sccsid;
> LIB3270_INTERNAL const char * build_rpq_timestamp;
> LIB3270_INTERNAL const char * build_rpq_version;
> LIB3270_INTERNAL const char * build_rpq_revision;
> */
> 
134c142
< LIB3270_INTERNAL Boolean		dbcs;
---
> 	LIB3270_INTERNAL Boolean		dbcs;
175c183
< #define SETLINEBUF(s)	setvbuf(s, (char *)NULL, _IOLBF, BUFSIZ)
---
> 	#define SETLINEBUF(s)	setvbuf(s, (char *)NULL, _IOLBF, BUFSIZ)
177c185
< #define SETLINEBUF(s)	setlinebuf(s)
---
> 	#define SETLINEBUF(s)	setlinebuf(s)
183c191
< #define gettimeofday(tp,tz)	gettimeofday(tp)
---
> 	#define gettimeofday(tp,tz)	gettimeofday(tp)
188c196
< #define DFT_BUF		(4 * 1024)
---
> 	#define DFT_BUF		(4 * 1024)
194c202,203
< enum keytype {
---
> enum keytype
> {
199c208,209
< LIB3270_INTERNAL struct _ansictl {
---
> LIB3270_INTERNAL struct _ansictl
> {
213c223,224
< struct lib3270_ea {
---
> struct lib3270_ea
> {
224c235,236
< struct lib3270_text {
---
> struct lib3270_text
> {
230c242
< #define LIB3270_TA void
---
> 	#define LIB3270_TA void
245c257,258
< typedef struct timeout {
---
> typedef struct timeout
> {
266c279,280
< typedef struct _input_t {
---
> typedef struct _input_t
> {
277c291,292
< struct lib3270_state_callback {
---
> struct lib3270_state_callback
> {
283c298,299
< struct lib3270_toggle_callback {
---
> struct lib3270_toggle_callback
> {
294c310,311
< struct _h3270 {
---
> struct _h3270
> {
315,316d331
< 		unsigned int		  retry;							///< @brief Time to retry when connection ends with error.
< 		LIB3270_POPUP		* error;							///< @brief Last connection error.
322,334c337,349
< 	unsigned int		  	  selected					: 1;	///< @brief Has selected region?
< 	unsigned int			  has_copy					: 1;	///< @brief Has copy?
< 	unsigned int			  rectsel					: 1;	///< @brief Selected region is a rectangle ?
< 	unsigned int			  vcontrol					: 1;	///< @brief Visible control ?
< 	unsigned int			  modified_sel				: 1;
< 	unsigned int			  mono						: 1;	///< @brief Forces monochrome display
< 	unsigned int			  m3279						: 1;
< 	unsigned int 			  extended					: 1;	///< @brief Extended data stream.
< 	unsigned int			  typeahead					: 1;
< 	unsigned int			  numeric_lock				: 1;
< 	unsigned int			  oerr_lock					: 1;	///< @brief If true, operator errors will lock the keyboard.
< 	unsigned int			  unlock_delay				: 1;	///< @brief If true the unlock delay feature is enabled. @see lib3270_set_unlock_delay
< 	unsigned int 			  auto_reconnect_inprogress	: 1;
---
> 	int					  	  selected					: 1;	///< @brief Has selected region?
> 	int						  has_copy					: 1;	///< @brief Has copy?
> 	int						  rectsel					: 1;	///< @brief Selected region is a rectangle ?
> 	int						  vcontrol					: 1;	///< @brief Visible control ?
> 	int						  modified_sel				: 1;
> 	int						  mono						: 1;	///< @brief Forces monochrome display
> 	int						  m3279						: 1;
> 	int 					  extended					: 1;	///< @brief Extended data stream.
> 	int						  typeahead					: 1;
> 	int						  numeric_lock				: 1;
> 	int						  oerr_lock					: 1;	///< @brief If true, operator errors will lock the keyboard.
> 	int						  unlock_delay				: 1;	///< @brief If true the unlock delay feature is enabled. @see lib3270_set_unlock_delay
> 	int			 			  auto_reconnect_inprogress	: 1;
336,354c351,371
< 	unsigned int			  apl_mode					: 1;	///< @brief If true enables APL mode.
< 	unsigned int			  icrnl						: 1;
< 	unsigned int			  inlcr						: 1;
< 	unsigned int			  onlcr						: 1;
< 	unsigned int			  bsd_tm					: 1;
< 	unsigned int			  syncing					: 1;
< 	unsigned int			  reverse                   : 1;    ///< @brief reverse-input mode
< 	unsigned int			  dbcs						: 1;
< 	unsigned int	   		  linemode					: 1;
< 	unsigned int			  trace_skipping			: 1;
< 	unsigned int			  need_tls_follows			: 1;
< 	unsigned int			  cut_xfer_in_progress		: 1;
< 	unsigned int			  formatted					: 1;	///< @brief Formatted screen flag
< 	unsigned int			  starting					: 1;	///< @brief Is starting (no first screen)?
< 
< 	struct lib3270_toggle {
< 		char value;																		///< toggle value
< 		void (*upcall)(H3270 *, const struct lib3270_toggle *, LIB3270_TOGGLE_TYPE);	///< change value
< 	} toggle[LIB3270_TOGGLE_COUNT];
---
> 	int						  apl_mode					: 1;	///< @brief If true enables APL mode.
> 	int						  icrnl						: 1;
> 	int						  inlcr						: 1;
> 	int						  onlcr						: 1;
> 	int						  bsd_tm					: 1;
> 	int 					  syncing					: 1;
> 	int						  reverse 					: 1;	/**< @brief reverse-input mode */
> 	int						  dbcs						: 1;
> 	int             		  linemode					: 1;
> 	int						  trace_skipping			: 1;
> 	int						  need_tls_follows			: 1;
> 	int						  cut_xfer_in_progress		: 1;
> //		int						  auto_keymap				: 1;
> 	int						  formatted					: 1;	/**< @brief Formatted screen flag */
> 	int						  starting					: 1;	/**< @brief Is starting (no first screen)? */
> 
> 	struct lib3270_toggle
> 	{
> 		char value;																		/**< toggle value */
> 		void (*upcall)(H3270 *, const struct lib3270_toggle *, LIB3270_TOGGLE_TYPE);	/**< change value */
> 	}						  toggle[LIB3270_TOGGLE_COUNT];
363c380,381
< 	struct {
---
> 	struct
> 	{
374c392,393
< 	struct {
---
> 	struct
> 	{
387c406,407
< 	struct {
---
> 	struct
> 	{
394c414,415
< 	struct {
---
> 	struct
> 	{
433,435c454,456
< 	unsigned int 			  trace_primed 		: 1;
< 	unsigned int			  ticking			: 1;
< 	unsigned int			  mticking			: 1;
---
> 	int 					  trace_primed 		: 1;
> 	int						  ticking			: 1;
> 	int						  mticking			: 1;
461c482,483
< 	struct {
---
> 	struct
> 	{
473c495,496
< 	enum {
---
> 	enum
> 	{
492c515,516
< 	struct {
---
> 	struct
> 	{
522c546
< 	unsigned int			  rpq_complained : 1;
---
> 	int						  rpq_complained : 1;
524c548
< 	unsigned int			  omit_due_space_limit : 1;
---
> 	int						  omit_due_space_limit : 1;
535c559,560
< 	struct {
---
> 	struct
> 	{
546c571
< 	unsigned int			  held_wrap					: 1;
---
> 	int						  held_wrap					: 1;
548,549c573,574
< 	unsigned int			  insert_mode				: 1;
< 	unsigned int			  auto_newline_mode			: 1;
---
> 	int						  insert_mode				: 1;
> 	int						  auto_newline_mode			: 1;
551,552c576,577
< 	unsigned int			  appl_cursor				: 1;
< 	unsigned int			  saved_appl_cursor			: 1;
---
> 	int						  appl_cursor				: 1;
> 	int						  saved_appl_cursor			: 1;
554,555c579,580
< 	unsigned int  			  wraparound_mode			: 1;
< 	unsigned int			  saved_wraparound_mode		: 1;
---
> 	int  					  wraparound_mode			: 1;
> 	int						  saved_wraparound_mode		: 1;
557,558c582,583
< 	unsigned int			  rev_wraparound_mode 		: 1;
< 	unsigned int			  saved_rev_wraparound_mode	: 1;
---
> 	int						  rev_wraparound_mode 		: 1;
> 	int						  saved_rev_wraparound_mode	: 1;
560,561c585,586
< 	unsigned int			  allow_wide_mode			: 1;
< 	unsigned int			  saved_allow_wide_mode		: 1;
---
> 	int						  allow_wide_mode			: 1;
> 	int						  saved_allow_wide_mode		: 1;
563,564c588,589
< 	unsigned int			  wide_mode 				: 1;
< 	unsigned int			  saved_wide_mode			: 1;
---
> 	int						  wide_mode 				: 1;
> 	int						  saved_wide_mode			: 1;
566,567c591,592
< 	unsigned int			  saved_altbuffer			: 1;
< 	unsigned int			  ansi_reset				: 1;	/**< @brief Non zero if the ansi_reset() was called in this session */
---
> 	int						  saved_altbuffer			: 1;
> 	int						  ansi_reset				: 1;	/**< @brief Non zero if the ansi_reset() was called in this session */
573c598,599
< 	enum lib3270_ansi_cs {
---
> 	enum lib3270_ansi_cs
> 	{
582c608,609
< 	enum lib3270_ansi_csd {
---
> 	enum lib3270_ansi_csd
> 	{
589c616,617
< 	enum lib3270_ansi_state {
---
> 	enum lib3270_ansi_state
> 	{
623c651,652
< 	struct {
---
> 	struct
> 	{
625c654
< 		unsigned int changed : 1;
---
> 		int changed : 1;
629,631c658,660
< 	struct {
< 		char *file;	///< @brief Trace file name (if set).
< 		LIB3270_TRACE_HANDLER handler;
---
> 	struct
> 	{
> 		void (*handler)(H3270 *session, void *userdata, const char *fmt, va_list args);
635,643c664,667
< 	struct {
< 		char *file; 		///< @brief Log file name (if set).
< 		LIB3270_LOG_HANDLER handler;
< 		void *userdata;
< 	} log;
< 
< 	struct {
< 		unsigned int					  host			: 1;		///< @brief Non zero if host requires SSL.
< 		unsigned int					  download_crl	: 1;		///< @brief Non zero to download CRL.
---
> 	struct
> 	{
> 		int								  host			: 1;		///< @brief Non zero if host requires SSL.
> 		int								  download_crl	: 1;		///< @brief Non zero to download CRL.
651c675,676
< 	struct {
---
> 	struct
> 	{
663d687
< 	unsigned int tasks;
705,706c729,730
< #define CHECK_SESSION_HANDLE(x) check_session_handle(&x,__FUNCTION__);
< LIB3270_INTERNAL void check_session_handle(H3270 **hSession, const char *fname);
---
> 	#define CHECK_SESSION_HANDLE(x) check_session_handle(&x,__FUNCTION__);
> 	LIB3270_INTERNAL void check_session_handle(H3270 **hSession, const char *fname);
708,709c732,733
< #define CHECK_SESSION_HANDLE(x) check_session_handle(&x);
< LIB3270_INTERNAL void check_session_handle(H3270 **hSession);
---
> 	#define CHECK_SESSION_HANDLE(x) check_session_handle(&x);
> 	LIB3270_INTERNAL void check_session_handle(H3270 **hSession);
737,781c761,762
< /// @brief Clear element at adress.
< LIB3270_INTERNAL void clear_chr(H3270 *hSession, int baddr);
< 
< LIB3270_INTERNAL unsigned char get_field_attribute(H3270 *session, int baddr);
< 
< /// @brief Default log writer.
< LIB3270_INTERNAL int default_loghandler(const H3270 *session, void *dunno, const char *module, int rc, const char *message);
< 
< LIB3270_INTERNAL char * lib3270_get_user_name();
< 
< /// @brief Query data from URL.
< ///
< /// @param hSession		Handle of the TN3270 Session.
< /// @param url			The url to get.
< /// @param length		Pointer to the response lenght (can be NULL).
< /// @param error		Pointer to the detailed error message.
< ///
< /// @return The data from URL (release it with lib3270_free) or NULL on error.
< ///
< LIB3270_INTERNAL char * lib3270_url_get(H3270 *hSession, const char *url, const char **error);
< 
< /// @brief Load text file.
< ///
< /// @param hSession		Handle of the TN3270 Session.
< /// @param filename		The file name.
< ///
< /// @return The file contents (release it with lib3270_free or NULL on error (sets errno).
< ///
< LIB3270_INTERNAL char * lib3270_file_get_contents(H3270 *hSession, const char *filename);
< 
< 
< /// @brief Fire CState change.
< LIB3270_INTERNAL int lib3270_set_cstate(H3270 *hSession, LIB3270_CSTATE cstate);
< 
< ///
< /// @brief Start TLS/SSL
< ///
< /// @param hSession	Session handle.
< /// @param required	Non zero if the SSL/TLS is not optional.
< ///
< /// @return 0 if ok, non zero if failed.
< ///
< /// @retval ENOTSUP	TLS/SSL is not supported by library.
< ///
< LIB3270_INTERNAL int lib3270_start_tls(H3270 *hSession);
---
> 	/// @brief Clear element at adress.
> 	LIB3270_INTERNAL void clear_chr(H3270 *hSession, int baddr);
783c764
< LIB3270_INTERNAL void lib3270_notify_tls(H3270 *hSession);
---
> 	LIB3270_INTERNAL unsigned char get_field_attribute(H3270 *session, int baddr);
784a766,767
> 	/// @brief Default log writer.
> 	LIB3270_INTERNAL void default_log_writer(H3270 *session, const char *module, int rc, const char *fmt, va_list arg_ptr);
786,799c769,823
< /**
<  * @brief Emit translated popup message.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param popup		Popup descriptor.
<  * @param wait		If non zero waits for user response.
<  *
<  * @return User action.
<  *
<  * @retval 0			User has confirmed, continue action.
<  * @retval ECANCELED	Operation was canceled.
<  * @retval ENOTSUP		No popup handler available.
<  */
< LIB3270_INTERNAL int lib3270_popup_translated(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
---
> 	LIB3270_INTERNAL char * lib3270_get_user_name();
> 
> 	/// @brief Query data from URL.
> 	///
> 	/// @param hSession		Handle of the TN3270 Session.
> 	/// @param url			The url to get.
> 	/// @param length		Pointer to the response lenght (can be NULL).
> 	/// @param error		Pointer to the detailed error message.
> 	///
> 	/// @return The data from URL (release it with lib3270_free) or NULL on error.
> 	///
> 	LIB3270_INTERNAL char * lib3270_url_get(H3270 *hSession, const char *url, const char **error);
> 
> 	/// @brief Load text file.
> 	///
> 	/// @param hSession		Handle of the TN3270 Session.
> 	/// @param filename		The file name.
> 	///
> 	/// @return The file contents (release it with lib3270_free or NULL on error (sets errno).
> 	///
> 	LIB3270_INTERNAL char * lib3270_file_get_contents(H3270 *hSession, const char *filename);
> 
> 
> 	/// @brief Fire CState change.
> 	LIB3270_INTERNAL int lib3270_set_cstate(H3270 *hSession, LIB3270_CSTATE cstate);
> 
> 	///
> 	/// @brief Start TLS/SSL
> 	///
> 	/// @param hSession	Session handle.
> 	/// @param required	Non zero if the SSL/TLS is not optional.
> 	///
> 	/// @return 0 if ok, non zero if failed.
> 	///
> 	/// @retval ENOTSUP	TLS/SSL is not supported by library.
> 	///
> 	LIB3270_INTERNAL int lib3270_start_tls(H3270 *hSession);
> 
> 	LIB3270_INTERNAL void lib3270_notify_tls(H3270 *hSession);
> 
> 
> 	/**
> 	 * @brief Emit translated popup message.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 * @param popup		Popup descriptor.
> 	 * @param wait		If non zero waits for user response.
> 	 *
> 	 * @return User action.
> 	 *
> 	 * @retval 0			User has confirmed, continue action.
> 	 * @retval ECANCELED	Operation was canceled.
> 	 * @retval ENOTSUP		No popup handler available.
> 	 */
> 	LIB3270_INTERNAL int lib3270_popup_translated(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
802,810c826,834
< /**
<  * @brief Download X509 CRL using LDAP backend.
<  *
<  * @param hSession	tn3270 session handle.
<  * @param url		URL for Ldap access.
<  * @param error		pointer to error message.
<  *
<  */
< LIB3270_INTERNAL X509_CRL * lib3270_crl_get_using_ldap(H3270 *hSession, const char *url, const char **error);
---
> 	/**
> 	 * @brief Download X509 CRL using LDAP backend.
> 	 *
> 	 * @param hSession	tn3270 session handle.
> 	 * @param url		URL for Ldap access.
> 	 * @param error		pointer to error message.
> 	 *
> 	 */
> 	LIB3270_INTERNAL X509_CRL * lib3270_crl_get_using_ldap(H3270 *hSession, const char *url, const char **error);
815c839
< LIB3270_INTERNAL char * lib3270_get_from_url(H3270 *hSession, const char *url, const char **error_message);
---
> 	LIB3270_INTERNAL char * lib3270_get_from_url(H3270 *hSession, const char *url, const char **error_message);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/kybdc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/kybdc.h
21,22c21,22
< #define KYBDC_H_INCLUDED
< #include <lib3270/keyboard.h>
---
> 	#define KYBDC_H_INCLUDED
> 	#include <lib3270/keyboard.h>
24,85c24,90
< /// @brief Element in typeahead queue.
< struct ta {
< 	struct ta *next;
< 
< 	enum _ta_type {
< 		TA_TYPE_DEFAULT,
< 		TA_TYPE_KEY_AID,
< 		TA_TYPE_ACTION,
< 		TA_TYPE_CURSOR_MOVE,
< 		TA_TYPE_USER
< 	} type;
< 
< 	union {
< 		unsigned char aid_code;
< 		struct {
< 			void (*fn)(H3270 *, const char *, const char *);
< 			char *parm[2];
< 		} def;
< 
< 		int (*action)(H3270 *);
< 
< 		struct {
< 			LIB3270_DIRECTION direction;
< 			unsigned char sel;
< 			int (*fn)(H3270 *, LIB3270_DIRECTION, unsigned char);
< 		} move;
< 
< 	} args;
< 
< };
< 
< #define KL_OERR_MASK		LIB3270_KL_OERR_MASK
< #define KL_OERR_PROTECTED	LIB3270_KL_OERR_PROTECTED
< #define KL_OERR_NUMERIC		LIB3270_KL_OERR_NUMERIC
< #define KL_OERR_OVERFLOW	LIB3270_KL_OERR_OVERFLOW
< #define KL_OERR_DBCS		LIB3270_KL_OERR_DBCS
< #define	KL_NOT_CONNECTED	LIB3270_KL_NOT_CONNECTED
< #define	KL_AWAITING_FIRST	LIB3270_KL_AWAITING_FIRST
< #define	KL_OIA_TWAIT		LIB3270_KL_OIA_TWAIT
< #define	KL_OIA_LOCKED		LIB3270_KL_OIA_LOCKED
< #define	KL_DEFERRED_UNLOCK	LIB3270_KL_DEFERRED_UNLOCK
< #define KL_ENTER_INHIBIT	LIB3270_KL_ENTER_INHIBIT
< #define KL_SCROLLED			LIB3270_KL_SCROLLED
< #define KL_OIA_MINUS		LIB3270_KL_OIA_MINUS
< 
< #define KYBDLOCK_IS_OERR(hSession)	(hSession->kybdlock && !(hSession->kybdlock & ~KL_OERR_MASK))
< 
< /* other functions */
< //LIB3270_INTERNAL void add_xk(KeySym key, KeySym assoc);
< LIB3270_INTERNAL void clear_xks(void);
< LIB3270_INTERNAL void do_reset(H3270 *session, Boolean explicit);
< 
< LIB3270_INTERNAL void lib3270_kybdlock_clear(H3270 *hSession, LIB3270_KEYBOARD_LOCK_STATE bits);
< 
< LIB3270_INTERNAL void kybd_inhibit(H3270 *session, Boolean inhibit);
< LIB3270_INTERNAL int  kybd_prime(H3270 *hSession);
< LIB3270_INTERNAL void kybd_scroll_lock(Boolean lock);
< LIB3270_INTERNAL void kybd_connect(H3270 *session, int connected, void *dunno);
< LIB3270_INTERNAL void kybd_in3270(H3270 *session, int in3270, void *dunno);
< 
< LIB3270_INTERNAL int			run_ta(H3270 *hSession);
< LIB3270_INTERNAL struct ta *	new_ta(H3270 *hSession, enum _ta_type type);
---
> 	/// @brief Element in typeahead queue.
> 	struct ta
> 	{
> 		struct ta *next;
> 
> 		enum _ta_type
> 		{
> 			TA_TYPE_DEFAULT,
> 			TA_TYPE_KEY_AID,
> 			TA_TYPE_ACTION,
> 			TA_TYPE_CURSOR_MOVE,
> 			TA_TYPE_USER
> 		} type;
> 
> 		union
> 		{
> 			unsigned char aid_code;
> 			struct
> 			{
> 				void (*fn)(H3270 *, const char *, const char *);
> 				char *parm[2];
> 			} def;
> 
> 			int (*action)(H3270 *);
> 
> 			struct
> 			{
> 				LIB3270_DIRECTION direction;
> 				unsigned char sel;
> 				int (*fn)(H3270 *, LIB3270_DIRECTION, unsigned char);
> 			} move;
> 
> 		} args;
> 
> 	};
> 
> 	#define KL_OERR_MASK		LIB3270_KL_OERR_MASK
> 	#define KL_OERR_PROTECTED	LIB3270_KL_OERR_PROTECTED
> 	#define KL_OERR_NUMERIC		LIB3270_KL_OERR_NUMERIC
> 	#define KL_OERR_OVERFLOW	LIB3270_KL_OERR_OVERFLOW
> 	#define KL_OERR_DBCS		LIB3270_KL_OERR_DBCS
> 	#define	KL_NOT_CONNECTED	LIB3270_KL_NOT_CONNECTED
> 	#define	KL_AWAITING_FIRST	LIB3270_KL_AWAITING_FIRST
> 	#define	KL_OIA_TWAIT		LIB3270_KL_OIA_TWAIT
> 	#define	KL_OIA_LOCKED		LIB3270_KL_OIA_LOCKED
> 	#define	KL_DEFERRED_UNLOCK	LIB3270_KL_DEFERRED_UNLOCK
> 	#define KL_ENTER_INHIBIT	LIB3270_KL_ENTER_INHIBIT
> 	#define KL_SCROLLED			LIB3270_KL_SCROLLED
> 	#define KL_OIA_MINUS		LIB3270_KL_OIA_MINUS
> 
> 	#define KYBDLOCK_IS_OERR(hSession)	(hSession->kybdlock && !(hSession->kybdlock & ~KL_OERR_MASK))
> 
> 	/* other functions */
> 	LIB3270_INTERNAL void add_xk(KeySym key, KeySym assoc);
> 	LIB3270_INTERNAL void clear_xks(void);
> 	LIB3270_INTERNAL void do_reset(H3270 *session, Boolean explicit);
> 
> 	LIB3270_INTERNAL void lib3270_kybdlock_clear(H3270 *hSession, LIB3270_KEYBOARD_LOCK_STATE bits);
> 
> 	LIB3270_INTERNAL void kybd_inhibit(H3270 *session, Boolean inhibit);
> 	LIB3270_INTERNAL int  kybd_prime(H3270 *hSession);
> 	LIB3270_INTERNAL void kybd_scroll_lock(Boolean lock);
> 	LIB3270_INTERNAL void kybd_connect(H3270 *session, int connected, void *dunno);
> 	LIB3270_INTERNAL void kybd_in3270(H3270 *session, int in3270, void *dunno);
> 
> 	LIB3270_INTERNAL int			run_ta(H3270 *hSession);
> 	LIB3270_INTERNAL struct ta *	new_ta(H3270 *hSession, enum _ta_type type);
87,88c92,93
< /// @brief Put a lib3270 action on the typeahead queue.
< LIB3270_INTERNAL void			enq_action(H3270 *hSession, int (*fn)(H3270 *));
---
> 	/// @brief Put a lib3270 action on the typeahead queue.
> 	LIB3270_INTERNAL void			enq_action(H3270 *hSession, int (*fn)(H3270 *));
90,91c95,96
< /// @brief Put a typeahed action on the typeahead queue.
< LIB3270_INTERNAL void			enq_ta(H3270 *hSession, void (*fn)(H3270 *, const char *, const char *), const char *parm1, const char *parm2);
---
> 	/// @brief Put a typeahed action on the typeahead queue.
> 	LIB3270_INTERNAL void			enq_ta(H3270 *hSession, void (*fn)(H3270 *, const char *, const char *), const char *parm1, const char *parm2);
93,94c98,99
< /// @brief Lock the keyboard because of an operator error.
< LIB3270_INTERNAL void			operator_error(H3270 *hSession, int error_type);
---
> 	/// @brief Lock the keyboard because of an operator error.
> 	LIB3270_INTERNAL void			operator_error(H3270 *hSession, int error_type);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/actions.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/actions.h
30c30
< #define LIB3270_ACTIONS_H_INCLUDED 1
---
> 	#define LIB3270_ACTIONS_H_INCLUDED 1
33c33
< extern "C" {
---
> 	extern "C" {
36c36,37
< typedef enum _lib3270_action_type {
---
>  typedef enum _lib3270_action_type
>  {
45c46
< } LIB3270_ACTION_TYPE;
---
>  } LIB3270_ACTION_TYPE;
47,48c48,50
< typedef struct _lib3270_action {
< 	LIB3270_PROPERTY_HEAD
---
>  typedef struct _lib3270_action
>  {
>  	LIB3270_PROPERTY_HEAD
52,53c54,55
< 	int (*activate)(H3270 *hSession);			///< @brief lib3270 associated method.
< 	int (*activatable)(const H3270 *hSession);	///< @brief Is the action activatable?
---
>     int (*activate)(H3270 *hSession);			///< @brief lib3270 associated method.
>     int (*activatable)(const H3270 *hSession);	///< @brief Is the action activatable?
55c57
< 	const char *keys;							///< @brief Default accelerators (or NULL if no default).
---
>     const char *keys;							///< @brief Default accelerators (or NULL if no default).
57c59
< } LIB3270_ACTION;
---
>  } LIB3270_ACTION;
68c70
< LIB3270_EXPORT int lib3270_action_group_get_activatable(const H3270 *hSession, const LIB3270_ACTION_GROUP group);
---
>  LIB3270_EXPORT int lib3270_action_group_get_activatable(const H3270 *hSession, const LIB3270_ACTION_GROUP group);
81c83
< LIB3270_EXPORT const void * lib3270_register_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, void (*func)(H3270 *, void *),void *data);
---
>  LIB3270_EXPORT const void * lib3270_register_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, void (*func)(H3270 *, void *),void *data);
93c95
< LIB3270_EXPORT int lib3270_unregister_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, const void *id);
---
>  LIB3270_EXPORT int lib3270_unregister_action_group_listener(H3270 *hSession, LIB3270_ACTION_GROUP group, const void *id);
108c110
< LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_action(H3270 *hSession, const char *name));
---
>  LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_action(H3270 *hSession, const char *name));
124c126
< LIB3270_EXPORT int lib3270_activate_by_name(H3270 *hSession, const char *name);
---
>  LIB3270_EXPORT int lib3270_activate_by_name(H3270 *hSession, const char *name);
137c139
< LIB3270_EXPORT int lib3270_action_activate(const LIB3270_ACTION *action, H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_action_activate(const LIB3270_ACTION *action, H3270 *hSession);
148c150
< LIB3270_EXPORT int lib3270_action_is_activatable(const LIB3270_ACTION *action, H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_action_is_activatable(const LIB3270_ACTION *action, H3270 *hSession);
159c161
< LIB3270_EXPORT int lib3270_enter(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_enter(H3270 *hSession);
171c173
< LIB3270_EXPORT int lib3270_pfkey(H3270 *hSession, int keycode);
---
>  LIB3270_EXPORT int lib3270_pfkey(H3270 *hSession, int keycode);
183c185
< LIB3270_EXPORT int lib3270_pakey(H3270 *hSession, int keycode);
---
>  LIB3270_EXPORT int lib3270_pakey(H3270 *hSession, int keycode);
194c196
< LIB3270_EXPORT int lib3270_cursor_up(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_cursor_up(H3270 *hSession);
205c207
< LIB3270_EXPORT int lib3270_cursor_down(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_cursor_down(H3270 *hSession);
216c218
< LIB3270_EXPORT int lib3270_cursor_left(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_cursor_left(H3270 *hSession);
227c229
< LIB3270_EXPORT int lib3270_cursor_right(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_cursor_right(H3270 *hSession);
238c240
< LIB3270_EXPORT int lib3270_newline(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_newline(H3270 *hSession);
249c251
< LIB3270_EXPORT int lib3270_kybdreset(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_kybdreset(H3270 *hSession);
260c262
< LIB3270_EXPORT int lib3270_clear(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_clear(H3270 *hSession);
271c273
< LIB3270_EXPORT int lib3270_eraseinput(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_eraseinput(H3270 *hSession);
282c284
< LIB3270_EXPORT int lib3270_select_field(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_select_field(H3270 *hSession);
293c295
< LIB3270_EXPORT int lib3270_select_all(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_select_all(H3270 *hSession);
304c306
< LIB3270_EXPORT int lib3270_unselect(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_unselect(H3270 *hSession);
315c317
< LIB3270_EXPORT int lib3270_reselect(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_reselect(H3270 *hSession);
326c328
< LIB3270_EXPORT int lib3270_eraseeof(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_eraseeof(H3270 *hSession);
337c339
< LIB3270_EXPORT int lib3270_eraseeol(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_eraseeol(H3270 *hSession);
348c350
< LIB3270_EXPORT int lib3270_erase(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_erase(H3270 *hSession);
359c361
< LIB3270_EXPORT int lib3270_delete(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_delete(H3270 *hSession);
370c372
< LIB3270_EXPORT int lib3270_dup(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_dup(H3270 *hSession);
381c383
< LIB3270_EXPORT int lib3270_fieldmark(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_fieldmark(H3270 *hSession);
392c394
< LIB3270_EXPORT int lib3270_backspace(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_backspace(H3270 *hSession);
403c405
< LIB3270_EXPORT int lib3270_previousword(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_previousword(H3270 *hSession);
414c416
< LIB3270_EXPORT int lib3270_nextword(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_nextword(H3270 *hSession);
425c427
< LIB3270_EXPORT int lib3270_fieldend(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_fieldend(H3270 *hSession);
436c438
< LIB3270_EXPORT int lib3270_firstfield(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_firstfield(H3270 *hSession);
447c449
< LIB3270_EXPORT int lib3270_nextfield(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_nextfield(H3270 *hSession);
458c460
< LIB3270_EXPORT int lib3270_previousfield(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_previousfield(H3270 *hSession);
469c471
< LIB3270_EXPORT int lib3270_attn(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_attn(H3270 *hSession);
480c482
< LIB3270_EXPORT int lib3270_break(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_break(H3270 *hSession);
491c493
< LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession);
502c504
< LIB3270_EXPORT int lib3270_deleteword(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_deleteword(H3270 *hSession);
513c515
< LIB3270_EXPORT int lib3270_deletefield(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_deletefield(H3270 *hSession);
524c526
< LIB3270_EXPORT int lib3270_sysreq(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_sysreq(H3270 *hSession);
535c537
< LIB3270_EXPORT int lib3270_testpattern(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_testpattern(H3270 *hSession);
546c548
< LIB3270_EXPORT int lib3270_charsettable(H3270 *hSession);
---
>  LIB3270_EXPORT int lib3270_charsettable(H3270 *hSession);
554c556
< LIB3270_EXPORT const LIB3270_ACTION * lib3270_action_get_by_name(const char *name);
---
>  LIB3270_EXPORT const LIB3270_ACTION * lib3270_action_get_by_name(const char *name);
556c558
< LIB3270_EXPORT const LIB3270_ACTION * LIB3270_DEPRECATED(lib3270_get_action(const char *name));
---
>  LIB3270_EXPORT const LIB3270_ACTION * LIB3270_DEPRECATED(lib3270_get_action(const char *name));
564c566
< LIB3270_EXPORT const LIB3270_ACTION * lib3270_get_actions();
---
>  LIB3270_EXPORT const LIB3270_ACTION * lib3270_get_actions();
567c569
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/charset.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/charset.h
34c34
< #define LIB3270_CHARSET_H_INCLUDED 1
---
> 	#define LIB3270_CHARSET_H_INCLUDED 1
37c37
< extern "C" {
---
> 	extern "C" {
40,41c40,41
< #define LIB3270_DEFAULT_CGEN			0x02b90000
< #define LIB3270_DEFAULT_CSET			0x00000025
---
> 	#define LIB3270_DEFAULT_CGEN			0x02b90000
> 	#define LIB3270_DEFAULT_CSET			0x00000025
43,113c43,115
< struct lib3270_charset {
< 	char			* host;
< 	char			* display;
< 	unsigned long	  cgcsgid;
< 
< 	// Translation tables
< 	unsigned short		  ebc2asc[256];
< 	unsigned short 		  asc2ebc[256];
< 
< 	unsigned short		  asc2uc[256];
< 
< };
< 
< typedef enum {
< 	CS_ONLY,
< 	FT_ONLY,
< 	BOTH
< } lib3270_remap_scope;
< 
< /**
<  * @brief Set host charset.
<  *
<  * @param hSession	Session Handle.
<  * @param name		Charset name (us, bracket, cp500) or NULL to lib3270's default.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  * @retval EINVAL	Invalid charset name.
<  *
<  */
< LIB3270_EXPORT int			  lib3270_set_host_charset(H3270 *hSession, const char *name);
< 
< LIB3270_EXPORT const char	* lib3270_get_host_charset(const H3270 *hSession);
< LIB3270_EXPORT void 		  lib3270_reset_charset(H3270 *hSession, const char * host, const char * display, unsigned long cgcsgid);
< 
< LIB3270_EXPORT void			  lib3270_remap_char(H3270 *hSession, unsigned short ebc, unsigned short iso, lib3270_remap_scope scope, unsigned char one_way);
< LIB3270_EXPORT const char	* lib3270_ebc2asc(H3270 *hSession, unsigned char *buffer, int sz);
< LIB3270_EXPORT const char	* lib3270_asc2ebc(H3270 *hSession, unsigned char *buffer, int sz);
< 
< /**
<  * @brief Get character code from string definition.
<  *
<  * @param id	The character definition (id or 0x[code]).
<  *
<  * @return Character code if ok, 0 if not (sets errno).
<  *
<  * @retval EINVAL	Invalid character id.
<  */
< LIB3270_EXPORT unsigned short lib3270_translate_char(const char *id);
< 
< typedef struct _lib3270_iconv LIB3270_ICONV;
< 
< ///
< /// @brief Create a new ICONV wrapper.
< ///
< LIB3270_EXPORT LIB3270_ICONV * lib3270_iconv_new(const char *remote, const char *local);
< 
< ///
< /// @brief Release the ICONV Wrapper.
< ///
< LIB3270_EXPORT void lib3270_iconv_free(LIB3270_ICONV *conv);
< 
< ///
< /// @brief Convert from host to local.
< ///
< LIB3270_EXPORT char * lib3270_iconv_from_host(LIB3270_ICONV *conv, const char *str, int len);
< 
< ///
< /// @brief Convert from local to host.
< ///
< LIB3270_EXPORT char * lib3270_iconv_to_host(LIB3270_ICONV *conv, const char *str, int len);
---
> 	struct lib3270_charset
> 	{
> 		char			* host;
> 		char			* display;
> 		unsigned long	  cgcsgid;
> 
> 		// Translation tables
> 		unsigned short		  ebc2asc[256];
> 		unsigned short 		  asc2ebc[256];
> 
> 		unsigned short		  asc2uc[256];
> 
> 	};
> 
> 	typedef enum
> 	{
> 		CS_ONLY,
> 		FT_ONLY,
> 		BOTH
> 	} lib3270_remap_scope;
> 
> 	/**
> 	 * @brief Set host charset.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 * @param name		Charset name (us, bracket, cp500) or NULL to lib3270's default.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 * @retval EINVAL	Invalid charset name.
> 	 *
> 	 */
> 	LIB3270_EXPORT int			  lib3270_set_host_charset(H3270 *hSession, const char *name);
> 
> 	LIB3270_EXPORT const char	* lib3270_get_host_charset(const H3270 *hSession);
> 	LIB3270_EXPORT void 		  lib3270_reset_charset(H3270 *hSession, const char * host, const char * display, unsigned long cgcsgid);
> 
> 	LIB3270_EXPORT void			  lib3270_remap_char(H3270 *hSession, unsigned short ebc, unsigned short iso, lib3270_remap_scope scope, unsigned char one_way);
> 	LIB3270_EXPORT const char	* lib3270_ebc2asc(H3270 *hSession, unsigned char *buffer, int sz);
> 	LIB3270_EXPORT const char	* lib3270_asc2ebc(H3270 *hSession, unsigned char *buffer, int sz);
> 
> 	/**
> 	 * @brief Get character code from string definition.
> 	 *
> 	 * @param id	The character definition (id or 0x[code]).
> 	 *
> 	 * @return Character code if ok, 0 if not (sets errno).
> 	 *
> 	 * @retval EINVAL	Invalid character id.
> 	 */
> 	LIB3270_EXPORT unsigned short lib3270_translate_char(const char *id);
> 
> 	typedef struct _lib3270_iconv LIB3270_ICONV;
> 
> 	///
> 	/// @brief Create a new ICONV wrapper.
> 	///
> 	LIB3270_EXPORT LIB3270_ICONV * lib3270_iconv_new(const char *remote, const char *local);
> 
> 	///
> 	/// @brief Release the ICONV Wrapper.
> 	///
> 	LIB3270_EXPORT void lib3270_iconv_free(LIB3270_ICONV *conv);
> 
> 	///
> 	/// @brief Convert from host to local.
> 	///
> 	LIB3270_EXPORT char * lib3270_iconv_from_host(LIB3270_ICONV *conv, const char *str, int len);
> 
> 	///
> 	/// @brief Convert from local to host.
> 	///
> 	LIB3270_EXPORT char * lib3270_iconv_to_host(LIB3270_ICONV *conv, const char *str, int len);
116c118
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/filetransfer.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/filetransfer.h
35,251c35,217
< #define LIB3270_FILETRANSFER_INCLUDED 1
< #include <stdio.h>
< #include <sys/time.h>
< #include <lib3270/charset.h>
< 
< typedef enum _lib3270_FT_OPTION {
< 	LIB3270_FT_OPTION_SEND 					= 0x0000,
< 
< 	LIB3270_FT_OPTION_RECEIVE				= 0x0001,
< 	LIB3270_FT_OPTION_ASCII					= 0x0002,		///< @brief Convert to ascii
< 	LIB3270_FT_OPTION_CRLF					= 0x0004,		///< @brief Add crlf to each line
< 	LIB3270_FT_OPTION_APPEND				= 0x0008,
< 	LIB3270_FT_OPTION_REMAP					= 0x0010,		///< @brief Remap ASCII<->EBCDIC
< 	LIB3270_FT_OPTION_UNIX					= 0x0020,		///< @brief Unix text file
< 
< 	LIB3270_FT_RECORD_FORMAT_DEFAULT		= 0x0000,
< 	LIB3270_FT_RECORD_FORMAT_FIXED			= 0x0100,
< 	LIB3270_FT_RECORD_FORMAT_VARIABLE		= 0x0200,
< 	LIB3270_FT_RECORD_FORMAT_UNDEFINED		= 0x0300,
< 
< 	LIB3270_FT_ALLOCATION_UNITS_DEFAULT		= 0x0000,
< 	LIB3270_FT_ALLOCATION_UNITS_TRACKS		= 0x1000,
< 	LIB3270_FT_ALLOCATION_UNITS_CYLINDERS	= 0x2000,
< 	LIB3270_FT_ALLOCATION_UNITS_AVBLOCK		= 0x3000
< 
< } LIB3270_FT_OPTION;
< 
< #define LIB3270_FT_ALLOCATION_UNITS_MASK		LIB3270_FT_ALLOCATION_UNITS_AVBLOCK
< #define LIB3270_FT_RECORD_FORMAT_MASK 			LIB3270_FT_RECORD_FORMAT_UNDEFINED
< 
< typedef enum _lib3270_ft_value {
< 
< 	LIB3270_FT_VALUE_LRECL,
< 	LIB3270_FT_VALUE_BLKSIZE,
< 	LIB3270_FT_VALUE_PRIMSPACE,
< 	LIB3270_FT_VALUE_SECSPACE,
< 	LIB3270_FT_VALUE_DFT,
< 
< 	LIB3270_FT_VALUE_COUNT
< 
< } LIB3270_FT_VALUE;
< 
< typedef enum _lib3270_ft_state {
< 	LIB3270_FT_STATE_NONE,			/**< No transfer in progress */
< 	LIB3270_FT_STATE_AWAIT_ACK,		/**< IND$FILE sent, awaiting acknowledgement message */
< 	LIB3270_FT_STATE_RUNNING,		/**< Ack received, data flowing */
< 	LIB3270_FT_STATE_ABORT_WAIT,	/**< Awaiting chance to send an abort */
< 	LIB3270_FT_STATE_ABORT_SENT		/**< Abort sent; awaiting response */
< } LIB3270_FT_STATE;
< 
< #define LIB3270_XLATE_NBUF	4
< 
< struct lib3270_ft_callbacks {
< 	void (*complete)(H3270 *hSession, unsigned long length,double kbytes_sec,const char *msg, void *userdata);
< 	void (*failed)(H3270 *hSession, unsigned long length,double kbytes_sec,const char *msg, void *userdata);
< 	void (*message)(H3270 *hSession, const char *msg, void *userdata);
< 	void (*update)(H3270 *hSession, unsigned long current, unsigned long length, double kbytes_sec, void *userdata);
< 	void (*running)(H3270 *hSession, int is_cut, void *userdata);
< 	void (*aborting)(H3270 *hSession, const char *reason, void *userdata);
< 	void (*state_changed)(H3270 *hSession, LIB3270_FT_STATE state, const char *text, void *userdata);
< };
< 
< /**
<  * @brief File transfer data.
<  *
<  */
< struct _h3270ft {
< 	struct lib3270_ft_callbacks	  cbk;				///< @brief Callback table - Always the first one.
< 
< 	unsigned int				  ft_last_cr	: 1;	///< @brief CR was last char in local file
< 	unsigned int 				  remap_flag	: 1;	///< @brief Remap ASCII<->EBCDIC
< 	unsigned int				  cr_flag		: 1;	///< @brief Add crlf to each line
< 	unsigned int				  unix_text		: 1;	///< @brief Following the convention for UNIX text files.
< 	unsigned int				  message_flag	: 1;	///< @brief Open Request for msg received
< 	unsigned int				  ascii_flag	: 1;	///< @brief Convert to ascii
< 	unsigned int				  ft_is_cut		: 1;	///< @brief File transfer is CUT-style
< 	unsigned int				  dft_eof		: 1;
< 
< 
< 	H3270					* host;
< 	void					* user_data;			///< @brief File transfer dialog handle
< 	FILE 					* local_file;			///< @brief File descriptor for local file
< 	unsigned long			  length;				///< @brief File length
< 
< 	LIB3270_FT_STATE		  state;
< 	LIB3270_FT_OPTION		  flags;
< 
< 	int 					  lrecl;
< 	int 					  blksize;
< 	int						  primspace;
< 	int						  secspace;
< 	int						  dft;
< 
< 	unsigned long			  ft_length;			///< Length of transfer
< 
< 	struct timeval			  starting_time;		///< Starting time
< 
< 	const char 				* local;				///< Local filename
< 	const char				* remote;				///< Remote filename
< 
< 	// ft_dft.c
< 	char 					* abort_string;
< 	unsigned long			  recnum;
< 	unsigned char			* dft_savebuf;
< 	int						  dft_savebuf_len;
< 	int						  dft_savebuf_max;
< 
< 	// ft_cut.c
< 	int						  quadrant;
< 	unsigned long			  expanded_length;
< 	char					* saved_errmsg;
< 	int						  xlate_buffered;					///< buffer count
< 	int						  xlate_buf_ix;						///< buffer index
< 	unsigned char			  xlate_buf[LIB3270_XLATE_NBUF];	///< buffer
< 
< 	// Charset
< 	struct lib3270_charset	  charset;
< 
< };
< 
< typedef struct _lib3270_ft_message {
< 	const char		* id;					///< @brief Message ID.
< 	unsigned char	  failed;				///< @brief Non zero if this message indicates a failure.
< 	const char		* message;				///< @brief Message text.
< 	const char 		* description;			///< @brief Message description.
< } LIB3270_FT_MESSAGE;
< 
< /**
<  * @brief Create a new file transfer session.
<  *
<  * @param hSession
<  * @param flags
<  * @param local
<  * @param remote
<  * @param lrecl
<  * @param blksize
<  * @param primspace
<  * @param secspace
<  * @param dft
<  * @param msg		Pointer to receive message text.
<  *
<  * @return Filetransfer session handle.
<   *
<  */
< LIB3270_EXPORT H3270FT						* lib3270_ft_new(H3270 *hSession, LIB3270_FT_OPTION flags, const char *local, const char *remote, int lrecl, int blksize, int primspace, int secspace, int dft, const char **msg);
< 
< LIB3270_EXPORT int							  lib3270_ft_start(H3270 *hSession);
< LIB3270_EXPORT int							  lib3270_ft_destroy(H3270 *hSession, const char *reason);
< 
< LIB3270_EXPORT int							  lib3270_ft_cancel(H3270 *hSession, int force, const char *reason);
< 
< LIB3270_EXPORT void							  lib3270_ft_set_user_data(H3270 *h, void *ptr);
< LIB3270_EXPORT void						 	* lib3270_ft_get_user_data(H3270 *h);
< 
< LIB3270_EXPORT LIB3270_FT_STATE				  lib3270_get_ft_state(H3270 *session);
< 
< LIB3270_EXPORT struct lib3270_ft_callbacks	* lib3270_get_ft_callbacks(H3270 *session, unsigned short sz);
< 
< LIB3270_EXPORT int							  lib3270_ft_set_lrecl(H3270 *hSession, int lrecl);
< LIB3270_EXPORT int							  lib3270_ft_set_blksize(H3270 *hSession, int blksize);
< LIB3270_EXPORT int							  lib3270_ft_set_primspace(H3270 *hSession, int primspace);
< LIB3270_EXPORT int							  lib3270_ft_set_secspace(H3270 *hSession, int secspace);
< 
< /**
<  * @brief Update the buffersize for generating a Query Reply.
<  */
< LIB3270_EXPORT int							  lib3270_set_dft_buffersize(H3270 *hSession, int dft_buffersize);
< 
< LIB3270_EXPORT int							  lib3270_ft_set_options(H3270 *hSession, LIB3270_FT_OPTION options);
< 
< /**
<  * @brief Send file.
<  *
<  * @param from	Origin filename
<  * @param to	Destination filename
<  * @param args	Null terminated file transfer options.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  * @retval	EBUSY	File transfer is already active.
<  *
<  */
< LIB3270_EXPORT int							  lib3270_send(H3270 *hSession, const char *from, const char *to, const char **args);
< 
< /**
<  * @brief Receive file.
<  *
<  * @param from	Origin filename
<  * @param to	Destination filename
<  * @param args	Null terminated file transfer options.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  * @retval	EBUSY	File transfer is already active.
<  *
<  */
< LIB3270_EXPORT int							  lib3270_receive(H3270 *hSession, const char *from, const char *to, const char **args);
< 
< /**
<  * @brief Set all FT callbacks to default valides.
<  *
<  * @param hSession	TN3270 session to reset.
<  *
<  * @return 0 if hSession has a valid FT session, non zero if not (sets errno).
<  *
<  */
< LIB3270_EXPORT int							  lib3270_reset_ft_callbacks(H3270 *hSession);
< 
< /**
<  * @brief Translate IND$FILE response.
<  *
<  * @param msg	Message received.
<  *
<  * @return Structure with message description and type.
<  *
<  */
< LIB3270_EXPORT const LIB3270_FT_MESSAGE * lib3270_translate_ft_message(const char *msg);
---
> 	#define LIB3270_FILETRANSFER_INCLUDED 1
> 	#include <stdio.h>
> 	#include <sys/time.h>
> 	#include <lib3270/charset.h>
> 
> 	typedef enum _lib3270_FT_OPTION
> 	{
> 		LIB3270_FT_OPTION_SEND 					= 0x0000,
> 
> 		LIB3270_FT_OPTION_RECEIVE				= 0x0001,
> 		LIB3270_FT_OPTION_ASCII					= 0x0002,		///< @brief Convert to ascii
> 		LIB3270_FT_OPTION_CRLF					= 0x0004,		///< @brief Add crlf to each line
> 		LIB3270_FT_OPTION_APPEND				= 0x0008,
> 		LIB3270_FT_OPTION_REMAP					= 0x0010,		///< @brief Remap ASCII<->EBCDIC
> 		LIB3270_FT_OPTION_UNIX					= 0x0020,		///< @brief Unix text file
> 
> 		LIB3270_FT_RECORD_FORMAT_DEFAULT		= 0x0000,
> 		LIB3270_FT_RECORD_FORMAT_FIXED			= 0x0100,
> 		LIB3270_FT_RECORD_FORMAT_VARIABLE		= 0x0200,
> 		LIB3270_FT_RECORD_FORMAT_UNDEFINED		= 0x0300,
> 
> 		LIB3270_FT_ALLOCATION_UNITS_DEFAULT		= 0x0000,
> 		LIB3270_FT_ALLOCATION_UNITS_TRACKS		= 0x1000,
> 		LIB3270_FT_ALLOCATION_UNITS_CYLINDERS	= 0x2000,
> 		LIB3270_FT_ALLOCATION_UNITS_AVBLOCK		= 0x3000
> 
> 	} LIB3270_FT_OPTION;
> 
> 	#define LIB3270_FT_ALLOCATION_UNITS_MASK		LIB3270_FT_ALLOCATION_UNITS_AVBLOCK
> 	#define LIB3270_FT_RECORD_FORMAT_MASK 			LIB3270_FT_RECORD_FORMAT_UNDEFINED
> 
> 	typedef enum _lib3270_ft_value
> 	{
> 
> 		LIB3270_FT_VALUE_LRECL,
> 		LIB3270_FT_VALUE_BLKSIZE,
> 		LIB3270_FT_VALUE_PRIMSPACE,
> 		LIB3270_FT_VALUE_SECSPACE,
> 		LIB3270_FT_VALUE_DFT,
> 
> 		LIB3270_FT_VALUE_COUNT
> 
> 	} LIB3270_FT_VALUE;
> 
> 	typedef enum _lib3270_ft_state
> 	{
> 		LIB3270_FT_STATE_NONE,			/**< No transfer in progress */
> 		LIB3270_FT_STATE_AWAIT_ACK,		/**< IND$FILE sent, awaiting acknowledgement message */
> 		LIB3270_FT_STATE_RUNNING,		/**< Ack received, data flowing */
> 		LIB3270_FT_STATE_ABORT_WAIT,	/**< Awaiting chance to send an abort */
> 		LIB3270_FT_STATE_ABORT_SENT		/**< Abort sent; awaiting response */
> 	} LIB3270_FT_STATE;
> 
> 	#define LIB3270_XLATE_NBUF	4
> 
> 	struct lib3270_ft_callbacks
> 	{
> 		void (*complete)(H3270 *hSession, unsigned long length,double kbytes_sec,const char *msg, void *userdata);
> 		void (*failed)(H3270 *hSession, unsigned long length,double kbytes_sec,const char *msg, void *userdata);
> 		void (*message)(H3270 *hSession, const char *msg, void *userdata);
> 		void (*update)(H3270 *hSession, unsigned long current, unsigned long length, double kbytes_sec, void *userdata);
> 		void (*running)(H3270 *hSession, int is_cut, void *userdata);
> 		void (*aborting)(H3270 *hSession, const char *reason, void *userdata);
> 		void (*state_changed)(H3270 *hSession, LIB3270_FT_STATE state, const char *text, void *userdata);
> 	};
> 
> 	/**
> 	 * @brief File transfer data.
> 	 *
> 	 */
> 	struct _h3270ft
> 	{
> 		struct lib3270_ft_callbacks	  cbk;				///< @brief Callback table - Always the first one.
> 
> 		int						  ft_last_cr	: 1;	///< @brief CR was last char in local file
> 		int 					  remap_flag	: 1;	///< @brief Remap ASCII<->EBCDIC
> 		int						  cr_flag		: 1;	///< @brief Add crlf to each line
> 		int						  unix_text		: 1;	///< @brief Following the convention for UNIX text files.
> 		int						  message_flag	: 1;	///< @brief Open Request for msg received
> 		int						  ascii_flag	: 1;	///< @brief Convert to ascii
> 		int						  ft_is_cut		: 1;	///< @brief File transfer is CUT-style
> 		int						  dft_eof		: 1;
> 
> 
> 		H3270					* host;
> 		void					* user_data;			///< @brief File transfer dialog handle
> 		FILE 					* local_file;			///< @brief File descriptor for local file
> 		unsigned long			  length;				///< @brief File length
> 
> 		LIB3270_FT_STATE		  state;
> 		LIB3270_FT_OPTION		  flags;
> 
> 		int 					  lrecl;
> 		int 					  blksize;
> 		int						  primspace;
> 		int						  secspace;
> 		int						  dft;
> 
> 		unsigned long			  ft_length;			///< Length of transfer
> 
> 		struct timeval			  starting_time;		///< Starting time
> 
> 		const char 				* local;				///< Local filename
> 		const char				* remote;				///< Remote filename
> 
> 		// ft_dft.c
> 		char 					* abort_string;
> 		unsigned long			  recnum;
> 		unsigned char			* dft_savebuf;
> 		int						  dft_savebuf_len;
> 		int						  dft_savebuf_max;
> 
> 		// ft_cut.c
> 		int						  quadrant;
> 		unsigned long			  expanded_length;
> 		char					* saved_errmsg;
> 		int						  xlate_buffered;					///< buffer count
> 		int						  xlate_buf_ix;						///< buffer index
> 		unsigned char			  xlate_buf[LIB3270_XLATE_NBUF];	///< buffer
> 
> 		// Charset
> 		struct lib3270_charset	  charset;
> 
> 	};
> 
> 	typedef struct _lib3270_ft_message
> 	{
> 		const char		* id;					///< @brief Message ID.
> 		unsigned char	  failed;				///< @brief Non zero if this message indicates a failure.
> 		const char		* message;				///< @brief Message text.
> 		const char 		* description;			///< @brief Message description.
> 	} LIB3270_FT_MESSAGE;
> 
> 	/**
> 	 * @brief Create a new file transfer session.
> 	 *
> 	 * @param hSession
> 	 * @param flags
> 	 * @param local
> 	 * @param remote
> 	 * @param lrecl
> 	 * @param blksize
> 	 * @param primspace
> 	 * @param secspace
> 	 * @param dft
> 	 * @param msg		Pointer to receive message text.
> 	 *
> 	 * @return Filetransfer session handle.
> 	  *
> 	 */
> 	LIB3270_EXPORT H3270FT						* lib3270_ft_new(H3270 *hSession, LIB3270_FT_OPTION flags, const char *local, const char *remote, int lrecl, int blksize, int primspace, int secspace, int dft, const char **msg);
> 
> 	LIB3270_EXPORT int							  lib3270_ft_start(H3270 *hSession);
> 	LIB3270_EXPORT int							  lib3270_ft_destroy(H3270 *hSession, const char *reason);
> 
> 	LIB3270_EXPORT int							  lib3270_ft_cancel(H3270 *hSession, int force, const char *reason);
> 
> 	LIB3270_EXPORT void							  lib3270_ft_set_user_data(H3270 *h, void *ptr);
> 	LIB3270_EXPORT void						 	* lib3270_ft_get_user_data(H3270 *h);
> 
> 	LIB3270_EXPORT LIB3270_FT_STATE				  lib3270_get_ft_state(H3270 *session);
> 
> 	LIB3270_EXPORT struct lib3270_ft_callbacks	* lib3270_get_ft_callbacks(H3270 *session, unsigned short sz);
> 
> 	/**
> 	 * @brief Set all FT callbacks to default valides.
> 	 *
> 	 * @param hSession	TN3270 session to reset.
> 	 *
> 	 * @return 0 if hSession has a valid FT session, non zero if not (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int							  lib3270_reset_ft_callbacks(H3270 *hSession);
> 
> 	/**
> 	 * @brief Translate IND$FILE response.
> 	 *
> 	 * @param msg	Message received.
> 	 *
> 	 * @return Structure with message description and type.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_FT_MESSAGE * lib3270_translate_ft_message(const char *msg);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/html.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/html.h
31c31
< /*
---
>  /*
34c34
< #define LIB3270_HTML_H_INCLUDED 1
---
> 	#define LIB3270_HTML_H_INCLUDED 1
37c37
< extern "C" {
---
> 	extern "C" {
40,44c40,44
< typedef enum _lib3270_html_option
< {
< 	LIB3270_HTML_OPTION_ALL			= 0x0001,
< 	LIB3270_HTML_OPTION_HEADERS		= 0x0002,
< 	LIB3270_HTML_OPTION_FORM		= 0x0004,
---
> 	typedef enum _lib3270_html_option
> 	{
> 		LIB3270_HTML_OPTION_ALL			= 0x0001,
> 		LIB3270_HTML_OPTION_HEADERS		= 0x0002,
> 		LIB3270_HTML_OPTION_FORM		= 0x0004,
46c46
< } LIB3270_HTML_OPTION;
---
> 	} LIB3270_HTML_OPTION;
49c49
< LIB3270_EXPORT char * lib3270_get_as_html(H3270 *session, LIB3270_HTML_OPTION option);
---
> 	LIB3270_EXPORT char * lib3270_get_as_html(H3270 *session, LIB3270_HTML_OPTION option);
52c52
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/internals.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/internals.h
31c31
< #define LIB3270_INTERNALS_H_INCLUDED 1
---
> 	#define LIB3270_INTERNALS_H_INCLUDED 1
34c34
< extern "C" {
---
> 	extern "C" {
37,40c37,40
< LIB3270_EXPORT void lib3270_data_recv(H3270 *hSession, size_t nr, const unsigned char *netrbuf);
< LIB3270_EXPORT void lib3270_set_disconnected(H3270 *hSession);
< LIB3270_EXPORT void lib3270_set_connected_initial(H3270 *hSession);
< LIB3270_EXPORT void lib3270_setup_session(H3270 *session);
---
> 	LIB3270_EXPORT void lib3270_data_recv(H3270 *hSession, size_t nr, const unsigned char *netrbuf);
> 	LIB3270_EXPORT void lib3270_set_disconnected(H3270 *hSession);
> 	LIB3270_EXPORT void lib3270_set_connected_initial(H3270 *hSession);
> 	LIB3270_EXPORT void lib3270_setup_session(H3270 *session);
44c44
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/keyboard.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/keyboard.h
30c30
< #define LIB3270_KEYBOARD_H_INCLUDED 1
---
> 	#define LIB3270_KEYBOARD_H_INCLUDED 1
33c33
< extern "C" {
---
> 	extern "C" {
36,87c36,88
< /**
<  * @brief keyboard lock states
<  */
< typedef enum lib3270_keyboard_lock_state {
< 	LIB3270_KL_UNLOCKED			= 0x0000,	///< @brief Keyboard is unlocked.
< 
< 	// Operator errors
< 	LIB3270_KL_OERR_MASK		= 0x000f,
< 	LIB3270_KL_OERR_PROTECTED	= 0x0001,
< 	LIB3270_KL_OERR_NUMERIC		= 0x0002,
< 	LIB3270_KL_OERR_OVERFLOW	= 0x0003,
< 	LIB3270_KL_OERR_DBCS		= 0x0004,
< 
< 	LIB3270_KL_NOT_CONNECTED	= 0x0010,	///< @brief Not connected to host.
< 	LIB3270_KL_AWAITING_FIRST	= 0x0020,
< 	LIB3270_KL_OIA_TWAIT		= 0x0040,
< 	LIB3270_KL_OIA_LOCKED		= 0x0080,
< 	LIB3270_KL_DEFERRED_UNLOCK	= 0x0100,
< 	LIB3270_KL_ENTER_INHIBIT	= 0x0200,
< 	LIB3270_KL_SCROLLED			= 0x0400,
< 	LIB3270_KL_OIA_MINUS		= 0x0800
< 
< } LIB3270_KEYBOARD_LOCK_STATE;
< 
< /**
<  * @brief Wait for keyboard unlock.
<  *
<  * Return status if the keyboard is locked by operator error ou if disconnected from host, waits until keyboard is unlocked if not.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  * @return keyboard lock status.
<  *
<  * @retval LIB3270_KL_UNLOCKED	Keyboard unlocked, acess ok.
<  */
< LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_wait_for_keyboard_unlock(H3270 *hSession, int seconds);
< 
< LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_get_keyboard_lock_state(const H3270 *hSession);
< 
< /**
<  * @brief Set te operator error lock.
<  *
<  * If lock is enabled (the default), operator errors (typing into protected fields, insert overflow, etc.)
<  * will cause the keyboard to lock with an error message in the OIA (status line). If disabled, these errors
<  * will simply cause the terminal bell will ring, without any keyboard lock or message.
<  *
<  * @param hSession	Session handle.
<  * @param enable	Non zero to enable operator lock, zero to disable.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_lock_on_operator_error(H3270 *hSession, int enable);
< LIB3270_EXPORT int lib3270_get_lock_on_operator_error(const H3270 *hSession);
---
> 	/**
> 	 * @brief keyboard lock states
> 	 */
> 	typedef enum lib3270_keyboard_lock_state
> 	{
> 		LIB3270_KL_UNLOCKED			= 0x0000,	///< @brief Keyboard is unlocked.
> 
> 		// Operator errors
> 		LIB3270_KL_OERR_MASK		= 0x000f,
> 		LIB3270_KL_OERR_PROTECTED	= 0x0001,
> 		LIB3270_KL_OERR_NUMERIC		= 0x0002,
> 		LIB3270_KL_OERR_OVERFLOW	= 0x0003,
> 		LIB3270_KL_OERR_DBCS		= 0x0004,
> 
> 		LIB3270_KL_NOT_CONNECTED	= 0x0010,	///< @brief Not connected to host.
> 		LIB3270_KL_AWAITING_FIRST	= 0x0020,
> 		LIB3270_KL_OIA_TWAIT		= 0x0040,
> 		LIB3270_KL_OIA_LOCKED		= 0x0080,
> 		LIB3270_KL_DEFERRED_UNLOCK	= 0x0100,
> 		LIB3270_KL_ENTER_INHIBIT	= 0x0200,
> 		LIB3270_KL_SCROLLED			= 0x0400,
> 		LIB3270_KL_OIA_MINUS		= 0x0800
> 
> 	} LIB3270_KEYBOARD_LOCK_STATE;
> 
> 	/**
> 	 * @brief Wait for keyboard unlock.
> 	 *
> 	 * Return status if the keyboard is locked by operator error ou if disconnected from host, waits until keyboard is unlocked if not.
> 	 *
> 	 * @param seconds	Number of seconds to wait.
> 	 *
> 	 * @return keyboard lock status.
> 	 *
> 	 * @retval LIB3270_KL_UNLOCKED	Keyboard unlocked, acess ok.
> 	 */
> 	LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_wait_for_keyboard_unlock(H3270 *hSession, int seconds);
> 
> 	LIB3270_EXPORT LIB3270_KEYBOARD_LOCK_STATE lib3270_get_keyboard_lock_state(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Set te operator error lock.
> 	 *
> 	 * If lock is enabled (the default), operator errors (typing into protected fields, insert overflow, etc.)
> 	 * will cause the keyboard to lock with an error message in the OIA (status line). If disabled, these errors
> 	 * will simply cause the terminal bell will ring, without any keyboard lock or message.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param enable	Non zero to enable operator lock, zero to disable.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_lock_on_operator_error(H3270 *hSession, int enable);
> 	LIB3270_EXPORT int lib3270_get_lock_on_operator_error(const H3270 *hSession);
89,90c90,91
< LIB3270_EXPORT int lib3270_set_numeric_lock(H3270 *hSession, int enable);
< LIB3270_EXPORT int lib3270_get_numeric_lock(const H3270 *hSession);
---
> 	LIB3270_EXPORT int lib3270_set_numeric_lock(H3270 *hSession, int enable);
> 	LIB3270_EXPORT int lib3270_get_numeric_lock(const H3270 *hSession);
94c95
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/log.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/log.h
30c30
< #ifndef LIB3270_LOG_H_INCLUDED
---
>  #ifndef LIB3270_LOG_H_INCLUDED
32c32
< #include <stdarg.h>
---
> 	#include <stdarg.h>
34c34
< #define LIB3270_LOG_H_INCLUDED 1
---
> 	#define LIB3270_LOG_H_INCLUDED 1
36c36
< #ifdef ANDROID
---
> 	#ifdef ANDROID
38c38
< #include <android/log.h>
---
> 		#include <android/log.h>
40c40
< #define DEBUG 1
---
> 		#define DEBUG 1
42,44c42,44
< #define lib3270_write_log(s,m,f,...)	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", __VA_ARGS__ )
< #define lib3270_write_rc(s,m,r,f,...)	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", __VA_ARGS__ )
< #define lib3270_write_va_log(s,m,f,a)	__android_log_vprint(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", a)
---
> 		#define lib3270_write_log(s,m,f,...)	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", __VA_ARGS__ )
> 		#define lib3270_write_rc(s,m,r,f,...)	__android_log_print(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", __VA_ARGS__ )
> 		#define lib3270_write_va_log(s,m,f,a)	__android_log_vprint(ANDROID_LOG_VERBOSE, PACKAGE_NAME, f "\n", a)
46,47c46,47
< // #define trace( fmt, ... )	__android_log_print(ANDROID_LOG_DEBUG, PACKAGE_NAME, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ );
< #define trace(x, ...) 		// __VA_ARGS__
---
> 		// #define trace( fmt, ... )	__android_log_print(ANDROID_LOG_DEBUG, PACKAGE_NAME, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ );
> 		#define trace(x, ...) 		// __VA_ARGS__
49c49
< #else
---
> 	#else
51,53c51,53
< #ifdef __cplusplus
< extern "C" {
< #endif
---
> 	#ifdef __cplusplus
> 		extern "C" {
> 	#endif
55c55,58
< typedef int (*LIB3270_LOG_HANDLER)(const H3270 *, void *, const char *, int, const char *);
---
> 		LIB3270_EXPORT void	  lib3270_set_log_handler(void (*loghandler)(H3270 *, const char *, int, const char *, va_list));
> 		LIB3270_EXPORT int	  lib3270_write_log(H3270 *session, const char *module, const char *fmt, ...) LIB3270_GNUC_FORMAT(3,4);
> 		LIB3270_EXPORT int	  lib3270_write_rc(H3270 *session, const char *module, int rc, const char *fmt, ...) LIB3270_GNUC_FORMAT(4,5);
> 		LIB3270_EXPORT void	  lib3270_write_va_log(H3270 *session, const char *module, const char *fmt, va_list arg);
57,59c60,68
< LIB3270_EXPORT void	  lib3270_set_log_handler(H3270 *session, const LIB3270_LOG_HANDLER loghandler, void *userdata);
< LIB3270_EXPORT int	  lib3270_set_log_filename(H3270 * hSession, const char *name);
< LIB3270_EXPORT const char * lib3270_get_log_filename(const H3270 * hSession);
---
> 		/**
> 		 * @brief Send logs to system log (if available)
> 		 *
> 		 * @param flag	Non-zero to use syslog.
> 		 *
> 		 * @return 0 if ok, non zero if not.
> 		 *
> 		 */
> 		LIB3270_EXPORT int	  lib3270_set_syslog(int flag);
61,63c70,79
< LIB3270_EXPORT int	  lib3270_write_log(const H3270 *session, const char *module, const char *fmt, ...) LIB3270_GNUC_FORMAT(3,4);
< LIB3270_EXPORT int	  lib3270_write_rc(const H3270 *session, const char *module, int rc, const char *fmt, ...) LIB3270_GNUC_FORMAT(4,5);
< LIB3270_EXPORT void	  lib3270_write_va_log(const H3270 *session, const char *module, const char *fmt, va_list arg);
---
> 		#ifdef DEBUG
> 			#include <stdio.h>
> 			#undef trace
> 			#define trace( fmt, ... )	fprintf(stderr, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ ); fflush(stderr);
> 			#define debug( fmt, ... )	fprintf(stderr, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ ); fflush(stderr);
> 		#else
> 			#undef trace
> 			#define trace(x, ...) 		// __VA_ARGS__
> 			#define debug(x, ...) 		// __VA_ARGS__
> 		#endif
64a81,83
> 	#ifdef __cplusplus
> 		}
> 	#endif
66,74c85
< /**
<  * @brief Send logs to system log (if available)
<  *
<  * @param flag	Non-zero to use syslog.
<  *
<  * @return 0 if ok, non zero if not.
<  *
<  */
< LIB3270_EXPORT int	  lib3270_set_syslog(int flag);
---
> 	#endif // ANDROID
76,85d86
< #ifdef DEBUG
< #include <stdio.h>
< #undef trace
< #define trace( fmt, ... )	fprintf(stderr, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ ); fflush(stderr);
< #define debug( fmt, ... )	fprintf(stderr, "%s(%d) " fmt "\n", __FILE__, __LINE__, __VA_ARGS__ ); fflush(stderr);
< #else
< #undef trace
< #define trace(x, ...) 		// __VA_ARGS__
< #define debug(x, ...) 		// __VA_ARGS__
< #endif
87,94c88
< #ifdef __cplusplus
< }
< #endif
< 
< #endif // ANDROID
< 
< 
< #endif // LIB3270_LOG_H_INCLUDED
---
>  #endif // LIB3270_LOG_H_INCLUDED
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/popup.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/popup.h
34c34
< #define LIB3270_POPUP_INCLUDED 1
---
> 	#define LIB3270_POPUP_INCLUDED 1
37c37
< extern "C" {
---
> 	extern "C" {
40,59c40,60
< /**
<  * Notification message types.
<  *
<  */
< typedef enum _LIB3270_NOTIFY {
< 	LIB3270_NOTIFY_INFO,		///< @brief Simple information dialog.
< 	LIB3270_NOTIFY_WARNING,		///< @brief Warning message.
< 	LIB3270_NOTIFY_ERROR,		///< @brief Error message.
< 	LIB3270_NOTIFY_CRITICAL,	///< @brief Critical error, user can abort application.
< 	LIB3270_NOTIFY_SECURE,		///< @brief Secure host dialog.
< 
< 	LIB3270_NOTIFY_USER			///< @brief Reserved, always the last one.
< } LIB3270_NOTIFY;
< 
< 
< /**
<  * @brief Head for popup descriptors.
<  *
<  */
< #define LIB3270_POPUP_HEAD	\
---
> 	/**
> 	 * Notification message types.
> 	 *
> 	 */
> 	typedef enum _LIB3270_NOTIFY
> 	{
> 		LIB3270_NOTIFY_INFO,		///< @brief Simple information dialog.
> 		LIB3270_NOTIFY_WARNING,		///< @brief Warning message.
> 		LIB3270_NOTIFY_ERROR,		///< @brief Error message.
> 		LIB3270_NOTIFY_CRITICAL,	///< @brief Critical error, user can abort application.
> 		LIB3270_NOTIFY_SECURE,		///< @brief Secure host dialog.
> 
> 		LIB3270_NOTIFY_USER			///< @brief Reserved, always the last one.
> 	} LIB3270_NOTIFY;
> 
> 
> 	/**
> 	 * @brief Head for popup descriptors.
> 	 *
> 	 */
> 	#define LIB3270_POPUP_HEAD	\
67,124c68,126
< typedef struct _LIB3270_POPUP {
< 	LIB3270_POPUP_HEAD
< } LIB3270_POPUP;
< 
< /**
<  * @brief Replace popup handler.
<  *
<  */
< LIB3270_EXPORT void lib3270_set_popup_handler(H3270 *hSession, int (*handler)(H3270 *, const LIB3270_POPUP *, unsigned char wait));
< 
< /**
<  * @brief Pop up an error dialog, based on an error number.
<  *
<  * @param hSession	Session handle
<  * @param errn		Error number (errno).
<  * @param fmt		Message format
<  * @param ...		Arguments for message
<  */
< LIB3270_EXPORT void lib3270_popup_an_errno(H3270 *hSession, int errn, const char *fmt, ...);
< 
< LIB3270_EXPORT void lib3270_popup_dialog(H3270 *session, LIB3270_NOTIFY id, const char *title, const char *message, const char *fmt, ...);
< 
< LIB3270_EXPORT void lib3270_popup_va(H3270 *session, LIB3270_NOTIFY id, const char *title, const char *message, const char *fmt, va_list);
< 
< LIB3270_EXPORT LIB3270_NOTIFY	lib3270_get_ssl_state_icon(const H3270 *hSession);
< LIB3270_EXPORT const char *		lib3270_get_ssl_state_icon_name(const H3270 *hSession);
< 
< /**
<  * @brief Clone popup object replacing the body contents.
<  *
<  * @param origin	Original popup definition.
<  * @param fmt		Printf formatting string.
<  *
<  * @return New popup object with the body replaced (release it with g_free).
<  *
<  */
< LIB3270_EXPORT LIB3270_POPUP * lib3270_popup_clone_printf(const LIB3270_POPUP *origin, const char *fmt, ...);
< 
< /**
<  * @brief Emit popup message.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param popup		Popup descriptor.
<  * @param wait		If non zero waits for user response.
<  *
<  * @return User action.
<  *
<  * @retval 0			User has confirmed, continue action.
<  * @retval ECANCELED	Operation was canceled.
<  * @retval ENOTSUP		Can't decide, use default behavior.
<  */
< LIB3270_EXPORT int lib3270_popup(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
< 
< /**
<  * @brief Auto cleanup method (for use with lib3270_autoptr).
<  *
<  */
< LIB3270_EXPORT void lib3270_autoptr_cleanup_LIB3270_POPUP(LIB3270_POPUP **ptr);
---
> 	typedef struct _LIB3270_POPUP
> 	{
> 		LIB3270_POPUP_HEAD
> 	} LIB3270_POPUP;
> 
> 	/**
> 	 * @brief Replace popup handler.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_set_popup_handler(H3270 *hSession, int (*handler)(H3270 *, const LIB3270_POPUP *, unsigned char wait));
> 
> 	/**
> 	 * @brief Pop up an error dialog, based on an error number.
> 	 *
> 	 * @param hSession	Session handle
> 	 * @param errn		Error number (errno).
> 	 * @param fmt		Message format
> 	 * @param ...		Arguments for message
> 	 */
> 	LIB3270_EXPORT void lib3270_popup_an_errno(H3270 *hSession, int errn, const char *fmt, ...);
> 
> 	LIB3270_EXPORT void lib3270_popup_dialog(H3270 *session, LIB3270_NOTIFY id , const char *title, const char *message, const char *fmt, ...);
> 
> 	LIB3270_EXPORT void lib3270_popup_va(H3270 *session, LIB3270_NOTIFY id , const char *title, const char *message, const char *fmt, va_list);
> 
> 	LIB3270_EXPORT LIB3270_NOTIFY	lib3270_get_ssl_state_icon(const H3270 *hSession);
> 	LIB3270_EXPORT const char *		lib3270_get_ssl_state_icon_name(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Clone popup object replacing the body contents.
> 	 *
> 	 * @param origin	Original popup definition.
> 	 * @param fmt		Printf formatting string.
> 	 *
> 	 * @return New popup object with the body replaced (release it with g_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_POPUP * lib3270_popup_clone_printf(const LIB3270_POPUP *origin, const char *fmt, ...);
> 
> 	/**
> 	 * @brief Emit popup message.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 * @param popup		Popup descriptor.
> 	 * @param wait		If non zero waits for user response.
> 	 *
> 	 * @return User action.
> 	 *
> 	 * @retval 0			User has confirmed, continue action.
> 	 * @retval ECANCELED	Operation was canceled.
> 	 * @retval ENOTSUP		Can't decide, use default behavior.
> 	 */
> 	LIB3270_EXPORT int lib3270_popup(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
> 
> 	/**
> 	 * @brief Auto cleanup method (for use with lib3270_autoptr).
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_autoptr_cleanup_LIB3270_POPUP(LIB3270_POPUP **ptr);
127c129
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/properties.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/properties.h
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4,9c2,19
<  * Copyright (C) 2008 Banco do Brasil S.A.
<  *
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * "Software PW3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
11,14c21
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa está nomeado como -.h e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
24c26
<  * erico.mendonca@gmail.com	(Erico Mascarenhas Mendonça)
---
>  * erico.mendonca@gmail.com	(Erico Mascarenhas de Mendonça)
28,33c30,35
< /**
<  * @brief TN3270 Session properties.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 Session properties.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
37c39
< #define LIB3270_PROPERTIES_H_INCLUDED
---
> 	#define LIB3270_PROPERTIES_H_INCLUDED
39c41
< #include <lib3270.h>
---
> 	#include <lib3270.h>
42c44
< extern "C" {
---
> 	extern "C" {
45,309c47,276
< typedef struct _lib3270_int_property {
< 	LIB3270_PROPERTY_HEAD
< 
< 	int (*get)(const H3270 *hSession);								///< @brief Get value.
< 	int (*set)(H3270 *hSession, int value);							///< @brief Set value.
< 
< 	int default_value;												///< @brief Default value for the property.
< 
< } LIB3270_INT_PROPERTY;
< 
< typedef struct _lib3270_uint_property {
< 	LIB3270_PROPERTY_HEAD
< 
< 	unsigned int (*get)(const H3270 *hSession);						///< @brief Get value.
< 	int (*set)(H3270 *hSession, unsigned int value);				///< @brief Set value.
< 
< 	unsigned int min;												///< @brief Minimum allowable value.
< 	unsigned int max;												///< @brief Maximum allowable value.
< 	unsigned int default_value;										///< @brief Default value for the property.
< 
< } LIB3270_UINT_PROPERTY;
< 
< typedef struct _lib3270_string_property {
< 	LIB3270_PROPERTY_HEAD
< 
< 	const char * (*get)(const H3270 *hSession);						///< @brief Get value.
< 	int (*set)(H3270 *hSession, const char * value);				///< @brief Set value.
< 
< 	const char * default_value;										///< @brief Default value
< 
< } LIB3270_STRING_PROPERTY;
< 
< /**
<  * @brief Get lib3270 integer properties table.
<  *
<  * @return The properties table.
<  *
<  */
< LIB3270_EXPORT const LIB3270_INT_PROPERTY * lib3270_get_boolean_properties_list(void);
< 
< /**
<  * @brief Get lib3270 signed int properties table.
<  *
<  * @return The properties table.
<  *
<  */
< LIB3270_EXPORT const LIB3270_INT_PROPERTY * lib3270_get_int_properties_list(void);
< 
< /**
<  * @brief Get lib3270 unsigned signed int properties table.
<  *
<  * @return The properties table.
<  *
<  */
< LIB3270_EXPORT const LIB3270_UINT_PROPERTY * lib3270_get_unsigned_properties_list(void);
< 
< /**
<  * @brief Get lib3270 string properties table.
<  *
<  * @return The properties table.
<  *
<  */
< LIB3270_EXPORT const LIB3270_STRING_PROPERTY * lib3270_get_string_properties_list(void);
< 
< /**
<  * @brief Get property descriptor by name.
<  *
<  * @return Property descriptor or NULL if failed.
<  *
<  */
< LIB3270_EXPORT const LIB3270_PROPERTY * lib3270_property_get_by_name(const char *name);
< 
< /**
<  * @brief Get lib3270 integer property by name.
<  *
<  * @param name		Nome of the property.
<  * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
<  *
<  * @return Property value or -1 in case of error (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_get_int_property(H3270 * hSession, const char *name, int seconds);
< 
< /**
<  * @brief Set lib3270 signed int property by name.
<  *
<  * @param name		Nome of the property.
<  * @param value		New property value.
<  * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
<  *
<  * @return 0 if ok error code if not (sets errno).
<  *
<  * @retval EPERM	Property is ready only.
<  * @retval ENOENT	Can't find a property with this name.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_int_property(H3270 * hSession, const char *name, int value, int seconds);
< 
< /**
<  * @brief Set lib3270 unsigned int property by name.
<  *
<  * @param name		Nome of the property.
<  * @param value		New property value.
<  * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
<  *
<  * @return 0 if ok error code if not (sets errno).
<  *
<  * @retval EPERM	Property is ready only.
<  * @retval ENOENT	Can't find a property with this name.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_uint_property(H3270 * hSession, const char *name, unsigned int value, int seconds);
< 
< /**
<  * @brief Set lib3270 boolean property by name.
<  *
<  * @param name		Nome of the property.
<  * @param value		New property value.
<  * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
<  *
<  * @return 0 if ok error code if not (sets errno).
<  *
<  * @retval EPERM	Property is ready only.
<  * @retval ENOENT	Can't find a property with this name.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_boolean_property(H3270 * hSession, const char *name, int value, int seconds);
< 
< /**
<  * @brief Set lib3270 string property by name.
<  *
<  * @param hSession	Session handle.
<  * @param name		Nome of the property.
<  * @param value		New property value.
<  * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
<  *
<  * @return 0 if ok error code if not (sets errno).
<  *
<  * @retval EPERM	Property is ready only.
<  * @retval ENOENT	Can't find a property with this name.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_string_property(H3270 * hSession, const char *name, const char * value, int seconds);
< 
< 
< /**
<  * @brief Get Oversize.
<  *
<  * @param hSession	Session handle.
<  *
<  * @return Oversize definition (NULL if not set).
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_oversize(const H3270 *hSession);
< 
< /**
<  * @brief Set oversize.
<  *
<  * @param hSession	Session handle.
<  * @param value	Oversize value.
<  *
<  * @return 0 if success, error code if not (sets errno)
<  *
<  * @retval EISCONN	Already connected to host.
<  * @retval ENOTSUP	Oversize is not supported.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_oversize(H3270 *hSession, const char *value);
< 
< /**
<  * @brief Get property label.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_property_get_label(const LIB3270_PROPERTY * property);
< 
< 
< LIB3270_EXPORT const char * lib3270_property_get_name(const LIB3270_PROPERTY * property);
< LIB3270_EXPORT const char * lib3270_property_get_tooltip(const LIB3270_PROPERTY * property);
< 
< /**
<  * @brief Get property description.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_property_get_description(const LIB3270_PROPERTY * property);
< 
< /**
<  * @brief Get property summary.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_property_get_summary(const LIB3270_PROPERTY * property);
< 
< /**
<  * @brief Get unsigned int property by name.
<  *
<  * @param name	Property name.
<  *
<  * @return Property descriptor, or NULL if failed.
<  *
<  */
< LIB3270_EXPORT const LIB3270_UINT_PROPERTY * lib3270_unsigned_property_get_by_name(const char *name);
< 
< /**
<  * @brief Get lib3270 version info.
<  *
<  * @return String with lib3270 version info (release it with lib3270_free).
<  */
< LIB3270_EXPORT char * lib3270_get_version_info(void);
< 
< /**
<  * @brief Get lib3270 product name.
<  *
<  * @return Internal string with the product name.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_product_name(void);
< 
< /**
<  * @brief Get hostname for the connect/reconnect operations.
<  *
<  * @param h		Session handle.
<  *
<  * @return Pointer to host id set (internal data, do not change it)
<  *
<  */
< LIB3270_EXPORT const char * lib3270_host_get_name(const H3270 *h);
< 
< /**
<  * @brief Get service or port for the connect/reconnect operations.
<  *
<  * @param h		Session handle.
<  *
<  * @return Pointer to service name (internal data, do not change it)
<  *
<  */
< LIB3270_EXPORT const char * lib3270_service_get_name(const H3270 *h);
< 
< /**
<  * @brief Check if there's an active task.
<  *
<  * @param h	Session handle.
<  *
<  * @return Number of background tasks.
<  *
<  */
< LIB3270_EXPORT unsigned int lib3270_get_task_count(const H3270 *h);
< 
< /**
<  * @brief Set timer for auto-reconnect when connection fails.
<  *
<  * @param hSession	Session handle.
<  */
< LIB3270_EXPORT int lib3270_set_auto_reconnect(H3270 *hSession, unsigned int timer);
< 
< /**
<  * @brief Get timer for auto-reconnect when connection fails.
<  *
<  * @param hSession	Session handle.
<  */
< LIB3270_EXPORT unsigned int lib3270_get_auto_reconnect(const H3270 *hSession);
< 
< LIB3270_EXPORT const char * lib3270_get_connection_state_as_string(const H3270 *hSession);
< LIB3270_EXPORT const char * lib3270_get_program_message_as_string(const H3270 *hSession);
< LIB3270_EXPORT const char * lib3270_get_ssl_state_as_string(const H3270 * hSession);
< LIB3270_EXPORT const char * lib3270_get_termtype(const H3270 *hSession);
< LIB3270_EXPORT const char * lib3270_get_termname(const H3270 *hSession);
---
> 	typedef struct _lib3270_int_property
> 	{
> 		LIB3270_PROPERTY_HEAD
> 
> 		int (*get)(const H3270 *hSession);								///< @brief Get value.
> 		int (*set)(H3270 *hSession, int value);							///< @brief Set value.
> 
> 		int default_value;												///< @brief Default value for the property.
> 
> 	} LIB3270_INT_PROPERTY;
> 
> 	typedef struct _lib3270_uint_property
> 	{
> 		LIB3270_PROPERTY_HEAD
> 
> 		unsigned int (*get)(const H3270 *hSession);						///< @brief Get value.
> 		int (*set)(H3270 *hSession, unsigned int value);				///< @brief Set value.
> 
> 		unsigned int min;												///< @brief Minimum allowable value.
> 		unsigned int max;												///< @brief Maximum allowable value.
> 		unsigned int default_value;										///< @brief Default value for the property.
> 
> 	} LIB3270_UINT_PROPERTY;
> 
> 	typedef struct _lib3270_string_property
> 	{
> 		LIB3270_PROPERTY_HEAD
> 
> 		const char * (*get)(const H3270 *hSession);						///< @brief Get value.
> 		int (*set)(H3270 *hSession, const char * value);				///< @brief Set value.
> 
> 		const char * default_value;										///< @brief Default value
> 
> 	} LIB3270_STRING_PROPERTY;
> 
> 	/**
> 	 * @brief Get lib3270 integer properties table.
> 	 *
> 	 * @return The properties table.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_INT_PROPERTY * lib3270_get_boolean_properties_list(void);
> 
> 	/**
> 	 * @brief Get lib3270 signed int properties table.
> 	 *
> 	 * @return The properties table.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_INT_PROPERTY * lib3270_get_int_properties_list(void);
> 
> 	/**
> 	 * @brief Get lib3270 unsigned signed int properties table.
> 	 *
> 	 * @return The properties table.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_UINT_PROPERTY * lib3270_get_unsigned_properties_list(void);
> 
> 	/**
> 	 * @brief Get lib3270 string properties table.
> 	 *
> 	 * @return The properties table.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_STRING_PROPERTY * lib3270_get_string_properties_list(void);
> 
> 	/**
> 	 * @brief Get property descriptor by name.
> 	 *
> 	 * @return Property descriptor or NULL if failed.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_PROPERTY * lib3270_property_get_by_name(const char *name);
> 
> 	/**
> 	 * @brief Get lib3270 integer property by name.
> 	 *
> 	 * @param name		Nome of the property.
> 	 * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
> 	 *
> 	 * @return Property value or -1 in case of error (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_int_property(H3270 * hSession, const char *name, int seconds);
> 
> 	/**
> 	 * @brief Set lib3270 signed int property by name.
> 	 *
> 	 * @param name		Nome of the property.
> 	 * @param value		New property value.
> 	 * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
> 	 *
> 	 * @return 0 if ok error code if not (sets errno).
> 	 *
> 	 * @retval EPERM	Property is ready only.
> 	 * @retval ENOENT	Can't find a property with this name.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_int_property(H3270 * hSession, const char *name, int value, int seconds);
> 
> 	/**
> 	 * @brief Set lib3270 unsigned int property by name.
> 	 *
> 	 * @param name		Nome of the property.
> 	 * @param value		New property value.
> 	 * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
> 	 *
> 	 * @return 0 if ok error code if not (sets errno).
> 	 *
> 	 * @retval EPERM	Property is ready only.
> 	 * @retval ENOENT	Can't find a property with this name.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_uint_property(H3270 * hSession, const char *name, unsigned int value, int seconds);
> 
> 	/**
> 	 * @brief Set lib3270 boolean property by name.
> 	 *
> 	 * @param name		Nome of the property.
> 	 * @param value		New property value.
> 	 * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
> 	 *
> 	 * @return 0 if ok error code if not (sets errno).
> 	 *
> 	 * @retval EPERM	Property is ready only.
> 	 * @retval ENOENT	Can't find a property with this name.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_boolean_property(H3270 * hSession, const char *name, int value, int seconds);
> 
> 	/**
> 	 * @brief Set lib3270 string property by name.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param name		Nome of the property.
> 	 * @param value		New property value.
> 	 * @param seconds	Time (in seconds) whe should wait for "ready" state (0 = none).
> 	 *
> 	 * @return 0 if ok error code if not (sets errno).
> 	 *
> 	 * @retval EPERM	Property is ready only.
> 	 * @retval ENOENT	Can't find a property with this name.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_string_property(H3270 * hSession, const char *name, const char * value, int seconds);
> 
> 
> 	/**
> 	 * @brief Get Oversize.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @return Oversize definition (NULL if not set).
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_oversize(const H3270 *hSession);
> 
> 	 /**
> 	  * @brief Set oversize.
> 	  *
> 	  * @param hSession	Session handle.
> 	  * @param value	Oversize value.
> 	  *
> 	  * @return 0 if success, error code if not (sets errno)
> 	  *
> 	  * @retval EISCONN	Already connected to host.
> 	  * @retval ENOTSUP	Oversize is not supported.
> 	  *
> 	  */
> 	LIB3270_EXPORT int lib3270_set_oversize(H3270 *hSession, const char *value);
> 
> 	/**
> 	 * @brief Get property label.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_property_get_label(const LIB3270_PROPERTY * property);
> 
> 
> 	LIB3270_EXPORT const char * lib3270_property_get_name(const LIB3270_PROPERTY * property);
> 	LIB3270_EXPORT const char * lib3270_property_get_tooltip(const LIB3270_PROPERTY * property);
> 
> 	/**
> 	 * @brief Get property description.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_property_get_description(const LIB3270_PROPERTY * property);
> 
> 	/**
> 	 * @brief Get property summary.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_property_get_summary(const LIB3270_PROPERTY * property);
> 
> 	/**
> 	 * @brief Get unsigned int property by name.
> 	 *
> 	 * @param name	Property name.
> 	 *
> 	 * @return Property descriptor, or NULL if failed.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_UINT_PROPERTY * lib3270_unsigned_property_get_by_name(const char *name);
> 
> 	/**
> 	 * @brief Get lib3270 version info.
> 	 *
> 	 * @return String with lib3270 version info (release it with lib3270_free).
> 	 */
> 	LIB3270_EXPORT char * lib3270_get_version_info(void);
> 
> 	/**
> 	 * @brief Get hostname for the connect/reconnect operations.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 * @return Pointer to host id set (internal data, do not change it)
> 	 *
> 	 */
> 	 LIB3270_EXPORT const char * lib3270_host_get_name(const H3270 *h);
> 
> 	/**
> 	 * @brief Get service or port for the connect/reconnect operations.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 * @return Pointer to service name (internal data, do not change it)
> 	 *
> 	 */
> 	 LIB3270_EXPORT const char * lib3270_service_get_name(const H3270 *h);
312c279
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/selection.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/selection.h
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4,82c2,93
<  * Copyright (C) 2008 Banco do Brasil S.A.
<  *
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /**
<  * @brief LIB3270 calls for managing selected area.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
< 
< #ifndef LIB3270_SELECTION_H_INCLUDED
< 
< #define LIB3270_SELECTION_H_INCLUDED 1
< 
< /**
<  * @brief Selection element
<  *
<  */
< typedef struct _lib3270_selection_element {
< 	unsigned char chr;			///< @brief Element character.
< 
< 	struct {
< 		unsigned short	visual;	///< @brief Element colors & visual state. @see LIB3270_ATTR
< 		unsigned char	field;	///< @brief Field attribute. @see LIB3270_FIELD_ATTRIBUTE
< 	} attribute;
< 
< } lib3270_selection_element;
< 
< /**
<  * @brief A rectangle with informations about the selected area.
<  *
<  */
< typedef struct _lib3270_selection {
< 	/// @brief Cursor address.
< 	unsigned int cursor_address;
< 
< 	/// @brief Clipboard rectangle.
< 	struct {
< 		unsigned int row;
< 		unsigned int col;
< 		unsigned int width;
< 		unsigned int height;
< 	} bounds;
< 
< 	/// @brief Selection contents.
< 	lib3270_selection_element contents[1];
< 
< } lib3270_selection;
< 
< LIB3270_EXPORT int	  lib3270_unselect(H3270 *session);
< LIB3270_EXPORT void	  lib3270_select_to(H3270 *session, int baddr);
< 
< /**
<  * @brief Select word at position.
<  *
<  * @param hSession	Session handle.
<  * @param baddr		position.
<  *
<  * @return 0 if ok, non zero if failed
<  *
<  * @retval 0		The word was selected.
<  * @retval EINVAL	baddr is out of the screen.
<  * @retval ENOTCONN	The terminal is offline.
<  *
<  */
<  LIB3270_EXPORT int	  lib3270_select_word_at(H3270 *session, int baddr);
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como selection.h e possui - linhas de código.
>  *
>  * Contatos:
>  *
>  * perry.werneck@gmail.com	(Alexandre Perry de Souza Werneck)
>  * erico.mendonca@gmail.com	(Erico Mascarenhas Mendonça)
>  *
>  */
> 
>  /**
>   * @brief LIB3270 calls for managing selected area.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
> 
>  #ifndef LIB3270_SELECTION_H_INCLUDED
> 
> 	#define LIB3270_SELECTION_H_INCLUDED 1
> 
> 	/**
> 	 * @brief Selection element
> 	 *
> 	 */
> 	typedef struct _lib3270_selection_element
> 	{
> 		unsigned char chr;			///< @brief Element character.
> 
> 		struct
> 		{
> 			unsigned short	visual;	///< @brief Element colors & visual state. @see LIB3270_ATTR
> 			unsigned char	field;	///< @brief Field attribute. @see LIB3270_FIELD_ATTRIBUTE
> 		} attribute;
> 
> 	} lib3270_selection_element;
> 
> 	/**
> 	 * @brief A rectangle with informations about the selected area.
> 	 *
> 	 */
> 	typedef struct _lib3270_selection
> 	{
> 		/// @brief Cursor address.
> 		unsigned int cursor_address;
> 
> 		/// @brief Clipboard rectangle.
> 		struct {
> 			unsigned int row;
> 			unsigned int col;
> 			unsigned int width;
> 			unsigned int height;
> 		} bounds;
> 
> 		/// @brief Selection contents.
> 		lib3270_selection_element contents[1];
> 
> 	} lib3270_selection;
> 
> 	LIB3270_EXPORT int	  lib3270_unselect(H3270 *session);
> 	LIB3270_EXPORT void	  lib3270_select_to(H3270 *session, int baddr);
> 	LIB3270_EXPORT int	  lib3270_select_word_at(H3270 *session, int baddr);
> 	LIB3270_EXPORT int	  lib3270_select_word(H3270 *session);
> 	LIB3270_EXPORT int	  lib3270_select_field_at(H3270 *session, int baddr);
> 	LIB3270_EXPORT int	  lib3270_select_field(H3270 *session);
> 	LIB3270_EXPORT int	  lib3270_select_all(H3270 *session);
> 
> 	/**
> 	 * @brief Get selection options.
> 	 *
> 	 * @see lib3270_get_selection_as_text
> 	 *
> 	 */
> 	typedef enum _LIB3270_SELECTION_OPTIONS {
84,98c95,96
<  LIB3270_EXPORT int	  lib3270_select_word(H3270 *session);
<  LIB3270_EXPORT int	  lib3270_select_field_at(H3270 *session, int baddr);
<  LIB3270_EXPORT int	  lib3270_select_field(H3270 *session);
<  LIB3270_EXPORT int	  lib3270_select_all(H3270 *session);
< 
< /**
<  * @brief Get selection options.
<  *
<  * @see lib3270_get_selection_as_text
<  *
<  */
< typedef enum _LIB3270_SELECTION_OPTIONS {
< 
< 	LIB3270_SELECTION_CUT				= 0x0001,		///< @brief Cut selected data (if available).
< 	LIB3270_SELECTION_ALL				= 0x0002,		///< @brief Get all data (the default is get only selected data).
---
> 		LIB3270_SELECTION_CUT				= 0x0001,		///< @brief Cut selected data (if available).
> 		LIB3270_SELECTION_ALL				= 0x0002,		///< @brief Get all data (the default is get only selected data).
101,130c99
< } LIB3270_SELECTION_OPTIONS;
< 
< /**
<  * @brief "Paste" supplied string.
<  *
<  * @param h		Session handle.
<  * @param str	String to paste.
<  *
<  * @see lib3270_paste_next.
<  *
<  * @return 0 if suceeded, negative if fails, > 0 if there's more data.
<  *
<  * @retval 0		The entire string was pasted.
<  * @retval -EINVAL	Invalid argument.
<  * @retval -EPERM	Keyboard is locked.
<  *
<  */
< LIB3270_EXPORT int lib3270_paste_text(H3270 *hSession, const unsigned char *str);
< 
< /**
<  * @brief Paste remaining string.
<  *
<  * @param hSession	Session handle.
<  *
<  * @see lib3270_paste_text.
<  *
<  * @return Non 0 if there's more to paste.
<  *
<  */
< LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession);
---
> 	} LIB3270_SELECTION_OPTIONS;
132,273c101,271
< /**
<  * @brief Check if can paste next.
<  *
<  * @param hSession	Session handle.
<  *
<  * @see lib3270_paste_next.
<  *
<  * @return Non 0 if there's more to paste.
<  *
<  */
< LIB3270_EXPORT int lib3270_can_paste_next(const H3270 *hSession);
< 
< /**
<  * @brief Move selected box 1 char in the selected direction.
<  *
<  * @param h		Session handle.
<  * @param dir	Direction to move
<  *
<  * @return 0 if the movement can be done, non zero if failed.
<  */
< LIB3270_EXPORT int lib3270_move_selection(H3270 *h, LIB3270_DIRECTION dir);
< 
< /**
<  * @brief Move selected box.
<  *
<  * @param h		Session handle.
<  * @param from	Address of origin position inside the selected buffer.
<  * @param to	Address of the new origin position.
<  *
<  * @return The new origin position.
<  *
<  */
< LIB3270_EXPORT int lib3270_move_selected_area(H3270 *h, int from, int to);
< 
< /**
<  * @brief Drag selected region.
<  *
<  * Move or resize selected box according to the selection flags.
<  *
<  * @param h			Session handle.
<  * @param flag		Selection flag.
<  * @param origin	Reference position (got from mouse button down or other move action).
<  * @param baddr		New position.
<  *
<  * @return The new reference position.
<  *
<  */
< LIB3270_EXPORT int lib3270_drag_selection(H3270 *h, unsigned char flag, int origin, int baddr);
< 
< /**
<  * @brief Gets the selected range of characters in the screen
<  *
<  * @param h		Session handle.
<  * @param start	return location for start of selection, as a character offset.
<  * @param end	return location for end of selection, as a character offset.
<  *
<  * @return Non 0 if selection is non-empty
<  *
<  */
< LIB3270_EXPORT int lib3270_get_selection_bounds(H3270 *hSession, int *start, int *end);
< 
< /**
<  * @brief Get the coordinates of a rectangle containing the selected region.
<  *
<  * @param hSession	Session handle.
<  * @param col		Pointer to last row.
<  * @param row		Pointer to first row.
<  * @param width		Pointer to first col.
<  * @param height	Pointer to last col.
<  *
<  * @return 0 if suceeds, error code if not (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_get_selection_rectangle(H3270 *hSession, unsigned int *row, unsigned int *col, unsigned int *width, unsigned int *height);
< 
< /**
<  * @brief Create a new selection block.
<  *
<  * @param hSession	Session handle.
<  * @param cut		Non zero to clear selected contents.
<  * @param all		Non zero to get entire terminal, zero to get only the selected rectangle.
<  *
<  * @return NULL on error (sets errno), pointer to a rectangle containing the selected area (release it with lib3270_free).
<  *
<  */
< LIB3270_EXPORT lib3270_selection * lib3270_selection_new(H3270 *hSession, int cut, int all);
< 
< LIB3270_EXPORT lib3270_selection * LIB3270_DEPRECATED(lib3270_get_selection(H3270 *hSession, int cut, int all));
< 
< /**
<  * @brief Get the length of the selection block.
<  *
<  * @param selection	Selection block.
<  *
<  * @return The length of the selection block.
<  *
<  */
< LIB3270_EXPORT size_t lib3270_selection_get_length(const lib3270_selection *selection);
< 
< /**
<  * @brief Get bitmasked flag for the current selection.
<  *
<  * Calculate flags to help drawing of the correct mouse pointer over a selection.
<  *
<  * @param h		Session handle.
<  * @param baddr	Position.
<  *
<  * @return bitmask for mouse pointer.
<  */
< LIB3270_EXPORT unsigned char lib3270_get_selection_flags(H3270 *h, int baddr);
< 
< /**
<  * @brief Get a string from required region.
<  *
<  * @param h			Session handle.
<  * @param start_pos	First char to get.
<  * @param end_pos	Last char to get.
<  * @param all		zero to get only selected chars.
<  *
<  * @return String with selected region (release it with free()
<  *
<  */
< LIB3270_EXPORT char * lib3270_get_region(H3270 *h, int start_pos, int end_pos, unsigned char all);
< 
< 
< /**
<  * @brief Selects a range of characters in the screen.
<  *
<  * @param h				Session handle.
<  * @param start_offset	Start offset.
<  * @param end_offset :	End offset.
<  *
<  */
< LIB3270_EXPORT int lib3270_select_region(H3270 *h, int start, int end);
< 
< /**
<  * @brief Erase selected inputs.
<  *
<  * @param hSession	Session handle.
<  *
<  */
< LIB3270_EXPORT int lib3270_erase_selected(H3270 *hSession);
---
> 	/**
> 	 * @brief "Paste" supplied string.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param str	String to paste.
> 	 *
> 	 * @see lib3270_paste_next.
> 	 *
> 	 * @return 0 if suceeded, negative if faile, > 0 if there's more data.
> 	 *
> 	 * @retval 0		The entire string was pasted.
> 	 * @retval -EINVAL	Invalid argument.
> 	 * @retval -EPERM	Keyboard is locked.
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_paste_text(H3270 *hSession, const unsigned char *str);
> 
> 	/**
> 	 * @brief Paste remaining string.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @see lib3270_paste_text.
> 	 *
> 	 * @return Non 0 if there's more to paste.
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_paste_next(H3270 *hSession);
> 
> 	/**
> 	 * @brief Check if can paste next.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @see lib3270_paste_next.
> 	 *
> 	 * @return Non 0 if there's more to paste.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_can_paste_next(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Move selected box 1 char in the selected direction.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param dir	Direction to move
> 	 *
> 	 * @return 0 if the movement can be done, non zero if failed.
> 	 */
> 	 LIB3270_EXPORT int lib3270_move_selection(H3270 *h, LIB3270_DIRECTION dir);
> 
> 	/**
> 	 * @brief Move selected box.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param from	Address of origin position inside the selected buffer.
> 	 * @param to	Address of the new origin position.
> 	 *
> 	 * @return The new origin position.
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_move_selected_area(H3270 *h, int from, int to);
> 
> 	/**
> 	 * @brief Drag selected region.
> 	 *
> 	 * Move or resize selected box according to the selection flags.
> 	 *
> 	 * @param h			Session handle.
> 	 * @param flag		Selection flag.
> 	 * @param origin	Reference position (got from mouse button down or other move action).
> 	 * @param baddr		New position.
> 	 *
> 	 * @return The new reference position.
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_drag_selection(H3270 *h, unsigned char flag, int origin, int baddr);
> 
> 	/**
> 	 * @brief Gets the selected range of characters in the screen
> 	 *
> 	 * @param h		Session handle.
> 	 * @param start	return location for start of selection, as a character offset.
> 	 * @param end	return location for end of selection, as a character offset.
> 	 *
> 	 * @return Non 0 if selection is non-empty
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_get_selection_bounds(H3270 *hSession, int *start, int *end);
> 
> 	/**
> 	 * @brief Get the coordinates of a rectangle containing the selected region.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param col		Pointer to last row.
> 	 * @param row		Pointer to first row.
> 	 * @param width		Pointer to first col.
> 	 * @param height	Pointer to last col.
> 	 *
> 	 * @return 0 if suceeds, error code if not (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_selection_rectangle(H3270 *hSession, unsigned int *row, unsigned int *col, unsigned int *width, unsigned int *height);
> 
> 	/**
> 	 * @brief Create a new selection block.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param cut		Non zero to clear selected contents.
> 	 * @param all		Non zero to get entire terminal, zero to get only the selected rectangle.
> 	 *
> 	 * @return NULL on error (sets errno), pointer to a rectangle containing the selected area (release it with lib3270_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT lib3270_selection * lib3270_selection_new(H3270 *hSession, int cut, int all);
> 
> 	LIB3270_EXPORT lib3270_selection * LIB3270_DEPRECATED(lib3270_get_selection(H3270 *hSession, int cut, int all));
> 
> 	/**
> 	 * @brief Get the length of the selection block.
> 	 *
> 	 * @param selection	Selection block.
> 	 *
> 	 * @return The length of the selection block.
> 	 *
> 	 */
> 	LIB3270_EXPORT size_t lib3270_selection_get_length(const lib3270_selection *selection);
> 
> 	/**
> 	 * @brief Get bitmasked flag for the current selection.
> 	 *
> 	 * Calculate flags to help drawing of the correct mouse pointer over a selection.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param baddr	Position.
> 	 *
> 	 * @return bitmask for mouse pointer.
> 	 */
> 	 LIB3270_EXPORT unsigned char lib3270_get_selection_flags(H3270 *h, int baddr);
> 
> 	/**
> 	 * @brief Get a string from required region.
> 	 *
> 	 * @param h			Session handle.
> 	 * @param start_pos	First char to get.
> 	 * @param end_pos	Last char to get.
> 	 * @param all		zero to get only selected chars.
> 	 *
> 	 * @return String with selected region (release it with free()
> 	 *
> 	 */
> 	 LIB3270_EXPORT char * lib3270_get_region(H3270 *h, int start_pos, int end_pos, unsigned char all);
> 
> 
> 	/**
> 	 * @brief Selects a range of characters in the screen.
> 	 *
> 	 * @param h				Session handle.
> 	 * @param start_offset	Start offset.
> 	 * @param end_offset :	End offset.
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_select_region(H3270 *h, int start, int end);
> 
> 	/**
> 	 * @brief Erase selected inputs.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_erase_selected(H3270 *hSession);
275c273
< #endif // LIB3270_SELECTION_H_INCLUDED
---
>  #endif // LIB3270_SELECTION_H_INCLUDED
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/session.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/session.h
30c30
< #ifndef LIB3270_SESSION_H_INCLUDED
---
>  #ifndef LIB3270_SESSION_H_INCLUDED
32c32
< #define LIB3270_SESSION_H_INCLUDED 1
---
> 	#define LIB3270_SESSION_H_INCLUDED 1
34,110c34,107
< #if defined(_WIN32) || defined(_MSC_VER)
< #include <winsock2.h>
< #include <windows.h>
< #include <ws2tcpip.h>
< #else
< #include <sys/socket.h>
< #endif // _WIN32
< 
< #include <lib3270/popup.h>
< #include <lib3270/toggle.h>
< #include <lib3270/ssl.h>
< 
< struct lib3270_session_callbacks {
< 	void (*configure)(H3270 *session, unsigned short rows, unsigned short cols);
< 	void (*update)(H3270 *session, int baddr, unsigned char c, unsigned short attr, unsigned char cursor);
< 	void (*changed)(H3270 *session, int offset, int len);
< 	void (*display)(H3270 *session);
< 	void (*set_width)(H3270 *session, int width);
< 
< 	void (*update_cursor)(H3270 *session, unsigned short row, unsigned short col, unsigned char c, unsigned short attr);
< 	void (*update_oia)(H3270 *session, LIB3270_FLAG id, unsigned char on);
< 	void (*update_toggle)(H3270 *session, LIB3270_TOGGLE_ID ix, unsigned char value, LIB3270_TOGGLE_TYPE reason, const char *name);
< 	void (*update_luname)(H3270 *session, const char *name);
< 	void (*update_status)(H3270 *session, LIB3270_MESSAGE id);
< 	void (*update_connect)(H3270 *session, unsigned char connected);
< 	void (*update_model)(H3270 *session, const char *name, int model, int rows, int cols);
< 	void (*update_selection)(H3270 *session, int start, int end);
< 	void (*update_ssl)(H3270 *session, LIB3270_SSL_STATE state);
< 	void (*update_url)(H3270 *session, const char *url);
< 
< 	void (*set_timer)(H3270 *session, unsigned char on);
< 	void (*erase)(H3270 *session);
< 	void (*suspend)(H3270 *session);
< 	void (*resume)(H3270 *session);
< 	void (*cursor)(H3270 *session, LIB3270_POINTER id);
< 	void (*set_selection)(H3270 *session, unsigned char on);
< 	void (*ctlr_done)(H3270 *session);
< 	void (*autostart)(H3270 *session);
< 
< 	int  (*print)(H3270 *session, LIB3270_CONTENT_OPTION mode);
< 	int  (*save)(H3270 *session, LIB3270_CONTENT_OPTION mode, const char *filename);
< 	int  (*load)(H3270 *hSession, const char *filename);
< 
< 	int  (*popup)(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
< 
< 	int	 (*action)(H3270 *hSession, const char *name);
< 
< 	int  (*reconnect)(H3270 *hSession,int seconds);
< 
< 	void (*word_selected)(H3270 *hSession, int start, int end);
< 
< };
< 
< /**
<  * Register application Handlers.
<  *
<  * @param cbk	Structure with the application I/O handles to set.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_session_io_handler(const LIB3270_IO_CONTROLLER *cbk);
< 
< LIB3270_EXPORT int lib3270_getpeername(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
< LIB3270_EXPORT int lib3270_getsockname(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
< 
< /**
<  * @brief Get lib3270 callback table.
<  *
<  * @param hSession	TN3270 Session.
<  . @param revision	Expected lib3270 revision.
<  * @param sz		Expected lib3270_session_callbacks struct length.
<  *
<  * @return Callback table if ok, NULL if failed.
<  *
<  */
< LIB3270_EXPORT struct lib3270_session_callbacks * lib3270_get_session_callbacks(H3270 *hSession, const char *revision, unsigned short sz);
---
> 	#if defined(_WIN32) || defined(_MSC_VER)
> 		#include <winsock2.h>
> 		#include <windows.h>
> 		#include <ws2tcpip.h>
> 	#else
> 		#include <sys/socket.h>
> 	#endif // _WIN32
> 
> 	#include <lib3270/popup.h>
> 	#include <lib3270/toggle.h>
> 	#include <lib3270/ssl.h>
> 
> 	struct lib3270_session_callbacks
> 	{
> 		void (*configure)(H3270 *session, unsigned short rows, unsigned short cols);
> 		void (*update)(H3270 *session, int baddr, unsigned char c, unsigned short attr, unsigned char cursor);
> 		void (*changed)(H3270 *session, int offset, int len);
> 		void (*display)(H3270 *session);
> 		void (*set_width)(H3270 *session, int width);
> 
> 		void (*update_cursor)(H3270 *session, unsigned short row, unsigned short col, unsigned char c, unsigned short attr);
> 		void (*update_oia)(H3270 *session, LIB3270_FLAG id, unsigned char on);
> 		void (*update_toggle)(H3270 *session, LIB3270_TOGGLE_ID ix, unsigned char value, LIB3270_TOGGLE_TYPE reason, const char *name);
> 		void (*update_luname)(H3270 *session, const char *name);
> 		void (*update_status)(H3270 *session, LIB3270_MESSAGE id);
> 		void (*update_connect)(H3270 *session, unsigned char connected);
> 		void (*update_model)(H3270 *session, const char *name, int model, int rows, int cols);
> 		void (*update_selection)(H3270 *session, int start, int end);
> 		void (*update_ssl)(H3270 *session, LIB3270_SSL_STATE state);
> 		void (*update_url)(H3270 *session, const char *url);
> 
> 		void (*set_timer)(H3270 *session, unsigned char on);
> 		void (*erase)(H3270 *session);
> 		void (*suspend)(H3270 *session);
> 		void (*resume)(H3270 *session);
> 		void (*cursor)(H3270 *session, LIB3270_POINTER id);
> 		void (*set_selection)(H3270 *session, unsigned char on);
> 		void (*ctlr_done)(H3270 *session);
> 		void (*autostart)(H3270 *session);
> 
> 		int  (*print)(H3270 *session, LIB3270_CONTENT_OPTION mode);
> 		int  (*save)(H3270 *session, LIB3270_CONTENT_OPTION mode, const char *filename);
> 		int  (*load)(H3270 *hSession, const char *filename);
> 
> 		int  (*popup)(H3270 *hSession, const LIB3270_POPUP *popup, unsigned char wait);
> 
> 		int	 (*action)(H3270 *hSession, const char *name);
> 
> 	};
> 
> 	/**
> 	 * Register application Handlers.
> 	 *
> 	 * @param cbk	Structure with the application I/O handles to set.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_session_io_handler(const LIB3270_IO_CONTROLLER *cbk);
> 
> 	LIB3270_EXPORT int lib3270_getpeername(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
> 	LIB3270_EXPORT int lib3270_getsockname(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
> 
> 	/**
> 	 * @brief Get lib3270 callback table.
> 	 *
> 	 * @param hSession	TN3270 Session.
> 	 . @param revision	Expected lib3270 revision.
> 	 * @param sz		Expected lib3270_session_callbacks struct length.
> 	 *
> 	 * @return Callback table if ok, NULL if failed.
> 	 *
> 	 */
> 	LIB3270_EXPORT struct lib3270_session_callbacks * lib3270_get_session_callbacks(H3270 *hSession, const char *revision, unsigned short sz);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/ssl.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/ssl.h
30,35c30,35
< /**
<  * @brief TN3270 SSL definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 SSL definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
39c39
< #define LIB3270_SSL_H_INCLUDED 1
---
> 	#define LIB3270_SSL_H_INCLUDED 1
41c41
< #include <lib3270.h>
---
> 	#include <lib3270.h>
44c44
< extern "C" {
---
> 	extern "C" {
47,120c47,121
< /// @brief SSL state
< typedef enum lib3270_ssl_state {
< 	LIB3270_SSL_UNSECURE,			/**< @brief No secure connection */
< 	LIB3270_SSL_SECURE,				/**< @brief Connection secure with CA check */
< 	LIB3270_SSL_NEGOTIATED,			/**< @brief Connection secure, no CA, self-signed or expired CRL */
< 	LIB3270_SSL_NEGOTIATING,		/**< @brief Negotiating SSL */
< 	LIB3270_SSL_VERIFYING,			/**< @brief Verifying SSL (Getting CRL) */
< 	LIB3270_SSL_UNDEFINED			/**< @brief Undefined */
< } LIB3270_SSL_STATE;
< 
< /**
<  * @brief Set URL for the certificate revocation list.
<  *
<  * @param hSession	Session handle.
<  * @param crl		URL for the certificate revocation list.
<  *
<  * @return 0 on sucess, non zero on error (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_crl_set_url(H3270 *hSession, const char *crl);
< LIB3270_EXPORT const char * lib3270_crl_get_url(const H3270 *hSession);
< 
< LIB3270_EXPORT int lib3270_crl_set_preferred_protocol(H3270 *hSession, const char *protocol);
< LIB3270_EXPORT const char * lib3270_crl_get_preferred_protocol(const H3270 *hSession);
< 
< /**
<  * @brief Get the available protocols for CRL download.
<  *
<  */
< LIB3270_EXPORT const char ** lib3270_get_available_crl_protocols(void);
< 
< /**
<  * @brief Get SSL host option.
<  *
<  * @return Non zero if the host URL has SSL scheme.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_secure_host(const H3270 *hSession);
< 
< /**
<  * @brief Get security state.
<  *
<  */
< LIB3270_EXPORT LIB3270_SSL_STATE lib3270_get_ssl_state(const H3270 *session);
< 
< /**
<  * @brief Get security state as text.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_ssl_state_message(const H3270 *hSession);
< 
< LIB3270_EXPORT const char * lib3270_get_ssl_state_icon_name(const H3270 *hSession);
< 
< /**
<  * @brief Get security state message.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_ssl_state_description(const H3270 *hSession);
< 
< LIB3270_EXPORT char * lib3270_get_ssl_crl_text(const H3270 *hSession);
< LIB3270_EXPORT char * lib3270_get_ssl_peer_certificate_text(const H3270 *hSession);
< 
< /**
<  * @brief Disable automatic download of the CRL.
<  *
<  * @param hSession	Session handle.
<  * @param Value		Non zero to enable automatic download of CRL.
<  *
<  * @return 0 if ok or error code if not (Sets errno).
<  *
<  * @retval	0 		Success, the property was set.
<  * @retval	ENOTSUP	No SSL/TLS support.
<  */
< LIB3270_EXPORT int lib3270_ssl_set_crl_download(H3270 *hSession, int enabled);
---
> 	/// @brief SSL state
> 	typedef enum lib3270_ssl_state
> 	{
> 		LIB3270_SSL_UNSECURE,			/**< @brief No secure connection */
> 		LIB3270_SSL_SECURE,				/**< @brief Connection secure with CA check */
> 		LIB3270_SSL_NEGOTIATED,			/**< @brief Connection secure, no CA, self-signed or expired CRL */
> 		LIB3270_SSL_NEGOTIATING,		/**< @brief Negotiating SSL */
> 		LIB3270_SSL_VERIFYING,			/**< @brief Verifying SSL (Getting CRL) */
> 		LIB3270_SSL_UNDEFINED			/**< @brief Undefined */
> 	} LIB3270_SSL_STATE;
> 
> 	/**
> 	 * @brief Set URL for the certificate revocation list.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param crl		URL for the certificate revocation list.
> 	 *
> 	 * @return 0 on sucess, non zero on error (sets errno).
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_crl_set_url(H3270 *hSession, const char *crl);
> 	 LIB3270_EXPORT const char * lib3270_crl_get_url(const H3270 *hSession);
> 
> 	 LIB3270_EXPORT int lib3270_crl_set_preferred_protocol(H3270 *hSession, const char *protocol);
> 	 LIB3270_EXPORT const char * lib3270_crl_get_preferred_protocol(const H3270 *hSession);
> 
> 	 /**
> 	  * @brief Get the available protocols for CRL download.
> 	  *
> 	  */
> 	 LIB3270_EXPORT const char ** lib3270_get_available_crl_protocols(void);
> 
> 	/**
> 	 * @brief Get SSL host option.
> 	 *
> 	 * @return Non zero if the host URL has SSL scheme.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_secure_host(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get security state.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_SSL_STATE lib3270_get_ssl_state(const H3270 *session);
> 
> 	/**
> 	 * @brief Get security state as text.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_ssl_state_message(const H3270 *hSession);
> 
> 	LIB3270_EXPORT const char * lib3270_get_ssl_state_icon_name(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get security state message.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_ssl_state_description(const H3270 *hSession);
> 
> 	LIB3270_EXPORT char * lib3270_get_ssl_crl_text(const H3270 *hSession);
> 	LIB3270_EXPORT char * lib3270_get_ssl_peer_certificate_text(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Disable automatic download of the CRL.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param Value		Non zero to enable automatic download of CRL.
> 	 *
> 	 * @return 0 if ok or error code if not (Sets errno).
> 	 *
> 	 * @retval	0 		Success, the property was set.
> 	 * @retval	ENOTSUP	No SSL/TLS support.
> 	 */
> 	LIB3270_EXPORT int lib3270_ssl_set_crl_download(H3270 *hSession, int enabled);
122c123
< LIB3270_EXPORT int lib3270_ssl_get_crl_download(const H3270 *hSession);
---
> 	LIB3270_EXPORT int lib3270_ssl_get_crl_download(const H3270 *hSession);
126c127
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/toggle.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/toggle.h
32c32
< #define LIB3270_TOGGLE_H_INCLUDED 1
---
> 	#define LIB3270_TOGGLE_H_INCLUDED 1
34c34
< #include <lib3270.h>
---
> 	#include <lib3270.h>
37c37
< extern "C" {
---
> 	extern "C" {
40,221c40,220
< /**
<  * @brief Toogles.
<  */
< typedef enum _lib3270_toggle_id {
< 	LIB3270_TOGGLE_MONOCASE,
< 	LIB3270_TOGGLE_CURSOR_BLINK,
< 	LIB3270_TOGGLE_SHOW_TIMING,
< 	LIB3270_TOGGLE_CURSOR_POS,
< 	LIB3270_TOGGLE_DS_TRACE,
< 	LIB3270_TOGGLE_LINE_WRAP,
< 	LIB3270_TOGGLE_BLANK_FILL,
< 	LIB3270_TOGGLE_SCREEN_TRACE,
< 	LIB3270_TOGGLE_EVENT_TRACE,
< 	LIB3270_TOGGLE_MARGINED_PASTE,
< 	LIB3270_TOGGLE_RECTANGLE_SELECT,
< 	LIB3270_TOGGLE_CROSSHAIR,
< 	LIB3270_TOGGLE_FULL_SCREEN,
< 	LIB3270_TOGGLE_INSERT,
< 	LIB3270_TOGGLE_SMART_PASTE,
< 	LIB3270_TOGGLE_BOLD,
< 	LIB3270_TOGGLE_KEEP_SELECTED,
< 	LIB3270_TOGGLE_UNDERLINE,					/**< @brief Show underline ? */
< 	LIB3270_TOGGLE_CONNECT_ON_STARTUP,
< 	LIB3270_TOGGLE_KP_ALTERNATIVE,              /**< @brief Keypad +/- move to next/previous field */
< 	LIB3270_TOGGLE_BEEP,						/**< @brief Beep on errors */
< 	LIB3270_TOGGLE_VIEW_FIELD,					/**< @brief View Field attribute */
< 	LIB3270_TOGGLE_ALTSCREEN,					/**< @brief auto resize on altscreen */
< 	LIB3270_TOGGLE_KEEP_ALIVE,					/**< @brief Enable network keep-alive with SO_KEEPALIVE */
< 	LIB3270_TOGGLE_NETWORK_TRACE,				/**< @brief Enable network in/out trace */
< 	LIB3270_TOGGLE_SSL_TRACE,					/**< @brief Enable security traces */
< 
< 	// Deprecated.
< 
< 	LIB3270_TOGGLE_RECONNECT,					/**< @brief Auto reconnect */
< 
< 	LIB3270_TOGGLE_COUNT
< 
< } LIB3270_TOGGLE_ID;
< 
< /**
<  * @brief Toggle types.
<  *
<  */
< typedef enum _LIB3270_TOGGLE_TYPE {
< 	LIB3270_TOGGLE_TYPE_INITIAL,
< 	LIB3270_TOGGLE_TYPE_INTERACTIVE,
< 	LIB3270_TOGGLE_TYPE_ACTION,
< 	LIB3270_TOGGLE_TYPE_FINAL,
< 	LIB3270_TOGGLE_TYPE_UPDATE,
< 
< 	LIB3270_TOGGLE_TYPE_USER
< 
< } LIB3270_TOGGLE_TYPE;
< 
< 
< typedef struct _lib3270_toggle {
< 	LIB3270_PROPERTY_HEAD
< 
< 	LIB3270_TOGGLE_ID	  id;			///< @brief Toggle ID.
< 	const char			  def;			///< @brief Default value.
< 	const char			* key;			///< @brief Default key (or NULL if no default).
< 	const char			* nick;			///< @brief Toggle nick.
< 
< } LIB3270_TOGGLE;
< 
< /**
<  * @brief Get the toggle by name.
<  *
<  */
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_by_name(const char *name);
< 
< /**
<  * @brief Get the toggle descriptors.
<  *
<  * @return Pointer to all available toggles.
<  *
<  */
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggles();
< 
< LIB3270_EXPORT const LIB3270_TOGGLE * LIB3270_DEPRECATED(lib3270_get_toggle_list());
< 
< /**
<  * @brief get toggle state.
<  *
<  * @param hSession		Session handle.
<  * @param ix			Toggle id.
<  *
<  * @return 0 if the toggle is disabled, non zero if enabled.
<  *
<  */
< LIB3270_EXPORT unsigned char lib3270_get_toggle(const H3270 *hSession, LIB3270_TOGGLE_ID ix);
< 
< /**
<  * @brief Set toggle state.
<  *
<  * @param hSession	Session handle.
<  * @param ix		Toggle id.
<  * @param value		New toggle state (non zero for true).
<  *
<  * @returns 0 if the toggle is already at the state, 1 if the toggle was changed; < 0 on error (sets errno).
<  *
<  * @retval -EINVAL	Invalid toggle id.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_toggle(H3270 *hSession, LIB3270_TOGGLE_ID ix, int value);
< 
< /**
<  * @brief Translate a string toggle name to the corresponding value.
<  *
<  * @param name	Toggle name.
<  *
<  * @return Toggle ID or negative if it's invalid.
<  *
<  */
< LIB3270_EXPORT LIB3270_TOGGLE_ID lib3270_get_toggle_id(const char *name);
< 
< /**
<  * @brief Get the toggle name as string.
<  *
<  * @param id	Toggle id
<  *
<  * @return Constant string with the toggle name or "" if invalid.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_toggle_name(LIB3270_TOGGLE_ID ix);
< 
< 
< 
< /**
<  * @brief Get a long description of the toggle.
<  *
<  * @return Constant string with the toggle description.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_toggle_description(LIB3270_TOGGLE_ID ix);
< 
< /**
<  * @brief Get a summary description of the toggle (for menus).
<  *
<  * @return Constant string with the toggle summary.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_toggle_summary(LIB3270_TOGGLE_ID ix);
< 
< /**
<  * @brief Get a short description of the toggle (for buttons).
<  *
<  * @return Constant string with the toggle label.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_toggle_label(LIB3270_TOGGLE_ID ix);
< 
< /**
<  * @brief Revert toggle status.
<  *
<  * @param hSession	Session handle.
<  * @param ix		Toggle id.
<  *
<  * @return 0 if the toggle is already at the state, 1 if the toggle was changed; < 0 on error (sets errno).
<  *
<  * @retval -EINVAL	Invalid toggle id.
<  */
< LIB3270_EXPORT int lib3270_toggle(H3270 *hSession, LIB3270_TOGGLE_ID ix);
< 
< LIB3270_EXPORT const void * lib3270_register_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, void (*func)(H3270 *, LIB3270_TOGGLE_ID, char, void *),void *data);
< LIB3270_EXPORT int lib3270_unregister_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, const void *id);
< 
< 
< /**
<  * @brief Get toggle descriptor from ID.
<  *
<  * @param id	Toggle.id.
<  *
<  * @return The toggle descriptor or NULL if the ID is invalid.
<  *
<  */
< LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_from_id(LIB3270_TOGGLE_ID id);
< 
< LIB3270_EXPORT const char * lib3270_toggle_get_name(const LIB3270_TOGGLE *toggle);
< LIB3270_EXPORT const char * lib3270_toggle_get_label(const LIB3270_TOGGLE *toggle);
< LIB3270_EXPORT const char * lib3270_toggle_get_summary(const LIB3270_TOGGLE *toggle);
< LIB3270_EXPORT const char * lib3270_toggle_get_description(const LIB3270_TOGGLE *toggle);
---
> 	/**
> 	 * @brief Toogles.
> 	 */
> 	typedef enum _lib3270_toggle_id
> 	{
> 		LIB3270_TOGGLE_MONOCASE,
> 		LIB3270_TOGGLE_CURSOR_BLINK,
> 		LIB3270_TOGGLE_SHOW_TIMING,
> 		LIB3270_TOGGLE_CURSOR_POS,
> 		LIB3270_TOGGLE_DS_TRACE,
> 		LIB3270_TOGGLE_LINE_WRAP,
> 		LIB3270_TOGGLE_BLANK_FILL,
> 		LIB3270_TOGGLE_SCREEN_TRACE,
> 		LIB3270_TOGGLE_EVENT_TRACE,
> 		LIB3270_TOGGLE_MARGINED_PASTE,
> 		LIB3270_TOGGLE_RECTANGLE_SELECT,
> 		LIB3270_TOGGLE_CROSSHAIR,
> 		LIB3270_TOGGLE_FULL_SCREEN,
> 		LIB3270_TOGGLE_RECONNECT,
> 		LIB3270_TOGGLE_INSERT,
> 		LIB3270_TOGGLE_SMART_PASTE,
> 		LIB3270_TOGGLE_BOLD,
> 		LIB3270_TOGGLE_KEEP_SELECTED,
> 		LIB3270_TOGGLE_UNDERLINE,					/**< @brief Show underline ? */
> 		LIB3270_TOGGLE_CONNECT_ON_STARTUP,
> 		LIB3270_TOGGLE_KP_ALTERNATIVE,              /**< @brief Keypad +/- move to next/previous field */
> 		LIB3270_TOGGLE_BEEP,						/**< @brief Beep on errors */
> 		LIB3270_TOGGLE_VIEW_FIELD,					/**< @brief View Field attribute */
> 		LIB3270_TOGGLE_ALTSCREEN,					/**< @brief auto resize on altscreen */
> 		LIB3270_TOGGLE_KEEP_ALIVE,					/**< @brief Enable network keep-alive with SO_KEEPALIVE */
> 		LIB3270_TOGGLE_NETWORK_TRACE,				/**< @brief Enable network in/out trace */
> 		LIB3270_TOGGLE_SSL_TRACE,					/**< @brief Enable security traces */
> 
> 		LIB3270_TOGGLE_COUNT
> 
> 	} LIB3270_TOGGLE_ID;
> 
> 	/**
> 	 * @brief Toggle types.
> 	 *
> 	 */
> 	typedef enum _LIB3270_TOGGLE_TYPE
> 	{
> 		LIB3270_TOGGLE_TYPE_INITIAL,
> 		LIB3270_TOGGLE_TYPE_INTERACTIVE,
> 		LIB3270_TOGGLE_TYPE_ACTION,
> 		LIB3270_TOGGLE_TYPE_FINAL,
> 		LIB3270_TOGGLE_TYPE_UPDATE,
> 
> 		LIB3270_TOGGLE_TYPE_USER
> 
> 	} LIB3270_TOGGLE_TYPE;
> 
> 
> 	typedef struct _lib3270_toggle
> 	{
> 		LIB3270_PROPERTY_HEAD
> 
> 		LIB3270_TOGGLE_ID	  id;			///< @brief Toggle ID.
> 		const char			  def;			///< @brief Default value.
> 		const char			* key;			///< @brief Default key (or NULL if no default).
> 
> 	} LIB3270_TOGGLE;
> 
> 	/**
> 	 * @brief Get the toggle by name.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_by_name(const char *name);
> 
> 	/**
> 	 * @brief Get the toggle descriptors.
> 	 *
> 	 * @return Pointer to all available toggles.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_get_toggles();
> 
> 	LIB3270_EXPORT const LIB3270_TOGGLE * LIB3270_DEPRECATED(lib3270_get_toggle_list());
> 
> 	/**
> 	 * @brief get toggle state.
> 	 *
> 	 * @param hSession		Session handle.
> 	 * @param ix			Toggle id.
> 	 *
> 	 * @return 0 if the toggle is disabled, non zero if enabled.
> 	 *
> 	 */
> 	LIB3270_EXPORT unsigned char lib3270_get_toggle(const H3270 *hSession, LIB3270_TOGGLE_ID ix);
> 
> 	/**
> 	 * @brief Set toggle state.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param ix		Toggle id.
> 	 * @param value		New toggle state (non zero for true).
> 	 *
> 	 * @returns 0 if the toggle is already at the state, 1 if the toggle was changed; < 0 on error (sets errno).
> 	 *
> 	 * @retval -EINVAL	Invalid toggle id.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_toggle(H3270 *hSession, LIB3270_TOGGLE_ID ix, int value);
> 
> 	/**
> 	 * @brief Translate a string toggle name to the corresponding value.
> 	 *
> 	 * @param name	Toggle name.
> 	 *
> 	 * @return Toggle ID or negative if it's invalid.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_TOGGLE_ID lib3270_get_toggle_id(const char *name);
> 
> 	/**
> 	 * @brief Get the toggle name as string.
> 	 *
> 	 * @param id	Toggle id
> 	 *
> 	 * @return Constant string with the toggle name or "" if invalid.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_toggle_name(LIB3270_TOGGLE_ID ix);
> 
> 
> 
> 	/**
> 	 * @brief Get a long description of the toggle.
> 	 *
> 	 * @return Constant string with the toggle description.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_toggle_description(LIB3270_TOGGLE_ID ix);
> 
> 	/**
> 	 * @brief Get a summary description of the toggle (for menus).
> 	 *
> 	 * @return Constant string with the toggle summary.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_toggle_summary(LIB3270_TOGGLE_ID ix);
> 
> 	/**
> 	 * @brief Get a short description of the toggle (for buttons).
> 	 *
> 	 * @return Constant string with the toggle label.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_toggle_label(LIB3270_TOGGLE_ID ix);
> 
> 	/**
> 	 * @brief Revert toggle status.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param ix		Toggle id.
> 	 *
> 	 * @return 0 if the toggle is already at the state, 1 if the toggle was changed; < 0 on error (sets errno).
> 	 *
> 	 * @retval -EINVAL	Invalid toggle id.
> 	 */
> 	LIB3270_EXPORT int lib3270_toggle(H3270 *hSession, LIB3270_TOGGLE_ID ix);
> 
> 	LIB3270_EXPORT const void * lib3270_register_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, void (*func)(H3270 *, LIB3270_TOGGLE_ID, char, void *),void *data);
> 	LIB3270_EXPORT int lib3270_unregister_toggle_listener(H3270 *hSession, LIB3270_TOGGLE_ID tx, const void *id);
> 
> 
> 	/**
> 	 * @brief Get toggle descriptor from ID.
> 	 *
> 	 * @param id	Toggle.id.
> 	 *
> 	 * @return The toggle descriptor or NULL if the ID is invalid.
> 	 *
> 	 */
> 	LIB3270_EXPORT const LIB3270_TOGGLE * lib3270_toggle_get_from_id(LIB3270_TOGGLE_ID id);
> 
> 	LIB3270_EXPORT const char * lib3270_toggle_get_name(const LIB3270_TOGGLE *toggle);
> 	LIB3270_EXPORT const char * lib3270_toggle_get_label(const LIB3270_TOGGLE *toggle);
> 	LIB3270_EXPORT const char * lib3270_toggle_get_summary(const LIB3270_TOGGLE *toggle);
> 	LIB3270_EXPORT const char * lib3270_toggle_get_description(const LIB3270_TOGGLE *toggle);
225c224
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/trace.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270/trace.h
33c33
< #define LIB3270_TRACE_H_INCLUDED 1
---
> 	#define LIB3270_TRACE_H_INCLUDED 1
35,36c35,36
< #include <lib3270.h>
< #include <lib3270/os.h>
---
> 	#include <lib3270.h>
> 	#include <lib3270/os.h>
39c39
< extern "C" {
---
> 	extern "C" {
43c43
< #define LIB3270_AS_PRINTF(a,b) /* __attribute__((format(printf, a, b))) */
---
> 	#define LIB3270_AS_PRINTF(a,b) /* __attribute__((format(printf, a, b))) */
45c45
< #define LIB3270_AS_PRINTF(a,b) __attribute__((format(printf, a, b)))
---
> 	#define LIB3270_AS_PRINTF(a,b) __attribute__((format(printf, a, b)))
48c48
< typedef int (*LIB3270_TRACE_HANDLER)(const H3270 *, void *, const char *);
---
> 	typedef void (*LIB3270_TRACE_HANDLER)(H3270 *, void *, const char *, va_list);
50,154c50,136
< /**
<  * @brief Set trace filename.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param name		The trace file name (null to disable).
<  *
<  */
< LIB3270_EXPORT int lib3270_set_trace_filename(H3270 * hSession, const char *name);
< 
< /**
<  * @brief Get trace file name.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @return The trace file name or NULL if disabled.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_trace_filename(const H3270 * hSession);
< 
< /**
<  * @brief Set trace handle callback.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param handler	Callback to write in trace file or show trace window (NULL send all trace to stdout/syslog).
<  * @param userdata	User data to pass to the trace handler.
<  *
<  */
< LIB3270_EXPORT void lib3270_set_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER handler, void *userdata);
< 
< /**
<  * @brief Get trace handle callback.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param handler	Callback to write in trace file or show trace window (NULL send all trace to stdout/syslog).
<  * @param userdata	User data to pass to the trace handler.
<  *
<  */
< LIB3270_EXPORT void lib3270_get_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER *handler, void **userdata);
< 
< /**
<  * @brief Write on trace file.
<  *
<  * Write text on trace file.
<  *
<  * @param fmt 	String format.
<  * @param ...	Arguments.
<  *
<  */
< LIB3270_EXPORT void lib3270_write_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
< 
< /**
<  * @brief Write on trace file.
<  *
<  * Write text on trace file, if DStrace is enabled.
<  *
<  * @param fmt 	String format.
<  * @param ...	Arguments.
<  *
<  */
< LIB3270_EXPORT void lib3270_write_dstrace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
< 
< /**
<  * @brief Write on trace file.
<  *
<  * Write text on trace file, if network trace is enabled.
<  *
<  * @param fmt 	String format.
<  * @param ...	Arguments.
<  *
<  */
< LIB3270_EXPORT void lib3270_write_nettrace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
< 
< /**
< * @brief Write on trace file.
< *
< * Write text on trace file, if screen trace is enabled.
< *
< * @param fmt 	String format.
< * @param ...	Arguments.
< *
< */
< LIB3270_EXPORT void lib3270_write_screen_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
< 
< /**
<  * @brief Write on trace file.
<  *
<  * Write text on trace file, if event is enabled.
<  *
<  * @param fmt 	String format.
<  * @param ...	Arguments.
<  *
<  */
< LIB3270_EXPORT void lib3270_write_event_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
< 
< LIB3270_EXPORT void LIB3270_DEPRECATED(lib3270_trace_event(H3270 *session, const char *fmt, ...)) LIB3270_AS_PRINTF(2,3);
< 
< /**
<  * @brief Write datablock on trace file.
<  *
<  * @param hSession	TN3270 Session handle.
<  * @param msg		Message.
<  * @param data		Data block in ASCII.
<  * @param datalen	Length of the data block.
<  *
<  */
< LIB3270_EXPORT void lib3270_trace_data(H3270 *hSession, const char *msg, const unsigned char *data, size_t datalen);
---
> 	/**
> 	 * @brief Set trace handle callback.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 * @param handler	Callback to write in trace file or show trace window (NULL send all trace to stdout/syslog).
> 	 * @param userdata	User data to pass to the trace handler.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_set_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER handler, void *userdata);
> 
> 	/**
> 	 * @brief Get trace handle callback.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 * @param handler	Callback to write in trace file or show trace window (NULL send all trace to stdout/syslog).
> 	 * @param userdata	User data to pass to the trace handler.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_get_trace_handler(H3270 *hSession, LIB3270_TRACE_HANDLER *handler, void **userdata);
> 
> 	/**
> 	 * @brief Write on trace file.
> 	 *
> 	 * Write text on trace file.
> 	 *
> 	 * @param fmt 	String format.
> 	 * @param ...	Arguments.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_write_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
> 
> 	/**
> 	 * @brief Write on trace file.
> 	 *
> 	 * Write text on trace file, if DStrace is enabled.
> 	 *
> 	 * @param fmt 	String format.
> 	 * @param ...	Arguments.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_write_dstrace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
> 
> 	/**
> 	 * @brief Write on trace file.
> 	 *
> 	 * Write text on trace file, if network trace is enabled.
> 	 *
> 	 * @param fmt 	String format.
> 	 * @param ...	Arguments.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_write_nettrace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
> 
> 		/**
> 	 * @brief Write on trace file.
> 	 *
> 	 * Write text on trace file, if screen trace is enabled.
> 	 *
> 	 * @param fmt 	String format.
> 	 * @param ...	Arguments.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_write_screen_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
> 
> 	/**
> 	 * @brief Write on trace file.
> 	 *
> 	 * Write text on trace file, if event is enabled.
> 	 *
> 	 * @param fmt 	String format.
> 	 * @param ...	Arguments.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_write_event_trace(H3270 *session, const char *fmt, ...) LIB3270_AS_PRINTF(2,3);
> 
> 	LIB3270_EXPORT void LIB3270_DEPRECATED(lib3270_trace_event(H3270 *session, const char *fmt, ...)) LIB3270_AS_PRINTF(2,3);
> 
> 	/**
> 	 * @brief Write datablock on trace file.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 * @param msg		Message.
> 	 * @param data		Data block in ASCII.
> 	 * @param datalen	Length of the data block.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_trace_data(H3270 *hSession, const char *msg, const unsigned char *data, size_t datalen);
158c140
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/lib3270.h
32,37c32,37
< /**
<  * @brief TN3270 API definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 API definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
41c41
< #define LIB3270_H_INCLUDED 1
---
> 	#define LIB3270_H_INCLUDED 1
43,44c43,44
< #include <stdarg.h>
< #include <errno.h>
---
> 	#include <stdarg.h>
> 	#include <errno.h>
46,49c46,320
< #ifdef _WIN32
< #include <winsock2.h>
< #include <windows.h>
< #endif // _WIN32
---
> 	#ifdef _WIN32
> 		#include <winsock2.h>
> 		#include <windows.h>
> 	#endif // _WIN32
> 
> 	#ifndef ENOTCONN
> 		#define ENOTCONN 126
> 	#endif // !ENOTCONN
> 
> 	#if defined (__GNUC__) || defined (__clang__)
> 
> 		#define LIB3270_AUTOPTR_FUNC_NAME(TypeName) lib3270_autoptr_cleanup_##TypeName
> 		#define lib3270_autoptr(TypeName) TypeName * __attribute__ ((__cleanup__(LIB3270_AUTOPTR_FUNC_NAME(TypeName))))
> 		#define lib3270_auto_cleanup(TypeName) TypeName __attribute__ ((__cleanup__(LIB3270_AUTOPTR_FUNC_NAME(TypeName))))
> 
> 	#endif // __GNUC__
> 
> 	#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1) || defined (__clang__)
> 
> 		#define LIB3270_DEPRECATED(func) func __attribute__ ((deprecated))
> 
> 	#elif defined(_WIN32) && !defined(_MSC_VER)
> 
> 		#define LIB3270_DEPRECATED(func) __declspec(deprecated) func
> 
> 	#else
> 
> 		#define LIB3270_DEPRECATED(func) func
> 
> 	#endif /* __GNUC__ */
> 
> 	#if defined(__GNUC__)
> 
> 		#define LIB3270_GNUC_FORMAT(s,f) __attribute__ ((__format__ (__printf__, s, f)))
> 		#define LIB3270_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
> 
> 	#elif defined(_WIN32) && !defined(_MSC_VER)
> 
> 		#define LIB3270_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
> 		#define LIB3270_GNUC_FORMAT(s,f)
> 
> 	#else
> 
> 		#define LIB3270_GNUC_NULL_TERMINATED
> 		#define LIB3270_GNUC_FORMAT(s,f)
> 
> 	#endif
> 
> 	#define LIB3270_STRINGIZE(x) #x
> 	#define LIB3270_STRINGIZE_VALUE_OF(x) LIB3270_STRINGIZE(x)
> 
> 	/**
> 	 * @brief BIND definitions.
> 	 */
> 	#define LIB3270_BIND_RU					0x31
> 	#define LIB3270_BIND_OFF_PLU_NAME_LEN	26
> 	#define LIB3270_BIND_OFF_PLU_NAME		27
> 	#define LIB3270_BIND_PLU_NAME_MAX		8
> 
> 	/**
> 	 * @brief Maximum size for LUNAME
> 	 *
> 	 */
> 	#define LIB3270_LUNAME_LENGTH			16
> 
> 	/**
> 	 * @brief Selection mode.
> 	 *
> 	 */
> 	typedef enum _lib3270_content_option
> 	{
> 		LIB3270_CONTENT_ALL,			///< @brief Get all the terminal data.
> 		LIB3270_CONTENT_SELECTED,		///< @brief Get only selected contents.
> 		LIB3270_CONTENT_COPY			///< @brief Get internal copy.
> 	} LIB3270_CONTENT_OPTION;
> 
> 	/**
> 	 * @brief Character attributes.
> 	 */
> 	typedef enum _lib3270_attr
> 	{
> 		LIB3270_ATTR_COLOR_BACKGROUND		= 0x0000,
> 
> 		LIB3270_ATTR_COLOR_BLUE				= 0x0001,
> 		LIB3270_ATTR_COLOR_RED				= 0x0002,
> 		LIB3270_ATTR_COLOR_PINK				= 0x0003,
> 		LIB3270_ATTR_COLOR_GREEN			= 0x0004,
> 		LIB3270_ATTR_COLOR_TURQUOISE		= 0x0005,
> 		LIB3270_ATTR_COLOR_YELLOW			= 0x0006,
> 		LIB3270_ATTR_COLOR_WHITE			= 0x0007,
> 		LIB3270_ATTR_COLOR_BLACK			= 0x0008,
> 		LIB3270_ATTR_COLOR_DARK_BLUE		= 0x0009,
> 		LIB3270_ATTR_COLOR_ORANGE			= 0x000A,
> 		LIB3270_ATTR_COLOR_PURPLE			= 0x000B,
> 		LIB3270_ATTR_COLOR_DARK_GREEN		= 0x000C,
> 		LIB3270_ATTR_COLOR_DARK_TURQUOISE	= 0x000D,
> 		LIB3270_ATTR_COLOR_MUSTARD			= 0x000E,
> 		LIB3270_ATTR_COLOR_GRAY				= 0x000F,
> 
> 		LIB3270_ATTR_COLOR					= 0x000F,
> 
> 		LIB3270_ATTR_INVERT					= 0x0080,
> 
> 		LIB3270_ATTR_FIELD					= 0x0100,
> 		LIB3270_ATTR_BLINK					= 0x0200,
> 		LIB3270_ATTR_UNDERLINE				= 0x0400,
> 		LIB3270_ATTR_INTENSIFY				= 0x0800,
> 
> 		LIB3270_ATTR_CG						= 0x1000,
> 		LIB3270_ATTR_MARKER					= 0x2000,
> 		LIB3270_ATTR_BACKGROUND_INTENSITY	= 0x4000,
> 		LIB3270_ATTR_SELECTED				= 0x8000
> 
> 	} LIB3270_ATTR;
> 
> 	typedef enum _lib3270_direction
> 	{
> 		LIB3270_DIR_UP,
> 		LIB3270_DIR_DOWN,
> 		LIB3270_DIR_LEFT,
> 		LIB3270_DIR_RIGHT,
> 
> 		LIB3270_DIR_END,
> 
> 		LIB3270_DIR_COUNT						/**< @brief Nº máximo de direções. */
> 
> 	} LIB3270_DIRECTION;
> 
> 	/**
> 	 * @brief OIA Status indicators.
> 	 *
> 	 */
> 	typedef enum _lib3270_flag
> 	{
> 		LIB3270_FLAG_BOXSOLID,	/**< @brief System available */
> 		LIB3270_FLAG_UNDERA,	/**< @brief Control Unit STATUS */
> 		LIB3270_FLAG_TYPEAHEAD,
> 		LIB3270_FLAG_PRINTER,	/**< @brief Printer session status */
> 		LIB3270_FLAG_REVERSE,
> 		LIB3270_FLAG_SCRIPT,	/**< @brief Script status */
> 
> 		LIB3270_FLAG_COUNT
> 
> 	} LIB3270_FLAG;
> 
> 
> 	/**
> 	 * @brief 3270 program messages.
> 	 *
> 	 */
> 	typedef enum _LIB3270_MESSAGE
> 	{
> 		LIB3270_MESSAGE_NONE,				///< @brief No message
> 		LIB3270_MESSAGE_SYSWAIT,			///< @brief --
> 		LIB3270_MESSAGE_TWAIT,				///< @brief --
> 		LIB3270_MESSAGE_CONNECTED,			///< @brief Connected
> 		LIB3270_MESSAGE_DISCONNECTED,		///< @brief Disconnected from host
> 		LIB3270_MESSAGE_AWAITING_FIRST,		///< @brief --
> 		LIB3270_MESSAGE_MINUS,				///< @brief --
> 		LIB3270_MESSAGE_PROTECTED,			///< @brief --
> 		LIB3270_MESSAGE_NUMERIC,			///< @brief --
> 		LIB3270_MESSAGE_OVERFLOW,			///< @brief --
> 		LIB3270_MESSAGE_INHIBIT,			///< @brief --
> 		LIB3270_MESSAGE_KYBDLOCK,			///< @brief Keyboard is locked
> 
> 		LIB3270_MESSAGE_X,					///< @brief --
> 		LIB3270_MESSAGE_RESOLVING,			///< @brief Resolving hostname (running DNS query)
> 		LIB3270_MESSAGE_CONNECTING,			///< @brief Connecting to host
> 
> 		LIB3270_MESSAGE_USER
> 
> 	} LIB3270_MESSAGE;
> 
> 
> 	/**
> 	 * @brief Pointer modes.
> 	 *
> 	 * Pointer modes set by library; an application can use it
> 	 * as a hint to change the mouse pointer based on connection status.
> 	 *
> 	 */
> 	typedef enum _LIB3270_POINTER
> 	{
> 		LIB3270_POINTER_UNLOCKED,				///< @brief Ready for user actions
> 		LIB3270_POINTER_WAITING,				///< @brief Waiting for host
> 		LIB3270_POINTER_LOCKED,					///< @brief Locked, can't receive user actions
> 
> 		LIB3270_POINTER_PROTECTED,
> 		LIB3270_POINTER_MOVE_SELECTION,
> 		LIB3270_POINTER_SELECTION_TOP_LEFT,
> 		LIB3270_POINTER_SELECTION_TOP_RIGHT,
> 		LIB3270_POINTER_SELECTION_TOP,
> 		LIB3270_POINTER_SELECTION_BOTTOM_LEFT,
> 		LIB3270_POINTER_SELECTION_BOTTOM_RIGHT,
> 		LIB3270_POINTER_SELECTION_BOTTOM,
> 		LIB3270_POINTER_SELECTION_LEFT,
> 		LIB3270_POINTER_SELECTION_RIGHT,
> 		LIB3270_POINTER_QUESTION,
> 
> 		LIB3270_POINTER_COUNT
> 
> 	} LIB3270_POINTER;
> 
> 
> 	/**
> 	 * @brief Connection state
> 	 */
> 	typedef enum lib3270_cstate
> 	{
> 		LIB3270_NOT_CONNECTED,			///< @brief no socket, disconnected
> 		LIB3270_CONNECTING,				///< @brief connecting to host
> 		LIB3270_PENDING,				///< @brief connection pending
> 		LIB3270_CONNECTED_INITIAL,		///< @brief connected, no mode yet
> 		LIB3270_CONNECTED_ANSI,			///< @brief connected in NVT ANSI mode
> 		LIB3270_CONNECTED_3270,			///< @brief connected in old-style 3270 mode
> 		LIB3270_CONNECTED_INITIAL_E,	///< @brief connected in TN3270E mode, unnegotiated
> 		LIB3270_CONNECTED_NVT,			///< @brief connected in TN3270E mode, NVT mode
> 		LIB3270_CONNECTED_SSCP,			///< @brief connected in TN3270E mode, SSCP-LU mode
> 		LIB3270_CONNECTED_TN3270E		///< @brief connected in TN3270E mode, 3270 mode
> 	} LIB3270_CSTATE;
> 
> 	/**
> 	 * @brief Field attributes.
> 	 */
> 	 typedef enum lib3270_field_attribute
> 	 {
> 		LIB3270_FIELD_ATTRIBUTE_INVALID			= 0x00,	///< @brief Attribute is invalid.
> 		LIB3270_FIELD_ATTRIBUTE_PRINTABLE		= 0xc0,	///< @brief these make the character "printable"
> 		LIB3270_FIELD_ATTRIBUTE_PROTECT			= 0x20,	///< @brief unprotected (0) / protected (1)
> 		LIB3270_FIELD_ATTRIBUTE_NUMERIC			= 0x10,	///< @brief alphanumeric (0) / numeric (1)
> 		LIB3270_FIELD_ATTRIBUTE_INTENSITY		= 0x0c,	///< @brief display/selector pen detectable:
> 		LIB3270_FIELD_ATTRIBUTE_INT_NORM_NSEL	= 0x00,	///< @brief 00 normal, non-detect
> 		LIB3270_FIELD_ATTRIBUTE_INT_NORM_SEL	= 0x04,	///< @brief 01 normal, detectable
> 		LIB3270_FIELD_ATTRIBUTE_INT_HIGH_SEL	= 0x08,	///< @brief 10 intensified, detectable
> 		LIB3270_FIELD_ATTRIBUTE_INT_ZERO_NSEL	= 0x0c,	///< @brief 11 nondisplay, non-detect
> 		LIB3270_FIELD_ATTRIBUTE_RESERVED		= 0x02,	///< @brief must be 0
> 		LIB3270_FIELD_ATTRIBUTE_MODIFIED		= 0x01	///< @brief modified (1)
> 	} LIB3270_FIELD_ATTRIBUTE;
> 
> 	/**
> 	 * @brief Host types.
> 	 *
> 	 */
> 	typedef enum lib3270_host_type
> 	{
> 		LIB3270_HOST_AS400		= 0x0001,	///< @brief AS400 host - Prefix every PF with PA1
> 		LIB3270_HOST_TSO		= 0x0002,	///< @brief Host is TSO
> 		LIB3270_HOST_S390		= 0x0006,	///< @brief Host is S390 (TSO included)
> 
> 	} LIB3270_HOST_TYPE;
> 
> 	#define LIB3270_HOSTTYPE_DEFAULT LIB3270_HOST_S390
> 
> 	typedef struct _LIB3270_HOST_TYPE_entry
> 	{
> 		LIB3270_HOST_TYPE	  type;
> 		const char			* name;
> 		const char			* description;
> 		const char			* tooltip;
> 	} LIB3270_HOST_TYPE_ENTRY;
> 
> 	/**
> 	 * @brief Field information.
> 	 *
> 	 */
> 	typedef struct _lib3270_field  {
> 
> 		unsigned short	baddr;				/**< @brief Address of the field. */
> 		unsigned short	length;				/**< @brief Field length */
> 		unsigned char	attribute;			/**< @brief Field attribute */
> 
> 		struct {
> 			unsigned char foreground;		/**< @brief foreground color (0x00 or 0xf) */
> 			unsigned char bacground;		/**< @brief background color (0x00 or 0xf) */
> 		} color;
51,53c322
< #ifndef ENOTCONN
< #define ENOTCONN 126
< #endif // !ENOTCONN
---
> 	} LIB3270_FIELD;
55,90c324
< #if defined (__GNUC__) || defined (__clang__)
< 
< #define LIB3270_AUTOPTR_FUNC_NAME(TypeName) lib3270_autoptr_cleanup_##TypeName
< #define lib3270_autoptr(TypeName) TypeName * __attribute__ ((__cleanup__(LIB3270_AUTOPTR_FUNC_NAME(TypeName))))
< #define lib3270_auto_cleanup(TypeName) TypeName __attribute__ ((__cleanup__(LIB3270_AUTOPTR_FUNC_NAME(TypeName))))
< 
< #endif // __GNUC__
< 
< #if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1) || defined (__clang__)
< 
< #define LIB3270_DEPRECATED(func) func __attribute__ ((deprecated))
< 
< #elif defined(_WIN32) && !defined(_MSC_VER)
< 
< #define LIB3270_DEPRECATED(func) __declspec(deprecated) func
< 
< #else
< 
< #define LIB3270_DEPRECATED(func) func
< 
< #endif /* __GNUC__ */
< 
< #if defined(__GNUC__)
< 
< #define LIB3270_GNUC_FORMAT(s,f) __attribute__ ((__format__ (__printf__, s, f)))
< #define LIB3270_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
< 
< #elif defined(_WIN32) && !defined(_MSC_VER)
< 
< #define LIB3270_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
< #define LIB3270_GNUC_FORMAT(s,f)
< 
< #else
< 
< #define LIB3270_GNUC_NULL_TERMINATED
< #define LIB3270_GNUC_FORMAT(s,f)
---
> 	#define LIB3270_SSL_FAILED LIB3270_SSL_UNSECURE
91a326,327
> #ifdef __cplusplus
> 	extern "C" {
94,95c330
< #define LIB3270_STRINGIZE(x) #x
< #define LIB3270_STRINGIZE_VALUE_OF(x) LIB3270_STRINGIZE(x)
---
> 	#if defined( ANDROID )
97,98c332,333
< typedef struct _h3270	H3270;
< typedef struct _h3270ft	H3270FT;
---
> 		#define LIB3270_INTERNAL	extern __attribute__((visibility("hidden")))
> 		#define LIB3270_EXPORT		extern __attribute__((visibility("hidden")))
100,313c335
< /**
<  * @brief BIND definitions.
<  */
< #define LIB3270_BIND_RU					0x31
< #define LIB3270_BIND_OFF_PLU_NAME_LEN	26
< #define LIB3270_BIND_OFF_PLU_NAME		27
< #define LIB3270_BIND_PLU_NAME_MAX		8
< 
< /**
<  * @brief Maximum size for LUNAME
<  *
<  */
< #define LIB3270_LUNAME_LENGTH			16
< 
< /**
<  * @brief Selection mode.
<  *
<  */
< typedef enum _lib3270_content_option {
< 	LIB3270_CONTENT_ALL,			///< @brief Get all the terminal data.
< 	LIB3270_CONTENT_SELECTED,		///< @brief Get only selected contents.
< 	LIB3270_CONTENT_COPY			///< @brief Get internal copy.
< } LIB3270_CONTENT_OPTION;
< 
< /**
<  * @brief Character attributes.
<  */
< typedef enum _lib3270_attr {
< 	LIB3270_ATTR_COLOR_BACKGROUND		= 0x0000,
< 
< 	LIB3270_ATTR_COLOR_BLUE				= 0x0001,
< 	LIB3270_ATTR_COLOR_RED				= 0x0002,
< 	LIB3270_ATTR_COLOR_PINK				= 0x0003,
< 	LIB3270_ATTR_COLOR_GREEN			= 0x0004,
< 	LIB3270_ATTR_COLOR_TURQUOISE		= 0x0005,
< 	LIB3270_ATTR_COLOR_YELLOW			= 0x0006,
< 	LIB3270_ATTR_COLOR_WHITE			= 0x0007,
< 	LIB3270_ATTR_COLOR_BLACK			= 0x0008,
< 	LIB3270_ATTR_COLOR_DARK_BLUE		= 0x0009,
< 	LIB3270_ATTR_COLOR_ORANGE			= 0x000A,
< 	LIB3270_ATTR_COLOR_PURPLE			= 0x000B,
< 	LIB3270_ATTR_COLOR_DARK_GREEN		= 0x000C,
< 	LIB3270_ATTR_COLOR_DARK_TURQUOISE	= 0x000D,
< 	LIB3270_ATTR_COLOR_MUSTARD			= 0x000E,
< 	LIB3270_ATTR_COLOR_GRAY				= 0x000F,
< 
< 	LIB3270_ATTR_COLOR					= 0x000F,
< 
< 	LIB3270_ATTR_INVERT					= 0x0080,
< 
< 	LIB3270_ATTR_FIELD					= 0x0100,
< 	LIB3270_ATTR_BLINK					= 0x0200,
< 	LIB3270_ATTR_UNDERLINE				= 0x0400,
< 	LIB3270_ATTR_INTENSIFY				= 0x0800,
< 
< 	LIB3270_ATTR_CG						= 0x1000,
< 	LIB3270_ATTR_MARKER					= 0x2000,
< 	LIB3270_ATTR_BACKGROUND_INTENSITY	= 0x4000,
< 	LIB3270_ATTR_SELECTED				= 0x8000
< 
< } LIB3270_ATTR;
< 
< typedef enum _lib3270_direction {
< 	LIB3270_DIR_UP,
< 	LIB3270_DIR_DOWN,
< 	LIB3270_DIR_LEFT,
< 	LIB3270_DIR_RIGHT,
< 
< 	LIB3270_DIR_END,
< 
< 	LIB3270_DIR_COUNT						/**< @brief Nº máximo de direções. */
< 
< } LIB3270_DIRECTION;
< 
< /**
<  * @brief OIA Status indicators.
<  *
<  */
< typedef enum _lib3270_flag {
< 	LIB3270_FLAG_BOXSOLID,	/**< @brief System available */
< 	LIB3270_FLAG_UNDERA,	/**< @brief Control Unit STATUS */
< 	LIB3270_FLAG_TYPEAHEAD,
< 	LIB3270_FLAG_PRINTER,	/**< @brief Printer session status */
< 	LIB3270_FLAG_REVERSE,
< 	LIB3270_FLAG_SCRIPT,	/**< @brief Script status */
< 
< 	LIB3270_FLAG_COUNT
< 
< } LIB3270_FLAG;
< 
< 
< /**
<  * @brief 3270 program messages.
<  *
<  */
< typedef enum _LIB3270_MESSAGE {
< 	LIB3270_MESSAGE_NONE,				///< @brief No message
< 	LIB3270_MESSAGE_SYSWAIT,			///< @brief --
< 	LIB3270_MESSAGE_TWAIT,				///< @brief --
< 	LIB3270_MESSAGE_CONNECTED,			///< @brief Connected
< 	LIB3270_MESSAGE_DISCONNECTED,		///< @brief Disconnected from host
< 	LIB3270_MESSAGE_AWAITING_FIRST,		///< @brief --
< 	LIB3270_MESSAGE_MINUS,				///< @brief --
< 	LIB3270_MESSAGE_PROTECTED,			///< @brief --
< 	LIB3270_MESSAGE_NUMERIC,			///< @brief --
< 	LIB3270_MESSAGE_OVERFLOW,			///< @brief --
< 	LIB3270_MESSAGE_INHIBIT,			///< @brief --
< 	LIB3270_MESSAGE_KYBDLOCK,			///< @brief Keyboard is locked
< 
< 	LIB3270_MESSAGE_X,					///< @brief --
< 	LIB3270_MESSAGE_RESOLVING,			///< @brief Resolving hostname (running DNS query)
< 	LIB3270_MESSAGE_CONNECTING,			///< @brief Connecting to host
< 
< 	LIB3270_MESSAGE_USER
< 
< } LIB3270_MESSAGE;
< 
< 
< /**
<  * @brief Pointer modes.
<  *
<  * Pointer modes set by library; an application can use it
<  * as a hint to change the mouse pointer based on connection status.
<  *
<  */
< typedef enum _LIB3270_POINTER {
< 	LIB3270_POINTER_UNLOCKED,				///< @brief Ready for user actions
< 	LIB3270_POINTER_WAITING,				///< @brief Waiting for host
< 	LIB3270_POINTER_LOCKED,					///< @brief Locked, can't receive user actions
< 
< 	LIB3270_POINTER_PROTECTED,
< 	LIB3270_POINTER_MOVE_SELECTION,
< 	LIB3270_POINTER_SELECTION_TOP_LEFT,
< 	LIB3270_POINTER_SELECTION_TOP_RIGHT,
< 	LIB3270_POINTER_SELECTION_TOP,
< 	LIB3270_POINTER_SELECTION_BOTTOM_LEFT,
< 	LIB3270_POINTER_SELECTION_BOTTOM_RIGHT,
< 	LIB3270_POINTER_SELECTION_BOTTOM,
< 	LIB3270_POINTER_SELECTION_LEFT,
< 	LIB3270_POINTER_SELECTION_RIGHT,
< 	LIB3270_POINTER_QUESTION,
< 
< 	LIB3270_POINTER_COUNT
< 
< } LIB3270_POINTER;
< 
< 
< /**
<  * @brief Connection state
<  */
< typedef enum lib3270_cstate {
< 	LIB3270_NOT_CONNECTED,			///< @brief no socket, disconnected
< 	LIB3270_CONNECTING,				///< @brief connecting to host
< 	LIB3270_PENDING,				///< @brief connection pending
< 	LIB3270_CONNECTED_INITIAL,		///< @brief connected, no mode yet
< 	LIB3270_CONNECTED_ANSI,			///< @brief connected in NVT ANSI mode
< 	LIB3270_CONNECTED_3270,			///< @brief connected in old-style 3270 mode
< 	LIB3270_CONNECTED_INITIAL_E,	///< @brief connected in TN3270E mode, unnegotiated
< 	LIB3270_CONNECTED_NVT,			///< @brief connected in TN3270E mode, NVT mode
< 	LIB3270_CONNECTED_SSCP,			///< @brief connected in TN3270E mode, SSCP-LU mode
< 	LIB3270_CONNECTED_TN3270E		///< @brief connected in TN3270E mode, 3270 mode
< } LIB3270_CSTATE;
< 
< /**
<  * @brief Field attributes.
<  */
< typedef enum lib3270_field_attribute {
< 	LIB3270_FIELD_ATTRIBUTE_INVALID			= 0x00,	///< @brief Attribute is invalid.
< 	LIB3270_FIELD_ATTRIBUTE_PRINTABLE		= 0xc0,	///< @brief these make the character "printable"
< 	LIB3270_FIELD_ATTRIBUTE_PROTECT			= 0x20,	///< @brief unprotected (0) / protected (1)
< 	LIB3270_FIELD_ATTRIBUTE_NUMERIC			= 0x10,	///< @brief alphanumeric (0) / numeric (1)
< 	LIB3270_FIELD_ATTRIBUTE_INTENSITY		= 0x0c,	///< @brief display/selector pen detectable:
< 	LIB3270_FIELD_ATTRIBUTE_INT_NORM_NSEL	= 0x00,	///< @brief 00 normal, non-detect
< 	LIB3270_FIELD_ATTRIBUTE_INT_NORM_SEL	= 0x04,	///< @brief 01 normal, detectable
< 	LIB3270_FIELD_ATTRIBUTE_INT_HIGH_SEL	= 0x08,	///< @brief 10 intensified, detectable
< 	LIB3270_FIELD_ATTRIBUTE_INT_ZERO_NSEL	= 0x0c,	///< @brief 11 nondisplay, non-detect
< 	LIB3270_FIELD_ATTRIBUTE_RESERVED		= 0x02,	///< @brief must be 0
< 	LIB3270_FIELD_ATTRIBUTE_MODIFIED		= 0x01	///< @brief modified (1)
< } LIB3270_FIELD_ATTRIBUTE;
< 
< /**
<  * @brief Host types.
<  *
<  */
< typedef enum lib3270_host_type {
< 	LIB3270_HOST_OTHER		= 0x0000,	///< @brief Other.
< 	LIB3270_HOST_AS400		= 0x0001,	///< @brief AS400 host - Prefix every PF with PA1
< 	LIB3270_HOST_TSO		= 0x0002,	///< @brief Host is TSO
< 	LIB3270_HOST_S390		= 0x0006,	///< @brief Host is S390 (TSO included)
< } LIB3270_HOST_TYPE;
< 
< #define LIB3270_HOSTTYPE_DEFAULT LIB3270_HOST_S390
< 
< typedef struct _LIB3270_HOST_TYPE_entry {
< 	LIB3270_HOST_TYPE	  type;
< 	const char			* name;
< 	const char			* description;
< 	const char			* tooltip;
< } LIB3270_HOST_TYPE_ENTRY;
< 
< /**
<  * @brief Field information.
<  *
<  */
< typedef struct _lib3270_field  {
< 
< 	unsigned short	baddr;				/**< @brief Address of the field. */
< 	unsigned short	length;				/**< @brief Field length */
< 	unsigned char	attribute;			/**< @brief Field attribute */
< 
< 	struct {
< 		unsigned char foreground;		/**< @brief foreground color (0x00 or 0xf) */
< 		unsigned char bacground;		/**< @brief background color (0x00 or 0xf) */
< 	} color;
---
> 	#elif defined(_WIN32) || defined(_MSC_VER)
315c337,338
< } LIB3270_FIELD;
---
> 		#define LIB3270_INTERNAL	extern
> 		#define LIB3270_EXPORT		extern __declspec (dllexport)
317c340
< #define LIB3270_SSL_FAILED LIB3270_SSL_UNSECURE
---
> 	#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
319,326c342,343
< #ifdef __cplusplus
< extern "C" {
< #endif
< 
< #if defined( ANDROID )
< 
< #define LIB3270_INTERNAL	extern __attribute__((visibility("hidden")))
< #define LIB3270_EXPORT		extern __attribute__((visibility("hidden")))
---
> 		#define LIB3270_INTERNAL	__hidden extern
> 		#define LIB3270_EXPORT		extern
328c345
< #elif defined(_WIN32) || defined(_MSC_VER)
---
> 	#elif defined(__GNUC__) || defined(HAVE_GNUC_VISIBILITY)
330,331c347,348
< #define LIB3270_INTERNAL	extern
< #define LIB3270_EXPORT		extern __declspec (dllexport)
---
> 		#define LIB3270_INTERNAL	__attribute__((visibility("hidden"))) extern
> 		#define LIB3270_EXPORT		__attribute__((visibility("default"))) extern
333c350
< #elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
---
> 	#else
335,336c352,353
< #define LIB3270_INTERNAL	__hidden extern
< #define LIB3270_EXPORT		extern
---
> 		#define LIB3270_INTERNAL
> 		#define LIB3270_EXPORT
338c355
< #elif defined(__GNUC__) || defined(HAVE_GNUC_VISIBILITY)
---
> 	#endif
340,341c357,366
< #define LIB3270_INTERNAL	__attribute__((visibility("hidden"))) extern
< #define LIB3270_EXPORT		__attribute__((visibility("default"))) extern
---
> 	/// @brief Action/property groups.
> 	typedef enum _lib3270_action_group
> 	{
> 		LIB3270_ACTION_GROUP_NONE,					///< @brief Simple action, no signals os special treatment.
> 		LIB3270_ACTION_GROUP_ONLINE,				///< @brief Action requires online state.
> 		LIB3270_ACTION_GROUP_OFFLINE,				///< @brief Action requires offline state.
> 		LIB3270_ACTION_GROUP_SELECTION,				///< @brief Action depends on selection.
> 		LIB3270_ACTION_GROUP_LOCK_STATE,			///< @brief Action depends on keyboard lock state.
> 		LIB3270_ACTION_GROUP_FORMATTED,				///< @brief Action depends on a formatted screen.
> 		LIB3270_ACTION_GROUP_COPY,					///< @brief Action depends on stored string.
343c368,369
< #else
---
> 		LIB3270_ACTION_GROUP_CUSTOM					///< @brief Custom group/Number of groups.
> 	} LIB3270_ACTION_GROUP;
345,348d370
< #define LIB3270_INTERNAL
< #define LIB3270_EXPORT
< 
< #endif
350,368c372,376
< /// @brief Action/property groups.
< typedef enum _lib3270_action_group {
< 	LIB3270_ACTION_GROUP_NONE,					///< @brief Simple action, no signals os special treatment.
< 	LIB3270_ACTION_GROUP_ONLINE,				///< @brief Action requires online state.
< 	LIB3270_ACTION_GROUP_OFFLINE,				///< @brief Action requires offline state.
< 	LIB3270_ACTION_GROUP_SELECTION,				///< @brief Action depends on selection.
< 	LIB3270_ACTION_GROUP_LOCK_STATE,			///< @brief Action depends on keyboard lock state.
< 	LIB3270_ACTION_GROUP_FORMATTED,				///< @brief Action depends on a formatted screen.
< 	LIB3270_ACTION_GROUP_COPY,					///< @brief Action depends on stored string.
< 
< 	LIB3270_ACTION_GROUP_CUSTOM					///< @brief Custom group/Number of groups.
< } LIB3270_ACTION_GROUP;
< 
< 
< /**
<  * @brief Head for property descriptors.
<  *
<  */
< #define LIB3270_PROPERTY_HEAD	\
---
> 	/**
> 	 * @brief Head for property descriptors.
> 	 *
> 	 */
> 	#define LIB3270_PROPERTY_HEAD	\
374,375c382
< 		const char * description; \
< 		const char * (*describe)(const H3270 *);
---
> 		const char * description;
377,1664c384,1596
< typedef struct _lib3270_property {
< 	LIB3270_PROPERTY_HEAD
< } LIB3270_PROPERTY;
< 
< /**
<  * @brief State change IDs.
<  *
<  */
< typedef enum _lib3270_state {
< 	LIB3270_STATE_RESOLVING,			///< @brief Resolving DNS.
< 	LIB3270_STATE_CONNECTING,			///< @brief Connecting to host.
< 	LIB3270_STATE_HALF_CONNECT,
< 	LIB3270_STATE_CONNECT,
< 	LIB3270_STATE_3270_MODE,
< 	LIB3270_STATE_LINE_MODE,
< 	LIB3270_STATE_REMODEL,
< 	LIB3270_STATE_PRINTER,
< 	LIB3270_STATE_EXITING,
< 	LIB3270_STATE_CHARSET,
< 
< 	LIB3270_STATE_USER				// Always the last one
< } LIB3270_STATE;
< 
< /**
<  * Get current screen size.
<  *
<  * Get the size of the terminal in rows/cols; this value can differ from
<  * the model if there's an active "altscreen" with diferent size.
<  *
<  * @param h	Handle of the desired session.
<  * @param r Pointer to screen rows.
<  * @param c Pointer to screen columns.
<  *
<  */
< LIB3270_EXPORT void lib3270_get_screen_size(const H3270 *h, unsigned int *r, unsigned int *c);
< 
< /**
<  * Get current screen width in columns.
<  *
<  * @param h	Handle of the desired session.
<  *
<  * @return screen width.
<  *
<  */
< LIB3270_EXPORT unsigned int lib3270_get_width(const H3270 *h);
< 
< LIB3270_EXPORT unsigned int lib3270_get_max_width(const H3270 *h);
< 
< /**
<  * Get current screen width in rows.
<  *
<  * @param h	Handle of the desired session.
<  *
<  * @return screen rows.
<  *
<  */
< LIB3270_EXPORT unsigned int lib3270_get_height(const H3270 *h);
< 
< LIB3270_EXPORT unsigned int lib3270_get_max_height(const H3270 *h);
< 
< LIB3270_EXPORT unsigned int lib3270_get_length(const H3270 *h);
< 
< /**
<  * @brief Creates an empty TN3270 session.
<  *
<  * @param model	Terminal model.
<  *
<  * @return Handle of the new session (release it with lib3270_session_free to avoid memory leaks).
<  *
<  */
< LIB3270_EXPORT H3270 * lib3270_session_new(const char *model);
< 
< /**
<  * @brief Closes a TN3270 session releasing resources.
<  *
<  * @param h handle of the session to close.
<  *
<  */
< LIB3270_EXPORT void lib3270_session_free(H3270 *h);
< 
< /**
<  * @brief Register a function interested in a state change.
<  *
<  * @param hSession	Session handle.
<  * @param tx		State ID
<  * @param func		Callback
<  * @param data		Data
<  *
<  * @return State change identifier.
<  *
<  */
< LIB3270_EXPORT const void * lib3270_register_schange(H3270 *hSession, LIB3270_STATE tx, void (*func)(H3270 *, int, void *),void *data);
< 
< /**
<  * @brief Unregister a function interested in a state change.
<  *
<  * @param hSession	Session handle.
<  * @param id		State change identifier.
<  *
<  * @return 0 if suceeds, non zero if fails (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_unregister_schange(H3270 *hSession, LIB3270_STATE tx, const void * id);
< 
< LIB3270_EXPORT void lib3270_reset_callbacks(H3270 *hSession);
< 
< /**
<  * @brief Set host id for the connect/reconnect operations.
<  *
<  * @param h		Session handle.
<  * @param url	URL of host to set in the format tn3270://hostname:service or tn3270s://hostname:service
<  *
<  * @return 0
<  *
<  */
< LIB3270_EXPORT int lib3270_set_url(H3270 *h, const char *url);
< 
< /**
<  * @brief Get the URL of the predefined tn3270 host.
<  *
<  * @param hSession	Session handle.
<  *
<  * @return URL of the predefined host in the format tn3270://hostname:service or tn3270s://hostname:service
<  */
< LIB3270_EXPORT const char * lib3270_get_default_host(const H3270 *hSession);
< 
< /**
<  * @brief Get HOST URL.
<  *
<  * @return TN3270 Connection URL.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_url(const H3270 *hSession);
< 
< /**
<  * @brief Get session options.
<  *
<  * @param h		Session handle.
<  *
<  */
< LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_get_host_type(const H3270 *hSession);
< 
< LIB3270_EXPORT const char * lib3270_get_host_type_name(const H3270 *hSession);
< 
< /**
<  * @brief Get URL of the hostname for the connect/reconnect operations.
<  *
<  * @param h		Session handle.
<  *
<  * @return Pointer to host URL set (internal data, do not change it)
<  *
<  */
< LIB3270_EXPORT const char * LIB3270_DEPRECATED(lib3270_get_host(const H3270 *h));
< 
< /**
<  * @brief Check if the session can reconnect.
<  *
<  * @param hSession			Session handle.
<  *
<  * @return zero if reconnect is unavailable (sets errno), non zero if available.
<  *
<  * @retval ENODATA	Invalid or empty hostname.
<  * @retval EBUSY	Auto reconnect in progress.
<  * @retval EISCONN	Session is connected.
<  *
<  */
< LIB3270_EXPORT int lib3270_allow_reconnect(const H3270 *hSession);
< 
< /**
<  * @brief Reconnect to host.
<  *
<  * @param hSession	Session handle.
<  * @param seconds	Seconds to wait for connection.
<  *
<  * @return 0 for success, non zero if fails (sets errno).
<  *
<  * @retval ENODATA	Invalid or empty hostname.
<  * @retval EBUSY	Auto reconnect in progress.
<  * @retval EISCONN	Session is connected.
<  * @retval -1		Unexpected error.
<  *
<  */
< LIB3270_EXPORT int lib3270_reconnect(H3270 *hSession,int seconds);
< 
< /**
<  * @brief Connect by URL
<  *
<  * @param hSession	Session handle.
<  * @param url		Host URL
<  * @param seconds	Seconds to wait for connection.
<  *
<  * @see lib3270_reconnect
<  *
<  * @return 0 for success, non zero if fails (sets errno).
<  */
< LIB3270_EXPORT int lib3270_connect_url(H3270 *hSession, const char *url, int seconds);
< 
< /**
<  * @brief Disconnect from host.
<  *
<  * @param h		Session handle.
<  *
<  * @return -1 if failed (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_disconnect(H3270 *h);
< 
< /**
<  * @brief Get connection state.
<  *
<  * @param h		Session handle.
<  *
<  * @return Connection state.
<  *
<  */
< LIB3270_EXPORT LIB3270_CSTATE lib3270_get_connection_state(const H3270 *h);
< 
< LIB3270_EXPORT const char * lib3270_connection_state_get_name(const LIB3270_CSTATE cstate);
< 
< LIB3270_EXPORT const char * lib3270_state_get_name(const LIB3270_STATE state);
< 
< /**
<  * @brief Pretend that a sequence of keys was entered at the keyboard.
<  *
<  * "Pasting" means that the sequence came from the clipboard.  Returns are
<  * ignored; newlines mean "move to beginning of next line"; tabs and formfeeds
<  * become spaces.  Backslashes are not special, but ASCII ESC characters are
<  * used to signify 3270 Graphic Escapes.
<  *
<  * "Not pasting" means that the sequence is a login string specified in the
<  * hosts file, or a parameter to the String action.  Returns are "move to
<  * beginning of next line"; newlines mean "Enter AID" and the termination of
<  * processing the string.  Backslashes are processed as in C.
<  *
<  * @param s			String to input.
<  * @param len		Size of the string (or -1 to null terminated strings)
<  * @param pasting	Non zero for pasting (See comments).
<  *
<  * @return The number of unprocessed characters or -1 if failed
<  */
< LIB3270_EXPORT int lib3270_emulate_input(H3270 *session, const char *s, int len, int pasting);
< 
< /**
<  * @brief Converts row/col in a buffer address.
<  *
<  * @param hSession	TN3270 Session.
<  * @param row		Row inside the screen.
<  * @param col		Col inside the screen.
<  *
<  * @return Current address or negative if invalid (sets errno).
<  *
<  * @retval -EOVERFLOW	The coordinates are out of the screen.
<  *
<  */
< LIB3270_EXPORT int lib3270_translate_to_address(const H3270 *hSession, unsigned int row, unsigned int col);
< 
< /**
<  * @brief Set field contents, jump to the next one.
<  *
<  * Set the string inside the corrent field, jump to the next one.
<  *
<  * @param hSession	Session handle.
<  * @param text		String to input.
<  * @param length	Length of the string (-1 for auto-detect).
<  *
<  * @return address of the cursor, negative if failed.
<  *
<  * @retval 0			No next field.
<  * @retval -EPERM		The keyboard is locked.
<  * @retval -ENOTCONN	Disconnected from host.
<  * @retval -ENODATA		No field at the current cursor position.
<  * @retval -ENOTSUP		The screen is not formatted.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_field(H3270 *hSession, const char *text, int length);
< 
< /**
<  * @brief Set string at current cursor position.
<  *
<  * Returns are ignored; newlines mean "move to beginning of next line";
<  * tabs and formfeeds become spaces.  Backslashes are not special.
<  *
<  * @param hSession	Session handle.
<  * @param text		String to input.
<  * @param length	Length of the string (-1 for auto-detect).
<  *
<  * @return Negative if error or number (sets errno) of processed characters.
<  *
<  * @retval -EPERM		The keyboard is locked.
<  * @retval -ENOTCONN	Disconnected from host.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_string(H3270 *h, const unsigned char *text, int length);
< 
< /**
<  * @brief Set string at defined row/column.
<  *
<  * Set the string in the defined row/column; returns number of processed caracter if succeeds or negative value if not.
<  *
<  * @param hSession	Session handle.
<  * @param row		Row for the first character.
<  * @param col		Col for the first character.
<  * @param str		String to set.
<  * @param length	Length of the string (-1 for auto-detect).
<  *
<  * @return Negative if error or number (sets errno) of processed characters.
<  *
<  * @retval -EPERM		The keyboard is locked.
<  * @retval -EOVERFLOW	The row or col is bigger than the screen size.
<  * @retval -ENOTCONN	Disconnected from host.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_string_at(H3270 *hSession, unsigned int row, unsigned int col, const unsigned char *str, int length);
< 
< /**
<  * @brief Set string at defined adress.
<  *
<  * @param hSession	Session handle.
<  * @param baddr		Adress for the first character (-1 for cursor position).
<  * @param str		String to set.
<  * @param length	Length of the string (-1 for auto-detect).
<  *
<  * @return Negative if error or number of processed characters.
<  *
<  * @retval -EPERM		The keyboard is locked.
<  * @retval -EOVERFLOW	The address is beyond the screen length.
<  * @retval -ENOTCONN	Disconnected from host.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_string_at_address(H3270 *hSession, int baddr, const unsigned char *str, int length);
< 
< /**
<  * @brief Insert string at current cursor position.
<  *
<  * @param hSession	Session handle.
<  * @param str		Text to insert.
<  * @param length	Length of the string (-1 for auto-detect).
<  *
<  * @return 0 if success, non zero if failed (sets errno).
<  *
<  * @retval EPERM		The keyboard is locked.
<  * @retval ENOTCONN		Disconnected from host.
<  *
<  */
< LIB3270_EXPORT int lib3270_input_string(H3270 *hSession, const unsigned char *str, int length);
< 
< /**
<  * @brief Move cursor to a new position.
<  *
<  * @see lib3270_set_cursor_position
<  *
<  * @param hSession	TN3270 session.
<  * @param baddr		New cursor position.
<  *
<  * @return Old cursor address or negative in case of error (sets errno).
<  *
<  * @retval -EOVERFLOW	The address is beyond the screen length.
<  * @retval -ENOTCONN	Disconnected from host.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_cursor_address(H3270 *hSession, int baddr);
< 
< /**
<  * @brief Set cursor position.
<  *
<  * @param h		Session handle.
<  * @param row	New cursor row.
<  * @param col	New cursor col.
<  *
<  * @return Old cursor address or negative in case of error (sets errno).
<  *
<  * @retval -EOVERFLOW	The address is beyond the screen length.
<  * @retval -ENOTCONN	Disconnected from host.
<  */
< LIB3270_EXPORT int lib3270_set_cursor_position(H3270 *h, unsigned int row, unsigned int col);
< 
< /**
<  * @brief Get cursor address.
<  *
<  * @param hSession Session handle.
<  *
<  * @return Cursor address or negative if invalid (sets errno).
<  *
<  * @retval -ENOTCONN	Disconnected from host.
<  * @retval -EINVAL		Invalid session handle.
<  * @retval -1			Unexpected error.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_cursor_address(const H3270 *hSession);
< 
< /**
<  * @brief Get row/col of the current cursor position.
<  *
<  * @param hSession	Session handler.
<  * @param row		Pointer for current cursor row.
<  * @param col		Pointer for current cursor column.
<  *
<  * @return 0 if ok, error code if not (sets errno).
<  *
<  * @retval EINVAL	Invalid session.
<  * @retval ENOTCONN	Not connected to host.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_cursor_position(const H3270 *hSession, unsigned short *row, unsigned short *col);
< 
< /**
<  * @brief Move cursor
<  *
<  * @param h		Session handle.
<  * @param dir	Direction to move
<  * @param sel	Non zero to move and selected to the current cursor position
<  *
<  * @return 0 if the movement can be done, non zero if failed.
<  */
< LIB3270_EXPORT int lib3270_move_cursor(H3270 *h, LIB3270_DIRECTION dir, unsigned char sel);
< 
< /**
<  * @brief Default print operation.
<  *
<  * If the terminal has selected area print them, if not, print all contents.
<  *
<  * @param hSession	Session Handle.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_print(H3270 *hSession);
< 
< /**
<  * @brief Print terminal screen.
<  *
<  * @param hSession	Session Handle.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_print_all(H3270 *hSession);
< 
< /**
<  * @brief Print only selected area (if available).
<  *
<  * @param hSession	Session Handle.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_print_selected(H3270 *hSession);
< 
< /**
<  * @brief Ask the front end module to print stored copy.
<  *
<  * @param hSession	Session Handle.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_print_copy(H3270 *hSession);
< 
< /**
<  * @brief Save contents to file.
<  *
<  * @param hSession	Session Handle.
<  * @param mode		Content option.
<  * @param filename	File name.
<  *
<  * @return 0 if ok, error code if not.
<  */
< LIB3270_EXPORT int lib3270_save(H3270 *hSession, LIB3270_CONTENT_OPTION mode, const char *filename);
< 
< LIB3270_EXPORT int lib3270_save_all(H3270 *hSession, const char *filename);
< LIB3270_EXPORT int lib3270_save_selected(H3270 *hSession, const char *filename);
< LIB3270_EXPORT int lib3270_save_copy(H3270 *hSession, const char *filename);
< 
< /**
<  * @brief Paste from file.
<  *
<  * @param hSession	Session Handle.
<  * @param filename	File name.
<  *
<  * @return 0 if ok, error code if not.
<  */
< LIB3270_EXPORT int lib3270_load(H3270 *hSession, const char *filename);
< 
< /**
<  * @brief Get buffer contents.
<  *
<  * @param h		Session handle.
<  * @param first	First element to get.
<  * @param last	Last element to get.
<  * @param chr	Pointer to buffer which will receive the read chars.
<  * @param attr	Pointer to buffer which will receive the chars attributes.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_contents(H3270 *h, int first, int last, unsigned char *chr, unsigned short *attr);
< 
< /**
<  * @brief IO flags.
<  *
<  */
< typedef enum _lib3270_io_event {
< 	LIB3270_IO_FLAG_READ		= 0x01,
< 	LIB3270_IO_FLAG_EXCEPTION	= 0x02,
< 	LIB3270_IO_FLAG_WRITE		= 0x04,
< 
< 	LIB3270_IO_FLAG_MASK		= 0x07
< } LIB3270_IO_FLAG;
< 
< LIB3270_EXPORT void		* lib3270_add_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata );
< LIB3270_EXPORT void		  lib3270_remove_poll(H3270 *session, void *id);
< LIB3270_EXPORT void		  lib3270_set_poll_state(H3270 *session, void *id, int enabled);
< 
< LIB3270_EXPORT void		  lib3270_remove_poll_fd(H3270 *session, int fd);
< LIB3270_EXPORT void		  lib3270_update_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag);
< 
< /**
<  * @brief I/O Controller.
<  *
<  * GUI unblocking I/O calls, used to replace the lib3270´s internal ones.
<  *
<  */
< typedef struct lib3270_io_controller {
< 	unsigned short sz;
< 
< 	void	* (*AddTimer)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata);
< 	void	  (*RemoveTimer)(H3270 *session, void *timer);
< 
< 	void	* (*add_poll)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata);
< 	void	  (*remove_poll)(H3270 *session, void *id);
< 	void	  (*set_poll_state)(H3270 *session, void *id, int enabled);
< 
< 	int		  (*Wait)(H3270 *hSession, int seconds);
< 	int		  (*event_dispatcher)(H3270 *session, int wait);
< 	void	  (*ring_bell)(H3270 *session);
< 	int		  (*run_task)(H3270 *session, int(*callback)(H3270 *, void *), void *parm);
< 
< } LIB3270_IO_CONTROLLER;
< 
< /**
<  * Register application Handlers.
<  *
<  * @param cbk	Structure with the application I/O handles to set.
<  *
<  * @return 0 if ok, error code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_register_io_controller(const LIB3270_IO_CONTROLLER *cbk);
< 
< /**
<  * Register time handlers.
<  *
<  * @param add	Callback for adding a timeout
<  * @param rm	Callback for removing a timeout
<  *
<  */
< LIB3270_EXPORT void lib3270_register_timer_handlers(void * (*add)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata), void (*rm)(H3270 *session, void *timer));
< 
< LIB3270_EXPORT void lib3270_register_fd_handlers(void * (*add)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata), void (*rm)(H3270 *, void *id));
< 
< /**
<  * @brief Get program message.
<  *
<  * @see LIB3270_MESSAGE
<  *
<  * @param h	Session handle.
<  *
<  * @return Latest program message.
<  *
<  */
< LIB3270_EXPORT LIB3270_MESSAGE	  lib3270_get_program_message(const H3270 *h);
< 
< /**
<  * @brief Get the LU name associated with the session, if there is one.
<  *
<  * Get the name LU associated with the session; the value is
<  * internal to lib3270 and should not be changed ou freed.
<  *
<  * @param hSession	Session handle.
<  *
<  * @return The associated LU name or NULL if not available.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_associated_luname(const H3270 *hSession);
< 
< /**
<  * @brief Set the LU names.
<  *
<  * @param hSession	Session handle.
<  * @param lunames	Comma separated list of the LU names to set.
<  *
<  * @return 0 if the list was set, non zero if not (sets errno)
<  *
<  * @retval EISCONN	The session is online.
<  * @retval EINVAL	Invalid session handle.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_lunames(H3270 *hSession, const char *luname);
< 
< LIB3270_EXPORT const char ** lib3270_get_lunames(H3270 *hSession);
< 
< LIB3270_EXPORT int lib3270_is_connected(const H3270 *h);
< 
< 
< LIB3270_EXPORT int lib3270_is_disconnected(const H3270 *h);
< 
< LIB3270_EXPORT int lib3270_is_unlocked(const H3270 *h);
< 
< LIB3270_EXPORT int lib3270_has_active_script(const H3270 *h);
< LIB3270_EXPORT int lib3270_get_typeahead(const H3270 *h);
< LIB3270_EXPORT int lib3270_get_undera(const H3270 *h);
< LIB3270_EXPORT int lib3270_get_oia_box_solid(const H3270 *h);
< LIB3270_EXPORT int lib3270_pconnected(const H3270 *h);
< LIB3270_EXPORT int lib3270_half_connected(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_neither(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_ansi(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_3270(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_sscp(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_tn3270e(const H3270 *h);
< LIB3270_EXPORT int lib3270_in_e(const H3270 *h);
< 
< LIB3270_EXPORT int lib3270_is_ready(const H3270 *h);
< LIB3270_EXPORT int lib3270_is_secure(const H3270 *h);
< 
< LIB3270_EXPORT LIB3270_MESSAGE		lib3270_get_lock_status(const H3270 *h);
< 
< /**
<  * Run main iteration.
<  *
<  * Run lib3270 internal iterations, check for network inputs, process signals.
<  *
<  * @param h		Related session.
<  * @param wait	Wait for signal if not available.
<  *
<  */
< LIB3270_EXPORT void lib3270_main_iterate(H3270 *h, int wait);
< 
< /**
<  * @brief Associate user data with 3270 session.
<  *
<  */
< LIB3270_EXPORT void lib3270_set_user_data(H3270 *h, void *ptr);
< 
< /**
<  * @brief Get associated user data.
<  *
<  */
< LIB3270_EXPORT void * lib3270_get_user_data(H3270 *h);
< 
< /**
<  * @brief Wait for "N" seconds keeping main loop active.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait(H3270 *hSession, int seconds);
< 
< /**
<  * @brief Wait for "N" seconds or screen change; keeps main loop active.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_update(H3270 *hSession, int seconds);
< 
< /**
<  * @brief Wait "N" seconds for "ready" state.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  * @return 0 if ok, errno code if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_ready(H3270 *hSession, int seconds);
< 
< /**
<  * @brief Wait "N" seconds for online state.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  * @return 0 if ok, errno code if not.
<  *
<  * @retval	ETIMEDOUT	Timeout waiting.
<  * @retval	ENOTCONN	Not connected to host.
<  * @retval	0			Session is online and in required state.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_cstate(H3270 *hSession, LIB3270_CSTATE cstate, int seconds);
< 
< /**
<  * @brief Wait "N" seconds for connected state.
<  *
<  * @param seconds	Number of seconds to wait.
<  *
<  * @return 0 if ok, errno code if not.
<  *
<  * @retval	ETIMEDOUT	Timeout waiting.
<  * @retval	ENOTCONN	Not connected to host.
<  * @retval	0			Session is online and in required state.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_connected(H3270 *hSession, int seconds);
< 
< /**
<  * "beep" to notify user.
<  *
<  * If available play a sound signal do alert user.
<  *
<  * @param h		Session handle.
<  *
<  */
< LIB3270_EXPORT void lib3270_ring_bell(H3270 *session);
< 
< /**
<  * Get lib3270's charset.
<  *
<  * @param h Session handle.
<  *
<  * @return String with current encoding.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_display_charset(const H3270 *session);
< 
< #define lib3270_get_charset(s) lib3270_get_display_charset(s)
< 
< LIB3270_EXPORT const char * lib3270_get_default_charset(void);
< 
< /**
<  * @brief Get selected area.
<  *
<  * @param h	Session Handle.
<  *
<  * @return selected text if available, or NULL. Release it with free()
<  *
<  */
< LIB3270_EXPORT char * lib3270_get_selected(H3270 *hSession);
< 
< LIB3270_EXPORT char * lib3270_cut_selected(H3270 *hSession);
< 
< /**
<  * @brief Check if the terminal has selected area (allways sets errno).
<  *
<  * @param hSession	Session handle.
<  *
<  * @return Greater than zero if the terminal has selected area, 0 if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_has_selection(const H3270 *hSession);
< 
< LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_has_selection(const H3270 *hSession));
< 
< /**
<  * @brief Check if the terminal has stored clipboard contents.
<  *
<  * @param hSession	Session handle.
<  *
<  * @return Greater than zero if the terminal has copy, 0 if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_has_copy(const H3270 *hSession);
< 
< LIB3270_EXPORT void lib3270_set_has_copy(H3270 *hSession, int has_copy);
< 
< 
< /**
<  * @brief Get all text inside the terminal.
<  *
<  * @param h			Session Handle.
<  * @param offset	Start position (-1 to current cursor position).
<  * @param len		Text length or -1 to all text.
<  * @param lf		Line break char (0 to disable line breaks).
<  *
<  * @return Contents at position if available, or NULL if error (sets errno). Release it with lib3270_free()
<  *
<  * @exception ENOTCONN	Not connected to host.
<  * @exception EOVERFLOW	Invalid offset.
<  *
<  */
< LIB3270_EXPORT char * lib3270_get_string_at_address(H3270 *h, int offset, int len, char lf);
< 
< /**
<  * @brief Get text at requested position
<  *
<  * @param h			Session Handle.
<  * @param row		Desired row.
<  * @param col		Desired col.
<  * @param len		Text length or -1 to all text.
<  * @param lf		Line break char (0 to disable line breaks).
<  *
<  * @return Contents at position if available, or NULL if error (sets errno). Release it with lib3270_free()
<  *
<  * @exception ENOTCONN	Not connected to host.
<  * @exception EOVERFLOW	Invalid position.
<  *
<  */
< LIB3270_EXPORT char * lib3270_get_string_at(H3270 *h, unsigned int row, unsigned int col, int len, char lf);
< 
< /**
<  * @brief Check for text at requested position
<  *
<  * @param h			Session Handle.
<  * @param row		Desired row.
<  * @param col		Desired col.
<  * @param text		Text to check.
<  * @param lf		Line break char (0 to disable line breaks).
<  *
<  * @return Test result from strcmp
<  *
<  */
< LIB3270_EXPORT int lib3270_cmp_string_at(H3270 *h, unsigned int row, unsigned int col, const char *text, char lf);
< 
< LIB3270_EXPORT int lib3270_cmp_string_at_address(H3270 *h, int baddr, const char *text, char lf);
< 
< /**
<  * @brief Get contents of the field at position.
<  *
<  * @param h			Session Handle.
<  * @param baddr		Reference position.
<  *
<  * @return NULL if failed (sets errno), contents of the entire field if suceeds (release it with lib3270_free()).
<  *
<  * @exception ENOTCONN	Not connected to host.
<  * @exception EOVERFLOW	Invalid position.
<  *
<  */
< LIB3270_EXPORT char * lib3270_get_field_string_at(H3270 *h, int baddr);
< 
< /**
<  * @brief Find the next unprotected field.
<  *
<  * @param hSession	Session handle.
<  * @param baddr0	Search start addr (-1 to use current cursor position).
<  *
<  * @return address following the unprotected attribute byte, or 0 if no nonzero-width unprotected field can be found.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_next_unprotected(H3270 *hSession, int baddr0);
< 
< /**
<  * @brief Check if the screen position is protected.
<  *
<  * @param hSession	Session handle.
<  * @param baddr0	Search start addr (-1 to use current cursor position).
<  *
<  * @return -1 when failed 1 if the addr is protected and 0 if not.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_is_protected(const H3270 *hSession, int baddr0);
< 
< LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_is_protected(H3270 *h, unsigned int baddr));
< 
< /**
<  * @brief Check if the screen is formatted.
<  *
<  * @param hSession	Session handle.
<  *
<  * @return -1 when failed 1 if the session is formatted and 0 if not.
<  *
<  * @retval -1	Failed (check errno for error code).
<  * @retval  0	Screen is not formatted.
<  * @retval  1	Screen is formatted.
<  */
< LIB3270_EXPORT int lib3270_is_formatted(const H3270 *hSession);
< 
< /**
<  * @brief Get Check if the screen position is protected.
<  *
<  * @param h			Session Handle.
<  * @param row		Desired row.
<  * @param col		Desired col.
<  *
<  */
< LIB3270_EXPORT int lib3270_get_is_protected_at(const H3270 *h, unsigned int row, unsigned int col);
< 
< /**
<  * @brief Get address of the first blank.
<  *
<  * Get address of the first blank after the last nonblank in the
<  * field, or if the field is full, to the last character in the field.
<  *
<  * @param hSession	Session handle.
<  * @param baddr		Field address.
<  *
<  * @return address of the first blank or negative if invalid.
<  *
<  * @retval -ENOTSUP		Screen is not formatted.
<  * @retval -EPERM		Current cursor position is protected.
<  */
< LIB3270_EXPORT int lib3270_get_field_end(H3270 *hSession, int baddr);
< 
< /**
<  * @brief Find the buffer address of the field attribute for a given buffer address.
<  *
<  * @param hSession	Session handle.
<  * @param addr		Buffer address of the field.
<  *
<  * @return field address or negative if the screen isn't formatted (sets errno).
<  *
<  * @retval -ENOTCONN	Not connected to host.
<  * @retval -EOVERFLOW	Invalid position.
<  * @retval -ENOTSUP		Screen is not formatted.
<  * @retval -ENODATA		No field at the address.
<  *
<  */
< LIB3270_EXPORT int lib3270_field_addr(const H3270 *hSession, int baddr);
< 
< /**
<  * @brief Get field attribute for a given buffer address.
<  *
<  * @param hSession	Session handle.
<  * @param addr		Buffer address of the field (-1 to use the cursor address).
<  *
<  * @return field attribute or LIB3270_FIELD_ATTRIBUTE_INVALID when failed (sets errno).
<  */
< LIB3270_EXPORT LIB3270_FIELD_ATTRIBUTE lib3270_get_field_attribute(H3270 *hSession, int baddr);
< 
< /**
<  * @brief Get the length of the field at given buffer address.
<  *
<  * @param hSession	Session handle.
<  * @param addr		Buffer address of the field.
<  *
<  * @return field length or -1 if invalid or not connected (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_field_length(H3270 *h, int baddr);
< 
< /**
<  * @brief Get a terminal character and attribute.
<  *
<  * @param h		Session Handle.
<  * @param baddr	Element address ((element_row*cols)+element_col)
<  * @param c		Pointer to character.
<  * @param attr	Pointer to attribute.
<  *
<  * @return 0 if ok, -1 if fails (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_get_element(H3270 *h, unsigned int baddr, unsigned char *c, unsigned short *attr);
< 
< /**
<  * @brief Check if the informed addr is marked as selected.
<  *
<  * @param h		Session Handle.
<  * @param baddr	Element address ((element_row*cols)+element_col)
<  *
<  * @return >0 zero if element is selected, 0 if not, -1 if fails (sets errno).
<  *
<  */
< LIB3270_EXPORT int lib3270_is_selected(H3270 *hSession, unsigned int baddr);
< 
< /**
<  * @brief Get attribute at the requested ADDR.
<  *
<  * @param h		Session Handle.
<  * @param baddr	Element address ((element_row*cols)+element_col)
<  *
<  * @return Attribute of the required address or -1 if failed.
<  *
<  */
< LIB3270_EXPORT LIB3270_ATTR lib3270_get_attribute_at_address(H3270 *hSession, unsigned int baddr);
< 
< /**
<  * Get field region
<  *
<  * @param h		Session handle.
<  * @param baddr	Reference position to get the field start/stop offsets.
<  * @param start	return location for start of selection, as a character offset.
<  * @param end	return location for end of selection, as a character offset.
<  *
<  * @return Non 0 if invalid
<  *
<  */
< LIB3270_EXPORT int lib3270_get_field_bounds(H3270 *hSession, int baddr, int *start, int *end);
< 
< LIB3270_EXPORT int lib3270_get_field_start(H3270 *hSession, int baddr);
< LIB3270_EXPORT int lib3270_get_field_len(H3270 *hSession, int baddr);
< 
< LIB3270_EXPORT int lib3270_get_word_bounds(H3270 *hSession, int baddr, int *start, int *end);
< 
< LIB3270_EXPORT int 			  LIB3270_DEPRECATED(lib3270_set_model(H3270 *hSession, const char *model_name));
< LIB3270_EXPORT const char	* LIB3270_DEPRECATED(lib3270_get_model(const H3270 *session));
< 
< LIB3270_EXPORT const char	* lib3270_get_model_name(const H3270 *session);
< LIB3270_EXPORT int			  lib3270_set_model_name(H3270 *hSession, const char *model_name);
< 
< LIB3270_EXPORT unsigned int	  lib3270_get_model_number(const H3270 *hSession);
< 
< /**
<  * @brief Set TN3270 model number.
<  *
<  * @param hSession	Session handle.
<  * @param model_number	The new model number (2-5).
<  *
<  * @return
<  */
< LIB3270_EXPORT int			  lib3270_set_model_number(H3270 *hSession, unsigned int model_number);
< 
< /**
<  *
<  * @brief Set the unlock delay in milliseconds.
<  *
<  * When lib3270 sends the host an AID (the Enter, Clear, PF or PA actions),
<  * it locks the keyboard until the host sends a reply to unlock it. Some
<  * hosts unlock the keyboard before they are actually finished processing
<  * the command, which can cause scripts to malfunction subtly.
<  *
<  * To avoid this, lib3270 implements a hack to briefly delay actually
<  * unlocking the keyboard. When the unlock delay is not 0, the keyboard
<  * unlock will be delayed for the number of milliseconds set by this call.
<  *
<  * Setting the delay to 0 disables the hack.
<  *
<  * @param session	lib3270 session.
<  * @param delay		Delay in milliseconds.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_unlock_delay(H3270 *session, unsigned int delay);
< LIB3270_EXPORT unsigned int lib3270_get_unlock_delay(const H3270 *session);
< 
< /**
<  * @brief Alloc/Realloc memory buffer.
<  *
<  * Allocate/reallocate an array.
<  *
<  * @param elsize	Element size.
<  * @param nelem		Number of elements in the array.
<  * @param ptr		Pointer to the actual array.
<  *
<  * @return Clean buffer with size for the number of elements.
<  *
<  */
< LIB3270_EXPORT void * lib3270_calloc(int elsize, int nelem, void *ptr);
< 
< /**
<  * @brief Get a block of memory, fill it with zeros.
<  *
<  * @param len	Length of memory block to get.
<  *
<  * @return Pointer to new memory block.
<  *
<  */
< LIB3270_EXPORT void * lib3270_malloc(int len);
< 
< LIB3270_EXPORT void * lib3270_realloc(void *p, int len);
< LIB3270_EXPORT void * lib3270_strdup(const char *str);
< 
< /**
<  * @brief Removes trailing white space from a string.
<  *
<  * This function doesn't allocate or reallocate any memory;
<  * it modifies in place. Therefore, it cannot be used
<  * on statically allocated strings.
<  *
<  * Reference: <https://git.gnome.org/browse/glib/tree/glib/gstrfuncs.c>
<  *
<  * @see chug() and strip().
<  *
<  * @return pointer to string.
<  *
<  */
< LIB3270_EXPORT char * lib3270_chomp(char *str);
< 
< /**
<  * @brief Remove the leading white space from the string.
<  *
<  * Removes leading white space from a string, by moving the rest
<  * of the characters forward.
<  *
<  * This function doesn't allocate or reallocate any memory;
<  * it modifies the string in place. Therefore, it cannot be used on
<  * statically allocated strings.
<  *
<  * Reference: <https://git.gnome.org/browse/glib/tree/glib/gstrfuncs.c>
<  *
<  * @see chomp() and strip().
<  *
<  * @return pointer to string.
<  *
<  */
< LIB3270_EXPORT char * lib3270_chug(char *str);
< 
< LIB3270_EXPORT char * lib3270_strip(char *str);
< 
< /**
<  * @brief Release allocated memory.
<  *
<  * @param p	Memory block to release (can be NULL)
<  *
<  * @return NULL
<  */
< LIB3270_EXPORT void  * lib3270_free(void *p);
< 
< LIB3270_EXPORT void   lib3270_autoptr_cleanup_char(char **ptr);
< 
< /**
<  * Get default session handle.
<  *
<  * @return Internal's lib3270 session handle.
<  *
<  */
< LIB3270_EXPORT H3270 * LIB3270_DEPRECATED(lib3270_get_default_session_handle(void));
< 
< /**
<  * Get library version.
<  *
<  * @return Version of active library as string.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_version(void);
< 
< /**
<  * Get source code revision.
<  *
<  * @return The revision of the current source code.
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_revision(void);
< 
< /**
<  * @brief Test if the revision is valid.
<  *
<  * @param revision Revision number to check.
<  *
<  * @return 0 if the supplied revision is valid to the current library.
<  *
<  */
< LIB3270_EXPORT int lib3270_check_revision(const char *revision);
< 
< 
< LIB3270_EXPORT char * lib3270_vsprintf(const char *fmt, va_list args);
< LIB3270_EXPORT char * lib3270_strdup_printf(const char *fmt, ...);
< 
< LIB3270_EXPORT int lib3270_clear_operator_error(H3270 *hSession);
< 
< /**
<  * @brief Set the terminal color type.
<  *
<  * @param hSession	Session handle.
<  * @param colortype	The color type for the emulator (2, 8, 16 or 0 to lib3270's default).
<  *
<  * @return 0 if ok, error code if failed (sets errno).
<  *
<  * @retval EINVAL	Invalid color type value.
<  * @retval EISCONN	The session is active.
<  *
<  */
< LIB3270_EXPORT int lib3270_set_color_type(H3270 *hSession, unsigned int colortype);
< 
< LIB3270_EXPORT unsigned int lib3270_get_color_type(const H3270 *hSession);
< 
< LIB3270_EXPORT int lib3270_set_host_type_by_name(H3270 *hSession, const char *name);
< LIB3270_EXPORT int lib3270_set_host_type(H3270 *hSession, LIB3270_HOST_TYPE opt);
< 
< LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_parse_host_type(const char *name);
< 
< LIB3270_EXPORT const LIB3270_HOST_TYPE_ENTRY * lib3270_get_option_list(void);
< 
< LIB3270_EXPORT LIB3270_POINTER lib3270_get_pointer(H3270 *hSession, int baddr);
< 
< /**
<  * @brief Run background task.
<  *
<  * Call task in a separate thread, keep gui main loop running until
<  * the function returns.
<  *
<  * @param hSession	TN3270 session.
<  * @param callback	Function to call.
<  * @param parm		Parameter to callback function.
<  *
<  */
< LIB3270_EXPORT int lib3270_run_task(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm);
< 
< /**
<  * @brief The host is TSO?
<  *
<  * @param hSession	Session Handle
<  *
<  * @return Non zero if the host is TSO.
<  *
<  */
< LIB3270_EXPORT int lib3270_is_tso(const H3270 *hSession);
< 
< LIB3270_EXPORT int lib3270_set_tso(H3270 *hSession, int on);
< 
< /**
<  * @brief Host is AS400 (Prefix every PF with PA1).
<  *
<  * @param hSession	Session Handle
<  *
<  * @return Non zero if the host is AS400.
<  *
<  */
< LIB3270_EXPORT int lib3270_is_as400(const H3270 *hSession);
< 
< LIB3270_EXPORT int lib3270_set_as400(H3270 *hSession, int on);
< 
< /**
<  * @brief Build filename on application data dir.
<  *
<  * @return Full path for the file (release it with lib3270_free).
<  *
<  */
< LIB3270_EXPORT char * lib3270_build_data_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
< 
< /**
<  * @brief Build filename on application configuration dir.
<  *
<  * @return Full path for the file (release it with lib3270_free).
<  *
<  */
< LIB3270_EXPORT char * lib3270_build_config_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
< 
< /**
<  * @brief Build and search for filename.
<  *
<  * Build filename and search for it on current, configuration and data dirs.
<  *
<  * @return Full path for the file (release it with lib3270_free).
<  *
<  */
< LIB3270_EXPORT char * lib3270_build_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
< 
< LIB3270_EXPORT void lib3270_set_session_id(H3270 *hSession, char id);
< LIB3270_EXPORT char lib3270_get_session_id(H3270 *hSession);
< 
< /**
<  * @brief Wait for string at screen.
<  *
<  * @param hSession	TN3270 Session.
<  * @param key		The string to wait for.
<  * @param seconds	Maximum wait time.
<  *
<  * @return 0 if the string was found, error code if not (sets errno).
<  *
<  * @retval ENOTCONN		Not connected to host.
<  * @retval ETIMEDOUT	Timeout.
<  * @retval EPERM		The keyboard is locked.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_string(H3270 *hSession, const char *key, int seconds);
< 
< /**
<  * @brief Wait for string at position.
<  *
<  * @param hSession	TN3270 Session.
<  * @param row		Row inside the screen.
<  * @param col		Col inside the screen.
<  * @param key		The string to wait for.
<  * @param seconds	Maximum wait time.
<  *
<  * @return 0 if the string was found, error code if not (sets errno).
<  *
<  * @retval ENOTCONN		Not connected to host.
<  * @retval EOVERFLOW	Invalid position.
<  * @retval ETIMEDOUT	Timeout.
<  * @retval EPERM		The keyboard is locked.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_string_at(H3270 *hSession, unsigned int row, unsigned int col, const char *key, int seconds);
< 
< /**
<  * @brief Wait for string at addrress.
<  *
<  * @param hSession	TN3270 Session.
<  * @param baddr		Start position (-1 to current cursor position).
<  * @param key		The string to wait for.
<  * @param seconds	Maximum wait time.
<  *
<  * @return 0 if the string was found, error code if not (sets errno).
<  *
<  * @retval ENOTCONN	Not connected to host.
<  * @retval EOVERFLOW	Invalid position.
<  * @retval ETIMEDOUT	Timeout.
<  * @retval EPERM		The keyboard is locked.
<  *
<  */
< LIB3270_EXPORT int lib3270_wait_for_string_at_address(H3270 *hSession, int baddr, const char *key, int seconds);
< 
< /**
<  * @brief Notify action group.
<  *
<  */
< LIB3270_EXPORT void lib3270_action_group_notify(H3270 *hSession, LIB3270_ACTION_GROUP group);
< 
< /**
<  * @brief Get lib3270's translation domain (for use with dgettext).
<  *
<  */
< LIB3270_EXPORT const char * lib3270_get_translation_domain();
---
> 	typedef struct _lib3270_property {
> 		LIB3270_PROPERTY_HEAD
> 	} LIB3270_PROPERTY;
> 
> 	/**
> 	 * @brief State change IDs.
> 	 *
> 	 */
> 	typedef enum _lib3270_state
> 	{
> 		LIB3270_STATE_RESOLVING,			///< @brief Resolving DNS.
> 		LIB3270_STATE_CONNECTING,			///< @brief Connecting to host.
> 		LIB3270_STATE_HALF_CONNECT,
> 		LIB3270_STATE_CONNECT,
> 		LIB3270_STATE_3270_MODE,
> 		LIB3270_STATE_LINE_MODE,
> 		LIB3270_STATE_REMODEL,
> 		LIB3270_STATE_PRINTER,
> 		LIB3270_STATE_EXITING,
> 		LIB3270_STATE_CHARSET,
> 
> 		LIB3270_STATE_USER				// Always the last one
> 	} LIB3270_STATE;
> 
> 	typedef struct _h3270	H3270;
> 	typedef struct _h3270ft	H3270FT;
> 
> 	/**
> 	 * Get current screen size.
> 	 *
> 	 * Get the size of the terminal in rows/cols; this value can differ from
> 	 * the model if there's an active "altscreen" with diferent size.
> 	 *
> 	 * @param h	Handle of the desired session.
> 	 * @param r Pointer to screen rows.
> 	 * @param c Pointer to screen columns.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_get_screen_size(const H3270 *h, unsigned int *r, unsigned int *c);
> 
> 	/**
> 	 * Get current screen width in columns.
> 	 *
> 	 * @param h	Handle of the desired session.
> 	 *
> 	 * @return screen width.
> 	 *
> 	 */
> 	LIB3270_EXPORT unsigned int lib3270_get_width(const H3270 *h);
> 
> 	LIB3270_EXPORT unsigned int lib3270_get_max_width(const H3270 *h);
> 
> 	/**
> 	 * Get current screen width in rows.
> 	 *
> 	 * @param h	Handle of the desired session.
> 	 *
> 	 * @return screen rows.
> 	 *
> 	 */
> 	LIB3270_EXPORT unsigned int lib3270_get_height(const H3270 *h);
> 
> 	LIB3270_EXPORT unsigned int lib3270_get_max_height(const H3270 *h);
> 
> 	LIB3270_EXPORT unsigned int lib3270_get_length(const H3270 *h);
> 
> 	/**
> 	 * @brief Creates an empty TN3270 session.
> 	 *
> 	 * @param model	Terminal model.
> 	 *
> 	 * @return Handle of the new session (release it with lib3270_session_free to avoid memory leaks).
> 	 *
> 	 */
> 	LIB3270_EXPORT H3270 * lib3270_session_new(const char *model);
> 
> 	/**
> 	 * @brief Closes a TN3270 session releasing resources.
> 	 *
> 	 * @param h handle of the session to close.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_session_free(H3270 *h);
> 
> 	/**
> 	 * @brief Register a function interested in a state change.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param tx		State ID
> 	 * @param func		Callback
> 	 * @param data		Data
> 	 *
> 	 * @return State change identifier.
> 	 *
> 	 */
> 	LIB3270_EXPORT const void * lib3270_register_schange(H3270 *hSession, LIB3270_STATE tx, void (*func)(H3270 *, int, void *),void *data);
> 
> 	/**
> 	 * @brief Unregister a function interested in a state change.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param id		State change identifier.
> 	 *
> 	 * @return 0 if suceeds, non zero if fails (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_unregister_schange(H3270 *hSession, LIB3270_STATE tx, const void * id);
> 
> 	LIB3270_EXPORT void lib3270_reset_callbacks(H3270 *hSession);
> 
> 	/**
> 	 * @brief Set host id for the connect/reconnect operations.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param url	URL of host to set in the format tn3270://hostname:service or tn3270s://hostname:service
> 	 *
> 	 * @return 0
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_set_url(H3270 *h, const char *url);
> 
> 	/**
> 	 * @brief Get the URL of the predefined tn3270 host.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @return URL of the predefined host in the format tn3270://hostname:service or tn3270s://hostname:service
> 	 */
> 	 LIB3270_EXPORT const char * lib3270_get_default_host(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get HOST URL.
> 	 *
> 	 * @return TN3270 Connection URL.
> 	 *
> 	 */
> 	 LIB3270_EXPORT const char * lib3270_get_url(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get session options.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_get_host_type(const H3270 *hSession);
> 
> 	LIB3270_EXPORT const char * lib3270_get_host_type_name(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get URL of the hostname for the connect/reconnect operations.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 * @return Pointer to host URL set (internal data, do not change it)
> 	 *
> 	 */
>     LIB3270_EXPORT const char * LIB3270_DEPRECATED(lib3270_get_host(const H3270 *h));
> 
> 	/**
> 	 * @brief Check if the session can reconnect.
> 	 *
> 	 * @param hSession			Session handle.
> 	 *
> 	 * @return zero if reconnect is unavailable (sets errno), non zero if available.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_allow_reconnect(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Reconnect to host.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param seconds	Seconds to wait for connection.
> 	 *
> 	 * @return 0 for success, non zero if fails (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_reconnect(H3270 *hSession,int seconds);
> 
> 	/**
> 	 * @brief Connect by URL
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param url		Host URL
> 	 * @param seconds	Seconds to wait for connection.
> 	 *
> 	 * @see lib3270_reconnect
> 	 *
> 	 * @return 0 for success, non zero if fails (sets errno).
> 	 */
> 	LIB3270_EXPORT int lib3270_connect_url(H3270 *hSession, const char *url, int seconds);
> 
> 	/**
> 	 * @brief Disconnect from host.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 * @return -1 if failed (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_disconnect(H3270 *h);
> 
> 	/**
> 	 * @brief Get connection state.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 * @return Connection state.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_CSTATE lib3270_get_connection_state(const H3270 *h);
> 
> 	LIB3270_EXPORT const char * lib3270_connection_state_get_name(const LIB3270_CSTATE cstate);
> 
> 	LIB3270_EXPORT const char * lib3270_state_get_name(const LIB3270_STATE state);
> 
> 	/**
> 	 * @brief Pretend that a sequence of keys was entered at the keyboard.
> 	 *
> 	 * "Pasting" means that the sequence came from the clipboard.  Returns are
> 	 * ignored; newlines mean "move to beginning of next line"; tabs and formfeeds
> 	 * become spaces.  Backslashes are not special, but ASCII ESC characters are
> 	 * used to signify 3270 Graphic Escapes.
> 	 *
> 	 * "Not pasting" means that the sequence is a login string specified in the
> 	 * hosts file, or a parameter to the String action.  Returns are "move to
> 	 * beginning of next line"; newlines mean "Enter AID" and the termination of
> 	 * processing the string.  Backslashes are processed as in C.
> 	 *
> 	 * @param s			String to input.
> 	 * @param len		Size of the string (or -1 to null terminated strings)
> 	 * @param pasting	Non zero for pasting (See comments).
> 	 *
> 	 * @return The number of unprocessed characters or -1 if failed
> 	 */
> 	LIB3270_EXPORT int lib3270_emulate_input(H3270 *session, const char *s, int len, int pasting);
> 
> 	/**
> 	 * @brief Converts row/col in a buffer address.
> 	 *
> 	 * @param hSession	TN3270 Session.
> 	 * @param row		Row inside the screen.
> 	 * @param col		Col inside the screen.
> 	 *
> 	 * @return Current address or negative if invalid (sets errno).
> 	 *
> 	 * @retval -EOVERFLOW	The coordinates are out of the screen.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_translate_to_address(const H3270 *hSession, unsigned int row, unsigned int col);
> 
> 	/**
> 	 * @brief Set field contents, jump to the next one.
> 	 *
> 	 * Set the string inside the corrent field, jump to the next one.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param text		String to input.
> 	 * @param length	Length of the string (-1 for auto-detect).
> 	 *
> 	 * @return address of the cursor, negative if failed.
> 	 *
> 	 * @retval 0			No next field.
> 	 * @retval -EPERM		The keyboard is locked.
> 	 * @retval -ENOTCONN	Disconnected from host.
>  	 * @retval -ENODATA		No field at the current cursor position.
>  	 * @retval -ENOTSUP		The screen is not formatted.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_field(H3270 *hSession, const char *text, int length);
> 
> 	/**
> 	 * @brief Set string at current cursor position.
> 	 *
> 	 * Returns are ignored; newlines mean "move to beginning of next line";
> 	 * tabs and formfeeds become spaces.  Backslashes are not special.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param text		String to input.
> 	 * @param length	Length of the string (-1 for auto-detect).
> 	 *
> 	 * @return Negative if error or number (sets errno) of processed characters.
> 	 *
> 	 * @retval -EPERM		The keyboard is locked.
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_string(H3270 *h, const unsigned char *text, int length);
> 
> 	/**
> 	 * @brief Set string at defined row/column.
> 	 *
> 	 * Set the string in the defined row/column; returns number of processed caracter if succeeds or negative value if not.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param row		Row for the first character.
> 	 * @param col		Col for the first character.
> 	 * @param str		String to set.
> 	 * @param length	Length of the string (-1 for auto-detect).
> 	 *
> 	 * @return Negative if error or number (sets errno) of processed characters.
> 	 *
> 	 * @retval -EPERM		The keyboard is locked.
> 	 * @retval -EOVERFLOW	The row or col is bigger than the screen size.
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_string_at(H3270 *hSession, unsigned int row, unsigned int col, const unsigned char *str, int length);
> 
> 	/**
> 	 * @brief Set string at defined adress.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param baddr		Adress for the first character (-1 for cursor position).
> 	 * @param str		String to set.
> 	 * @param length	Length of the string (-1 for auto-detect).
> 	 *
> 	 * @return Negative if error or number of processed characters.
> 	 *
> 	 * @retval -EPERM		The keyboard is locked.
> 	 * @retval -EOVERFLOW	The address is beyond the screen length.
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_string_at_address(H3270 *hSession, int baddr, const unsigned char *str, int length);
> 
> 	/**
> 	 * @brief Insert string at current cursor position.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param str		Text to insert.
> 	 * @param length	Length of the string (-1 for auto-detect).
> 	 *
> 	 * @return 0 if success, non zero if failed (sets errno).
> 	 *
> 	 * @retval EPERM		The keyboard is locked.
> 	 * @retval ENOTCONN		Disconnected from host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_input_string(H3270 *hSession, const unsigned char *str, int length);
> 
> 	/**
> 	 * @brief Move cursor to a new position.
> 	 *
> 	 * @see lib3270_set_cursor_position
> 	 *
> 	 * @param hSession	TN3270 session.
> 	 * @param baddr		New cursor position.
> 	 *
> 	 * @return Old cursor address or negative in case of error (sets errno).
> 	 *
> 	 * @retval -EOVERFLOW	The address is beyond the screen length.
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_cursor_address(H3270 *hSession, int baddr);
> 
> 	/**
> 	 * @brief Set cursor position.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param row	New cursor row.
> 	 * @param col	New cursor col.
> 	 *
> 	 * @return Old cursor address or negative in case of error (sets errno).
> 	 *
> 	 * @retval -EOVERFLOW	The address is beyond the screen length.
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 */
> 	LIB3270_EXPORT int lib3270_set_cursor_position(H3270 *h, unsigned int row, unsigned int col);
> 
> 	/**
> 	 * @brief Get cursor address.
> 	 *
> 	 * @param hSession Session handle.
> 	 *
> 	 * @return Cursor address or negative if invalid (sets errno).
> 	 *
> 	 * @retval -ENOTCONN	Disconnected from host.
> 	 * @retval -EINVAL		Invalid session handle.
> 	 * @retval -1			Unexpected error.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_cursor_address(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get row/col of the current cursor position.
> 	 *
> 	 * @param hSession	Session handler.
> 	 * @param row		Pointer for current cursor row.
> 	 * @param col		Pointer for current cursor column.
> 	 *
> 	 * @return 0 if ok, error code if not (sets errno).
> 	 *
> 	 * @retval EINVAL	Invalid session.
> 	 * @retval ENOTCONN	Not connected to host.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_cursor_position(const H3270 *hSession, unsigned short *row, unsigned short *col);
> 
> 	/**
> 	 * @brief Move cursor
> 	 *
> 	 * @param h		Session handle.
> 	 * @param dir	Direction to move
> 	 * @param sel	Non zero to move and selected to the current cursor position
> 	 *
> 	 * @return 0 if the movement can be done, non zero if failed.
> 	 */
> 	 LIB3270_EXPORT int lib3270_move_cursor(H3270 *h, LIB3270_DIRECTION dir, unsigned char sel);
> 
> 	/**
> 	 * @brief Default print operation.
> 	 *
> 	 * If the terminal has selected area print them, if not, print all contents.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_print(H3270 *hSession);
> 
> 	/**
> 	 * @brief Print terminal screen.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_print_all(H3270 *hSession);
> 
> 	/**
> 	 * @brief Print only selected area (if available).
> 	 *
> 	 * @param hSession	Session Handle.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_print_selected(H3270 *hSession);
> 
> 	/**
> 	 * @brief Ask the front end module to print stored copy.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_print_copy(H3270 *hSession);
> 
> 	/**
> 	 * @brief Save contents to file.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 * @param mode		Content option.
> 	 * @param filename	File name.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 */
> 	LIB3270_EXPORT int lib3270_save(H3270 *hSession, LIB3270_CONTENT_OPTION mode, const char *filename);
> 
> 	LIB3270_EXPORT int lib3270_save_all(H3270 *hSession, const char *filename);
> 	LIB3270_EXPORT int lib3270_save_selected(H3270 *hSession, const char *filename);
> 	LIB3270_EXPORT int lib3270_save_copy(H3270 *hSession, const char *filename);
> 
> 	/**
> 	 * @brief Paste from file.
> 	 *
> 	 * @param hSession	Session Handle.
> 	 * @param filename	File name.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 */
> 	LIB3270_EXPORT int lib3270_load(H3270 *hSession, const char *filename);
> 
> 	/**
> 	 * @brief Get buffer contents.
> 	 *
> 	 * @param h		Session handle.
> 	 * @param first	First element to get.
> 	 * @param last	Last element to get.
> 	 * @param chr	Pointer to buffer which will receive the read chars.
> 	 * @param attr	Pointer to buffer which will receive the chars attributes.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_contents(H3270 *h, int first, int last, unsigned char *chr, unsigned short *attr);
> 
> 	/**
> 	 * @brief IO flags.
> 	 *
> 	 */
> 	typedef enum _lib3270_io_event {
> 		LIB3270_IO_FLAG_READ		= 0x01,
> 		LIB3270_IO_FLAG_EXCEPTION	= 0x02,
> 		LIB3270_IO_FLAG_WRITE		= 0x04,
> 
> 		LIB3270_IO_FLAG_MASK		= 0x07
> 	} LIB3270_IO_FLAG;
> 
> 	LIB3270_EXPORT void		* lib3270_add_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata );
> 	LIB3270_EXPORT void		  lib3270_remove_poll(H3270 *session, void *id);
> 	LIB3270_EXPORT void		  lib3270_set_poll_state(H3270 *session, void *id, int enabled);
> 
> 	LIB3270_EXPORT void		  lib3270_remove_poll_fd(H3270 *session, int fd);
> 	LIB3270_EXPORT void		  lib3270_update_poll_fd(H3270 *session, int fd, LIB3270_IO_FLAG flag);
> 
> 	/**
> 	 * @brief I/O Controller.
> 	 *
> 	 * GUI unblocking I/O calls, used to replace the lib3270´s internal ones.
> 	 *
> 	 */
> 	typedef struct lib3270_io_controller
> 	{
> 		unsigned short sz;
> 
> 		void	* (*AddTimer)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata);
> 		void	  (*RemoveTimer)(H3270 *session, void *timer);
> 
> 		void	* (*add_poll)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata);
> 		void	  (*remove_poll)(H3270 *session, void *id);
> 		void	  (*set_poll_state)(H3270 *session, void *id, int enabled);
> 
> 		int		  (*Wait)(H3270 *hSession, int seconds);
> 		int		  (*event_dispatcher)(H3270 *session, int wait);
> 		void	  (*ring_bell)(H3270 *session);
> 		int		  (*run_task)(H3270 *session, int(*callback)(H3270 *, void *), void *parm);
> 
> 	} LIB3270_IO_CONTROLLER;
> 
> 	/**
> 	 * Register application Handlers.
> 	 *
> 	 * @param cbk	Structure with the application I/O handles to set.
> 	 *
> 	 * @return 0 if ok, error code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_register_io_controller(const LIB3270_IO_CONTROLLER *cbk);
> 
> 	/**
> 	 * Register time handlers.
> 	 *
> 	 * @param add	Callback for adding a timeout
> 	 * @param rm	Callback for removing a timeout
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_register_timer_handlers(void * (*add)(H3270 *session, unsigned long interval_ms, int (*proc)(H3270 *session, void *userdata), void *userdata), void (*rm)(H3270 *session, void *timer));
> 
> 	LIB3270_EXPORT void lib3270_register_fd_handlers(void * (*add)(H3270 *session, int fd, LIB3270_IO_FLAG flag, void(*proc)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata), void (*rm)(H3270 *, void *id));
> 
> 	/**
> 	 * @brief Get program message.
> 	 *
> 	 * @see LIB3270_MESSAGE
> 	 *
> 	 * @param h	Session handle.
> 	 *
> 	 * @return Latest program message.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_MESSAGE	  lib3270_get_program_message(const H3270 *h);
> 
> 	/**
> 	 * @brief Get the LU name associated with the session, if there is one.
> 	 *
> 	 * Get the name LU associated with the session; the value is
> 	 * internal to lib3270 and should not be changed ou freed.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @return The associated LU name or NULL if not available.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_associated_luname(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Set the LU names.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param lunames	Comma separated list of the LU names to set.
> 	 *
> 	 * @return 0 if the list was set, non zero if not (sets errno)
> 	 *
> 	 * @retval EISCONN	The session is online.
> 	 * @retval EINVAL	Invalid session handle.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_lunames(H3270 *hSession, const char *luname);
> 
> 	LIB3270_EXPORT const char ** lib3270_get_lunames(H3270 *hSession);
> 
> 	LIB3270_EXPORT int lib3270_is_connected(const H3270 *h);
> 
> 
> 	LIB3270_EXPORT int lib3270_is_disconnected(const H3270 *h);
> 
> 	LIB3270_EXPORT int lib3270_is_unlocked(const H3270 *h);
> 
> 	LIB3270_EXPORT int lib3270_has_active_script(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_get_typeahead(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_get_undera(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_get_oia_box_solid(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_pconnected(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_half_connected(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_neither(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_ansi(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_3270(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_sscp(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_tn3270e(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_in_e(const H3270 *h);
> 
> 	LIB3270_EXPORT int lib3270_is_ready(const H3270 *h);
> 	LIB3270_EXPORT int lib3270_is_secure(const H3270 *h);
> 
> 	LIB3270_EXPORT LIB3270_MESSAGE		lib3270_get_lock_status(const H3270 *h);
> 
> 	/**
> 	 * Run main iteration.
> 	 *
> 	 * Run lib3270 internal iterations, check for network inputs, process signals.
> 	 *
> 	 * @param h		Related session.
> 	 * @param wait	Wait for signal if not available.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_main_iterate(H3270 *h, int wait);
> 
> 	/**
> 	 * @brief Associate user data with 3270 session.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_set_user_data(H3270 *h, void *ptr);
> 
> 	/**
> 	 * @brief Get associated user data.
> 	 *
> 	 */
> 	LIB3270_EXPORT void * lib3270_get_user_data(H3270 *h);
> 
> 	/**
> 	 * @brief Wait for "N" seconds keeping main loop active.
> 	 *
> 	 * @param seconds	Number of seconds to wait.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait(H3270 *hSession, int seconds);
> 
> 	/**
> 	 * @brief Wait for "N" seconds or screen change; keeps main loop active.
> 	 *
> 	 * @param seconds	Number of seconds to wait.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_update(H3270 *hSession, int seconds);
> 
> 	/**
> 	 * @brief Wait "N" seconds for "ready" state.
> 	 *
> 	 * @param seconds	Number of seconds to wait.
> 	 *
> 	 * @return 0 if ok, errno code if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_ready(H3270 *hSession, int seconds);
> 
> 	/**
> 	 * @brief Wait "N" seconds for online state.
> 	 *
> 	 * @param seconds	Number of seconds to wait.
> 	 *
> 	 * @return 0 if ok, errno code if not.
> 	 *
> 	 * @retval	ETIMEDOUT	Timeout waiting.
> 	 * @retval	ENOTCONN	Not connected to host.
> 	 * @retval	0			Session is online and in required state.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_cstate(H3270 *hSession, LIB3270_CSTATE cstate, int seconds);
> 
> 	/**
> 	 * "beep" to notify user.
> 	 *
> 	 * If available play a sound signal do alert user.
> 	 *
> 	 * @param h		Session handle.
> 	 *
> 	 */
> 	 LIB3270_EXPORT void lib3270_ring_bell(H3270 *session);
> 
> 	/**
> 	 * Get lib3270's charset.
> 	 *
> 	 * @param h Session handle.
> 	 *
> 	 * @return String with current encoding.
> 	 *
> 	 */
> 	 LIB3270_EXPORT const char * lib3270_get_display_charset(const H3270 *session);
> 
> 	 #define lib3270_get_charset(s) lib3270_get_display_charset(s)
> 
> 	 LIB3270_EXPORT const char * lib3270_get_default_charset(void);
> 
> 	/**
> 	 * @brief Get selected area.
> 	 *
> 	 * @param h	Session Handle.
> 	 *
> 	 * @return selected text if available, or NULL. Release it with free()
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_get_selected(H3270 *hSession);
> 
> 	LIB3270_EXPORT char * lib3270_cut_selected(H3270 *hSession);
> 
> 	/**
> 	 * @brief Check if the terminal has selected area (allways sets errno).
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @return Greater than zero if the terminal has selected area, 0 if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_has_selection(const H3270 *hSession);
> 
> 	LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_has_selection(const H3270 *hSession));
> 
> 	/**
> 	 * @brief Check if the terminal has stored clipboard contents.
> 	 *
> 	 * @param hSession	Session handle.
> 	 *
> 	 * @return Greater than zero if the terminal has copy, 0 if not.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_has_copy(const H3270 *hSession);
> 
> 	LIB3270_EXPORT void lib3270_set_has_copy(H3270 *hSession, int has_copy);
> 
> 
> 	/**
> 	 * @brief Get all text inside the terminal.
> 	 *
> 	 * @param h			Session Handle.
> 	 * @param offset	Start position (-1 to current cursor position).
> 	 * @param len		Text length or -1 to all text.
> 	 * @param lf		Line break char (0 to disable line breaks).
> 	 *
> 	 * @return Contents at position if available, or NULL if error (sets errno). Release it with lib3270_free()
> 	 *
> 	 * @exception ENOTCONN	Not connected to host.
> 	 * @exception EOVERFLOW	Invalid offset.
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_get_string_at_address(H3270 *h, int offset, int len, char lf);
> 
> 	/**
> 	 * @brief Get text at requested position
> 	 *
> 	 * @param h			Session Handle.
> 	 * @param row		Desired row.
> 	 * @param col		Desired col.
> 	 * @param len		Text length or -1 to all text.
> 	 * @param lf		Line break char (0 to disable line breaks).
> 	 *
> 	 * @return Contents at position if available, or NULL if error (sets errno). Release it with lib3270_free()
> 	 *
> 	 * @exception ENOTCONN	Not connected to host.
> 	 * @exception EOVERFLOW	Invalid position.
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_get_string_at(H3270 *h, unsigned int row, unsigned int col, int len, char lf);
> 
> 	/**
> 	 * @brief Check for text at requested position
> 	 *
> 	 * @param h			Session Handle.
> 	 * @param row		Desired row.
> 	 * @param col		Desired col.
> 	 * @param text		Text to check.
> 	 * @param lf		Line break char (0 to disable line breaks).
> 	 *
> 	 * @return Test result from strcmp
> 	 *
> 	 */
> 	 LIB3270_EXPORT int lib3270_cmp_string_at(H3270 *h, unsigned int row, unsigned int col, const char *text, char lf);
> 
> 	 LIB3270_EXPORT int lib3270_cmp_string_at_address(H3270 *h, int baddr, const char *text, char lf);
> 
> 	/**
> 	 * @brief Get contents of the field at position.
> 	 *
> 	 * @param h			Session Handle.
> 	 * @param baddr		Reference position.
> 	 *
> 	 * @return NULL if failed (sets errno), contents of the entire field if suceeds (release it with lib3270_free()).
> 	 *
> 	 * @exception ENOTCONN	Not connected to host.
> 	 * @exception EOVERFLOW	Invalid position.
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_get_field_string_at(H3270 *h, int baddr);
> 
> 	/**
> 	 * @brief Find the next unprotected field.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param baddr0	Search start addr (-1 to use current cursor position).
> 	 *
> 	 * @return address following the unprotected attribute byte, or 0 if no nonzero-width unprotected field can be found.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_next_unprotected(H3270 *hSession, int baddr0);
> 
> 	/**
> 	 * @brief Check if the screen position is protected.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param baddr0	Search start addr (-1 to use current cursor position).
>      *
>      * @return -1 when failed 1 if the addr is protected and 0 if not.
>      *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_is_protected(const H3270 *hSession, int baddr0);
> 
> 	LIB3270_EXPORT int LIB3270_DEPRECATED(lib3270_is_protected(H3270 *h, unsigned int baddr));
> 
> 	/**
> 	 * @brief Check if the screen is formatted.
> 	 *
> 	 * @param hSession	Session handle.
>      *
>      * @return -1 when failed 1 if the session is formatted and 0 if not.
>      *
>      * @retval -1	Failed (check errno for error code).
>      * @retval  0	Screen is not formatted.
>      * @retval  1	Screen is formatted.
> 	 */
> 	LIB3270_EXPORT int lib3270_is_formatted(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Get Check if the screen position is protected.
> 	 *
> 	 * @param h			Session Handle.
> 	 * @param row		Desired row.
> 	 * @param col		Desired col.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_is_protected_at(const H3270 *h, unsigned int row, unsigned int col);
> 
> 	/**
> 	 * @brief Get address of the first blank.
> 	 *
> 	 * Get address of the first blank after the last nonblank in the
> 	 * field, or if the field is full, to the last character in the field.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param baddr		Field address.
> 	 *
> 	 * @return address of the first blank or negative if invalid.
> 	 *
> 	 * @retval -ENOTSUP		Screen is not formatted.
> 	 * @retval -EPERM		Current cursor position is protected.
> 	 */
> 	LIB3270_EXPORT int lib3270_get_field_end(H3270 *hSession, int baddr);
> 
> 	/**
> 	 * @brief Find the buffer address of the field attribute for a given buffer address.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param addr		Buffer address of the field.
> 	 *
> 	 * @return field address or negative if the screen isn't formatted (sets errno).
> 	 *
> 	 * @retval -ENOTCONN	Not connected to host.
> 	 * @retval -EOVERFLOW	Invalid position.
> 	 * @retval -ENOTSUP		Screen is not formatted.
> 	 * @retval -ENODATA		No field at the address.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_field_addr(const H3270 *hSession, int baddr);
> 
> 	/**
> 	 * @brief Get field attribute for a given buffer address.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param addr		Buffer address of the field (-1 to use the cursor address).
> 	 *
> 	 * @return field attribute or LIB3270_FIELD_ATTRIBUTE_INVALID when failed (sets errno).
> 	 */
> 	LIB3270_EXPORT LIB3270_FIELD_ATTRIBUTE lib3270_get_field_attribute(H3270 *hSession, int baddr);
> 
> 	/**
> 	 * @brief Get the length of the field at given buffer address.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param addr		Buffer address of the field.
> 	 *
> 	 * @return field length or -1 if invalid or not connected (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_field_length(H3270 *h, int baddr);
> 
> 	/**
> 	 * @brief Get a terminal character and attribute.
> 	 *
> 	 * @param h		Session Handle.
> 	 * @param baddr	Element address ((element_row*cols)+element_col)
> 	 * @param c		Pointer to character.
> 	 * @param attr	Pointer to attribute.
> 	 *
> 	 * @return 0 if ok, -1 if fails (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_element(H3270 *h, unsigned int baddr, unsigned char *c, unsigned short *attr);
> 
> 	/**
> 	 * @brief Check if the informed addr is marked as selected.
> 	 *
> 	 * @param h		Session Handle.
> 	 * @param baddr	Element address ((element_row*cols)+element_col)
> 	 *
> 	 * @return >0 zero if element is selected, 0 if not, -1 if fails (sets errno).
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_is_selected(H3270 *hSession, unsigned int baddr);
> 
> 	/**
> 	 * @brief Get attribute at the requested ADDR.
> 	 *
> 	 * @param h		Session Handle.
> 	 * @param baddr	Element address ((element_row*cols)+element_col)
> 	 *
> 	 * @return Attribute of the required address or -1 if failed.
> 	 *
> 	 */
> 	LIB3270_EXPORT LIB3270_ATTR lib3270_get_attribute_at_address(H3270 *hSession, unsigned int baddr);
> 
> 	/**
> 	 * Get field region
> 	 *
> 	 * @param h		Session handle.
> 	 * @param baddr	Reference position to get the field start/stop offsets.
> 	 * @param start	return location for start of selection, as a character offset.
> 	 * @param end	return location for end of selection, as a character offset.
> 	 *
> 	 * @return Non 0 if invalid
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_get_field_bounds(H3270 *hSession, int baddr, int *start, int *end);
> 
> 	LIB3270_EXPORT int lib3270_get_field_start(H3270 *hSession, int baddr);
> 	LIB3270_EXPORT int lib3270_get_field_len(H3270 *hSession, int baddr);
> 
> 	LIB3270_EXPORT int lib3270_get_word_bounds(H3270 *hSession, int baddr, int *start, int *end);
> 
> 	LIB3270_EXPORT int 			  LIB3270_DEPRECATED(lib3270_set_model(H3270 *hSession, const char *model_name));
> 	LIB3270_EXPORT const char	* LIB3270_DEPRECATED(lib3270_get_model(const H3270 *session));
> 
> 	LIB3270_EXPORT const char	* lib3270_get_model_name(const H3270 *session);
> 	LIB3270_EXPORT int			  lib3270_set_model_name(H3270 *hSession, const char *model_name);
> 
> 	LIB3270_EXPORT unsigned int	  lib3270_get_model_number(const H3270 *hSession);
> 
> 	/**
> 	 * @brief Set TN3270 model number.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param model_number	The new model number (2-5).
> 	 *
> 	 * @return
> 	 */
> 	LIB3270_EXPORT int			  lib3270_set_model_number(H3270 *hSession, unsigned int model_number);
> 
> 	/**
> 	 *
> 	 * @brief Set the unlock delay in milliseconds.
> 	 *
> 	 * When lib3270 sends the host an AID (the Enter, Clear, PF or PA actions),
> 	 * it locks the keyboard until the host sends a reply to unlock it. Some
> 	 * hosts unlock the keyboard before they are actually finished processing
> 	 * the command, which can cause scripts to malfunction subtly.
> 	 *
> 	 * To avoid this, lib3270 implements a hack to briefly delay actually
> 	 * unlocking the keyboard. When the unlock delay is not 0, the keyboard
> 	 * unlock will be delayed for the number of milliseconds set by this call.
> 	 *
> 	 * Setting the delay to 0 disables the hack.
> 	 *
> 	 * @param session	lib3270 session.
> 	 * @param delay		Delay in milliseconds.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_unlock_delay(H3270 *session, unsigned int delay);
> 	LIB3270_EXPORT unsigned int lib3270_get_unlock_delay(const H3270 *session);
> 
> 	/**
> 	 * @brief Alloc/Realloc memory buffer.
> 	 *
> 	 * Allocate/reallocate an array.
> 	 *
> 	 * @param elsize	Element size.
> 	 * @param nelem		Number of elements in the array.
> 	 * @param ptr		Pointer to the actual array.
> 	 *
> 	 * @return Clean buffer with size for the number of elements.
> 	 *
> 	 */
> 	LIB3270_EXPORT void * lib3270_calloc(int elsize, int nelem, void *ptr);
> 
> 	LIB3270_EXPORT void * lib3270_malloc(int len);
> 	LIB3270_EXPORT void * lib3270_realloc(void *p, int len);
> 	LIB3270_EXPORT void * lib3270_strdup(const char *str);
> 
> 	/**
> 	 * @brief Release allocated memory.
> 	 *
> 	 * @param p	Memory block to release (can be NULL)
> 	 *
> 	 * @return NULL
> 	 */
> 	LIB3270_EXPORT void  * lib3270_free(void *p);
> 
> 	LIB3270_EXPORT void   lib3270_autoptr_cleanup_char(char **ptr);
> 
> 	/**
> 	 * Get default session handle.
> 	 *
> 	 * @return Internal's lib3270 session handle.
> 	 *
> 	 */
> 	LIB3270_EXPORT H3270 * lib3270_get_default_session_handle(void);
> 
> 	/**
> 	 * Get library version.
> 	 *
> 	 * @return Version of active library as string.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_version(void);
> 
> 	/**
> 	 * Get source code revision.
> 	 *
> 	 * @return The revision of the current source code.
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_revision(void);
> 
> 	LIB3270_EXPORT char * lib3270_vsprintf(const char *fmt, va_list args);
> 	LIB3270_EXPORT char * lib3270_strdup_printf(const char *fmt, ...);
> 
> 	LIB3270_EXPORT int lib3270_clear_operator_error(H3270 *hSession);
> 
> 	/**
> 	 * @brief Set the terminal color type.
> 	 *
> 	 * @param hSession	Session handle.
> 	 * @param colortype	The color type for the emulator (2, 8, 16 or 0 to lib3270's default).
> 	 *
> 	 * @return 0 if ok, error code if failed (sets errno).
> 	 *
> 	 * @retval EINVAL	Invalid color type value.
> 	 * @retval EISCONN	The session is active.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_set_color_type(H3270 *hSession, unsigned int colortype);
> 
> 	LIB3270_EXPORT unsigned int lib3270_get_color_type(const H3270 *hSession);
> 
> 	LIB3270_EXPORT int lib3270_set_host_type_by_name(H3270 *hSession, const char *name);
> 	LIB3270_EXPORT int lib3270_set_host_type(H3270 *hSession, LIB3270_HOST_TYPE opt);
> 
> 	LIB3270_EXPORT LIB3270_HOST_TYPE lib3270_parse_host_type(const char *name);
> 
> 	LIB3270_EXPORT const LIB3270_HOST_TYPE_ENTRY * lib3270_get_option_list(void);
> 
> 	LIB3270_EXPORT LIB3270_POINTER lib3270_get_pointer(H3270 *hSession, int baddr);
> 
> 	/**
> 	 * @brief Run background task.
> 	 *
> 	 * Call task in a separate thread, keep gui main loop running until
> 	 * the function returns.
> 	 *
> 	 * @param hSession	TN3270 session.
> 	 * @param callback	Function to call.
> 	 * @param parm		Parameter to callback function.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_run_task(H3270 *hSession, int(*callback)(H3270 *h, void *), void *parm);
> 
> 	/**
> 	 * @brief The host is TSO?
> 	 *
> 	 * @param hSession	Session Handle
> 	 *
> 	 * @return Non zero if the host is TSO.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_is_tso(const H3270 *hSession);
> 
> 	LIB3270_EXPORT int lib3270_set_tso(H3270 *hSession, int on);
> 
> 	/**
> 	 * @brief Host is AS400 (Prefix every PF with PA1).
> 	 *
> 	 * @param hSession	Session Handle
> 	 *
> 	 * @return Non zero if the host is AS400.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_is_as400(const H3270 *hSession);
> 
> 	LIB3270_EXPORT int lib3270_set_as400(H3270 *hSession, int on);
> 
> 	/**
> 	 * @brief Build filename on application data dir.
> 	 *
> 	 * @return Full path for the file (release it with lib3270_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_build_data_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
> 
> 	/**
> 	 * @brief Build filename on application configuration dir.
> 	 *
> 	 * @return Full path for the file (release it with lib3270_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_build_config_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
> 
> 	/**
> 	 * @brief Build and search for filename.
> 	 *
> 	 * Build filename and search for it on current, configuration and data dirs.
> 	 *
> 	 * @return Full path for the file (release it with lib3270_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT char * lib3270_build_filename(const char *str, ...) LIB3270_GNUC_NULL_TERMINATED;
> 
> 	LIB3270_EXPORT void lib3270_set_session_id(H3270 *hSession, char id);
> 	LIB3270_EXPORT char lib3270_get_session_id(H3270 *hSession);
> 
> 	/**
> 	 * @brief Wait for string at screen.
> 	 *
> 	 * @param hSession	TN3270 Session.
> 	 * @param key		The string to wait for.
> 	 * @param seconds	Maximum wait time.
> 	 *
> 	 * @return 0 if the string was found, error code if not (sets errno).
> 	 *
> 	 * @retval ENOTCONN		Not connected to host.
> 	 * @retval ETIMEDOUT	Timeout.
> 	 * @retval EPERM		The keyboard is locked.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_string(H3270 *hSession, const char *key, int seconds);
> 
> 	/**
> 	 * @brief Wait for string at position.
> 	 *
> 	 * @param hSession	TN3270 Session.
> 	 * @param row		Row inside the screen.
> 	 * @param col		Col inside the screen.
> 	 * @param key		The string to wait for.
> 	 * @param seconds	Maximum wait time.
> 	 *
> 	 * @return 0 if the string was found, error code if not (sets errno).
> 	 *
> 	 * @retval ENOTCONN		Not connected to host.
> 	 * @retval EOVERFLOW	Invalid position.
> 	 * @retval ETIMEDOUT	Timeout.
> 	 * @retval EPERM		The keyboard is locked.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_string_at(H3270 *hSession, unsigned int row, unsigned int col, const char *key, int seconds);
> 
> 	/**
> 	 * @brief Wait for string at addrress.
> 	 *
> 	 * @param hSession	TN3270 Session.
> 	 * @param baddr		Start position (-1 to current cursor position).
> 	 * @param key		The string to wait for.
> 	 * @param seconds	Maximum wait time.
> 	 *
> 	 * @return 0 if the string was found, error code if not (sets errno).
> 	 *
> 	 * @retval ENOTCONN	Not connected to host.
> 	 * @retval EOVERFLOW	Invalid position.
> 	 * @retval ETIMEDOUT	Timeout.
> 	 * @retval EPERM		The keyboard is locked.
> 	 *
> 	 */
> 	LIB3270_EXPORT int lib3270_wait_for_string_at_address(H3270 *hSession, int baddr, const char *key, int seconds);
> 
> 	/**
> 	 * @brief Notify action group.
> 	 *
> 	 */
> 	LIB3270_EXPORT void lib3270_action_group_notify(H3270 *hSession, LIB3270_ACTION_GROUP group);
> 
> 	/**
> 	 * @brief Get lib3270's translation domain (for use with dgettext).
> 	 *
> 	 */
> 	LIB3270_EXPORT const char * lib3270_get_translation_domain();
1667c1599
< }
---
> 	}
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include: lib3270++.h
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/linkedlist.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/linkedlist.h
37c37
< #define LIB3270_LINKED_LIST_H_INCLUDED
---
> 	#define LIB3270_LINKED_LIST_H_INCLUDED
39,40c39,40
< #include <stddef.h>
< #include <lib3270.h>
---
> 	#include <stddef.h>
> 	#include <lib3270.h>
42c42
< #define LIB3270_LINKED_LIST_HEAD	\
---
> 	#define LIB3270_LINKED_LIST_HEAD	\
47,49c47,50
< struct lib3270_linked_list_node {
< 	LIB3270_LINKED_LIST_HEAD
< };
---
> 	struct lib3270_linked_list_node
> 	{
> 		LIB3270_LINKED_LIST_HEAD
> 	};
51,54c52,56
< struct lib3270_linked_list_head {
< 	struct lib3270_linked_list_node * first;
< 	struct lib3270_linked_list_node * last;
< };
---
> 	struct lib3270_linked_list_head
> 	{
> 		struct lib3270_linked_list_node * first;
> 		struct lib3270_linked_list_node * last;
> 	};
56,58c58,60
< LIB3270_INTERNAL void	* lib3270_linked_list_append_node(struct lib3270_linked_list_head *head, size_t szBlock, void *userdata);
< LIB3270_INTERNAL int	  lib3270_linked_list_delete_node(struct lib3270_linked_list_head *head, const void *node);
< LIB3270_INTERNAL void	  lib3270_linked_list_free(struct lib3270_linked_list_head *head);
---
> 	LIB3270_INTERNAL void	* lib3270_linked_list_append_node(struct lib3270_linked_list_head *head, size_t szBlock, void *userdata);
> 	LIB3270_INTERNAL int	  lib3270_linked_list_delete_node(struct lib3270_linked_list_head *head, const void *node);
> 	LIB3270_INTERNAL void	  lib3270_linked_list_free(struct lib3270_linked_list_head *head);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/linux/lib3270/os.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/linux/lib3270/os.h
30,35c30,35
< /**
<  * @brief TN3270 API linux definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 API linux definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
39c39
< #define LIB3270_OS_H_INCLUDED 1
---
> 	#define LIB3270_OS_H_INCLUDED 1
41c41
< #include <unistd.h>
---
> 	#include <unistd.h>
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/localdefs.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/localdefs.h
36c36,38
< 
---
> //typedef void *XtPointer;
> // typedef void *Widget;
> // typedef void *XEvent;
38c40
< typedef unsigned char Boolean;
---
>     typedef unsigned char Boolean;
40c42
< typedef char Boolean;
---
>     typedef char Boolean;
42d43
< 
44c45,46
< //typedef unsigned long KeySym;
---
> // typedef unsigned int Cardinal;
> typedef unsigned long KeySym;
47,48c49,66
< //#define XtNumber(n)	(sizeof(n)/sizeof((n)[0]))
< //#define NoSymbol		0L
---
> /*
> typedef void (*XtActionProc)(
>     Widget 		// widget,
>     XEvent*		// event,
>     String*		// params,
>     Cardinal*		// num_param
> );
> */
> 
> /*
> typedef struct _XtActionsRec{
>     String	 string;
>     XtActionProc proc;
> } XtActionsRec;
> */
> 
> #define XtNumber(n)	(sizeof(n)/sizeof((n)[0]))
> #define NoSymbol		0L
50a69,76
> 
> // void * Malloc(size_t);
> // void   Free(void *);
> // void * Calloc(size_t, size_t);
> // void * Realloc(void *, size_t);
> 
> // #define Malloc(x) lib3270_malloc(x)
> // #define Free(x)	lib3270_free(x)
54a81
> //extern char *NewString(const char *);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/macos/lib3270/os.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/macos/lib3270/os.h
30,35c30,35
< /**
<  * @brief TN3270 API MAC definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 API MAC definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
39c39
< #define LIB3270_OS_H_INCLUDED 1
---
> 	#define LIB3270_OS_H_INCLUDED 1
41c41
< #include <unistd.h>
---
> 	#include <unistd.h>
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/networking.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/networking.h
32c32
< #define LIB3270_NETWORKING_H_INCLUDED
---
> 	#define LIB3270_NETWORKING_H_INCLUDED
35,36c35,36
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
38c38
< typedef int socklen_t;
---
> 	typedef int socklen_t;
41c41
< #include <sys/socket.h>
---
> 	#include <sys/socket.h>
44c44
< #include <lib3270/popup.h>
---
> 	#include <lib3270/popup.h>
46,47c46,47
< typedef struct _lib3270_network_popup LIB3270_NETWORK_POPUP;
< typedef struct _lib3270_net_context LIB3270_NET_CONTEXT;
---
> 	typedef struct _lib3270_network_popup LIB3270_NETWORK_POPUP;
> 	typedef struct _lib3270_net_context LIB3270_NET_CONTEXT;
49,52c49,52
< typedef struct lib3270_ssl_message {
< 	LIB3270_POPUP_HEAD			///< @brief Standard popup fields.
< 	const char		* icon;		///< @brief Icon name from https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
< } LIB3270_SSL_MESSAGE;
---
> 	typedef struct lib3270_ssl_message {
> 		LIB3270_POPUP_HEAD			///< @brief Standard popup fields.
> 		const char		* icon;		///< @brief Icon name from https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
> 	} LIB3270_SSL_MESSAGE;
54c54
< typedef struct lib3270_network_state {
---
> 	typedef struct lib3270_network_state {
56c56
< 	int syserror;				///< @brief System error (errno)
---
> 		int syserror;				///< @brief System error (errno)
58c58
< 	DWORD 	winerror;			///< @brief Win32 error got from GetLastError()
---
> 		DWORD 	winerror;			///< @brief Win32 error got from GetLastError()
61c61
< 	const char * error_message;	/// @brief System error message.
---
> 		const char * error_message;	/// @brief System error message.
63c63
< 	const LIB3270_POPUP *popup;	/// @brief Detailed info for popup.
---
> 		const LIB3270_POPUP *popup;	/// @brief Detailed info for popup.
65c65
< } LIB3270_NETWORK_STATE;
---
> 	} LIB3270_NETWORK_STATE;
67c67
< typedef struct lib3270_net_module {
---
> 	typedef struct lib3270_net_module {
69,247c69,233
< 	/// @brief Protocol name for URL.
< 	const char *name;
< 
< 	/// @brief Default service name.
< 	const char *service;
< 
< 	/// @brief Prepare to connect.
< 	///
< 	/// @param hSession	TN3270 session.
< 	/// @param state	Pointer to state message.
< 	///
< 	int (*init)(H3270 *hSession);
< 
< 	/// @brief Deinitialize network module.
< 	///
< 	/// @param hSession	TN3270 session.
< 	/// @param state	Pointer to state message.
< 	///
< 	void (*finalize)(H3270 *hSession);
< 
< 	/// @brief Connect to host.
< 	///
< 	/// @param hSession	TN3270 session.
< 	/// @param seconds	Seconds for timeout.
< 	/// @param state	Pointer to state message.
< 	///
< 	int (*connect)(H3270 *hSession, LIB3270_NETWORK_STATE *state);
< 
< 	/// @brief Disconnect from host.
< 	///
< 	/// @param hSession	TN3270 session.
< 	/// @param state	Pointer to state message.
< 	///
< 	int (*disconnect)(H3270 *hSession);
< 
< 	/// @brief Start TLS/SSL.
< 	///
< 	/// @param hSession	TN3270 session.
< 	///
< 	/// @return 0 if ok, error code if not.
< 	///
< 	/// @retval 0		TLS/SSL was negotiated.
< 	/// @retval ENOTSUP	No TLS/SSL support in the network module.
< 	///
< 	int (*start_tls)(H3270 *hSession);
< 
< 	/// @brief Send on network context.
< 	///
< 	/// @return Positive on data received, negative on error.
< 	///
< 	ssize_t (*send)(H3270 *hSession, const void *buffer, size_t length);
< 
< 	/// @brief Receive on network context.
< 	///
< 	/// @return Positive on data received, negative on error.
< 	///
< 	/// @retval -ENOTCONN		Not connected to host.
< 	/// @retval -EWOULDBLOCK	Next request will block.
< 	/// @retval -EAGAIN			Try again.
< 	///
< 	ssize_t (*recv)(H3270 *hSession, void *buf, size_t len);
< 
< 	/// @brief Add socket in poll list.
< 	void * (*add_poll)(H3270 *hSession, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata);
< 
< 	/// @brief Set non blocking mode.
< 	///
< 	/// @retval 0	Not connected or Success.
< 	/// @retval -1	Failed (popup was sent).
< 	int (*non_blocking)(H3270 *hSession, const unsigned char on);
< 
< 	/// @brief Check if the session is online.
< 	///
< 	/// @retval 0	The session is offline.
< 	int (*is_connected)(const H3270 *hSession);
< 
< 	/// @brief Get socket name.
< 	///
< 	/// @return On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.
< 	///
< 	/// @retval 0	Success.
< 	/// @retval -1	Error (errno is set).
< 	int (*getsockname)(const H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
< 
< 	/// @brief Get name of connected peer socket.
< 	///
< 	/// @return On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.
< 	///
< 	/// @retval 0	Success.
< 	/// @retval -1	Error (errno is set).
< 	int (*getpeername)(const H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
< 
< 	/// @brief Set socket options.
< 	int (*setsockopt)(H3270 *hSession, int level, int optname, const void *optval, size_t optlen);
< 
< 	/// @brief Get socket options.
< 	int (*getsockopt)(H3270 *hSession, int level, int optname, void *optval, socklen_t *optlen);
< 
< 	/// @brief Get Peer certificate.
< 	///
< 	/// @return String with the peer certificate (release it with lib3270_free); NULL if not available.
< 	char * (*getcert)(const H3270 *hSession);
< 
< 	/// @brief Get CRL.
< 	///
< 	/// @return String with the CRL certificate (release it with lib3270_free); NULL if not available.
< 	char * (*getcrl)(const H3270 *hSession);
< 
< 	/// @brief Reset.
< 	///
< 	/// Clear network module state (used when URL changes).
< 	void (*reset)(H3270 *hSession);
< 
< } LIB3270_NET_MODULE;
< 
< /**
<  * @brief Activate the default (and insecure) network module.
<  *
<  */
< LIB3270_INTERNAL void lib3270_set_default_network_module(H3270 *hSession);
< 
< /**
<  * @brief Set network error message.
<  *
<  */
< LIB3270_INTERNAL void lib3270_set_network_error(H3270 *hSession,const char *summary, const char *fmt, ...);
< 
< /**
<  * @brief Connect to host, returns a connected socket.
<  *
<  * @param hSession	Disconnected TN3270 session.
<  * @param state		Pointer to network state context.
<  *
<  * @return The Socket number or -1 in case of failure.
<  *
<  */
< LIB3270_INTERNAL int	  lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state);
< 
< /**
<  * @brief Translate system socket receive error codes, show popup if needed.
<  *
<  * @param hSession TN3270 Session handle.
<  *
<  * @return Translated error code.
<  *
<  * @retval -EWOULDBLOCK	Next call would block.
<  * @retval -EAGAIN		Try again.
<  *
<  */
< LIB3270_INTERNAL int lib3270_socket_recv_failed(H3270 *hSession);
< 
< /**
<  * @brief Translate system socket send error codes, show popup if needed.
<  *
<  * @param hSession TN3270 Session handle.
<  *
<  * @return Translated error code.
<  *
<  */
< LIB3270_INTERNAL int lib3270_socket_send_failed(H3270 *hSession);
< 
< LIB3270_INTERNAL int lib3270_socket_set_non_blocking(H3270 *hSession, int sock, const unsigned char on);
< 
< /**
<  * @breif Select the network context from URL.
<  *
<  * @return Pointer to the hostname or NULL if failed (sets errno).
<  *
<  */
< LIB3270_INTERNAL char * lib3270_set_network_module_from_url(H3270 *hSession, char *url);
< 
< 
< /**
<  * @brief Select the default (unsecure) network context.
<  *
<  * @param hSession	TN3270 Session handle.
<  *
<  */
< LIB3270_INTERNAL void	  lib3270_set_default_network_module(H3270 *hSession);
---
> 		/// @brief Protocol name for URL.
> 		const char *name;
> 
> 		/// @brief Default service name.
> 		const char *service;
> 
> 		/// @brief Prepare to connect.
> 		///
> 		/// @param hSession	TN3270 session.
> 		/// @param state	Pointer to state message.
> 		///
> 		int (*init)(H3270 *hSession);
> 
> 		/// @brief Deinitialize network module.
> 		///
> 		/// @param hSession	TN3270 session.
> 		/// @param state	Pointer to state message.
> 		///
> 		void (*finalize)(H3270 *hSession);
> 
> 		/// @brief Connect to host.
> 		///
> 		/// @param hSession	TN3270 session.
> 		/// @param seconds	Seconds for timeout.
> 		/// @param state	Pointer to state message.
> 		///
> 		int (*connect)(H3270 *hSession, LIB3270_NETWORK_STATE *state);
> 
> 		/// @brief Disconnect from host.
> 		///
> 		/// @param hSession	TN3270 session.
> 		/// @param state	Pointer to state message.
> 		///
> 		int (*disconnect)(H3270 *hSession);
> 
> 		/// @brief Start TLS/SSL.
> 		///
> 		/// @param hSession	TN3270 session.
> 		///
> 		/// @return 0 if ok, error code if not.
> 		///
> 		/// @retval 0		TLS/SSL was negotiated.
> 		/// @retval ENOTSUP	No TLS/SSL support in the network module.
> 		///
> 		int (*start_tls)(H3270 *hSession);
> 
> 		/// @brief Send on network context.
> 		///
> 		/// @return Positive on data received, negative on error.
> 		///
> 		ssize_t (*send)(H3270 *hSession, const void *buffer, size_t length);
> 
> 		/// @brief Receive on network context.
> 		///
> 		/// @return Positive on data received, negative on error.
> 		///
> 		/// @retval -ENOTCONN		Not connected to host.
> 		/// @retval -EWOULDBLOCK	Next request will block.
> 		/// @retval -EAGAIN			Try again.
> 		///
> 		ssize_t (*recv)(H3270 *hSession, void *buf, size_t len);
> 
> 		/// @brief Add socket in poll list.
> 		void * (*add_poll)(H3270 *hSession, LIB3270_IO_FLAG flag, void(*call)(H3270 *, int, LIB3270_IO_FLAG, void *), void *userdata);
> 
> 		/// @brief Set non blocking mode.
> 		///
> 		/// @retval 0	Not connected or Success.
> 		/// @retval -1	Failed (popup was sent).
> 		int (*non_blocking)(H3270 *hSession, const unsigned char on);
> 
> 		/// @brief Check if the session is online.
> 		///
> 		/// @retval 0	The session is offline.
> 		int (*is_connected)(const H3270 *hSession);
> 
> 		/// @brief get socket name.
> 		///
> 		/// @return On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.
> 		///
> 		/// @retval 0	Success.
> 		/// @retval -1	Error (errno is set).
> 		int (*getsockname)(const H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen);
> 
> 		/// @brief Set socket options.
> 		int (*setsockopt)(H3270 *hSession, int level, int optname, const void *optval, size_t optlen);
> 
> 		/// @brief Get socket options.
> 		int (*getsockopt)(H3270 *hSession, int level, int optname, void *optval, socklen_t *optlen);
> 
> 		/// @brief Get Peer certificate.
> 		///
> 		/// @return String with the peer certificate (release it with lib3270_free); NULL if not available.
> 		char * (*getcert)(const H3270 *hSession);
> 
> 		/// @brief Get CRL.
> 		///
> 		/// @return String with the CRL certificate (release it with lib3270_free); NULL if not available.
> 		char * (*getcrl)(const H3270 *hSession);
> 
> 		/// @brief Reset.
> 		///
> 		/// Clear network module state (used when URL changes).
> 		void (*reset)(H3270 *hSession);
> 
> 	} LIB3270_NET_MODULE;
> 
> 	/**
> 	 * @brief Activate the default (and insecure) network module.
> 	 *
> 	 */
> 	LIB3270_INTERNAL void lib3270_set_default_network_module(H3270 *hSession);
> 
> 	/**
> 	 * @brief Connect to host, returns a connected socket.
> 	 *
> 	 * @param hSession	Disconnected TN3270 session.
> 	 * @param state		Pointer to network state context.
> 	 *
> 	 * @return The Socket number or -1 in case of failure.
> 	 *
> 	 */
> 	LIB3270_INTERNAL int	  lib3270_network_connect(H3270 *hSession, LIB3270_NETWORK_STATE *state);
> 
> 	/**
> 	 * @brief Translate system socket receive error codes, show popup if needed.
> 	 *
> 	 * @param hSession TN3270 Session handle.
> 	 *
> 	 * @return Translated error code.
> 	 *
> 	 * @retval -EWOULDBLOCK	Next call would block.
> 	 * @retval -EAGAIN		Try again.
> 	 *
> 	 */
> 	LIB3270_INTERNAL int lib3270_socket_recv_failed(H3270 *hSession);
> 
> 	/**
> 	 * @brief Translate system socket send error codes, show popup if needed.
> 	 *
> 	 * @param hSession TN3270 Session handle.
> 	 *
> 	 * @return Translated error code.
> 	 *
> 	 */
> 	LIB3270_INTERNAL int lib3270_socket_send_failed(H3270 *hSession);
> 
> 	LIB3270_INTERNAL int lib3270_socket_set_non_blocking(H3270 *hSession, int sock, const unsigned char on);
> 
> 	/**
> 	 * @breif Select the network context from URL.
> 	 *
> 	 * @return Pointer to the hostname or NULL if failed (sets errno).
> 	 *
> 	 */
> 	LIB3270_INTERNAL char * lib3270_set_network_module_from_url(H3270 *hSession, char *url);
> 
> 
> 	/**
> 	 * @brief Select the default (unsecure) network context.
> 	 *
> 	 * @param hSession	TN3270 Session handle.
> 	 *
> 	 */
> 	LIB3270_INTERNAL void	  lib3270_set_default_network_module(H3270 *hSession);
250c236
< LIB3270_INTERNAL void	  lib3270_set_libssl_network_module(H3270 *hSession);
---
> 	LIB3270_INTERNAL void	  lib3270_set_libssl_network_module(H3270 *hSession);
253c239
< LIB3270_INTERNAL int	  lib3270_activate_ssl_network_module(H3270 *hSession, int sock);
---
> 	LIB3270_INTERNAL int	  lib3270_activate_ssl_network_module(H3270 *hSession, int sock);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/popupsc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/popupsc.h
32,35c32,35
< /**
<  * @brief Popup calls
<  *
<  */
---
>  /**
>   * @brief Popup calls
>   *
>   */
37c37
< #include <lib3270.h>
---
>  #include <lib3270.h>
39c39
< #define popup_an_errno(hSession, errn, fmt, ...) lib3270_popup_an_errno(hSession, errn, fmt, __VA_ARGS__)
---
>  #define popup_an_errno(hSession, errn, fmt, ...) lib3270_popup_an_errno(hSession, errn, fmt, __VA_ARGS__)
41,43c41,43
< LIB3270_INTERNAL void popup_an_error(H3270 *session, const char *fmt, ...) LIB3270_GNUC_FORMAT(2,3);
< LIB3270_INTERNAL void popup_system_error(H3270 *session, const char *title, const char *message, const char *fmt, ...) LIB3270_GNUC_FORMAT(4,5);
< LIB3270_INTERNAL void popup_a_sockerr(H3270 *session, char *fmt, ...) LIB3270_GNUC_FORMAT(2,3);
---
>  LIB3270_INTERNAL void popup_an_error(H3270 *session, const char *fmt, ...) LIB3270_GNUC_FORMAT(2,3);
>  LIB3270_INTERNAL void popup_system_error(H3270 *session, const char *title, const char *message, const char *fmt, ...) LIB3270_GNUC_FORMAT(4,5);
>  LIB3270_INTERNAL void popup_a_sockerr(H3270 *session, char *fmt, ...) LIB3270_GNUC_FORMAT(2,3);
45,46c45,46
< LIB3270_INTERNAL void Error(H3270 *session, const char *fmt, ...);
< LIB3270_INTERNAL void Warning(H3270 *session, const char *fmt, ...);
---
>  LIB3270_INTERNAL void Error(H3270 *session, const char *fmt, ...);
>  LIB3270_INTERNAL void Warning(H3270 *session, const char *fmt, ...);
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include: proxyc.h
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include: resolverc.h
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/resources.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/resources.h
21,22d20
< #error Deprecated
< 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/shlobj_missing.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/shlobj_missing.h
3,4d2
< #error Deprecated
< 
8c6,7
< DECLARE_INTERFACE_(IShellLinkDataList, IUnknown) {
---
> DECLARE_INTERFACE_(IShellLinkDataList, IUnknown)
> {
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/statusc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/statusc.h
32a33,35
> // LIB3270_INTERNAL void 		status_timing(H3270 *session, struct timeval *t0, struct timeval *t1);
> // LIB3270_INTERNAL void 		status_untiming(H3270 *session);
> 
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/telnetc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/telnetc.h
60c60
< LIB3270_INTERNAL void trace_netdata(H3270 *hSession, char direction, unsigned const char *buf, int len);
---
> 	LIB3270_INTERNAL void trace_netdata(H3270 *hSession, char direction, unsigned const char *buf, int len);
62c62
< #define trace_netdata(direction, buf, len) /* */
---
> 	#define trace_netdata(direction, buf, len) /* */
64a65
> // LIB3270_INTERNAL int net_getsockname(const H3270 *h3270, void *buf, int *len);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/tn3270e.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/tn3270e.h
79,82c79,82
< 	unsigned char data_type;
< 	unsigned char request_flag;
< 	unsigned char response_flag;
< 	unsigned char seq_number[2]; /* actually, 16 bits, unaligned (!) */
---
>     unsigned char data_type;
>     unsigned char request_flag;
>     unsigned char response_flag;
>     unsigned char seq_number[2]; /* actually, 16 bits, unaligned (!) */
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/togglesc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/togglesc.h
35c35
< #include <lib3270/toggle.h>
---
>  #include <lib3270/toggle.h>
37,39c37,39
< LIB3270_INTERNAL void initialize_toggles(H3270 *session);
< LIB3270_INTERNAL void shutdown_toggles(H3270 *session);
< LIB3270_INTERNAL const LIB3270_TOGGLE toggle_descriptor[LIB3270_TOGGLE_COUNT+1];
---
>  LIB3270_INTERNAL void initialize_toggles(H3270 *session);
>  LIB3270_INTERNAL void shutdown_toggles(H3270 *session);
>  LIB3270_INTERNAL const LIB3270_TOGGLE toggle_descriptor[LIB3270_TOGGLE_COUNT+1];
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/trace_dsc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/trace_dsc.h
36c36
< const char *rcba(H3270 *session, int baddr);
---
> 	const char *rcba(H3270 *session, int baddr);
38,44c38,44
< void trace_ansi_disc(H3270 *hSession);
< void trace_char(H3270 *hSession, char c);
< void trace_ds(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
< void trace_ds_nb(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
< void trace_dsn(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
< void trace_ssl(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
< void trace_screen(H3270 *session);
---
> 	void trace_ansi_disc(H3270 *hSession);
> 	void trace_char(H3270 *hSession, char c);
> 	void trace_ds(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
> 	void trace_ds_nb(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
> 	void trace_dsn(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
> 	void trace_ssl(H3270 *hSession, const char *fmt, ...) LIB3270_GNUC_FORMAT(2, 3);
> 	void trace_screen(H3270 *session);
48,51c48,51
< #define trace_ds(session, format, args...)
< #define trace_dsn(session, format, args...)
< #define trace_ssl(session, format, args...)
< #define trace_ds_nb(session, format, args...)
---
> 	#define trace_ds(session, format, args...)
> 	#define trace_dsn(session, format, args...)
> 	#define trace_ssl(session, format, args...)
> 	#define trace_ds_nb(session, format, args...)
55,59c55,59
< #define trace_ds 0 &&
< #define trace_ds_nb 0 &&
< #define trace_dsn 0 &&
< #define trace_ssl 0 &&
< #define rcba 0 &&
---
> 	#define trace_ds 0 &&
> 	#define trace_ds_nb 0 &&
> 	#define trace_dsn 0 &&
> 	#define trace_ssl 0 &&
> 	#define rcba 0 &&
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/utf8c.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/utf8c.h
21d20
< /*
23,25c22,24
<    	ULFAIL_NOUTF8,		// not using UTF-8
< ULFAIL_INCOMPLETE,	// incomplete sequence
< ULFAIL_INVALID		// invalid sequence
---
>     	ULFAIL_NOUTF8,		/* not using UTF-8 */
> 	ULFAIL_INCOMPLETE,	/* incomplete sequence */
> 	ULFAIL_INVALID		/* invalid sequence */
27d25
< */
33,34c31,32
< // LIB3270_INTERNAL char *utf8_expand(unsigned char c);
< // LIB3270_INTERNAL unsigned char utf8_lookup(char *mbs, enum ulfail *fail, int *consumed);
---
>  LIB3270_INTERNAL char *utf8_expand(unsigned char c);
>  LIB3270_INTERNAL unsigned char utf8_lookup(char *mbs, enum ulfail *fail, int *consumed);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/w3miscc.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/w3miscc.h
19c19
< #include <config.h>
---
>  #include <config.h>
21,23c21,23
< #ifndef HAVE_INET_NTOP
< LIB3270_INTERNAL const char *inet_ntop(int af, const void *src, char *dst,socklen_t cnt);
< #endif // HAVE_INET_NTOP
---
>  #ifndef HAVE_INET_NTOP
> 	LIB3270_INTERNAL const char *inet_ntop(int af, const void *src, char *dst,socklen_t cnt);
>  #endif // HAVE_INET_NTOP
26,28c26,28
< #if defined(_WIN32)
< LIB3270_INTERNAL const char *win32_strerror(int e);
< #endif // WIN32
---
>  #if defined(_WIN32)
> 	LIB3270_INTERNAL const char *win32_strerror(int e);
>  #endif // WIN32
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/widec.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/widec.h
24c24
<                                       unsigned char c[]);
---
>     unsigned char c[]);
26c26
<                                         unsigned char c[]);
---
>     unsigned char c[]);
31c31
<                                    UErrorCode *err);
---
>     UErrorCode *err);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/windows/lib3270/os.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/windows/lib3270/os.h
30,35c30,35
< /**
<  * @brief TN3270 API windows definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 API windows definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
39c39
< #define LIB3270_OS_H_INCLUDED 1
---
> 	#define LIB3270_OS_H_INCLUDED 1
41,42c41,42
< #include <winsock2.h>
< #include <windows.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
44c44
< LIB3270_EXPORT void lib3270_autoptr_cleanup_HKEY(HKEY *hKey);
---
> 	LIB3270_EXPORT void lib3270_autoptr_cleanup_HKEY(HKEY *hKey);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/windows/lib3270/win32.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/windows/lib3270/win32.h
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,19
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
6,14c21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa está nomeado como lib3270.h e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
28,33c30,35
< /**
<  * @brief TN3270 WIN32 API definitions.
<  *
<  * @author perry.werneck@gmail.com
<  *
<  */
---
>  /**
>   * @brief TN3270 API windows definitions.
>   *
>   * @author perry.werneck@gmail.com
>   *
>   */
37c39
< #define LIB3270_WIN32_H_INCLUDED 1
---
> 	#define LIB3270_WIN32_H_INCLUDED 1
39,41c41,43
< #include <winsock2.h>
< #include <windows.h>
< #include <lib3270.h>
---
> 	#include <winsock2.h>
> 	#include <windows.h>
> 	#include <lib3270.h>
44c46
< extern "C" {
---
> 	extern "C" {
47,70c49,70
< LIB3270_EXPORT const char	* lib3270_win32_strerror(int e);
< LIB3270_EXPORT const char	* lib3270_win32_local_charset(void);
< LIB3270_EXPORT LSTATUS		  lib3270_win32_create_regkey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult);
< LIB3270_EXPORT DWORD		  lib3270_win32_get_dword(HKEY hKey, const char *name, DWORD def);
< LIB3270_EXPORT LSTATUS		  lib3270_win32_set_registry(LPCSTR module, LPCSTR keyname, LPCSTR value);
< LIB3270_EXPORT LSTATUS		  lib3270_win32_set_string(LPCSTR module, LPCSTR keyname, LPCSTR value);
< 
< /**
<  * @brief Translate windows error code.
<  *
<  * @param lasterror	Windows error code (from GetLastError()).
<  *
<  * @return String with translated message (release it with lib3270_free).
<  *
<  */
< LIB3270_EXPORT char 		* lib3270_win32_translate_error_code(int lasterror);
< 
< /**
<  * @brief Get lib3270's installation path.
<  *
<  * @return Full path for the lib3270 installation path (release it with lib3270_free)
<  *
<  */
< LIB3270_EXPORT char		* lib3270_get_installation_path();
---
> 	LIB3270_EXPORT const char	* lib3270_win32_strerror(int e);
> 	LIB3270_EXPORT const char	* lib3270_win32_local_charset(void);
> 	LIB3270_EXPORT LSTATUS		  lib3270_win32_create_regkey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult);
> 	LIB3270_EXPORT DWORD		  lib3270_win32_get_dword(HKEY hKey, const char *name, DWORD def);
> 
> 	/**
> 	 * @brief Translate windows error code.
> 	 *
> 	 * @param lasterror	Windows error code (from GetLastError()).
> 	 *
> 	 * @return String with translated message (release it with lib3270_free).
> 	 *
> 	 */
> 	LIB3270_EXPORT char 		* lib3270_win32_translate_error_code(int lasterror);
> 
> 	/**
> 	 * @brief Get lib3270's installation path.
> 	 *
> 	 * @return Full path for the lib3270 installation path (release it with lib3270_free)
> 	 *
> 	 */
> 	 LIB3270_EXPORT char		* lib3270_get_installation_path();
75c75
< }
---
> 	}
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/xl.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/include/xl.h
20d19
< /*
22,23c21,22
< unsigned n;
< unsigned short *data;
---
> 	unsigned n;
> 	unsigned short *data;
27d25
< */
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src: mkactions
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/mkfb/mkfb.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/mkfb/mkfb.c
40,41c40,41
< #include <windows.h>
< #define tmpfile w32_tmpfile
---
> 	#include <windows.h>
> 	#define tmpfile w32_tmpfile
43,44c43
< #define tmpfile osx_tmpfile
< #include <unistd.h>
---
> 	#define tmpfile osx_tmpfile
109c108
<     MODE_FT
---
> 	MODE_FT
111c110
<     0
---
> 	0
113c112
<     |
---
> |
115c114
<     MODE_TRACE
---
> 	MODE_TRACE
117c116
<     0
---
> 	0
119c118
<     |
---
> |
121c120
<     MODE_MENUS
---
> 	MODE_MENUS
123c122
<     0
---
> 	0
125c124
<     |
---
> |
127c126
<     MODE_ANSI
---
> 	MODE_ANSI
129c128
<     0
---
> 	0
131c130
<     |
---
> |
133c132
<     MODE_KEYPAD
---
> 	MODE_KEYPAD
135c134
<     0
---
> 	0
137c136
<     |
---
> |
139c138
<     MODE_APL
---
> 	MODE_APL
141c140
<     0
---
> 	0
143c142
<     |
---
> |
145c144
<     MODE_PRINTER
---
> 	MODE_PRINTER
147c146
<     0
---
> 	0
149c148
<     |
---
> |
151c150
<     MODE_SCRIPT
---
> 	MODE_SCRIPT
153c152
<     0
---
> 	0
155c154
<     |
---
> |
157c156
<     MODE_DBCS
---
> 	MODE_DBCS
159c158
<     0
---
> 	0
161c160
<     |
---
> |
163c162
<     MODE__WIN32
---
> 	MODE__WIN32
165c164
<     0
---
> 	0
175c174,175
< usage(void) {
---
> usage(void)
> {
181c181,182
< main(int argc, char *argv[]) {
---
> main(int argc, char *argv[])
> {
200,203c201,204
< 		cmode = 1;
< 		is_defined |= MODE_STANDALONE;
< 		argc--;
< 		argv++;
---
> 	    cmode = 1;
> 	    is_defined |= MODE_STANDALONE;
> 	    argc--;
> 	    argv++;
206c207
< 	case 1:
---
> 	    case 1:
208,209c209,210
< 	case 2:
< 	case 3:
---
> 	    case 2:
> 	    case 3:
218c219
< 	default:
---
> 	    default:
242c243
< 		        (!strncmp(s, "x3270.", 6) || !strncmp(s, "x3270*", 6))) {
---
> 		    (!strncmp(s, "x3270.", 6) || !strncmp(s, "x3270*", 6))) {
259c260
< 			        !(ifnd = strncmp(s, "#ifndef ", 8))) {
---
> 			    !(ifnd = strncmp(s, "#ifndef ", 8))) {
264,265c265,266
< 					        "%s, line %d: Stack overflow\n",
< 					        filename, lno);
---
> 					    "%s, line %d: Stack overflow\n",
> 					    filename, lno);
286,287c287,288
< 					        "%s, line %d: Unknown condition\n",
< 					        filename, lno);
---
> 					    "%s, line %d: Unknown condition\n",
> 					    filename, lno);
298,299c299,300
< 					        "%s, line %d: Missing #if[n]def\n",
< 					        filename, lno);
---
> 					    "%s, line %d: Missing #if[n]def\n",
> 					    filename, lno);
308,309c309,310
< 					        "%s, line %d: Missing #if[n]def\n",
< 					        filename, lno);
---
> 					    "%s, line %d: Missing #if[n]def\n",
> 					    filename, lno);
315,316c316,317
< 				        "%s, line %d: Unrecognized # directive\n",
< 				        filename, lno);
---
> 				    "%s, line %d: Unrecognized # directive\n",
> 				    filename, lno);
384c385
< 	        filename);
---
> 	    filename);
448,449c449,450
< 			case ' ':
< 			case '\t':
---
> 			    case ' ':
> 			    case '\t':
451c452
< 			case '#':
---
> 			    case '#':
461c462
< 			case '\\':
---
> 			    case '\\':
466,475c467,476
< 					switch ((c = *s++)) {
< 					case 't':
< 						c = '\t';
< 						break;
< 					case 'n':
< 						c = '\n';
< 						break;
< 					default:
< 						break;
< 					}
---
> 				    switch ((c = *s++)) {
> 				    case 't':
> 					c = '\t';
> 					break;
> 				    case 'n':
> 					c = '\n';
> 					break;
> 				    default:
> 					break;
> 				    }
477,478c478,479
< 			/* else fall through */
< 			default:
---
> 				/* else fall through */
> 			    default:
512,518c513
< 		int fd = creat(argv[2], S_IWUSR | S_IRUSR);
< 		if(fd < 0) {
< 			perror(argv[2]);
< 			exit(1);
< 		}
< 
< 		o = fdopen(fd,"w");
---
> 		o = fopen(argv[2], "w");
523d517
< 
550,551c544,545
< 			        aix[i],
< 			        xlno[i]);
---
> 					aix[i],
> 			    xlno[i]);
584c578,579
< emit(FILE *t, int ix, char c) {
---
> emit(FILE *t, int ix, char c)
> {
594c589,590
< FILE * w32_tmpfile( void ) {
---
> FILE * w32_tmpfile( void )
> {
614c610,611
< 	do {
---
> 	do
> 	{
620c617,618
< 	} while (fd < 0 && errno == EEXIST);
---
> 	}
> 	while (fd < 0 && errno == EEXIST);
626c624,625
< 	if (file == NULL) {
---
> 	if (file == NULL)
> 	{
632c631
< done:
---
> 	done:
638c637,638
< FILE * osx_tmpfile( void ) {
---
> FILE * osx_tmpfile( void )
> {
642c642,643
< 	do {
---
> 	do
> 	{
651c652,653
< 	if (file == NULL) {
---
> 	if (file == NULL)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/default/main.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/default/main.c
30,33c30,33
< /**
<  * @brief Default networking methods.
<  *
<  */
---
>  /**
>   * @brief Default networking methods.
>   *
>   */
35c35
< #include "private.h"
---
>  #include "private.h"
37c37
< static void unsecure_network_finalize(H3270 *hSession) {
---
>  static void unsecure_network_finalize(H3270 *hSession) {
46c46
< }
---
>  }
48c48
< static int unsecure_network_disconnect(H3270 *hSession) {
---
>  static int unsecure_network_disconnect(H3270 *hSession) {
63c63
< }
---
>  }
65,66c65,66
< static void unsecure_network_reset(H3270 GNUC_UNUSED(*hSession)) {
< }
---
>  static void unsecure_network_reset(H3270 GNUC_UNUSED(*hSession)) {
>  }
68c68
< ssize_t unsecure_network_send(H3270 *hSession, const void *buffer, size_t length) {
---
>  ssize_t unsecure_network_send(H3270 *hSession, const void *buffer, size_t length) {
77c77
< }
---
>  }
79c79
< static ssize_t unsecure_network_recv(H3270 *hSession, void *buf, size_t len) {
---
>  static ssize_t unsecure_network_recv(H3270 *hSession, void *buf, size_t len) {
95,98d94
< static int unsecure_network_getpeername(const H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen) {
< 	return getpeername(hSession->network.context->sock, addr, addrlen);
< }
< 
173d168
< 		.getpeername = unsecure_network_getpeername,
179c174
< 	debug("%s",__FUNCTION__);
---
>  	debug("%s",__FUNCTION__);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/default/private.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/default/private.h
32c32
< #define LIB3270_DEFAULT_MODULE_PRIVATE_H_INCLUDED
---
> 	#define LIB3270_DEFAULT_MODULE_PRIVATE_H_INCLUDED
34,37c34,37
< #include <config.h>
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <internals.h>
---
> 	#include <config.h>
> 	#include <lib3270.h>
>  	#include <lib3270/log.h>
>  	#include <internals.h>
39,41c39,41
< struct _lib3270_net_context {
< 	int sock;
< };
---
> 	struct _lib3270_net_context {
> 		int sock;
> 	};
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/context.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/context.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,19
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
6,14c21
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa está nomeado como - e possui - linhas de código.
16,20d22
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /*
25a28
>  *
37c40,41
< #include <config.h>
---
> #include "private.h"
> 
39,40d42
< 	#include <winsock2.h>
< 	#include <windows.h>
44,45d45
< #include "private.h"
< 
50c50
< #define SSL_ST_OK 3
---
> 	#define SSL_ST_OK 3
54c54
< #define INFO_CONST const
---
> 	#define INFO_CONST const
56c56
< #define INFO_CONST
---
> 	#define INFO_CONST
65c65,66
< static void info_callback(INFO_CONST SSL *s, int where, int ret) {
---
> static void info_callback(INFO_CONST SSL *s, int where, int ret)
> {
69c70,73
< 	switch(where) {
---
> 	debug("************************ %s where=%d",__FUNCTION__,where);
> 
> 	switch(where)
> 	{
78c82,83
< 		if (ret == 0) {
---
> 		if (ret == 0)
> 		{
81c86,88
< 		} else if (ret < 0) {
---
> 		}
> 		else if (ret < 0)
> 		{
87c94,95
< 			if(e != 0) {
---
> 			if(e != 0)
> 			{
92c100,101
< 			else if (GetLastError() != 0) {
---
> 			else if (GetLastError() != 0)
> 			{
96c105,106
< 			else if (errno != 0) {
---
> 			else if (errno != 0)
> 			{
100c110,111
< 			else {
---
> 			else
> 			{
105,109c116,120
< 			      ret,
< 			      err_buf,
< 			      SSL_state_string_long(s),
< 			      SSL_alert_type_string_long(ret)
< 			     );
---
> 							ret,
> 							err_buf,
> 							SSL_state_string_long(s),
> 							SSL_alert_type_string_long(ret)
> 						);
115,119c126,130
< 			          ret,
< 			          err_buf,
< 			          SSL_state_string_long(s),
< 			          SSL_alert_type_string_long(ret)
< 			         );
---
> 							ret,
> 							err_buf,
> 							SSL_state_string_long(s),
> 							SSL_alert_type_string_long(ret)
> 						);
129c140,141
< 	if(where & SSL_CB_EXIT) {
---
> 	if(where & SSL_CB_EXIT)
> 	{
133c145,146
< 	if(where & SSL_CB_ALERT) {
---
> 	if(where & SSL_CB_ALERT)
> 	{
138c151,152
< 	if(where & SSL_CB_HANDSHAKE_DONE) {
---
> 	if(where & SSL_CB_HANDSHAKE_DONE)
> 	{
154,227c168
< 	SSL_load_error_strings();
< 
< #if !defined(OPENSSL_FIPS)
< 
< 	lib3270_write_log(
< 		hSession,
< 		"openssl",
< 		"Initializing %s\n",
< 		SSLeay_version(SSLEAY_VERSION)
< 	);
< 
< #elif defined(_WIN32)
< 		{
< 			lib3270_auto_cleanup(HKEY) hKey = 0;
< 			DWORD disp = 0;
< 			LSTATUS	rc = RegCreateKeyEx(
< 				HKEY_LOCAL_MACHINE,
< 				"Software\\" LIB3270_STRINGIZE_VALUE_OF(PRODUCT_NAME) "\\tweaks",
< 				0,
< 				NULL,
< 				REG_OPTION_NON_VOLATILE,
< 				KEY_QUERY_VALUE|KEY_READ,
< 				NULL,
< 				&hKey,
< 				&disp);
< 
< 			if(rc == ERROR_SUCCESS) {
< 				DWORD mode = lib3270_win32_get_dword(hKey, "fips_mode", FIPS_mode());
< 				if(FIPS_mode_set(mode) != 1) {
< 
< 					SSL_load_error_strings();
< 
< 					char err_buff[1024];
< 					memset(err_buff,0,sizeof(err_buff));
< 					(void) ERR_error_string_n(ERR_get_error(), err_buff, 1023);
< 
< 					lib3270_write_log(
< 						hSession,
< 						"openssl",
< 						"Cant set FIPS mode to %u: %s\n",
< 						(unsigned int) mode,
< 						err_buff
< 					);
< 
< 				} else {
< 					lib3270_write_log(
< 						hSession,
< 						"openssl",
< 						"FIPS mode set to %u\n",
< 						(unsigned int) mode
< 					);
< 				}
< 			}
< 
< 			lib3270_write_log(
< 				hSession,
< 				"openssl",
< 				"Initializing windows %s using fips mode %u.\n",
< 				SSLeay_version(SSLEAY_VERSION),
< 				FIPS_mode()
< 			);
< 
< 		}
< #else
< 
< 	lib3270_write_log(
< 		hSession,
< 		"openssl",
< 		"Initializing %s %s FIPS.\n",
< 		SSLeay_version(SSLEAY_VERSION),
< 		(FIPS_mode() ? "with" : "without" )
< 	);
< 
< #endif
---
> 	trace_ssl(hSession,"Initializing SSL context.\n");
228a170
> 	SSL_load_error_strings();
232c174,175
< 	if(context == NULL) {
---
> 	if(context == NULL)
> 	{
267,354d209
< 
< #ifdef _WIN32
< 	{
< 		// Load certs
< 		// https://stackoverflow.com/questions/9507184/can-openssl-on-windows-use-the-system-certificate-store
< 		X509_STORE * store = SSL_CTX_get_cert_store(context);
< 
< 		lib3270_autoptr(char) certpath = lib3270_build_data_filename("certs","*.der",NULL);
< 
< 		trace_ssl(hSession,"Loading SSL certs from %s\n",certpath);
< 
< 		WIN32_FIND_DATA ffd;
< 		HANDLE hFind = FindFirstFile(certpath, &ffd);
< 
< 		if(hFind == INVALID_HANDLE_VALUE)
< 		{
< 			static const LIB3270_SSL_MESSAGE message = {
< 				.type = LIB3270_NOTIFY_SECURE,
< 				.icon = "dialog-error",
< 				.summary = N_( "Cant open custom certificate directory." ),
< 			};
< 
< 			hSession->ssl.message = &message;
< 
< 			trace_ssl(hSession, _( "Can't open \"%s\" (The Windows error code was %ld)" ), certpath, (long) GetLastError());
< 		}
< 		else
< 		{
< 			do
< 			{
< 				char * filename = lib3270_build_data_filename("certs", ffd.cFileName, NULL);
< 
< 				debug("Loading \"%s\"",filename);
< 
< 				FILE *fp = fopen(filename,"r");
< 				if(!fp) {
< 
< 					trace_ssl(hSession, _( "Can't open \"%s\": %s" ), filename, strerror(errno));
< 
< 				}
< 				else
< 				{
< 					X509 * cert = d2i_X509_fp(fp, NULL);
< 
< 					if(!cert)
< 					{
< 						static const LIB3270_SSL_MESSAGE message = {
< 							.type = LIB3270_NOTIFY_SECURE,
< 							.icon = "dialog-error",
< 							.summary = N_( "Cant read custom certificate file." ),
< 						};
< 
< 						hSession->ssl.message = &message;
< 						hSession->network.context->state.error = ERR_get_error();
< 
< 						trace_ssl(hSession, _( "Can't read \"%s\": %s" ), filename, ERR_lib_error_string(hSession->ssl.error));
< 					}
< 					else
< 					{
< 
< 						if(X509_STORE_add_cert(store, cert) != 1)
< 						{
< 							static const LIB3270_SSL_MESSAGE message = {
< 								.type = LIB3270_NOTIFY_SECURE,
< 								.icon = "dialog-error",
< 								.summary = N_( "Cant load custom certificate file." ),
< 							};
< 
< 							hSession->ssl.message = &message;
< 							hSession->network.context->state.error = ERR_get_error();
< 
< 							trace_ssl(hSession, _( "Can't load \"%s\": %s" ), filename, ERR_lib_error_string(hSession->ssl.error));
< 						}
< 
< 						X509_free(cert);
< 					}
< 
< 					fclose(fp);
< 				}
< 
< 				lib3270_free(filename);
< 
< 			}
< 			while (FindNextFile(hFind, &ffd) != 0);
< 
< 		}
< 	}
< #endif // _WIN32
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/crl.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/crl.c
30c30
< /// @brief Get CRL info from X509 cert.
---
> /// @brief Get CRL infro from X509 cert.
38d37
< #include <utilc.h>
72c71,72
< 			if(uri && gtype == GEN_URI) {
---
> 			if(uri && gtype == GEN_URI)
> 			{
81,87c81,82
< 				if(data && length > 0) {
< 					lib3270_autoptr(char) uri = lib3270_malloc( ((size_t) length) + 1);
< 					strncpy(uri,(char *) data, (size_t) length);
< 
< 					lib3270_autoptr(char) unescaped = lib3270_unescape(uri);
< 					lib3270_string_array_append(uris,unescaped);
< 				}
---
> 				if(data && length > 0)
> 					lib3270_string_array_append_with_length(uris,(char *) data, (size_t) length);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/main.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/main.c
30,33c30,35
< /**
<  * @brief OpenSSL based networking methods.
<  *
<  */
---
>  /**
>   * @brief OpenSSL based networking methods.
>   *
>   */
> 
>  #include "private.h"
35,36d36
< #include "private.h"
< #include <openssl/asn1.h>
98c98
< 		lib3270_set_network_error(
---
> 		lib3270_popup_dialog(
100,102c100,104
< 		    _("Disconnected from host."),
< 		    "%s",
< 		    _("The secure connection has been closed cleanly.")
---
> 			LIB3270_NOTIFY_ERROR,
> 			NULL,
> 			_("Disconnected from host."),
> 			"%s",
> 			_("The secure connection has been closed cleanly.")
104d105
< 
121,126c122,129
< 	lib3270_set_network_error(
< 		hSession,
< 		_("Error writing to host."),
< 		_("The SSL error message was %s"),
< 		err_buf
< 	);
---
> 	lib3270_autoptr(char) body = lib3270_strdup_printf(_("The SSL error message was %s"), err_buf);
> 
> 	LIB3270_POPUP popup = {
> 		.summary = _("Error writing to host"),
> 		.body = body
> 	};
> 
> 	lib3270_popup(hSession,&popup,0);
146c149
< 		lib3270_set_network_error(
---
> 		lib3270_popup_dialog(
148,150c151,155
< 		    _("Disconnected from host."),
< 		    "%s",
< 		    _("The secure connection has been closed cleanly.")
---
> 			LIB3270_NOTIFY_ERROR,
> 			NULL,
> 			_("Disconnected from host."),
> 			"%s",
> 			_("The secure connection has been closed cleanly.")
168,173c173,180
< 	lib3270_set_network_error(
< 		hSession,
< 		_("Error reading from host"),
< 		_("The SSL error message was %s"),
< 		err_buf
< 	);
---
> 	lib3270_autoptr(char) body = lib3270_strdup_printf(_("The SSL error message was %s"), err_buf);
> 
> 	LIB3270_POPUP popup = {
> 		.summary = _("Error reading from host"),
> 		.body = body
> 	};
> 
> 	lib3270_popup(hSession,&popup,0);
182,185d188
< static int openssl_network_getpeername(const H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen) {
< 	return getpeername(hSession->network.context->sock, addr, addrlen);
< }
< 
267,268d269
< 	debug("%s",__FUNCTION__);
< 
290,296c291,295
< #if OPENSSL_VERSION_NUMBER < 0x10100000L
< 		const ASN1_TIME * next_update = X509_CRL_get_nextUpdate(context->crl.cert);
< #else
< 		const ASN1_TIME * next_update = X509_CRL_get0_nextUpdate(context->crl.cert);
< #endif
< 
< 		if(X509_cmp_current_time(next_update) == 1) {
---
> 		#if OPENSSL_VERSION_NUMBER < 0x10100000L
> 			const ASN1_TIME * next_update = X509_CRL_get_nextUpdate(context->crl.cert);
> 		#else
> 			const ASN1_TIME * next_update = X509_CRL_get0_nextUpdate(context->crl.cert);
> 		#endif
298,299c297,298
< 			trace_ssl(hSession,"CRL is valid\n");
< 			/*
---
> 		if(X509_cmp_current_time(next_update) == 1)
> 		{
301c300,301
< 			if(ASN1_TIME_diff(&day, &sec, NULL, next_update)) {
---
> 			if(ASN1_TIME_diff(&day, &sec, NULL, next_update))
> 			{
303c303,305
< 			} else {
---
> 			}
> 			else
> 			{
307d308
< 			*/
309c310,312
< 		} else {
---
> 		}
> 		else
> 		{
346d348
< 		.getpeername = openssl_network_getpeername,
354,359c356
< 	if(hSession->network.module == &module) {
< 		debug("%s - Network module is already set",__FUNCTION__);
< 		return;
< 	}
< 
< 	debug("%s - Setting network module",__FUNCTION__);
---
>  	debug("%s",__FUNCTION__);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/messages.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/messages.c
49d48
< 				.name = "X509_V_OK",
60d58
< 				.name = "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT",
71d68
< 				.name = "X509_V_ERR_UNABLE_TO_GET_CRL",
76a74
> 				.name = "X509UnableToGetCRL",
87d84
< 				.name = "X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE",
98d94
< 				.name = "X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE",
109d104
< 				.name = "X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
120d114
< 				.name = "X509_V_ERR_CERT_SIGNATURE_FAILURE",
131d124
< 				.name = "X509_V_ERR_CRL_SIGNATURE_FAILURE",
142d134
< 				.name = "X509_V_ERR_CERT_NOT_YET_VALID",
153d144
< 				.name = "X509_V_ERR_CERT_HAS_EXPIRED",
164d154
< 				.name = "X509_V_ERR_CRL_NOT_YET_VALID",
175,176c165
< 				.name = "X509_V_ERR_CRL_HAS_EXPIRED",
< #ifdef SSL_ENABLE_CRL_EXPIRATION_CHECK
---
> 	#ifdef SSL_ENABLE_CRL_EXPIRATION_CHECK
178c167
< #else
---
> 	#else
180c169
< #endif // SSL_ENABLE_CRL_EXPIRATION_CHECK
---
> 	#endif // SSL_ENABLE_CRL_EXPIRATION_CHECK
190d178
< 				.name = "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD",
201d188
< 				.name = "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD",
212d198
< 				.name = "X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD",
223d208
< 				.name = "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD",
234d218
< 				.name = "X509_V_ERR_OUT_OF_MEM",
245,246d228
< 				.name = "X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT",
< #ifdef SSL_ENABLE_SELF_SIGNED_CERT_CHECK
248,250d229
< #else
< 				.type = LIB3270_NOTIFY_SECURE,
< #endif // SSL_ENABLE_SELF_SIGNED_CERT_CHECK
253d231
< 				.label = N_( "Continue" ),
261,264c239
< 				.name = "X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN",
< #ifdef SSL_ENABLE_SELF_SIGNED_CERT_CHECK
< 				.type = LIB3270_NOTIFY_INFO,
< #else
---
> 	#ifdef SSL_ENABLE_SELF_SIGNED_CERT_CHECK
266c241,244
< #endif // SSL_ENABLE_SELF_SIGNED_CERT_CHECK
---
> 	#else
> 				.type = LIB3270_NOTIFY_INFO,
> 	#endif // SSL_ENABLE_SELF_SIGNED_CERT_CHECK
> 				.name = "SelfSignedCertInChain",
277d254
< 				.name = "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
288d264
< 				.name = "X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE",
299d274
< 				.name = "X509_V_ERR_CERT_REVOKED",
310d284
< 				.name = "X509_V_ERR_INVALID_CA",
321d294
< 				.name = "X509_V_ERR_PATH_LENGTH_EXCEEDED",
332d304
< 				.name = "X509_V_ERR_INVALID_PURPOSE",
343d314
< 				.name = "X509_V_ERR_CERT_UNTRUSTED",
354d324
< 				.name = "X509_V_ERR_CERT_REJECTED",
365d334
< 				.name = "X509_V_ERR_SUBJECT_ISSUER_MISMATCH",
376d344
< 				.name = "X509_V_ERR_AKID_SKID_MISMATCH",
387d354
< 				.name = "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH",
398d364
< 				.name = "X509_V_ERR_KEYUSAGE_NO_CERTSIGN",
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/private.h lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/private.h
32c32
< #define LIB3270_OPENSSL_MODULE_PRIVATE_H_INCLUDED
---
> 	#define LIB3270_OPENSSL_MODULE_PRIVATE_H_INCLUDED
34c34
< #include <config.h>
---
> 	#include <config.h>
36,107c36,108
< #ifdef _WIN32
< #include <winsock2.h>
< #include <windows.h>
< #else
< #include <fcntl.h>
< #endif // _WIN32
< 
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <lib3270/popup.h>
< #include <lib3270/os.h>
< #include <array.h>
< #include <internals.h>
< #include <networking.h>
< #include <trace_dsc.h>
< 
< #include <openssl/ssl.h>
< #include <openssl/x509.h>
< #include <openssl/x509v3.h>
< #include <openssl/err.h>
< 
< struct _lib3270_network_popup {
< 	LIB3270_POPUP_HEAD
< 
< 	long                      id;
< 	const char              * icon;             ///< @brief Icon name from https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
< };
< 
< struct _lib3270_net_context {
< 
< 	int sock;						///< @brief Session socket.
< 
< 	SSL * con;						///< @brief SSL Connection handle.
< 
< 	struct {
< 		char			  download;	///< @brief Non zero to download CRL.
< 		char			* prefer;	///< @brief Prefered protocol for CRL.
< 		char			* url;		///< @brief URL for CRL download.
< 		X509_CRL 		* cert;		///< @brief Loaded CRL (can be null).
< 	} crl;
< 
< 	struct {
< 		unsigned long	  error;				///< @brief The last OpenSSL error code.
< 		const char 		* message;				///< @brief The last OpenSSL state message.
< 		const char		* alert;				///< @brief The last OpenSSL alert message.
< 	} state;
< 
< };
< 
< /// @brief X509 auto-cleanup.
< static inline void lib3270_autoptr_cleanup_X509(X509 **ptr) {
< 	if(*ptr)
< 		X509_free(*ptr);
< 	*ptr = NULL;
< }
< 
< /// @brief Dist points auto-cleanup.
< static inline void lib3270_autoptr_cleanup_CRL_DIST_POINTS(CRL_DIST_POINTS **ptr) {
< 	if(*ptr)
< 		CRL_DIST_POINTS_free(*ptr);
< 	*ptr = NULL;
< }
< 
< static inline void lib3270_autoptr_cleanup_BIO(BIO **ptr) {
< 	if(*ptr)
< 		BIO_free_all(*ptr);
< 	*ptr = NULL;
< }
< 
< LIB3270_INTERNAL SSL_CTX * lib3270_openssl_get_context(H3270 *hSession);
< LIB3270_INTERNAL int lib3270_openssl_get_ex_index(H3270 *hSession);
< LIB3270_INTERNAL const LIB3270_NETWORK_POPUP * lib3270_openssl_get_popup_from_error_code(long id);
---
> 	#ifdef _WIN32
> 		#include <winsock2.h>
> 		#include <windows.h>
> 	#else
> 		#include <fcntl.h>
> 	#endif // _WIN32
> 
> 	#include <lib3270.h>
>  	#include <lib3270/log.h>
>  	#include <lib3270/popup.h>
> 	#include <lib3270/os.h>
>  	#include <array.h>
>  	#include <internals.h>
> 	#include <networking.h>
> 	#include <trace_dsc.h>
> 
> 	#include <openssl/ssl.h>
> 	#include <openssl/x509.h>
> 	#include <openssl/x509v3.h>
> 	#include <openssl/err.h>
> 
> 	struct _lib3270_network_popup {
> 		LIB3270_POPUP_HEAD
> 
> 		long                      id;
> 		const char              * icon;             ///< @brief Icon name from https://specifications.freedesktop.org/icon-naming-spec/icon-naming-spec-latest.html
> 	};
> 
> 	struct _lib3270_net_context {
> 
> 		int sock;						///< @brief Session socket.
> 
> 		SSL * con;						///< @brief SSL Connection handle.
> 
> 		struct {
> 			char			  download;	///< @brief Non zero to download CRL.
> 			char			* prefer;	///< @brief Prefered protocol for CRL.
> 			char			* url;		///< @brief URL for CRL download.
> 			X509_CRL 		* cert;		///< @brief Loaded CRL (can be null).
> 		} crl;
> 
> 		struct {
> 			unsigned long	  error;				///< @brief The last OpenSSL error code.
> 			const char 		* message;				///< @brief The last OpenSSL state message.
> 			const char		* alert;				///< @brief The last OpenSSL alert message.
> 		} state;
> 
> 	};
> 
> 	/// @brief X509 auto-cleanup.
> 	static inline void lib3270_autoptr_cleanup_X509(X509 **ptr) {
> 		if(*ptr)
> 			X509_free(*ptr);
> 		*ptr = NULL;
> 	}
> 
> 	/// @brief Dist points auto-cleanup.
> 	static inline void lib3270_autoptr_cleanup_CRL_DIST_POINTS(CRL_DIST_POINTS **ptr)
> 	{
> 		if(*ptr)
> 			CRL_DIST_POINTS_free(*ptr);
> 		*ptr = NULL;
> 	}
> 
> 	static inline void lib3270_autoptr_cleanup_BIO(BIO **ptr) {
> 		if(*ptr)
> 			BIO_free_all(*ptr);
> 		*ptr = NULL;
> 	}
> 
> 	LIB3270_INTERNAL SSL_CTX * lib3270_openssl_get_context(H3270 *hSession);
> 	LIB3270_INTERNAL int lib3270_openssl_get_ex_index(H3270 *hSession);
> 	LIB3270_INTERNAL const LIB3270_NETWORK_POPUP * lib3270_openssl_get_popup_from_error_code(long id);
109c110
< LIB3270_INTERNAL int openssl_network_start_tls(H3270 *hSession);
---
> 	LIB3270_INTERNAL int openssl_network_start_tls(H3270 *hSession);
111c112
< LIB3270_INTERNAL LIB3270_STRING_ARRAY * lib3270_openssl_get_crls_from_peer(H3270 *hSession, X509 *cert);
---
> 	LIB3270_INTERNAL LIB3270_STRING_ARRAY * lib3270_openssl_get_crls_from_peer(H3270 *hSession, X509 *cert);
113,114c114,115
< LIB3270_INTERNAL const LIB3270_SSL_MESSAGE * lib3270_openssl_message_from_id(long id);
< LIB3270_INTERNAL void lib3270_openssl_crl_free(LIB3270_NET_CONTEXT *context);
---
> 	LIB3270_INTERNAL const LIB3270_SSL_MESSAGE * lib3270_openssl_message_from_id(long id);
> 	LIB3270_INTERNAL void lib3270_openssl_crl_free(LIB3270_NET_CONTEXT *context);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/start.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/openssl/start.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,4
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software PW3270, desenvolvido com base nos códigos fontes do WC3270  e  X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
6,9c6
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
11,14c8,10
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  ',  conforme  publicado  pela
>  * Free Software Foundation.
16,21c12,26
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
<  */
< 
< /**
<  * @brief Negotiate OpenSSL session.
---
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
>  *
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
>  *
>  * Este programa está nomeado como openssl.c e possui - linhas de código.
>  *
>  * Contatos:
>  *
>  * perry.werneck@gmail.com	(Alexandre Perry de Souza Werneck)
>  * erico.mendonca@gmail.com	(Erico Mascarenhas de Mendonça)
25,27c30,36
< #include "private.h"
< #include <lib3270/properties.h>
< #include <utilc.h>
---
>  /**
>   * @brief Negotiate OpenSSL session.
>   *
>   */
> 
>  #include "private.h"
>  #include <lib3270/properties.h>
29c38
< static int import_crl(H3270 *hSession, SSL_CTX * ssl_ctx, LIB3270_NET_CONTEXT * context, const char *url) {
---
>  static int import_crl(H3270 *hSession, SSL_CTX * ssl_ctx, LIB3270_NET_CONTEXT * context, const char *url) {
97c106,107
< 		return 0;
---
> 	} else {
> 		trace_ssl(hSession,"CRL was not added to context cert store\n");
100,102c110
< 	trace_ssl(hSession,"CRL was not added to context cert store\n");
< 
< 	return -1;
---
> 	return 0;
104c112
< }
---
>  }
106c114
< static int download_crl_from_peer(H3270 *hSession, SSL_CTX * ctx_context, LIB3270_NET_CONTEXT * context, X509 *peer) {
---
>  static void download_crl_from_peer(H3270 *hSession, SSL_CTX * ctx_context, LIB3270_NET_CONTEXT * context, X509 *peer) {
111c119
< 		return -1;
---
> 		return;
116c124
< 		return -1;
---
> 		return;
129c137
< 				return 0;
---
> 				return;
133c141
< 		return -1;
---
> 		return;
146a155
> 		debug("Trying %s",uris->str[ix]);
149c158
< 			return 0;
---
> 			return;
162c171
< 			return 0;
---
> 			return;
167,187c176
< 	return -1;
< 
< }
< 
< int x509_store_ctx_error_callback(int ok, X509_STORE_CTX GNUC_UNUSED(*ctx)) {
< 	debug("%s(%d)",__FUNCTION__,ok);
< 
< 	/*
< 	  55     {
< 	  56         if (!ok) {
< 	  57             Category::getInstance("OpenSSL").error(
< 	  58                 "path validation failure at depth(%d): %s",
< 	  59                 X509_STORE_CTX_get_error_depth(ctx),
< 	  60                 X509_verify_cert_error_string(X509_STORE_CTX_get_error(ctx))
< 	  61                 );
< 	  62         }
< 	  63         return ok;
< 	  64     }
< 	*/
< 	return ok;
< }
---
>  }
189c178
< int openssl_network_start_tls(H3270 *hSession) {
---
>  int openssl_network_start_tls(H3270 *hSession) {
192,200c181
< 	if(!ctx_context) {
< 
< 		if(!hSession->ssl.message) {
< 			static const LIB3270_SSL_MESSAGE message = {
< 				.type = LIB3270_NOTIFY_SECURE,
< 				.summary = N_( "Cant get SSL context for current connection." )
< 			};
< 			hSession->ssl.message = &message;
< 		}
---
> 	if(!ctx_context)
202d182
< 	}
209c189,190
< 	if(context->con == NULL) {
---
> 	if(context->con == NULL)
> 	{
213a195
> 
220,221c202
< //	SSL_set_verify(context->con, SSL_VERIFY_PEER, NULL);
< 	SSL_set_verify(context->con, SSL_VERIFY_NONE, NULL);
---
> 	SSL_set_verify(context->con, 0, NULL);
223c204,205
< 	if(SSL_set_fd(context->con, context->sock) != 1) {
---
> 	if(SSL_set_fd(context->con, context->sock) != 1)
> 	{
241,242c223,224
< 	if (rv != 1) {
< 
---
> 	if (rv != 1)
> 	{
288c270,271
< 		if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 		if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE))
> 		{
318,319d300
< 		int rc_download = -1;
< 
321c302
< 			rc_download = import_crl(hSession, ctx_context,context,context->crl.url);
---
> 			import_crl(hSession, ctx_context,context,context->crl.url);
323,346c304
< 			rc_download = download_crl_from_peer(hSession, ctx_context, context, peer);
< 		}
< 
< 		debug("Download rc=%d",rc_download);
< 
< 		if(!rc_download) {
< 			// Got CRL, verify it!
< 			// Reference: https://stackoverflow.com/questions/10510850/how-to-verify-the-certificate-for-the-ongoing-ssl-session
< 
< 			X509_STORE_CTX *csc = X509_STORE_CTX_new();
< 			X509_STORE_CTX_set_verify_cb(csc, x509_store_ctx_error_callback);
< 			X509_STORE_CTX_init(csc, SSL_CTX_get_cert_store(ctx_context), peer, NULL);
< 
< 			if(X509_verify_cert(csc) != 1)
< 				rv = X509_STORE_CTX_get_error(csc);
< 			else
< 				rv = X509_V_OK;
< 
< 			trace_ssl(hSession, "X509_verify_cert error code was %d\n", rv);
< 
< 			SSL_set_verify_result(context->con, rv);
< 
< 			X509_STORE_CTX_free(csc);
< 
---
> 			download_crl_from_peer(hSession, ctx_context, context, peer);
358d315
< 	debug("Verify message: %s",hSession->ssl.message->summary);
361c318,319
< 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE)) {
---
> 	if(lib3270_get_toggle(hSession,LIB3270_TOGGLE_SSL_TRACE))
> 	{
369,371c327,329
< 		          SSL_CIPHER_get_name(cipher),
< 		          SSL_CIPHER_get_version(cipher),
< 		          alg_bits);
---
> 						SSL_CIPHER_get_name(cipher),
> 						SSL_CIPHER_get_version(cipher),
> 						alg_bits);
376c334
< 		trace_ssl(hSession,"%s\n",hSession->ssl.message->summary);
---
> 		trace_ssl(hSession,"%s",hSession->ssl.message->summary);
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/select.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/select.c
30,40c30,40
< /**
<  * @brief Select network methods.
<  *
<  */
< 
< #include <config.h>
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <lib3270/trace.h>
< #include <networking.h>
< #include <string.h>
---
>  /**
>   * @brief Select network methods.
>   *
>   */
> 
>  #include <config.h>
>  #include <lib3270.h>
>  #include <lib3270/log.h>
>  #include <lib3270/trace.h>
>  #include <networking.h>
>  #include <string.h>
42c42
< /*--[ Implement ]------------------------------------------------------------------------------------*/
---
>  /*--[ Implement ]------------------------------------------------------------------------------------*/
67c67
< 	for(ix=0; ix < (sizeof(modules)/sizeof(modules[0])); ix++) {
---
> 	for(ix=0;ix < (sizeof(modules)/sizeof(modules[0])); ix++) {
78c78
< }
---
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/state.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/state.c
42,43c42,43
< #include <openssl/ssl.h>
< #include <openssl/err.h>
---
> 	#include <openssl/ssl.h>
> 	#include <openssl/err.h>
48c48,49
< LIB3270_EXPORT int lib3270_is_secure(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_is_secure(const H3270 *hSession)
> {
52c53,54
< LIB3270_EXPORT LIB3270_SSL_STATE lib3270_get_ssl_state(const H3270 *hSession) {
---
> LIB3270_EXPORT LIB3270_SSL_STATE lib3270_get_ssl_state(const H3270 *hSession)
> {
56c58,59
< void set_ssl_state(H3270 *hSession, LIB3270_SSL_STATE state) {
---
> void set_ssl_state(H3270 *hSession, LIB3270_SSL_STATE state)
> {
91,92c94,99
< 	if(hSession->ssl.message && hSession->ssl.message->body) {
< 		return dgettext(GETTEXT_PACKAGE,hSession->ssl.message->body);
---
> 	if(hSession->ssl.message) {
> 
> 		if(hSession->ssl.message->body)
> 			return dgettext(GETTEXT_PACKAGE,hSession->ssl.message->body);
> 
> 		return "";
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/tools.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/network_modules/tools.c
30,43c30,43
< /**
<  * @brief Common methods for send/recv errors.
<  *
<  */
< 
< #include <config.h>
< #include <lib3270.h>
< #include <lib3270/log.h>
< #include <internals.h>
< #include <networking.h>
< #include <fcntl.h>
< #ifdef _WIN32
< #include <lib3270/win32.h>
< #endif // _WIN32
---
>  /**
>   * @brief Common methods for send/recv errors.
>   *
>   */
> 
>  #include <config.h>
>  #include <lib3270.h>
>  #include <lib3270/log.h>
>  #include <internals.h>
>  #include <networking.h>
>  #include <fcntl.h>
>  #ifdef _WIN32
> 	#include <lib3270/win32.h>
>  #endif // _WIN32
47c47
< int lib3270_socket_recv_failed(H3270 *hSession) {
---
>  int lib3270_socket_recv_failed(H3270 *hSession) {
61a62,67
> 	LIB3270_POPUP popup = {
> 		.name = "RecvFailed",
> 		.type = LIB3270_NOTIFY_ERROR,
> 		.summary = _("Error receiving data from host"),
> 	};
> 
64,69c70
< 	lib3270_set_network_error(
< 		hSession,
< 		_("Error receiving data from host"),
< 		_("The windows error code was %u"),
< 		(unsigned int) wsaError
< 	);
---
> 	lib3270_popup(hSession,&popup,0);
80,86c81,94
< 	lib3270_set_network_error(
< 		hSession,
< 		_("Error receiving data from host"),
< 		_("The system error code was %d (%s)"),
< 		errno,
< 		strerror(errno)
< 	);
---
> 	lib3270_autoptr(char) body = lib3270_strdup_printf(
> 										_("The system error code was %d (%s)"),
> 										errno,
> 										strerror(errno)
> 								);
> 
> 	LIB3270_POPUP popup = {
> 		.name = "RecvFailed",
> 		.type = LIB3270_NOTIFY_ERROR,
> 		.summary = _("Error receiving data from host"),
> 		.body = body
> 	};
> 
> 	lib3270_popup(hSession,&popup,0);
92c100
< }
---
>  }
94c102
< int lib3270_socket_send_failed(H3270 *hSession) {
---
>  int lib3270_socket_send_failed(H3270 *hSession) {
96c104
< #ifdef _WIN32
---
>  #ifdef _WIN32
98c106,108
< 	lib3270_set_network_error(
---
> 	int rc = WSAGetLastError();
> 
> 	lib3270_popup_dialog(
100,102c110,115
< 	    _("Erro sending data to host"),
< 		_("The windows error code was %u"),
< 		(unsigned int) WSAGetLastError()
---
> 		LIB3270_NOTIFY_ERROR,
> 		NULL,
> 		_("Erro sending data to host"),
> 		_( "The system error was %s (%d)" ),
> 		lib3270_win32_strerror(rc),
> 		rc
105c118
< #else
---
>  #else
111,117c124,132
< 		lib3270_set_network_error(
< 			hSession,
< 		    _("Broken pipe"),
< 			_("The system error code was %d"),
< 			rc
< 		);
< 		break;
---
> 		   lib3270_popup_dialog(
> 				   hSession,
> 				   LIB3270_NOTIFY_ERROR,
> 				   NULL,
> 				   _("Broken pipe"),
> 				   _("The system error code was %d"),
> 				   rc
> 		   );
> 		   break;
120,126c135,143
< 		lib3270_set_network_error(
< 			hSession,
< 		    _("Connection reset by peer"),
< 			_("The system error code was %d"),
< 			rc
< 		);
< 		break;
---
> 		   lib3270_popup_dialog(
> 				   hSession,
> 				   LIB3270_NOTIFY_ERROR,
> 				   NULL,
> 				   _("Connection reset by peer"),
> 				   _("The system error code was %d"),
> 				   rc
> 		   );
> 		   break;
129c146
< 		return 0;
---
> 		   return 0;
132,137c149,156
< 		lib3270_set_network_error(
< 			hSession,
< 		    _("Unexpected error writing to network socket"),
< 		    _("The system error code was %d (%s)"),
< 		    rc, strerror(rc)
< 		);
---
> 		   lib3270_popup_dialog(
> 				   hSession,
> 				   LIB3270_NOTIFY_ERROR,
> 				   NULL,
> 				   _("Unexpected error writing to network socket"),
> 				   _("The system error code was %d (%s)"),
> 				   rc, strerror(rc)
> 		   );
141c160,161
< #endif // _WIN32
---
> 
>  #endif // _WIN32
145c165
< }
---
>  }
154,155c174,175
< 	WSASetLastError(0);
< 	u_long iMode= on ? 1 : 0;
---
> 		WSASetLastError(0);
> 		u_long iMode= on ? 1 : 0;
157,164c177,185
< 	if(ioctlsocket(sock,FIONBIO,&iMode)) {
< 		lib3270_popup_dialog(	hSession,
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Connection error" ),
< 		                        _( "ioctlsocket(FIONBIO) failed." ),
< 		                        "%s", lib3270_win32_strerror(GetLastError()));
< 		return -1;
< 	}
---
> 		if(ioctlsocket(sock,FIONBIO,&iMode))
> 		{
> 			lib3270_popup_dialog(	hSession,
> 									LIB3270_NOTIFY_ERROR,
> 									_( "Connection error" ),
> 									_( "ioctlsocket(FIONBIO) failed." ),
> 									"%s", lib3270_win32_strerror(GetLastError()));
> 			return -1;
> 		}
170c191,192
< 	if ((f = fcntl(sock, F_GETFL, 0)) == -1) {
---
> 	if ((f = fcntl(sock, F_GETFL, 0)) == -1)
> 	{
172,176c194,198
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Socket error" ),
< 		                        _( "fcntl() error when getting socket state." ),
< 		                        _( "%s" ), strerror(errno)
< 		                    );
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Socket error" ),
> 								_( "fcntl() error when getting socket state." ),
> 								_( "%s" ), strerror(errno)
> 							);
186c208,209
< 	if (fcntl(sock, F_SETFL, f) < 0) {
---
> 	if (fcntl(sock, F_SETFL, f) < 0)
> 	{
188,192c211,215
< 		                        LIB3270_NOTIFY_ERROR,
< 		                        _( "Socket error" ),
< 		                        on ? _( "Can't set socket to blocking mode." ) : _( "Can't set socket to non blocking mode" ),
< 		                        _( "%s" ), strerror(errno)
< 		                    );
---
> 								LIB3270_NOTIFY_ERROR,
> 								_( "Socket error" ),
> 								on ? _( "Can't set socket to blocking mode." ) : _( "Can't set socket to non blocking mode" ),
> 								_( "%s" ), strerror(errno)
> 							);
204,205c227,228
< static const char * crl_download_protocols[] = {
< 	NULL,
---
>  static const char * crl_download_protocols[] = {
>  	NULL,
212c235
< };
---
>  };
214,216c237,240
< const char * lib3270_crl_get_preferred_protocol(const H3270 *hSession) {
< 	debug("%s: selected: %d",__FUNCTION__,(int) hSession->ssl.crl_preferred_protocol);
< 	if(hSession->ssl.crl_preferred_protocol < (sizeof(crl_download_protocols)/sizeof(crl_download_protocols[0])))
---
>  const char * lib3270_crl_get_preferred_protocol(const H3270 *hSession)
>  {
>  	debug("%s: selected: %d",__FUNCTION__,(int) hSession->ssl.crl_preferred_protocol);
>  	if(hSession->ssl.crl_preferred_protocol < (sizeof(crl_download_protocols)/sizeof(crl_download_protocols[0])))
221,224c245
< }
< 
< int lib3270_crl_set_preferred_protocol(H3270 *hSession, const char *protocol) {
< 	FAIL_IF_ONLINE(hSession);
---
>  }
226,228c247,253
< 	debug("%s(%s)",__FUNCTION__,protocol);
< 	size_t ix;
< 	for(ix = 0; ix < (sizeof(crl_download_protocols)/sizeof(crl_download_protocols[0])); ix++) {
---
>  int lib3270_crl_set_preferred_protocol(H3270 *hSession, const char *protocol)
>  {
>     FAIL_IF_ONLINE(hSession);
> 
>     debug("%s(%s)",__FUNCTION__,protocol);
>     size_t ix;
>     for(ix = 0; ix < (sizeof(crl_download_protocols)/sizeof(crl_download_protocols[0])); ix++) {
235,240c260
< 	}
< 
< 	debug("Unsupported protocol: %s",protocol);
< 
< 	return EINVAL;
< }
---
>     }
242,250c262
< LIB3270_EXPORT int lib3270_getpeername(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen) {
< 	FAIL_IF_NOT_ONLINE(hSession);
< 	return hSession->network.module->getpeername(hSession, addr, addrlen);
< }
< 
< LIB3270_EXPORT int lib3270_getsockname(H3270 *hSession, struct sockaddr *addr, socklen_t *addrlen) {
< 	FAIL_IF_NOT_ONLINE(hSession);
< 	return hSession->network.module->getsockname(hSession, addr, addrlen);
< }
---
>     debug("Unsupported protocol: %s",protocol);
251a264,265
>     return EINVAL;
>  }
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/actions.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/actions.c
1,2d0
< /* SPDX-License-Identifier: LGPL-3.0-or-later */
< 
4c2,15
<  * Copyright (C) 2008 Banco do Brasil S.A.
---
>  * "Software pw3270, desenvolvido com base nos códigos fontes do WC3270  e X3270
>  * (Paul Mattes Paul.Mattes@usa.net), de emulação de terminal 3270 para acesso a
>  * aplicativos mainframe. Registro no INPI sob o nome G3270.
>  *
>  * Copyright (C) <2008> <Banco do Brasil S.A.>
>  *
>  * Este programa é software livre. Você pode redistribuí-lo e/ou modificá-lo sob
>  * os termos da GPL v.2 - Licença Pública Geral  GNU,  conforme  publicado  pela
>  * Free Software Foundation.
>  *
>  * Este programa é distribuído na expectativa de  ser  útil,  mas  SEM  QUALQUER
>  * GARANTIA; sem mesmo a garantia implícita de COMERCIALIZAÇÃO ou  de  ADEQUAÇÃO
>  * A QUALQUER PROPÓSITO EM PARTICULAR. Consulte a Licença Pública Geral GNU para
>  * obter mais detalhes.
6,9c17,19
<  * This program is free software: you can redistribute it and/or modify
<  * it under the terms of the GNU Lesser General Public License as published
<  * by the Free Software Foundation, either version 3 of the License, or
<  * (at your option) any later version.
---
>  * Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este
>  * programa; se não, escreva para a Free Software Foundation, Inc., 51 Franklin
>  * St, Fifth Floor, Boston, MA  02110-1301  USA
11,14c21,26
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
---
>  * Este programa está nomeado como - e possui - linhas de código.
>  *
>  * Contatos:
>  *
>  * perry.werneck@gmail.com	(Alexandre Perry de Souza Werneck)
>  * erico.mendonca@gmail.com	(Erico Mascarenhas Mendonça)
16,17d27
<  * You should have received a copy of the GNU Lesser General Public License
<  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
20,28c30,38
< #include <internals.h>
< #include <lib3270.h>
< #include <lib3270/actions.h>
< #include <lib3270/session.h>
< #include <lib3270/selection.h>
< #include <lib3270/log.h>
< #include <lib3270/trace.h>
< #include <lib3270/toggle.h>
< #include "3270ds.h"
---
>  #include <internals.h>
>  #include <lib3270.h>
>  #include <lib3270/actions.h>
>  #include <lib3270/session.h>
>  #include <lib3270/selection.h>
>  #include <lib3270/log.h>
>  #include <lib3270/trace.h>
>  #include <lib3270/toggle.h>
>  #include "3270ds.h"
32c42,43
< LIB3270_EXPORT int lib3270_unselect(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_unselect(H3270 *hSession)
> {
39c50,51
< 	if(hSession->selected) {
---
> 	if(hSession->selected)
> 	{
42,43c54,57
< 		for(a = 0; a < ((int) (hSession->view.rows * hSession->view.cols)); a++) {
< 			if(hSession->text[a].attr & LIB3270_ATTR_SELECTED) {
---
> 		for(a = 0; a < ((int) (hSession->view.rows * hSession->view.cols)); a++)
> 		{
> 			if(hSession->text[a].attr & LIB3270_ATTR_SELECTED)
> 			{
60c74,75
< LIB3270_EXPORT void lib3270_select_to(H3270 *session, int baddr) {
---
> LIB3270_EXPORT void lib3270_select_to(H3270 *session, int baddr)
> {
76c91,92
< LIB3270_EXPORT int lib3270_select_region(H3270 *h, int start, int end) {
---
> LIB3270_EXPORT int lib3270_select_region(H3270 *h, int start, int end)
> {
95c111,112
< LIB3270_EXPORT int lib3270_select_word(H3270 *session) {
---
> LIB3270_EXPORT int lib3270_select_word(H3270 *session)
> {
99,100c116,118
< LIB3270_EXPORT int lib3270_select_word_at(H3270 *session, int baddr) {
< 	int start, end, rc;
---
> LIB3270_EXPORT int lib3270_select_word_at(H3270 *session, int baddr)
> {
> 	int start, end;
102,104c120,121
< 	rc = lib3270_get_word_bounds(session,baddr,&start,&end);
< 	if(rc)
< 		return rc;
---
> 	if(lib3270_get_word_bounds(session,baddr,&start,&end))
> 		return -1;
108,113c125
< 	rc = do_select(session,start,end,0);
< 	if(rc)
< 		return rc;
< 
< 	// Notify word selected to allow testing for URL selection.
< 	session->cbk.word_selected(session,start,end);
---
> 	do_select(session,start,end,0);
118c130,131
< LIB3270_EXPORT int lib3270_select_field_at(H3270 *session, int baddr) {
---
> LIB3270_EXPORT int lib3270_select_field_at(H3270 *session, int baddr)
> {
129c142,143
< LIB3270_EXPORT int lib3270_select_field(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_select_field(H3270 *hSession)
> {
135c149,150
< LIB3270_EXPORT int lib3270_select_all(H3270 * hSession) {
---
> LIB3270_EXPORT int lib3270_select_all(H3270 * hSession)
> {
143c158,159
< LIB3270_EXPORT int lib3270_reselect(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_reselect(H3270 *hSession)
> {
154c170,171
< LIB3270_EXPORT int lib3270_get_selection_bounds(H3270 *hSession, int *start, int *end) {
---
> LIB3270_EXPORT int lib3270_get_selection_bounds(H3270 *hSession, int *start, int *end)
> {
162c179,180
< 	if(hSession->select.end > hSession->select.start) {
---
> 	if(hSession->select.end > hSession->select.start)
> 	{
165c183,185
< 	} else {
---
> 	}
> 	else
> 	{
179c199,200
< LIB3270_EXPORT int lib3270_move_selected_area(H3270 *hSession, int from, int to) {
---
> LIB3270_EXPORT int lib3270_move_selected_area(H3270 *hSession, int from, int to)
> {
192c213,214
< 	for(f=0; f<2; f++) {
---
> 	for(f=0;f<2;f++)
> 	{
217c239,240
< LIB3270_EXPORT int lib3270_drag_selection(H3270 *h, unsigned char flag, int origin, int baddr) {
---
> LIB3270_EXPORT int lib3270_drag_selection(H3270 *h, unsigned char flag, int origin, int baddr)
> {
223,231c246,254
< 	/*
< 		trace("%s: flag=%04x %s %s %s %s",__FUNCTION__,
< 					flag,
< 					flag & SELECTION_LEFT	? "Left"	: "-",
< 					flag & SELECTION_TOP	? "Top"		: "-",
< 					flag & SELECTION_RIGHT	? "Right"	: "-",
< 					flag & SELECTION_BOTTOM	? "Bottom"	: "-"
< 					);
< 	*/
---
> /*
> 	trace("%s: flag=%04x %s %s %s %s",__FUNCTION__,
> 				flag,
> 				flag & SELECTION_LEFT	? "Left"	: "-",
> 				flag & SELECTION_TOP	? "Top"		: "-",
> 				flag & SELECTION_RIGHT	? "Right"	: "-",
> 				flag & SELECTION_BOTTOM	? "Bottom"	: "-"
> 				);
> */
265c288,289
< LIB3270_EXPORT int lib3270_move_selection(H3270 *hSession, LIB3270_DIRECTION dir) {
---
> LIB3270_EXPORT int lib3270_move_selection(H3270 *hSession, LIB3270_DIRECTION dir)
> {
274c298,299
< 	switch(dir) {
---
> 	switch(dir)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/get.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/get.c
30,36c30,36
< #include <internals.h>
< #include <lib3270.h>
< #include <lib3270/session.h>
< #include <lib3270/selection.h>
< #include <lib3270/trace.h>
< #include <lib3270/log.h>
< #include "3270ds.h"
---
>  #include <internals.h>
>  #include <lib3270.h>
>  #include <lib3270/session.h>
>  #include <lib3270/selection.h>
>  #include <lib3270/trace.h>
>  #include <lib3270/log.h>
>  #include "3270ds.h"
38c38
< /*--[ Implement ]------------------------------------------------------------------------------------*/
---
>  /*--[ Implement ]------------------------------------------------------------------------------------*/
40c40,41
< void clear_chr(H3270 *hSession, int baddr) {
---
> void clear_chr(H3270 *hSession, int baddr)
> {
47,50c48,51
< 	                        baddr,
< 	                        hSession->text[baddr].chr,
< 	                        hSession->text[baddr].attr,
< 	                        baddr == hSession->cursor_addr );
---
> 							baddr,
> 							hSession->text[baddr].chr,
> 							hSession->text[baddr].attr,
> 							baddr == hSession->cursor_addr );
53c54,55
< LIB3270_EXPORT char * lib3270_get_selected_text(H3270 *hSession, char tok, LIB3270_SELECTION_OPTIONS options) {
---
> LIB3270_EXPORT char * lib3270_get_selected_text(H3270 *hSession, char tok, LIB3270_SELECTION_OPTIONS options)
> {
58,60c60,62
< 	unsigned short	  attr		= 0xFFFF;
< 	char			  cut		= (options & LIB3270_SELECTION_CUT) != 0;
< 	char			  all		= (options & LIB3270_SELECTION_ALL) != 0;
---
>     unsigned short	  attr		= 0xFFFF;
>     char			  cut		= (options & LIB3270_SELECTION_CUT) != 0;
>     char			  all		= (options & LIB3270_SELECTION_ALL) != 0;
65c67,68
< 	if(!hSession->selected || hSession->select.start == hSession->select.end) {
---
> 	if(!hSession->selected || hSession->select.start == hSession->select.end)
> 	{
75c78,79
< 	for(row=0; row < ((int) hSession->view.rows); row++) {
---
> 	for(row=0;row < ((int) hSession->view.rows);row++)
> 	{
78c82,83
< 		for(col = 0; col < ((int) hSession->view.cols); col++) {
---
> 		for(col = 0; col < ((int) hSession->view.cols);col++)
> 		{
83,84c88,91
< 			if(all || hSession->text[baddr].attr & LIB3270_ATTR_SELECTED) {
< 				if(tok && attr != hSession->text[baddr].attr) {
---
> 			if(all || hSession->text[baddr].attr & LIB3270_ATTR_SELECTED)
> 			{
> 				if(tok && attr != hSession->text[baddr].attr)
> 				{
106,109c113,117
< 		if((sz+10) > buflen) {
< 			buflen += 100;
< 			ret = lib3270_realloc(ret,buflen);
< 		}
---
>         if((sz+10) > buflen)
>         {
>             buflen += 100;
>        		ret = lib3270_realloc(ret,buflen);
>         }
112c120,121
< 	if(!sz) {
---
> 	if(!sz)
> 	{
116c125,127
< 	} else if(sz > 1 && ret[sz-1] == '\n') { // Remove ending \n
---
> 	}
> 	else if(sz > 1 && ret[sz-1] == '\n') // Remove ending \n
> 	{
128c139,140
< LIB3270_EXPORT char * lib3270_get_selected(H3270 *hSession) {
---
> LIB3270_EXPORT char * lib3270_get_selected(H3270 *hSession)
> {
132c144,145
< LIB3270_EXPORT char * lib3270_cut_selected(H3270 *hSession) {
---
> LIB3270_EXPORT char * lib3270_cut_selected(H3270 *hSession)
> {
136c149,150
< static size_t get_selection_length(unsigned int width, unsigned int height) {
---
> static size_t get_selection_length(unsigned int width, unsigned int height)
> {
140c154,155
< LIB3270_EXPORT size_t lib3270_selection_get_length(const lib3270_selection *selection) {
---
> LIB3270_EXPORT size_t lib3270_selection_get_length(const lib3270_selection *selection)
> {
144c159,160
< LIB3270_EXPORT lib3270_selection * lib3270_get_selection(H3270 *hSession, int cut, int all) {
---
> LIB3270_EXPORT lib3270_selection * lib3270_get_selection(H3270 *hSession, int cut, int all)
> {
148c164,165
< LIB3270_EXPORT lib3270_selection * lib3270_selection_new(H3270 *hSession, int cut, int all) {
---
> LIB3270_EXPORT lib3270_selection * lib3270_selection_new(H3270 *hSession, int cut, int all)
> {
155c172,173
< 	if(all) {
---
> 	if(all)
> 	{
159c177,179
< 	} else if(lib3270_get_selection_rectangle(hSession, &row, &col, &width, &height)) {
---
> 	}
> 	else if(lib3270_get_selection_rectangle(hSession, &row, &col, &width, &height))
> 	{
176,182c196,202
< 	    "width=%u height=%u length=%u (sz=%u szHeader=%u szElement=%u)",
< 	    selection->bounds.width,
< 	    selection->bounds.height,
< 	    ((selection->bounds.width * selection->bounds.height) + 1),
< 	    (unsigned int) length,
< 	    (unsigned int) sizeof(lib3270_selection),
< 	    (unsigned int) sizeof(lib3270_selection_element)
---
> 		"width=%u height=%u length=%u (sz=%u szHeader=%u szElement=%u)",
> 			selection->bounds.width,
> 			selection->bounds.height,
> 			((selection->bounds.width * selection->bounds.height) + 1),
> 			(unsigned int) length,
> 			(unsigned int) sizeof(lib3270_selection),
> 			(unsigned int) sizeof(lib3270_selection_element)
187c207,208
< 	for(row=0; row < selection->bounds.height; row++) {
---
> 	for(row=0;row < selection->bounds.height; row++)
> 	{
192c213,214
< 		if(baddr < 0) {
---
> 		if(baddr < 0)
> 		{
197c219,220
< 		for(col=0; col < selection->bounds.width; col++) {
---
> 		for(col=0;col < selection->bounds.width; col++)
> 		{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/selection.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/selection/selection.c
30,42c30,44
< #include <internals.h>
< #include <lib3270.h>
< #include <lib3270/actions.h>
< #include <lib3270/session.h>
< #include <lib3270/selection.h>
< #include <lib3270/log.h>
< #include "3270ds.h"
< #include "kybdc.h"
< 
< /*--[ Implement ]------------------------------------------------------------------------------------*/
< 
< static void get_selected_addr(H3270 *session, int *start, int *end) {
< 	if(session->select.start > session->select.end) {
---
>  #include <internals.h>
>  #include <lib3270.h>
>  #include <lib3270/actions.h>
>  #include <lib3270/session.h>
>  #include <lib3270/selection.h>
>  #include <lib3270/log.h>
>  #include "3270ds.h"
>  #include "kybdc.h"
> 
>  /*--[ Implement ]------------------------------------------------------------------------------------*/
> 
> static void get_selected_addr(H3270 *session, int *start, int *end)
> {
> 	if(session->select.start > session->select.end)
> 	{
45c47,49
< 	} else {
---
> 	}
> 	else
> 	{
51,52c55,58
< static void update_selected_rectangle(H3270 *session) {
< 	struct {
---
> static void update_selected_rectangle(H3270 *session)
> {
> 	struct
> 	{
67c73,74
< 	if(p[0].row > p[1].row) {
---
> 	if(p[0].row > p[1].row)
> 	{
73c80,81
< 	if(p[0].col > p[1].col) {
---
> 	if(p[0].col > p[1].col)
> 	{
81,83c89,94
< 	for(row=0; row < ((int) session->view.rows); row++) {
< 		for(col = 0; col < ((int) session->view.cols); col++) {
< 			if(!(row >= p[0].row && row <= p[1].row && col >= p[0].col && col <= p[1].col) && (session->text[baddr].attr & LIB3270_ATTR_SELECTED)) {
---
> 	for(row=0;row < ((int) session->view.rows);row++)
> 	{
> 		for(col = 0; col < ((int) session->view.cols);col++)
> 		{
> 			if(!(row >= p[0].row && row <= p[1].row && col >= p[0].col && col <= p[1].col) && (session->text[baddr].attr & LIB3270_ATTR_SELECTED))
> 			{
93,95c104,109
< 	for(row=0; row < ((int) session->view.rows); row++) {
< 		for(col = 0; col < ((int) session->view.cols); col++) {
< 			if((row >= p[0].row && row <= p[1].row && col >= p[0].col && col <= p[1].col) && !(session->text[baddr].attr & LIB3270_ATTR_SELECTED)) {
---
> 	for(row=0;row < ((int) session->view.rows);row++)
> 	{
> 		for(col = 0; col < ((int) session->view.cols);col++)
> 		{
> 			if((row >= p[0].row && row <= p[1].row && col >= p[0].col && col <= p[1].col) && !(session->text[baddr].attr & LIB3270_ATTR_SELECTED))
> 			{
105c119,120
< static void update_selected_region(H3270 *session) {
---
> static void update_selected_region(H3270 *session)
> {
112,113c127,130
< 	for(baddr = 0; baddr < begin; baddr++) {
< 		if(session->text[baddr].attr & LIB3270_ATTR_SELECTED) {
---
> 	for(baddr = 0; baddr < begin; baddr++)
> 	{
> 		if(session->text[baddr].attr & LIB3270_ATTR_SELECTED)
> 		{
119,120c136,139
< 	for(baddr = end+1; baddr < len; baddr++) {
< 		if(session->text[baddr].attr & LIB3270_ATTR_SELECTED) {
---
> 	for(baddr = end+1; baddr < len; baddr++)
> 	{
> 		if(session->text[baddr].attr & LIB3270_ATTR_SELECTED)
> 		{
127,128c146,149
< 	for(baddr = begin; baddr <= end; baddr++) {
< 		if(!(session->text[baddr].attr & LIB3270_ATTR_SELECTED)) {
---
> 	for(baddr = begin; baddr <= end; baddr++)
> 	{
> 		if(!(session->text[baddr].attr & LIB3270_ATTR_SELECTED))
> 		{
136c157,158
< void toggle_rectselect(H3270 *hSession, const struct lib3270_toggle *t, LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt)) {
---
> void toggle_rectselect(H3270 *hSession, const struct lib3270_toggle *t, LIB3270_TOGGLE_TYPE GNUC_UNUSED(tt))
> {
148c170,171
< int do_select(H3270 *hSession, unsigned int start, unsigned int end, unsigned int rect) {
---
> int do_select(H3270 *hSession, unsigned int start, unsigned int end, unsigned int rect)
> {
162c185,186
< 	if(rect) {
---
> 	if(rect)
> 	{
165c189,191
< 	} else {
---
> 	}
> 	else
> 	{
170c196,197
< 	if(!hSession->selected) {
---
> 	if(!hSession->selected)
> 	{
181c208,209
< LIB3270_EXPORT unsigned char lib3270_get_selection_flags(H3270 *hSession, int baddr) {
---
> LIB3270_EXPORT unsigned char lib3270_get_selection_flags(H3270 *hSession, int baddr)
> {
194c222,223
< 	if( (hSession->select.start % hSession->view.cols) == (hSession->select.end % hSession->view.cols) ) {
---
> 	if( (hSession->select.start % hSession->view.cols) == (hSession->select.end % hSession->view.cols) )
> 	{
196c225,227
< 	} else {
---
> 	}
> 	else
> 	{
206c237,238
< 	if( (hSession->select.start / hSession->view.cols) == (hSession->select.end / hSession->view.cols) ) {
---
> 	if( (hSession->select.start / hSession->view.cols) == (hSession->select.end / hSession->view.cols) )
> 	{
208c240,242
< 	} else {
---
> 	}
> 	else
> 	{
219c253,254
< LIB3270_EXPORT char * lib3270_get_region(H3270 *h, int start_pos, int end_pos, unsigned char all) {
---
> LIB3270_EXPORT char * lib3270_get_region(H3270 *h, int start_pos, int end_pos, unsigned char all)
> {
235c270,271
< 	for(baddr=start_pos; baddr<end_pos; baddr++) {
---
> 	for(baddr=start_pos;baddr<end_pos;baddr++)
> 	{
247c283,284
< LIB3270_EXPORT char * lib3270_get_string_at_address(H3270 *h, int offset, int len, char lf) {
---
> LIB3270_EXPORT char * lib3270_get_string_at_address(H3270 *h, int offset, int len, char lf)
> {
254c291,292
< 	if(!lib3270_is_connected(h)) {
---
> 	if(!lib3270_is_connected(h))
> 	{
263c301,302
< 	if(maxlen <= 0 || offset < 0) {
---
> 	if(maxlen <= 0 || offset < 0)
> 	{
278c317,318
< 	while(len > 0) {
---
> 	while(len > 0)
> 	{
290c330,331
< 		if(lf && (offset%h->view.cols) == 0 && len > 0) {
---
> 		if(lf && (offset%h->view.cols) == 0 && len > 0)
> 		{
302c343,344
< LIB3270_EXPORT char * lib3270_get_string_at(H3270 *h, unsigned int row, unsigned int col, int len, char lf) {
---
> LIB3270_EXPORT char * lib3270_get_string_at(H3270 *h, unsigned int row, unsigned int col, int len, char lf)
> {
312c354,355
< LIB3270_EXPORT int lib3270_cmp_string_at(H3270 *h, unsigned int row, unsigned int col, const char *text, char lf) {
---
> LIB3270_EXPORT int lib3270_cmp_string_at(H3270 *h, unsigned int row, unsigned int col, const char *text, char lf)
> {
320c363,364
< LIB3270_EXPORT int lib3270_cmp_string_at_address(H3270 *h, int baddr, const char *text, char lf) {
---
>  LIB3270_EXPORT int lib3270_cmp_string_at_address(H3270 *h, int baddr, const char *text, char lf)
>  {
334c378
< }
---
>  }
345c389,390
< LIB3270_EXPORT char * lib3270_get_field_string_at(H3270 *session, int baddr) {
---
> LIB3270_EXPORT char * lib3270_get_field_string_at(H3270 *session, int baddr)
> {
354c399,400
< LIB3270_EXPORT int lib3270_get_has_selection(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_get_has_selection(const H3270 *hSession)
> {
366c412,413
< LIB3270_EXPORT int lib3270_get_has_copy(const H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_get_has_copy(const H3270 *hSession)
> {
381c428,429
< LIB3270_EXPORT int lib3270_get_selection_rectangle(H3270 *hSession, unsigned int *row, unsigned int *col, unsigned int *width, unsigned int *height) {
---
> LIB3270_EXPORT int lib3270_get_selection_rectangle(H3270 *hSession, unsigned int *row, unsigned int *col, unsigned int *width, unsigned int *height)
> {
397,399c445,450
< 	for(r=0; r < hSession->view.rows; r++) {
< 		for(c = 0; c < hSession->view.cols; c++) {
< 			if(hSession->text[baddr].attr & LIB3270_ATTR_SELECTED) {
---
> 	for(r=0;r < hSession->view.rows;r++)
> 	{
> 		for(c = 0; c < hSession->view.cols;c++)
> 		{
> 			if(hSession->text[baddr].attr & LIB3270_ATTR_SELECTED)
> 			{
431c482,483
< LIB3270_EXPORT int lib3270_erase_selected(H3270 *hSession) {
---
> LIB3270_EXPORT int lib3270_erase_selected(H3270 *hSession)
> {
434c486,487
< 	if (hSession->kybdlock) {
---
> 	if (hSession->kybdlock)
> 	{
442c495,496
< 	for(baddr = 0; baddr < lib3270_get_length(hSession); baddr++) {
---
> 	for(baddr = 0; baddr < lib3270_get_length(hSession); baddr++)
> 	{
447c501,502
< 		if( (hSession->text[baddr].attr & LIB3270_ATTR_SELECTED) && !FA_IS_PROTECTED(fa)) {
---
> 		if( (hSession->text[baddr].attr & LIB3270_ATTR_SELECTED) && !FA_IS_PROTECTED(fa))
> 		{
452c507
< 	return -1;
---
>     return -1;
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/testprogram/testprogram.c lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/src/testprogram/testprogram.c
44d43
< #include <stdio.h>
54c53,65
< static void online_group_state_changed(H3270 GNUC_UNUSED(*hSession), void GNUC_UNUSED(*dunno)) {
---
> static void write_trace(H3270 GNUC_UNUSED(*session), void GNUC_UNUSED(*userdata), const char *fmt, va_list args)
> {
> 	FILE *out = fopen(trace_file,"a");
> 	if(out)
> 	{
> 
> 		vfprintf(out,fmt,args);
> 		fclose(out);
> 	}
> }
> 
> static void online_group_state_changed(H3270 GNUC_UNUSED(*hSession), void GNUC_UNUSED(*dunno))
> {
68c79,80
< int main(int argc, char *argv[]) {
---
> int main(int argc, char *argv[])
> {
79,86d90
< 	/*
< 	{
< 		lib3270_autoptr(char) testfilename = lib3270_build_data_filename("test",NULL);
< 		printf("\n\nFilename: '%s'\n\n", testfilename);
< 		return 0;
< 	}
< 	*/
< 
90,94c94,97
< 		{ "crl",					required_argument,	0,	'C' },
< 		{ "disable-crl-download",	no_argument,		0,	'D' },
< 		{ "url",					required_argument,	0,	'U' },
< 		{ "tracefile",				required_argument,	0,	't' },
< 		{ "reconnect",				no_argument,		0,	'r' },
---
> 		{ "crl",		required_argument,	0,	'C' },
> 		{ "url",		required_argument,	0,	'U' },
> 		{ "tracefile",	required_argument,	0,	't' },
> 		{ "reconnect",	no_argument,		0,	'r' },
98a102
> //	#pragma GCC diagnostic pop
103d106
< 	lib3270_set_log_filename(h,"testprogram.log");
113,114d115
< 	lib3270_ssl_set_crl_download(h,0);
< 
117d117
< 	//lib3270_set_url(h,"tn3270://localhost:3270");
127,130d126
< 		case 'D':
< 			lib3270_ssl_set_crl_download(h,0);
< 			break;
< 
140c136,137
< 			lib3270_set_trace_filename(h,optarg);
---
> 			trace_file = optarg;
> 			lib3270_set_trace_handler(h,write_trace,NULL);
161d157
< 	/*
171d166
< 	*/
173d167
< 	exit(0);
185c179,180
< 	if(!rc) {
---
> 	if(!rc)
> 	{
190c185,186
< 	if(!rc) {
---
> 	if(!rc)
> 	{
195c191,192
< 	if(!rc) {
---
> 	if(!rc)
> 	{
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.vscode/c_cpp_properties.json lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/.vscode/c_cpp_properties.json
19,20c19
<             "intelliSenseMode": "msvc-x64",
<             "configurationProvider": "ms-vscode.makefile-tools"
---
>             "intelliSenseMode": "msvc-x64"
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: bundle.common
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: bundle.cross
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: bundle.msys
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/configure.sh lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/configure.sh
2d1
< cd $(dirname $(dirname $(readlink -f ${0})))
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: install-cross.sh
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/lib3270.def lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/lib3270.def
1,359c1,330
< EXPORTS
<     lib3270_action @1
<     lib3270_action_activate @2
<     lib3270_action_get_by_name @3
<     lib3270_action_group_get_activatable @4
<     lib3270_action_group_notify @5
<     lib3270_action_is_activatable @6
<     lib3270_activate_by_name @7
<     lib3270_add_poll_fd @8
<     lib3270_allow_reconnect @9
<     lib3270_asc2ebc @10
<     lib3270_attn @11
<     lib3270_autoptr_cleanup_HKEY @12
<     lib3270_autoptr_cleanup_LIB3270_POPUP @13
<     lib3270_autoptr_cleanup_char @14
<     lib3270_backspace @15
<     lib3270_break @16
<     lib3270_build_config_filename @17
<     lib3270_build_data_filename @18
<     lib3270_build_filename @19
<     lib3270_calloc @20
<     lib3270_can_paste_next @21
<     lib3270_charsettable @22
<     lib3270_check_revision @23
<     lib3270_chomp @24
<     lib3270_chug @25
<     lib3270_clear @26
<     lib3270_clear_operator_error @27
<     lib3270_cmp_string_at @28
<     lib3270_cmp_string_at_address @29
<     lib3270_connect_url @30
<     lib3270_connection_state_get_name @31
<     lib3270_crl_get_preferred_protocol @32
<     lib3270_crl_set_preferred_protocol @33
<     lib3270_cursor_down @34
<     lib3270_cursor_left @35
<     lib3270_cursor_right @36
<     lib3270_cursor_up @37
<     lib3270_cut_selected @38
<     lib3270_data_recv @39
<     lib3270_delete @40
<     lib3270_deletefield @41
<     lib3270_deleteword @42
<     lib3270_disconnect @43
<     lib3270_drag_selection @44
<     lib3270_dup @45
<     lib3270_ebc2asc @46
<     lib3270_emulate_input @47
<     lib3270_enter @48
<     lib3270_erase @49
<     lib3270_erase_selected @50
<     lib3270_eraseeof @51
<     lib3270_eraseeol @52
<     lib3270_eraseinput @53
<     lib3270_field_addr @54
<     lib3270_field_length @55
<     lib3270_fieldend @56
<     lib3270_fieldmark @57
<     lib3270_firstfield @58
<     lib3270_free @59
<     lib3270_ft_cancel @60
<     lib3270_ft_destroy @61
<     lib3270_ft_get_user_data @62
<     lib3270_ft_new @63
<     lib3270_ft_set_blksize @64
<     lib3270_ft_set_lrecl @65
<     lib3270_ft_set_options @66
<     lib3270_ft_set_primspace @67
<     lib3270_ft_set_secspace @68
<     lib3270_ft_set_user_data @69
<     lib3270_ft_start @70
<     lib3270_get_action @71
<     lib3270_get_actions @72
<     lib3270_get_associated_luname @73
<     lib3270_get_attribute_at_address @74
<     lib3270_get_auto_reconnect @75
<     lib3270_get_boolean_properties_list @76
<     lib3270_get_color_type @77
<     lib3270_get_connection_state @78
<     lib3270_get_connection_state_as_string @79
<     lib3270_get_contents @80
<     lib3270_get_cursor_address @81
<     lib3270_get_cursor_position @82
<     lib3270_get_default_charset @83
<     lib3270_get_default_host @84
<     lib3270_get_default_session_handle @85
<     lib3270_get_display_charset @86
<     lib3270_get_element @87
<     lib3270_get_field_attribute @88
<     lib3270_get_field_bounds @89
<     lib3270_get_field_end @90
<     lib3270_get_field_len @91
<     lib3270_get_field_start @92
<     lib3270_get_field_string_at @93
<     lib3270_get_ft_callbacks @94
<     lib3270_get_ft_state @95
<     lib3270_get_has_copy @96
<     lib3270_get_has_selection @97
<     lib3270_get_height @98
<     lib3270_get_host @99
<     lib3270_get_host_charset @100
<     lib3270_get_host_type @101
<     lib3270_get_host_type_name @102
<     lib3270_get_installation_path @103
<     lib3270_get_int_properties_list @104
<     lib3270_get_int_property @105
<     lib3270_get_is_protected @106
<     lib3270_get_is_protected_at @107
<     lib3270_get_keyboard_lock_state @108
<     lib3270_get_length @109
<     lib3270_get_lock_on_operator_error @110
<     lib3270_get_lock_status @111
<     lib3270_get_log_filename @112
<     lib3270_get_lunames @113
<     lib3270_get_max_height @114
<     lib3270_get_max_width @115
<     lib3270_get_model @116
<     lib3270_get_model_name @117
<     lib3270_get_model_number @118
<     lib3270_get_next_unprotected @119
<     lib3270_get_numeric_lock @120
<     lib3270_get_oia_box_solid @121
<     lib3270_get_option_list @122
<     lib3270_get_oversize @123
<     lib3270_get_pointer @124
<     lib3270_get_product_name @125
<     lib3270_get_program_message @126
<     lib3270_get_program_message_as_string @127
<     lib3270_get_region @128
<     lib3270_get_revision @129
<     lib3270_get_screen_size @130
<     lib3270_get_selected @131
<     lib3270_get_selected_text @132
<     lib3270_get_selection @133
<     lib3270_get_selection_bounds @134
<     lib3270_get_selection_flags @135
<     lib3270_get_selection_rectangle @136
<     lib3270_get_session_callbacks @137
<     lib3270_get_session_id @138
<     lib3270_get_ssl_crl_text @139
<     lib3270_get_ssl_peer_certificate_text @140
<     lib3270_get_ssl_state @141
<     lib3270_get_ssl_state_as_string @142
<     lib3270_get_ssl_state_description @143
<     lib3270_get_ssl_state_icon_name @144
<     lib3270_get_ssl_state_message @145
<     lib3270_get_string_at @146
<     lib3270_get_string_at_address @147
<     lib3270_get_string_properties_list @148
<     lib3270_get_task_count @149
<     lib3270_get_termname @150
<     lib3270_get_termtype @151
<     lib3270_get_toggle @152
<     lib3270_get_toggle_description @153
<     lib3270_get_toggle_id @154
<     lib3270_get_toggle_label @155
<     lib3270_get_toggle_list @156
<     lib3270_get_toggle_name @157
<     lib3270_get_toggle_summary @158
<     lib3270_get_toggles @159
<     lib3270_get_trace_filename @160
<     lib3270_get_trace_handler @161
<     lib3270_get_translation_domain @162
<     lib3270_get_typeahead @163
<     lib3270_get_undera @164
<     lib3270_get_unlock_delay @165
<     lib3270_get_unsigned_properties_list @166
<     lib3270_get_url @167
<     lib3270_get_user_data @168
<     lib3270_get_version @169
<     lib3270_get_version_info @170
<     lib3270_get_width @171
<     lib3270_get_word_bounds @172
<     lib3270_getpeername @173
<     lib3270_getsockname @174
<     lib3270_half_connected @175
<     lib3270_has_active_script @176
<     lib3270_has_selection @177
<     lib3270_host_get_name @178
<     lib3270_iconv_free @179
<     lib3270_iconv_from_host @180
<     lib3270_iconv_new @181
<     lib3270_iconv_to_host @182
<     lib3270_in_3270 @183
<     lib3270_in_ansi @184
<     lib3270_in_e @185
<     lib3270_in_neither @186
<     lib3270_in_sscp @187
<     lib3270_in_tn3270e @188
<     lib3270_input_string @189
<     lib3270_is_as400 @190
<     lib3270_is_connected @191
<     lib3270_is_disconnected @192
<     lib3270_is_formatted @193
<     lib3270_is_protected @194
<     lib3270_is_ready @195
<     lib3270_is_secure @196
<     lib3270_is_selected @197
<     lib3270_is_tso @198
<     lib3270_is_unlocked @199
<     lib3270_kybdreset @200
<     lib3270_load @201
<     lib3270_main_iterate @202
<     lib3270_malloc @203
<     lib3270_move_cursor @204
<     lib3270_move_selected_area @205
<     lib3270_move_selection @206
<     lib3270_newline @207
<     lib3270_nextfield @208
<     lib3270_nextword @209
<     lib3270_pakey @210
<     lib3270_parse_host_type @211
<     lib3270_paste_next @212
<     lib3270_paste_text @213
<     lib3270_pconnected @214
<     lib3270_pfkey @215
<     lib3270_popup @216
<     lib3270_popup_an_errno @217
<     lib3270_popup_clone_printf @218
<     lib3270_popup_dialog @219
<     lib3270_popup_va @220
<     lib3270_previousfield @221
<     lib3270_previousword @222
<     lib3270_print @223
<     lib3270_print_all @224
<     lib3270_print_copy @225
<     lib3270_print_selected @226
<     lib3270_property_get_by_name @227
<     lib3270_property_get_description @228
<     lib3270_property_get_label @229
<     lib3270_property_get_name @230
<     lib3270_property_get_summary @231
<     lib3270_property_get_tooltip @232
<     lib3270_realloc @233
<     lib3270_receive @234
<     lib3270_reconnect @235
<     lib3270_register_action_group_listener @236
<     lib3270_register_fd_handlers @237
<     lib3270_register_io_controller @238
<     lib3270_register_schange @239
<     lib3270_register_timer_handlers @240
<     lib3270_register_toggle_listener @241
<     lib3270_remap_char @242
<     lib3270_remove_poll @243
<     lib3270_remove_poll_fd @244
<     lib3270_reselect @245
<     lib3270_reset_callbacks @246
<     lib3270_reset_charset @247
<     lib3270_reset_ft_callbacks @248
<     lib3270_ring_bell @249
<     lib3270_run_task @250
<     lib3270_save @251
<     lib3270_save_all @252
<     lib3270_save_copy @253
<     lib3270_save_selected @254
<     lib3270_select_all @255
<     lib3270_select_field @256
<     lib3270_select_field_at @257
<     lib3270_select_region @258
<     lib3270_select_to @259
<     lib3270_select_word @260
<     lib3270_select_word_at @261
<     lib3270_selection_get_length @262
<     lib3270_selection_new @263
<     lib3270_send @264
<     lib3270_service_get_name @265
<     lib3270_session_free @266
<     lib3270_session_new @267
<     lib3270_set_as400 @268
<     lib3270_set_auto_reconnect @269
<     lib3270_set_boolean_property @270
<     lib3270_set_color_type @271
<     lib3270_set_connected_initial @272
<     lib3270_set_cursor_address @273
<     lib3270_set_cursor_position @274
<     lib3270_set_dft_buffersize @275
<     lib3270_set_disconnected @276
<     lib3270_set_field @277
<     lib3270_set_has_copy @278
<     lib3270_set_host_charset @279
<     lib3270_set_host_type @280
<     lib3270_set_host_type_by_name @281
<     lib3270_set_int_property @282
<     lib3270_set_lock_on_operator_error @283
<     lib3270_set_log_filename @284
<     lib3270_set_log_handler @285
<     lib3270_set_lunames @286
<     lib3270_set_model @287
<     lib3270_set_model_name @288
<     lib3270_set_model_number @289
<     lib3270_set_numeric_lock @290
<     lib3270_set_oversize @291
<     lib3270_set_poll_state @292
<     lib3270_set_popup_handler @293
<     lib3270_set_session_id @294
<     lib3270_set_string @295
<     lib3270_set_string_at @296
<     lib3270_set_string_at_address @297
<     lib3270_set_string_property @298
<     lib3270_set_syslog @299
<     lib3270_set_toggle @300
<     lib3270_set_trace_filename @301
<     lib3270_set_trace_handler @302
<     lib3270_set_tso @303
<     lib3270_set_uint_property @304
<     lib3270_set_unlock_delay @305
<     lib3270_set_url @306
<     lib3270_set_user_data @307
<     lib3270_setup_session @308
<     lib3270_ssl_get_crl_download @309
<     lib3270_ssl_set_crl_download @310
<     lib3270_state_get_name @311
<     lib3270_strdup @312
<     lib3270_strdup_printf @313
<     lib3270_strip @314
<     lib3270_sysreq @315
<     lib3270_testpattern @316
<     lib3270_toggle @317
<     lib3270_toggle_get_by_name @318
<     lib3270_toggle_get_description @319
<     lib3270_toggle_get_from_id @320
<     lib3270_toggle_get_label @321
<     lib3270_toggle_get_name @322
<     lib3270_toggle_get_summary @323
<     lib3270_trace_data @324
<     lib3270_trace_event @325
<     lib3270_translate_char @326
<     lib3270_translate_ft_message @327
<     lib3270_translate_to_address @328
<     lib3270_unregister_action_group_listener @329
<     lib3270_unregister_schange @330
<     lib3270_unregister_toggle_listener @331
<     lib3270_unselect @332
<     lib3270_unsigned_property_get_by_name @333
<     lib3270_update_poll_fd @334
<     lib3270_vsprintf @335
<     lib3270_wait @336
<     lib3270_wait_for_connected @337
<     lib3270_wait_for_cstate @338
<     lib3270_wait_for_keyboard_unlock @339
<     lib3270_wait_for_ready @340
<     lib3270_wait_for_string @341
<     lib3270_wait_for_string_at @342
<     lib3270_wait_for_string_at_address @343
<     lib3270_wait_for_update @344
<     lib3270_win32_create_regkey @345
<     lib3270_win32_get_dword @346
<     lib3270_win32_local_charset @347
<     lib3270_win32_set_string @348
<     lib3270_win32_strerror @349
<     lib3270_win32_translate_error_code @350
<     lib3270_write_dstrace @351
<     lib3270_write_event_trace @352
<     lib3270_write_log @353
<     lib3270_write_nettrace @354
<     lib3270_write_rc @355
<     lib3270_write_screen_trace @356
<     lib3270_write_trace @357
<     lib3270_write_va_log @358
---
> EXPORTS
>     lib3270_action @1
>     lib3270_action_activate @2
>     lib3270_action_get_by_name @3
>     lib3270_action_group_get_activatable @4
>     lib3270_action_group_notify @5
>     lib3270_action_is_activatable @6
>     lib3270_activate_by_name @7
>     lib3270_add_poll_fd @8
>     lib3270_allow_reconnect @9
>     lib3270_asc2ebc @10
>     lib3270_attn @11
>     lib3270_autoptr_cleanup_HKEY @12
>     lib3270_autoptr_cleanup_LIB3270_POPUP @13
>     lib3270_autoptr_cleanup_char @14
>     lib3270_backspace @15
>     lib3270_break @16
>     lib3270_build_config_filename @17
>     lib3270_build_data_filename @18
>     lib3270_build_filename @19
>     lib3270_calloc @20
>     lib3270_can_paste_next @21
>     lib3270_charsettable @22
>     lib3270_clear @23
>     lib3270_clear_operator_error @24
>     lib3270_cmp_string_at @25
>     lib3270_cmp_string_at_address @26
>     lib3270_connect_url @27
>     lib3270_connection_state_get_name @28
>     lib3270_crl_get_preferred_protocol @29
>     lib3270_crl_set_preferred_protocol @30
>     lib3270_cursor_down @31
>     lib3270_cursor_left @32
>     lib3270_cursor_right @33
>     lib3270_cursor_up @34
>     lib3270_cut_selected @35
>     lib3270_data_recv @36
>     lib3270_delete @37
>     lib3270_deletefield @38
>     lib3270_deleteword @39
>     lib3270_disconnect @40
>     lib3270_drag_selection @41
>     lib3270_dup @42
>     lib3270_ebc2asc @43
>     lib3270_emulate_input @44
>     lib3270_enter @45
>     lib3270_erase @46
>     lib3270_erase_selected @47
>     lib3270_eraseeof @48
>     lib3270_eraseeol @49
>     lib3270_eraseinput @50
>     lib3270_field_addr @51
>     lib3270_field_length @52
>     lib3270_fieldend @53
>     lib3270_fieldmark @54
>     lib3270_firstfield @55
>     lib3270_free @56
>     lib3270_ft_cancel @57
>     lib3270_ft_destroy @58
>     lib3270_ft_get_user_data @59
>     lib3270_ft_new @60
>     lib3270_ft_set_user_data @61
>     lib3270_ft_start @62
>     lib3270_get_action @63
>     lib3270_get_actions @64
>     lib3270_get_associated_luname @65
>     lib3270_get_attribute_at_address @66
>     lib3270_get_boolean_properties_list @67
>     lib3270_get_color_type @68
>     lib3270_get_connection_state @69
>     lib3270_get_contents @70
>     lib3270_get_cursor_address @71
>     lib3270_get_cursor_position @72
>     lib3270_get_default_charset @73
>     lib3270_get_default_host @74
>     lib3270_get_default_session_handle @75
>     lib3270_get_display_charset @76
>     lib3270_get_element @77
>     lib3270_get_field_attribute @78
>     lib3270_get_field_bounds @79
>     lib3270_get_field_end @80
>     lib3270_get_field_len @81
>     lib3270_get_field_start @82
>     lib3270_get_field_string_at @83
>     lib3270_get_ft_callbacks @84
>     lib3270_get_ft_state @85
>     lib3270_get_has_copy @86
>     lib3270_get_has_selection @87
>     lib3270_get_height @88
>     lib3270_get_host @89
>     lib3270_get_host_charset @90
>     lib3270_get_host_type @91
>     lib3270_get_host_type_name @92
>     lib3270_get_installation_path @93
>     lib3270_get_int_properties_list @94
>     lib3270_get_int_property @95
>     lib3270_get_is_protected @96
>     lib3270_get_is_protected_at @97
>     lib3270_get_keyboard_lock_state @98
>     lib3270_get_length @99
>     lib3270_get_lock_on_operator_error @100
>     lib3270_get_lock_status @101
>     lib3270_get_lunames @102
>     lib3270_get_max_height @103
>     lib3270_get_max_width @104
>     lib3270_get_model @105
>     lib3270_get_model_name @106
>     lib3270_get_model_number @107
>     lib3270_get_next_unprotected @108
>     lib3270_get_numeric_lock @109
>     lib3270_get_oia_box_solid @110
>     lib3270_get_option_list @111
>     lib3270_get_oversize @112
>     lib3270_get_pointer @113
>     lib3270_get_program_message @114
>     lib3270_get_region @115
>     lib3270_get_revision @116
>     lib3270_get_screen_size @117
>     lib3270_get_selected @118
>     lib3270_get_selected_text @119
>     lib3270_get_selection @120
>     lib3270_get_selection_bounds @121
>     lib3270_get_selection_flags @122
>     lib3270_get_selection_rectangle @123
>     lib3270_get_session_callbacks @124
>     lib3270_get_session_id @125
>     lib3270_get_ssl_crl_text @126
>     lib3270_get_ssl_peer_certificate_text @127
>     lib3270_get_ssl_state @128
>     lib3270_get_ssl_state_description @129
>     lib3270_get_ssl_state_icon_name @130
>     lib3270_get_ssl_state_message @131
>     lib3270_get_string_at @132
>     lib3270_get_string_at_address @133
>     lib3270_get_string_properties_list @134
>     lib3270_get_toggle @135
>     lib3270_get_toggle_description @136
>     lib3270_get_toggle_id @137
>     lib3270_get_toggle_label @138
>     lib3270_get_toggle_list @139
>     lib3270_get_toggle_name @140
>     lib3270_get_toggle_summary @141
>     lib3270_get_toggles @142
>     lib3270_get_trace_handler @143
>     lib3270_get_translation_domain @144
>     lib3270_get_typeahead @145
>     lib3270_get_undera @146
>     lib3270_get_unlock_delay @147
>     lib3270_get_unsigned_properties_list @148
>     lib3270_get_url @149
>     lib3270_get_user_data @150
>     lib3270_get_version @151
>     lib3270_get_version_info @152
>     lib3270_get_width @153
>     lib3270_get_word_bounds @154
>     lib3270_half_connected @155
>     lib3270_has_active_script @156
>     lib3270_has_selection @157
>     lib3270_host_get_name @158
>     lib3270_iconv_free @159
>     lib3270_iconv_from_host @160
>     lib3270_iconv_new @161
>     lib3270_iconv_to_host @162
>     lib3270_in_3270 @163
>     lib3270_in_ansi @164
>     lib3270_in_e @165
>     lib3270_in_neither @166
>     lib3270_in_sscp @167
>     lib3270_in_tn3270e @168
>     lib3270_input_string @169
>     lib3270_is_as400 @170
>     lib3270_is_connected @171
>     lib3270_is_disconnected @172
>     lib3270_is_formatted @173
>     lib3270_is_protected @174
>     lib3270_is_ready @175
>     lib3270_is_secure @176
>     lib3270_is_selected @177
>     lib3270_is_tso @178
>     lib3270_is_unlocked @179
>     lib3270_kybdreset @180
>     lib3270_load @181
>     lib3270_main_iterate @182
>     lib3270_malloc @183
>     lib3270_move_cursor @184
>     lib3270_move_selected_area @185
>     lib3270_move_selection @186
>     lib3270_newline @187
>     lib3270_nextfield @188
>     lib3270_nextword @189
>     lib3270_pakey @190
>     lib3270_parse_host_type @191
>     lib3270_paste_next @192
>     lib3270_paste_text @193
>     lib3270_pconnected @194
>     lib3270_pfkey @195
>     lib3270_popup @196
>     lib3270_popup_an_errno @197
>     lib3270_popup_clone_printf @198
>     lib3270_popup_dialog @199
>     lib3270_popup_va @200
>     lib3270_previousfield @201
>     lib3270_previousword @202
>     lib3270_print @203
>     lib3270_print_all @204
>     lib3270_print_copy @205
>     lib3270_print_selected @206
>     lib3270_property_get_by_name @207
>     lib3270_property_get_description @208
>     lib3270_property_get_label @209
>     lib3270_property_get_name @210
>     lib3270_property_get_summary @211
>     lib3270_property_get_tooltip @212
>     lib3270_realloc @213
>     lib3270_reconnect @214
>     lib3270_register_action_group_listener @215
>     lib3270_register_fd_handlers @216
>     lib3270_register_io_controller @217
>     lib3270_register_schange @218
>     lib3270_register_timer_handlers @219
>     lib3270_register_toggle_listener @220
>     lib3270_remap_char @221
>     lib3270_remove_poll @222
>     lib3270_remove_poll_fd @223
>     lib3270_reselect @224
>     lib3270_reset_callbacks @225
>     lib3270_reset_charset @226
>     lib3270_reset_ft_callbacks @227
>     lib3270_ring_bell @228
>     lib3270_run_task @229
>     lib3270_save @230
>     lib3270_save_all @231
>     lib3270_save_copy @232
>     lib3270_save_selected @233
>     lib3270_select_all @234
>     lib3270_select_field @235
>     lib3270_select_field_at @236
>     lib3270_select_region @237
>     lib3270_select_to @238
>     lib3270_select_word @239
>     lib3270_select_word_at @240
>     lib3270_selection_get_length @241
>     lib3270_selection_new @242
>     lib3270_service_get_name @243
>     lib3270_session_free @244
>     lib3270_session_new @245
>     lib3270_set_as400 @246
>     lib3270_set_boolean_property @247
>     lib3270_set_color_type @248
>     lib3270_set_connected_initial @249
>     lib3270_set_cursor_address @250
>     lib3270_set_cursor_position @251
>     lib3270_set_disconnected @252
>     lib3270_set_field @253
>     lib3270_set_has_copy @254
>     lib3270_set_host_charset @255
>     lib3270_set_host_type @256
>     lib3270_set_host_type_by_name @257
>     lib3270_set_int_property @258
>     lib3270_set_lock_on_operator_error @259
>     lib3270_set_log_handler @260
>     lib3270_set_lunames @261
>     lib3270_set_model @262
>     lib3270_set_model_name @263
>     lib3270_set_model_number @264
>     lib3270_set_numeric_lock @265
>     lib3270_set_oversize @266
>     lib3270_set_poll_state @267
>     lib3270_set_popup_handler @268
>     lib3270_set_session_id @269
>     lib3270_set_string @270
>     lib3270_set_string_at @271
>     lib3270_set_string_at_address @272
>     lib3270_set_string_property @273
>     lib3270_set_syslog @274
>     lib3270_set_toggle @275
>     lib3270_set_trace_handler @276
>     lib3270_set_tso @277
>     lib3270_set_uint_property @278
>     lib3270_set_unlock_delay @279
>     lib3270_set_url @280
>     lib3270_set_user_data @281
>     lib3270_setup_session @282
>     lib3270_ssl_get_crl_download @283
>     lib3270_ssl_set_crl_download @284
>     lib3270_state_get_name @285
>     lib3270_strdup @286
>     lib3270_strdup_printf @287
>     lib3270_sysreq @288
>     lib3270_testpattern @289
>     lib3270_toggle @290
>     lib3270_toggle_get_by_name @291
>     lib3270_toggle_get_description @292
>     lib3270_toggle_get_from_id @293
>     lib3270_toggle_get_label @294
>     lib3270_toggle_get_name @295
>     lib3270_toggle_get_summary @296
>     lib3270_trace_data @297
>     lib3270_trace_event @298
>     lib3270_translate_char @299
>     lib3270_translate_ft_message @300
>     lib3270_translate_to_address @301
>     lib3270_unregister_action_group_listener @302
>     lib3270_unregister_schange @303
>     lib3270_unregister_toggle_listener @304
>     lib3270_unselect @305
>     lib3270_unsigned_property_get_by_name @306
>     lib3270_update_poll_fd @307
>     lib3270_vsprintf @308
>     lib3270_wait @309
>     lib3270_wait_for_cstate @310
>     lib3270_wait_for_keyboard_unlock @311
>     lib3270_wait_for_ready @312
>     lib3270_wait_for_string @313
>     lib3270_wait_for_string_at @314
>     lib3270_wait_for_string_at_address @315
>     lib3270_wait_for_update @316
>     lib3270_win32_create_regkey @317
>     lib3270_win32_get_dword @318
>     lib3270_win32_local_charset @319
>     lib3270_win32_strerror @320
>     lib3270_win32_translate_error_code @321
>     lib3270_write_dstrace @322
>     lib3270_write_event_trace @323
>     lib3270_write_log @324
>     lib3270_write_nettrace @325
>     lib3270_write_rc @326
>     lib3270_write_screen_trace @327
>     lib3270_write_trace @328
>     lib3270_write_va_log @329
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: mingw-build.sh
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: msvc-build.sh
Only in lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win: PKGBUILD
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_32/mingw32-lib3270.spec lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_32/mingw32-lib3270.spec
47d46
< BuildRequires:	libtool
70c69
< %define MINOR_VERSION %(echo %{version} | cut -d. -f2 | cut -d+ -f1)
---
> %define MINOR_VERSION %(echo %{version} | cut -d. -f2)
115c114
< %_mingw32_find_lang %{_libname}-%{MAJOR_VERSION}.%{MINOR_VERSION} langfiles
---
> %_mingw32_find_lang %{_libname} langfiles
Only in source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_64: CHANGELOG
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_64/mingw64-lib3270.spec lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_64/mingw64-lib3270.spec
47d46
< BuildRequires:	libtool
56a56
> BuildRequires:	mingw64-libopenssl-devel
60,63d59
< BuildRequires:	mingw64-gettext-tools
< 
< BuildRequires:	mingw64(pkg:libcrypto) >= 1.1
< BuildRequires:	mingw64(pkg:libssl) >= 1.1
73c69
< %define MINOR_VERSION %(echo %{version} | cut -d. -f2 | cut -d+ -f1)
---
> %define MINOR_VERSION %(echo %{version} | cut -d. -f2)
118c114
< %_mingw64_find_lang %{_libname}-%{MAJOR_VERSION}.%{MINOR_VERSION} langfiles
---
> %_mingw64_find_lang %{_libname} langfiles
130c126
< %exclude %{_mingw64_libdir}/*.dll
---
> %{_mingw64_libdir}/*.dll
diff -r source-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_64/_service lookaside-lib3270-5.4.tar.gz-extracted/lib3270-5.4/win/x86_64/_service
5c5,6
< 		<param name="changesgenerate">enable</param>
---
>         <param name="changesgenerate">enable</param>
> 		<param name="versionformat">@PARENT_TAG@</param>
7d7
< 		<param name="versionformat">@PARENT_TAG@+git%cd</param>
9d8
< 		<param name="revision">develop</param>
