Source package : python-pyvmomi
File name       : pyvmomi-7.0.3.tar.gz
Lookaside URL   : https://src.fedoraproject.org/repo/pkgs/python-pyvmomi/pyvmomi-7.0.3.tar.gz/sha512/f3277cd1289bf66e549e342aa4e2f252e3926692af0cb613136bd683c9b75db8204571a7522f255afbe9c202399eadcb875ae0070f670579cb4622c203d9e00d/pyvmomi-7.0.3.tar.gz
Source URL      : https://files.pythonhosted.org/packages/source/p/pyvmomi/pyvmomi-7.0.3.tar.gz

source file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/source-pyvmomi-7.0.3.tar.gz: gzip compressed data, was "dist\pyvmomi-7.0.3.tar", last modified: Thu Oct 14 20:38:23 2021, max compression, original size modulo 2^32 6696960
lookaside file type: /tmp/fedora-lookaside-verification--620412-UnEb0Nzwp0B1/lookaside-pyvmomi-7.0.3.tar.gz: gzip compressed data, from Unix, original size modulo 2^32 6553600


Only in lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3: .gitignore
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/MANIFEST.in lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/MANIFEST.in
1,6c1,6
< include README.*
< include *.txt
< include setup.py
< include tox.ini
< recursive-include tests *
< recursive-include sample *
---
> include README.*
> include *.txt
> include setup.py
> include tox.ini
> recursive-include tests *
> recursive-include sample *
Only in source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3: PKG-INFO
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/connect.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/connect.py
1,934c1,934
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2021 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< ## @file connect.py
< ## @brief Connect to a VMOMI ServiceInstance.
< ##
< ## Detailed description (for Doxygen goes here)
< 
< """
< Connect to a VMOMI ServiceInstance.
< 
< Detailed description (for [e]pydoc goes here).
< """
< from six import reraise
< import sys
< import re
< import ssl
< from xml.etree import ElementTree
< from xml.parsers.expat import ExpatError
< from six.moves import http_client
< 
< import requests
< from requests.auth import HTTPBasicAuth
< 
< from pyVmomi import vim, vmodl, SoapStubAdapter, SessionOrientedStub
< from pyVmomi.SoapAdapter import CONNECTION_POOL_IDLE_TIMEOUT_SEC
< from pyVmomi.VmomiSupport import nsMap, versionIdMap, versionMap, IsChildVersion
< from pyVmomi.VmomiSupport import GetServiceVersions
< 
< 
< """
< Global regular expression for parsing host and port connection
< See http://www.ietf.org/rfc/rfc3986.txt sec 3.2.2
< """
< _rx = re.compile(r"(^\[.+\]|[^:]+)(:\d+)?$")
< 
< _si = None
< """
< Global (thread-shared) ServiceInstance
< 
< @todo: Get rid of me?
< """
< 
< 
< def getSslContext(host, sslContext, disableSslCertValidation):
<     """
<     Connections to 'localhost' do not need SSL verification as a certificate
<     will never match. The OS provides security by only allowing root to bind
<     to low-numbered ports.
<     """
<     if disableSslCertValidation or (not sslContext and host in ['localhost', '127.0.0.1', '::1']):
<         sslContext = ssl._create_unverified_context()
<     return sslContext
< 
< class closing(object):
<    """
<    Helper class for using closable objects in a 'with' statement,
<    similar to the one provided by contextlib.
<    """
<    def __init__(self, obj):
<       self.obj = obj
<    def __enter__(self):
<       return self.obj
<    def __exit__(self, *exc_info):
<       self.obj.close()
< 
< 
< class VimSessionOrientedStub(SessionOrientedStub):
<    '''A vim-specific SessionOrientedStub.  See the SessionOrientedStub class
<    in pyVmomi/SoapAdapter.py for more information.'''
< 
<    # The set of exceptions that should trigger a relogin by the session stub.
<    SESSION_EXCEPTIONS = (
<       vim.fault.NotAuthenticated,
<       )
< 
<    @staticmethod
<    def makeUserLoginMethod(username, password, locale=None):
<       '''Return a function that will call the vim.SessionManager.Login() method
<       with the given parameters.  The result of this function can be passed as
<       the "loginMethod" to a SessionOrientedStub constructor.'''
<       def _doLogin(soapStub):
<          si = vim.ServiceInstance("ServiceInstance", soapStub)
<          sm = si.content.sessionManager
<          if not sm.currentSession:
<             si.content.sessionManager.Login(username, password, locale)
< 
<       return _doLogin
< 
<    @staticmethod
<    def makeExtensionLoginMethod(extensionKey):
<       '''Return a function that will call the vim.SessionManager.Login() method
<       with the given parameters.  The result of this function can be passed as
<       the "loginMethod" to a SessionOrientedStub constructor.'''
<       def _doLogin(soapStub):
<          si = vim.ServiceInstance("ServiceInstance", soapStub)
<          sm = si.content.sessionManager
<          if not sm.currentSession:
<             si.content.sessionManager.LoginExtensionByCertificate(extensionKey)
< 
<       return _doLogin
< 
<    @staticmethod
<    def makeCertHokTokenLoginMethod(stsUrl, stsCert=None):
<       '''Return a function that will call the vim.SessionManager.LoginByToken()
<       after obtaining a HoK SAML token from the STS. The result of this function
<       can be passed as the "loginMethod" to a SessionOrientedStub constructor.
< 
<       @param stsUrl: URL of the SAML Token issuing service. (i.e. SSO server).
<       @param stsCert: public key of the STS service.
<       '''
<       assert(stsUrl)
< 
<       def _doLogin(soapStub):
<          from . import sso
<          cert =  soapStub.schemeArgs['cert_file']
<          key = soapStub.schemeArgs['key_file']
<          authenticator = sso.SsoAuthenticator(sts_url=stsUrl,
<                                               sts_cert=stsCert)
< 
<          samlAssertion = authenticator.get_hok_saml_assertion(cert,key)
< 
< 
<          def _requestModifier(request):
<             return sso.add_saml_context(request, samlAssertion, key)
< 
<          si = vim.ServiceInstance("ServiceInstance", soapStub)
<          sm = si.content.sessionManager
<          if not sm.currentSession:
<             with soapStub.requestModifier(_requestModifier):
<                try:
<                   soapStub.samlToken = samlAssertion
<                   si.content.sessionManager.LoginByToken()
<                finally:
<                   soapStub.samlToken = None
< 
<       return _doLogin
< 
<    @staticmethod
<    def makeCredBearerTokenLoginMethod(username,
<                                       password,
<                                       stsUrl,
<                                       stsCert=None):
<       '''Return a function that will call the vim.SessionManager.LoginByToken()
<       after obtaining a Bearer token from the STS. The result of this function
<       can be passed as the "loginMethod" to a SessionOrientedStub constructor.
< 
<       @param username: username of the user/service registered with STS.
<       @param password: password of the user/service registered with STS.
<       @param stsUrl: URL of the SAML Token issueing service. (i.e. SSO server).
<       @param stsCert: public key of the STS service.
<       '''
<       assert(username)
<       assert(password)
<       assert(stsUrl)
< 
<       def _doLogin(soapStub):
<          from . import sso
<          cert = soapStub.schemeArgs['cert_file']
<          key = soapStub.schemeArgs['key_file']
<          authenticator = sso.SsoAuthenticator(sts_url=stsUrl,
<                                               sts_cert=stsCert)
<          samlAssertion = authenticator.get_bearer_saml_assertion(username,
<                                                                  password,
<                                                                  cert,
<                                                                  key)
<          si = vim.ServiceInstance("ServiceInstance", soapStub)
<          sm = si.content.sessionManager
<          if not sm.currentSession:
<             try:
<                soapStub.samlToken = samlAssertion
<                si.content.sessionManager.LoginByToken()
<             finally:
<                soapStub.samlToken = None
< 
<       return _doLogin
< 
< 
< def Connect(host='localhost', port=443, user='root', pwd='',
<             service="hostd", adapter="SOAP", namespace=None, path="/sdk",
<             connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
<             version=None, keyFile=None, certFile=None, thumbprint=None,
<             sslContext=None, b64token=None, mechanism='userpass', disableSslCertValidation=False):
<    """
<    Connect to the specified server, login and return the service
<    instance object.
< 
<    Throws any exception back to caller. The service instance object is
<    also saved in the library for easy access.
< 
<    Clients should modify the service parameter only when connecting to
<    a VMOMI server other than hostd/vpxd. For both of the latter, the
<    default value is fine.
< 
<    @param host: Which host to connect to.
<    @type  host: string
<    @param port: Port
<    @type  port: int
<    @param user: User
<    @type  user: string
<    @param pwd: Password
<    @type  pwd: string
<    @param service: Service
<    @type  service: string
<    @param adapter: Adapter
<    @type  adapter: string
<    @param namespace: Namespace *** Deprecated: Use version instead ***
<    @type  namespace: string
<    @param path: Path
<    @type  path: string
<    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
<                                  closing the connections
<    @type  connectionPoolTimeout: int
<    @param version: Version
<    @type  version: string
<    @param keyFile: ssl key file path
<    @type  keyFile: string
<    @param certFile: ssl cert file path
<    @type  certFile: string
<    @param thumbprint: host cert thumbprint
<    @type  thumbprint: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    @param b64token: base64 encoded token
<    @type  b64token: string
<    @param mechanism: authentication mechanism: userpass or sspi
<    @type  mechanism: string
<    @type disableSslCertValidation: bool
<    @param disableSslCertValidation: Creates an unverified SSL context when True.
<    """
<    try:
<       info = re.match(_rx, host)
<       if info is not None:
<          host = info.group(1)
<          if host[0] == '[':
<             host = info.group(1)[1:-1]
<          if info.group(2) is not None:
<             port = int(info.group(2)[1:])
<    except ValueError as ve:
<       pass
< 
<    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
< 
<    if namespace:
<       assert(version is None)
<       version = versionMap[namespace]
<    elif not version:
<       version = "vim.version.version6"
< 
<    si, stub = None, None
<    if mechanism == 'userpass':
<       si, stub = __Login(host, port, user, pwd, service, adapter, version, path,
<                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
<    elif mechanism == 'sspi':
<       si, stub = __LoginBySSPI(host, port, service, adapter, version, path,
<                                keyFile, certFile, thumbprint, sslContext, b64token, connectionPoolTimeout)
<    else:
<       raise Exception('''The provided connection mechanism is not available, the
<               supported mechanisms are userpass or sspi''')
< 
<    SetSi(si)
< 
<    return si
< 
< # ConnectNoSSL() is deprecated. Use Connect(disableSslCertValidation=True).
< def ConnectNoSSL(host='localhost', port=443, user='root', pwd='',
<                  service="hostd", adapter="SOAP", namespace=None, path="/sdk",
<                  version=None, keyFile=None, certFile=None, thumbprint=None,
<                  b64token=None, mechanism='userpass'):
<    """
<    Provides a standard method for connecting to a specified server without SSL
<    verification. Useful when connecting to servers with self-signed certificates
<    or when you wish to ignore SSL altogether. Will attempt to create an unverified
<    SSL context and then connect via the Connect method.
<    """
< 
<    sslContext = ssl._create_unverified_context()
< 
<    return Connect(host=host,
<                   port=port,
<                   user=user,
<                   pwd=pwd,
<                   service=service,
<                   adapter=adapter,
<                   namespace=namespace,
<                   path=path,
<                   version=version,
<                   keyFile=keyFile,
<                   certFile=certFile,
<                   thumbprint=thumbprint,
<                   sslContext=sslContext,
<                   b64token=b64token,
<                   mechanism=mechanism)
< 
< def Disconnect(si):
<    """
<    Disconnect (logout) service instance
<    @param si: Service instance (returned from Connect)
<    """
<    # Logout
<    __Logout(si)
<    SetSi(None)
< 
< 
< ## Method that gets a local ticket for the specified user
< def GetLocalTicket(si, user):
<    try:
<       sessionManager = si.content.sessionManager
<    except Exception as e:
<       if type(e).__name__ == 'ExpatError':
<          msg = 'Malformed response while querying for local ticket: "%s"' % e
<          raise vim.fault.HostConnectFault(msg=msg)
<       else:
<          msg = 'Failed to query for local ticket: "%s"' % e
<          raise vim.fault.HostConnectFault(msg=msg)
<    localTicket = sessionManager.AcquireLocalTicket(userName=user)
<    with open(localTicket.passwordFilePath) as f:
<       content = f.read()
<    return localTicket.userName, content
< 
< 
< ## Private method that performs the actual Connect and returns a
< ## connected service instance object.
< 
< def __Login(host, port, user, pwd, service, adapter, version, path,
<             keyFile, certFile, thumbprint, sslContext,
<             connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
<    """
<    Private method that performs the actual Connect and returns a
<    connected service instance object.
< 
<    @param host: Which host to connect to.
<    @type  host: string
<    @param port: Port
<    @type  port: int
<    @param user: User
<    @type  user: string
<    @param pwd: Password
<    @type  pwd: string
<    @param service: Service
<    @type  service: string
<    @param adapter: Adapter
<    @type  adapter: string
<    @param version: Version
<    @type  version: string
<    @param path: Path
<    @type  path: string
<    @param keyFile: ssl key file path
<    @type  keyFile: string
<    @param certFile: ssl cert file path
<    @type  certFile: string
<    @param thumbprint: host cert thumbprint
<    @type  thumbprint: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
<                                  closing the connections
<    @type  connectionPoolTimeout: int
<    """
< 
<    content, si, stub = __RetrieveContent(host, port, adapter, version, path,
<                                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
< 
<    # Get a ticket if we're connecting to localhost and password is not specified
<    if host == 'localhost' and not pwd:
<       try:
<          (user, pwd) = GetLocalTicket(si, user)
<       except:
<          pass # This is not supported against vCenter, and connecting
<               # with an empty password is fine in debug builds
< 
<    # Login
<    try:
<       x = content.sessionManager.Login(user, pwd, None)
<    except vim.fault.InvalidLogin:
<       raise
<    except Exception as e:
<       raise
<    return si, stub
< 
< ## Private method that performs LoginBySSPI and returns a
< ## connected service instance object.
< ## Copyright (c) 2015 Morgan Stanley.  All rights reserved.
< 
< def __LoginBySSPI(host, port, service, adapter, version, path,
<                   keyFile, certFile, thumbprint, sslContext, b64token,
<                   connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
<    """
<    Private method that performs the actual Connect and returns a
<    connected service instance object.
< 
<    @param host: Which host to connect to.
<    @type  host: string
<    @param port: Port
<    @type  port: int
<    @param service: Service
<    @type  service: string
<    @param adapter: Adapter
<    @type  adapter: string
<    @param version: Version
<    @type  version: string
<    @param path: Path
<    @type  path: string
<    @param keyFile: ssl key file path
<    @type  keyFile: string
<    @param certFile: ssl cert file path
<    @type  certFile: string
<    @param thumbprint: host cert thumbprint
<    @type  thumbprint: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    @param b64token: base64 encoded token
<    @type  b64token: string
<    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
<                                  closing the connections
<    @type  connectionPoolTimeout: int
<    """
< 
<    content, si, stub = __RetrieveContent(host, port, adapter, version, path,
<                                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
< 
<    if b64token is None:
<       raise Exception('Token is not defined for sspi login')
< 
<    # Login
<    try:
<       x = content.sessionManager.LoginBySSPI(b64token)
<    except vim.fault.InvalidLogin:
<       raise
<    except Exception as e:
<       raise
<    return si, stub
< 
< ## Private method that performs the actual Disonnect
< 
< def __Logout(si):
<    """
<    Disconnect (logout) service instance
<    @param si: Service instance (returned from Connect)
<    """
<    try:
<       if si:
<          content = si.RetrieveContent()
<          content.sessionManager.Logout()
<    except Exception as e:
<       pass
< 
< ## Private method that returns the service content
< 
< def __RetrieveContent(host, port, adapter, version, path, keyFile, certFile,
<                       thumbprint, sslContext, connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
<    """
<    Retrieve service instance for connection.
<    @param host: Which host to connect to.
<    @type  host: string
<    @param port: Port
<    @type  port: int
<    @param adapter: Adapter
<    @type  adapter: string
<    @param version: Version
<    @type  version: string
<    @param path: Path
<    @type  path: string
<    @param keyFile: ssl key file path
<    @type  keyFile: string
<    @param certFile: ssl cert file path
<    @type  certFile: string
<    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
<                                  closing the connections
<    @type  connectionPoolTimeout: int
<    """
< 
<    # XXX remove the adapter and service arguments once dependent code is fixed
<    if adapter != "SOAP":
<       raise ValueError(adapter)
< 
<    # Create the SOAP stub adapter
<    stub = SoapStubAdapter(host, port, version=version, path=path,
<                           certKeyFile=keyFile, certFile=certFile,
<                           thumbprint=thumbprint, sslContext=sslContext,
<                           connectionPoolTimeout=connectionPoolTimeout)
< 
<    # Get Service instance
<    si = vim.ServiceInstance("ServiceInstance", stub)
<    content = None
<    try:
<       content = si.RetrieveContent()
<    except vmodl.MethodFault:
<       raise
<    except Exception as e:
<       # NOTE (hartsock): preserve the traceback for diagnostics
<       # pulling and preserving the traceback makes diagnosing connection
<       # failures easier since the fault will also include where inside the
<       # library the fault occurred. Without the traceback we have no idea
<       # why the connection failed beyond the message string.
<       (type, value, traceback) = sys.exc_info()
<       if traceback:
<          fault = vim.fault.HostConnectFault(msg=str(e))
<          reraise(vim.fault.HostConnectFault, fault, traceback)
<       else:
<           raise vim.fault.HostConnectFault(msg=str(e))
< 
<    return content, si, stub
< 
< 
< ## Get the saved service instance.
< 
< def GetSi():
<    """ Get the saved service instance. """
<    return _si
< 
< 
< ## Set the saved service instance.
< 
< def SetSi(si):
<    """ Set the saved service instance. """
< 
<    global _si
<    _si = si
< 
< 
< ## Get the global saved stub
< 
< def GetStub():
<    """ Get the global saved stub. """
<    si = GetSi()
<    if si:
<       return si._GetStub()
<    return None;
< 
< ## RAII-style class for managing connections
< 
< class Connection(object):
<    def __init__(self, *args, **kwargs):
<       self.args = args
<       self.kwargs = kwargs
<       self.si = None
< 
<    def __enter__(self):
<       self.si = Connect(*self.args, **self.kwargs)
<       return self.si
< 
<    def __exit__(self, *exc_info):
<       if self.si:
<          Disconnect(self.si)
<          self.si = None
< 
< class SmartConnection(object):
<    def __init__(self, *args, **kwargs):
<       self.args = args
<       self.kwargs = kwargs
<       self.si = None
< 
<    def __enter__(self):
<       self.si = SmartConnect(*self.args, **self.kwargs)
<       return self.si
< 
<    def __exit__(self, *exc_info):
<       if self.si:
<          Disconnect(self.si)
<          self.si = None
< 
< def __GetElementTree(protocol, server, port, path, sslContext, httpProxyHost=None, httpProxyPort=None):
<    """
<    Private method that returns a root from ElementTree for a remote XML document.
< 
<    @param protocol: What protocol to use for the connection (e.g. https or http).
<    @type  protocol: string
<    @param server: Which server to connect to.
<    @type  server: string
<    @param port: Port
<    @type  port: int
<    @param path: Path
<    @type  path: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    """
< 
<    if httpProxyHost:
<       kwargs = {"context": sslContext} if sslContext else {}
<       conn = http_client.HTTPSConnection(httpProxyHost, port=httpProxyPort, **kwargs)
<       conn.set_tunnel(server, port)
<    elif protocol == "https":
<       kwargs = {"context": sslContext} if sslContext else {}
<       conn = http_client.HTTPSConnection(server, port=port, **kwargs)
<    elif protocol == "http":
<       conn = http_client.HTTPConnection(server, port=port)
<    else:
<       raise Exception("Protocol " + protocol + " not supported.")
<    conn.request("GET", path)
<    response = conn.getresponse()
<    if response.status == 200:
<       try:
<          tree = ElementTree.fromstring(response.read())
<          return tree
<       except ExpatError:
<          pass
<    return None
< 
< ## Private method that returns an ElementTree describing the API versions
< ## supported by the specified server.  The result will be vimServiceVersions.xml
< ## if it exists, otherwise vimService.wsdl if it exists, otherwise None.
< 
< def __GetServiceVersionDescription(protocol, server, port, path, sslContext, httpProxyHost=None, httpProxyPort=None):
<    """
<    Private method that returns a root from an ElementTree describing the API versions
<    supported by the specified server.  The result will be vimServiceVersions.xml
<    if it exists, otherwise vimService.wsdl if it exists, otherwise None.
< 
<    @param protocol: What protocol to use for the connection (e.g. https or http).
<    @type  protocol: string
<    @param server: Which server to connect to.
<    @type  server: string
<    @param port: Port
<    @type  port: int
<    @param path: Path
<    @type  path: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    """
< 
<    tree = __GetElementTree(protocol, server, port,
<                            path + "/vimServiceVersions.xml", sslContext,
<                            httpProxyHost, httpProxyPort)
<    if tree is not None:
<       return tree
< 
<    tree = __GetElementTree(protocol, server, port,
<                            path + "/vimService.wsdl", sslContext,
<                            httpProxyHost, httpProxyPort)
<    return tree
< 
< 
< ## Private method that returns true if the service version description document
< ##  indicates that the desired version is supported
< 
< def __VersionIsSupported(desiredVersion, serviceVersionDescription):
<    """
<    Private method that returns true if the service version description document
<    indicates that the desired version is supported
< 
<    @param desiredVersion: The version we want to see if the server supports
<                           (eg. vim.version.version2.
<    @type  desiredVersion: string
<    @param serviceVersionDescription: A root ElementTree for vimServiceVersions.xml
<                                      or vimService.wsdl.
<    @type  serviceVersionDescription: root ElementTree
<    """
< 
<    root = serviceVersionDescription
<    if root.tag == 'namespaces':
<       # serviceVersionDescription appears to be a vimServiceVersions.xml document
<       if root.get('version') != '1.0':
<          raise RuntimeError('vimServiceVersions.xml has version %s,' \
<              ' which is not understood' % (root.get('version')))
<       desiredVersionId = versionIdMap[desiredVersion]
<       supportedVersion = None
<       for namespace in root.findall('namespace'):
<          versionId = namespace.findtext('version')
<          if versionId == desiredVersionId:
<             return True
<          else:
<             for versionId in namespace.findall('priorVersions/version'):
<                if versionId.text == desiredVersionId:
<                   return True
<    else:
<       # serviceVersionDescription must be a vimService.wsdl document
<       wsdlNS = 'http://schemas.xmlsoap.org/wsdl/'
<       importElement = serviceVersionDescription.find('.//{%s}import' % wsdlNS)
<       supportedVersion = versionMap[importElement.get('namespace')[4:]]
<       if IsChildVersion(supportedVersion, desiredVersion):
<          return True
<    return False
< 
< 
< ## Private method that returns the most preferred API version supported by the
< ## specified server,
< 
< def __FindSupportedVersion(protocol, server, port, path, preferredApiVersions, sslContext, httpProxyHost=None, httpProxyPort=None):
<    """
<    Private method that returns the most preferred API version supported by the
<    specified server,
< 
<    @param protocol: What protocol to use for the connection (e.g. https or http).
<    @type  protocol: string
<    @param server: Which server to connect to.
<    @type  server: string
<    @param port: Port
<    @type  port: int
<    @param path: Path
<    @type  path: string
<    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
<                                 If a list of versions is specified the versions should
<                                 be ordered from most to least preferred.
<    @type  preferredApiVersions: string or string list
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    """
< 
<    serviceVersionDescription = __GetServiceVersionDescription(protocol,
<                                                               server,
<                                                               port,
<                                                               path,
<                                                               sslContext,
<                                                               httpProxyHost,
<                                                               httpProxyPort)
<    if serviceVersionDescription is None:
<       return None
< 
<    if not isinstance(preferredApiVersions, list):
<       preferredApiVersions = [ preferredApiVersions ]
< 
<    for desiredVersion in preferredApiVersions:
<       if __VersionIsSupported(desiredVersion, serviceVersionDescription):
<          return desiredVersion
<    return None
< 
< def SmartStubAdapter(host='localhost', port=443, path='/sdk',
<                      url=None, sock=None, poolSize=5,
<                      certFile=None, certKeyFile=None,
<                      httpProxyHost=None, httpProxyPort=80, sslProxyPath=None,
<                      thumbprint=None, cacertsFile=None, preferredApiVersions=None,
<                      acceptCompressedResponses=True,
<                      connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
<                      samlToken=None, sslContext=None, disableSslCertValidation=False):
<    """
<    Determine the most preferred API version supported by the specified server,
<    then create a soap stub adapter using that version
< 
<    The parameters are the same as for pyVmomi.SoapStubAdapter except for
<    version which is renamed to prefferedApiVersions
< 
<    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
<                                 If a list of versions is specified the versions should
<                                 be ordered from most to least preferred.  If None is
<                                 specified, the list of versions support by pyVmomi will
<                                 be used.
<    @type  preferredApiVersions: string or string list
<    @type disableSslCertValidation: bool
<    @param disableSslCertValidation: Creates an unverified SSL context when True.
<    """
<    if preferredApiVersions is None:
<       preferredApiVersions = GetServiceVersions('vim25')
< 
<    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
< 
<    supportedVersion = __FindSupportedVersion('https' if port > 0 else 'http',
<                                              host,
<                                              port,
<                                              path,
<                                              preferredApiVersions,
<                                              sslContext,
<                                              httpProxyHost,
<                                              httpProxyPort
<                                              )
<    if supportedVersion is None:
<       raise Exception("%s:%s is not a VIM server" % (host, port))
< 
<    return SoapStubAdapter(host=host, port=port, path=path,
<                           url=url, sock=sock, poolSize=poolSize,
<                           certFile=certFile, certKeyFile=certKeyFile,
<                           httpProxyHost=httpProxyHost, httpProxyPort=httpProxyPort,
<                           sslProxyPath=sslProxyPath, thumbprint=thumbprint,
<                           cacertsFile=cacertsFile, version=supportedVersion,
<                           acceptCompressedResponses=acceptCompressedResponses,
<                           connectionPoolTimeout=connectionPoolTimeout,
<                           samlToken=samlToken, sslContext=sslContext)
< 
< def SmartConnect(protocol='https', host='localhost', port=443, user='root', pwd='',
<                  service="hostd", path="/sdk", connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
<                  preferredApiVersions=None, keyFile=None, certFile=None,
<                  thumbprint=None, sslContext=None, b64token=None, mechanism='userpass',
<                  disableSslCertValidation=False):
<    """
<    Determine the most preferred API version supported by the specified server,
<    then connect to the specified server using that API version, login and return
<    the service instance object.
< 
<    Throws any exception back to caller. The service instance object is
<    also saved in the library for easy access.
< 
<    Clients should modify the service parameter only when connecting to
<    a VMOMI server other than hostd/vpxd. For both of the latter, the
<    default value is fine.
< 
<    @param protocol: What protocol to use for the connection (e.g. https or http).
<    @type  protocol: string
<    @param host: Which host to connect to.
<    @type  host: string
<    @param port: Port
<    @type  port: int
<    @param user: User
<    @type  user: string
<    @param pwd: Password
<    @type  pwd: string
<    @param service: Service
<    @type  service: string
<    @param path: Path
<    @type  path: string
<    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
<                                  closing the connections
<    @type  connectionPoolTimeout: int
<    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
<                                 If a list of versions is specified the versions should
<                                 be ordered from most to least preferred.  If None is
<                                 specified, the list of versions support by pyVmomi will
<                                 be used.
<    @type  preferredApiVersions: string or string list
<    @param keyFile: ssl key file path
<    @type  keyFile: string
<    @param certFile: ssl cert file path
<    @type  certFile: string
<    @param thumbprint: host cert thumbprint
<    @type  thumbprint: string
<    @param sslContext: SSL Context describing the various SSL options. It is only
<                       supported in Python 2.7.9 or higher.
<    @type  sslContext: SSL.Context
<    @type disableSslCertValidation: bool
<    @param disableSslCertValidation: Creates an unverified SSL context when True.
<    """
< 
<    if preferredApiVersions is None:
<       preferredApiVersions = GetServiceVersions('vim25')
< 
<    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
< 
<    supportedVersion = __FindSupportedVersion(protocol,
<                                              host,
<                                              port,
<                                              path,
<                                              preferredApiVersions,
<                                              sslContext)
<    if supportedVersion is None:
<       raise Exception("%s:%s is not a VIM server" % (host, port))
< 
<    portNumber = protocol == "http" and -int(port) or int(port)
< 
<    return Connect(host=host,
<                   port=portNumber,
<                   user=user,
<                   pwd=pwd,
<                   service=service,
<                   adapter='SOAP',
<                   version=supportedVersion,
<                   path=path,
<                   connectionPoolTimeout=connectionPoolTimeout,
<                   keyFile=keyFile,
<                   certFile=certFile,
<                   thumbprint=thumbprint,
<                   sslContext=sslContext,
<                   b64token=b64token,
<                   mechanism=mechanism,
<                   disableSslCertValidation=disableSslCertValidation)
< 
< # SmartConnectNoSSL() is deprecated. Use SmartConnect(disableSslCertValidation=True).
< def SmartConnectNoSSL(protocol='https', host='localhost', port=443, user='root', pwd='',
<                       service="hostd", path="/sdk", connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
<                       preferredApiVersions=None, keyFile=None, certFile=None,
<                       thumbprint=None, b64token=None, mechanism='userpass'):
<    """
<    Provides a standard method for connecting to a specified server without SSL
<    verification. Useful when connecting to servers with self-signed certificates
<    or when you wish to ignore SSL altogether. Will attempt to create an unverified
<    SSL context and then connect via the SmartConnect method.
<    """
< 
<    sslContext = ssl._create_unverified_context()
< 
<    return SmartConnect(protocol=protocol,
<                        host=host,
<                        port=port,
<                        user=user,
<                        pwd=pwd,
<                        service=service,
<                        path=path,
<                        connectionPoolTimeout=connectionPoolTimeout,
<                        preferredApiVersions=preferredApiVersions,
<                        keyFile=keyFile,
<                        certFile=certFile,
<                        thumbprint=thumbprint,
<                        sslContext=sslContext,
<                        b64token=b64token,
<                        mechanism=mechanism)
< 
< def OpenUrlWithBasicAuth(url, user='root', pwd='', verify=True):
<    """
<    Open the specified URL, using HTTP basic authentication to provide
<    the specified credentials to the server as part of the request.
<    Returns the response as a file-like object.
<    """
<    return requests.get(url, auth=HTTPBasicAuth(user, pwd), verify=verify)
< 
< def OpenPathWithStub(path, stub, verify=True):
<    """
<    Open the specified path using HTTP, using the host/port/protocol
<    associated with the specified stub.  If the stub has a session cookie,
<    it is included with the HTTP request.  Returns the response as a
<    file-like object.
<    """
<    from six.moves import http_client
<    if not hasattr(stub, 'scheme'):
<       raise vmodl.fault.NotSupported()
<    elif stub.scheme == http_client.HTTPConnection:
<       protocol = 'http'
<       verify = False
<    elif stub.scheme == http_client.HTTPSConnection:
<       protocol = 'https'
<    else:
<       raise vmodl.fault.NotSupported()
<    hostPort = stub.host
<    url = '%s://%s%s' % (protocol, hostPort, path)
<    headers = {}
<    if stub.cookie:
<       headers["Cookie"] = stub.cookie
<    return requests.get(url, headers=headers, verify=verify)
< 
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2021 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> ## @file connect.py
> ## @brief Connect to a VMOMI ServiceInstance.
> ##
> ## Detailed description (for Doxygen goes here)
> 
> """
> Connect to a VMOMI ServiceInstance.
> 
> Detailed description (for [e]pydoc goes here).
> """
> from six import reraise
> import sys
> import re
> import ssl
> from xml.etree import ElementTree
> from xml.parsers.expat import ExpatError
> from six.moves import http_client
> 
> import requests
> from requests.auth import HTTPBasicAuth
> 
> from pyVmomi import vim, vmodl, SoapStubAdapter, SessionOrientedStub
> from pyVmomi.SoapAdapter import CONNECTION_POOL_IDLE_TIMEOUT_SEC
> from pyVmomi.VmomiSupport import nsMap, versionIdMap, versionMap, IsChildVersion
> from pyVmomi.VmomiSupport import GetServiceVersions
> 
> 
> """
> Global regular expression for parsing host and port connection
> See http://www.ietf.org/rfc/rfc3986.txt sec 3.2.2
> """
> _rx = re.compile(r"(^\[.+\]|[^:]+)(:\d+)?$")
> 
> _si = None
> """
> Global (thread-shared) ServiceInstance
> 
> @todo: Get rid of me?
> """
> 
> 
> def getSslContext(host, sslContext, disableSslCertValidation):
>     """
>     Connections to 'localhost' do not need SSL verification as a certificate
>     will never match. The OS provides security by only allowing root to bind
>     to low-numbered ports.
>     """
>     if disableSslCertValidation or (not sslContext and host in ['localhost', '127.0.0.1', '::1']):
>         sslContext = ssl._create_unverified_context()
>     return sslContext
> 
> class closing(object):
>    """
>    Helper class for using closable objects in a 'with' statement,
>    similar to the one provided by contextlib.
>    """
>    def __init__(self, obj):
>       self.obj = obj
>    def __enter__(self):
>       return self.obj
>    def __exit__(self, *exc_info):
>       self.obj.close()
> 
> 
> class VimSessionOrientedStub(SessionOrientedStub):
>    '''A vim-specific SessionOrientedStub.  See the SessionOrientedStub class
>    in pyVmomi/SoapAdapter.py for more information.'''
> 
>    # The set of exceptions that should trigger a relogin by the session stub.
>    SESSION_EXCEPTIONS = (
>       vim.fault.NotAuthenticated,
>       )
> 
>    @staticmethod
>    def makeUserLoginMethod(username, password, locale=None):
>       '''Return a function that will call the vim.SessionManager.Login() method
>       with the given parameters.  The result of this function can be passed as
>       the "loginMethod" to a SessionOrientedStub constructor.'''
>       def _doLogin(soapStub):
>          si = vim.ServiceInstance("ServiceInstance", soapStub)
>          sm = si.content.sessionManager
>          if not sm.currentSession:
>             si.content.sessionManager.Login(username, password, locale)
> 
>       return _doLogin
> 
>    @staticmethod
>    def makeExtensionLoginMethod(extensionKey):
>       '''Return a function that will call the vim.SessionManager.Login() method
>       with the given parameters.  The result of this function can be passed as
>       the "loginMethod" to a SessionOrientedStub constructor.'''
>       def _doLogin(soapStub):
>          si = vim.ServiceInstance("ServiceInstance", soapStub)
>          sm = si.content.sessionManager
>          if not sm.currentSession:
>             si.content.sessionManager.LoginExtensionByCertificate(extensionKey)
> 
>       return _doLogin
> 
>    @staticmethod
>    def makeCertHokTokenLoginMethod(stsUrl, stsCert=None):
>       '''Return a function that will call the vim.SessionManager.LoginByToken()
>       after obtaining a HoK SAML token from the STS. The result of this function
>       can be passed as the "loginMethod" to a SessionOrientedStub constructor.
> 
>       @param stsUrl: URL of the SAML Token issuing service. (i.e. SSO server).
>       @param stsCert: public key of the STS service.
>       '''
>       assert(stsUrl)
> 
>       def _doLogin(soapStub):
>          from . import sso
>          cert =  soapStub.schemeArgs['cert_file']
>          key = soapStub.schemeArgs['key_file']
>          authenticator = sso.SsoAuthenticator(sts_url=stsUrl,
>                                               sts_cert=stsCert)
> 
>          samlAssertion = authenticator.get_hok_saml_assertion(cert,key)
> 
> 
>          def _requestModifier(request):
>             return sso.add_saml_context(request, samlAssertion, key)
> 
>          si = vim.ServiceInstance("ServiceInstance", soapStub)
>          sm = si.content.sessionManager
>          if not sm.currentSession:
>             with soapStub.requestModifier(_requestModifier):
>                try:
>                   soapStub.samlToken = samlAssertion
>                   si.content.sessionManager.LoginByToken()
>                finally:
>                   soapStub.samlToken = None
> 
>       return _doLogin
> 
>    @staticmethod
>    def makeCredBearerTokenLoginMethod(username,
>                                       password,
>                                       stsUrl,
>                                       stsCert=None):
>       '''Return a function that will call the vim.SessionManager.LoginByToken()
>       after obtaining a Bearer token from the STS. The result of this function
>       can be passed as the "loginMethod" to a SessionOrientedStub constructor.
> 
>       @param username: username of the user/service registered with STS.
>       @param password: password of the user/service registered with STS.
>       @param stsUrl: URL of the SAML Token issueing service. (i.e. SSO server).
>       @param stsCert: public key of the STS service.
>       '''
>       assert(username)
>       assert(password)
>       assert(stsUrl)
> 
>       def _doLogin(soapStub):
>          from . import sso
>          cert = soapStub.schemeArgs['cert_file']
>          key = soapStub.schemeArgs['key_file']
>          authenticator = sso.SsoAuthenticator(sts_url=stsUrl,
>                                               sts_cert=stsCert)
>          samlAssertion = authenticator.get_bearer_saml_assertion(username,
>                                                                  password,
>                                                                  cert,
>                                                                  key)
>          si = vim.ServiceInstance("ServiceInstance", soapStub)
>          sm = si.content.sessionManager
>          if not sm.currentSession:
>             try:
>                soapStub.samlToken = samlAssertion
>                si.content.sessionManager.LoginByToken()
>             finally:
>                soapStub.samlToken = None
> 
>       return _doLogin
> 
> 
> def Connect(host='localhost', port=443, user='root', pwd='',
>             service="hostd", adapter="SOAP", namespace=None, path="/sdk",
>             connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
>             version=None, keyFile=None, certFile=None, thumbprint=None,
>             sslContext=None, b64token=None, mechanism='userpass', disableSslCertValidation=False):
>    """
>    Connect to the specified server, login and return the service
>    instance object.
> 
>    Throws any exception back to caller. The service instance object is
>    also saved in the library for easy access.
> 
>    Clients should modify the service parameter only when connecting to
>    a VMOMI server other than hostd/vpxd. For both of the latter, the
>    default value is fine.
> 
>    @param host: Which host to connect to.
>    @type  host: string
>    @param port: Port
>    @type  port: int
>    @param user: User
>    @type  user: string
>    @param pwd: Password
>    @type  pwd: string
>    @param service: Service
>    @type  service: string
>    @param adapter: Adapter
>    @type  adapter: string
>    @param namespace: Namespace *** Deprecated: Use version instead ***
>    @type  namespace: string
>    @param path: Path
>    @type  path: string
>    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
>                                  closing the connections
>    @type  connectionPoolTimeout: int
>    @param version: Version
>    @type  version: string
>    @param keyFile: ssl key file path
>    @type  keyFile: string
>    @param certFile: ssl cert file path
>    @type  certFile: string
>    @param thumbprint: host cert thumbprint
>    @type  thumbprint: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    @param b64token: base64 encoded token
>    @type  b64token: string
>    @param mechanism: authentication mechanism: userpass or sspi
>    @type  mechanism: string
>    @type disableSslCertValidation: bool
>    @param disableSslCertValidation: Creates an unverified SSL context when True.
>    """
>    try:
>       info = re.match(_rx, host)
>       if info is not None:
>          host = info.group(1)
>          if host[0] == '[':
>             host = info.group(1)[1:-1]
>          if info.group(2) is not None:
>             port = int(info.group(2)[1:])
>    except ValueError as ve:
>       pass
> 
>    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
> 
>    if namespace:
>       assert(version is None)
>       version = versionMap[namespace]
>    elif not version:
>       version = "vim.version.version6"
> 
>    si, stub = None, None
>    if mechanism == 'userpass':
>       si, stub = __Login(host, port, user, pwd, service, adapter, version, path,
>                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
>    elif mechanism == 'sspi':
>       si, stub = __LoginBySSPI(host, port, service, adapter, version, path,
>                                keyFile, certFile, thumbprint, sslContext, b64token, connectionPoolTimeout)
>    else:
>       raise Exception('''The provided connection mechanism is not available, the
>               supported mechanisms are userpass or sspi''')
> 
>    SetSi(si)
> 
>    return si
> 
> # ConnectNoSSL() is deprecated. Use Connect(disableSslCertValidation=True).
> def ConnectNoSSL(host='localhost', port=443, user='root', pwd='',
>                  service="hostd", adapter="SOAP", namespace=None, path="/sdk",
>                  version=None, keyFile=None, certFile=None, thumbprint=None,
>                  b64token=None, mechanism='userpass'):
>    """
>    Provides a standard method for connecting to a specified server without SSL
>    verification. Useful when connecting to servers with self-signed certificates
>    or when you wish to ignore SSL altogether. Will attempt to create an unverified
>    SSL context and then connect via the Connect method.
>    """
> 
>    sslContext = ssl._create_unverified_context()
> 
>    return Connect(host=host,
>                   port=port,
>                   user=user,
>                   pwd=pwd,
>                   service=service,
>                   adapter=adapter,
>                   namespace=namespace,
>                   path=path,
>                   version=version,
>                   keyFile=keyFile,
>                   certFile=certFile,
>                   thumbprint=thumbprint,
>                   sslContext=sslContext,
>                   b64token=b64token,
>                   mechanism=mechanism)
> 
> def Disconnect(si):
>    """
>    Disconnect (logout) service instance
>    @param si: Service instance (returned from Connect)
>    """
>    # Logout
>    __Logout(si)
>    SetSi(None)
> 
> 
> ## Method that gets a local ticket for the specified user
> def GetLocalTicket(si, user):
>    try:
>       sessionManager = si.content.sessionManager
>    except Exception as e:
>       if type(e).__name__ == 'ExpatError':
>          msg = 'Malformed response while querying for local ticket: "%s"' % e
>          raise vim.fault.HostConnectFault(msg=msg)
>       else:
>          msg = 'Failed to query for local ticket: "%s"' % e
>          raise vim.fault.HostConnectFault(msg=msg)
>    localTicket = sessionManager.AcquireLocalTicket(userName=user)
>    with open(localTicket.passwordFilePath) as f:
>       content = f.read()
>    return localTicket.userName, content
> 
> 
> ## Private method that performs the actual Connect and returns a
> ## connected service instance object.
> 
> def __Login(host, port, user, pwd, service, adapter, version, path,
>             keyFile, certFile, thumbprint, sslContext,
>             connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
>    """
>    Private method that performs the actual Connect and returns a
>    connected service instance object.
> 
>    @param host: Which host to connect to.
>    @type  host: string
>    @param port: Port
>    @type  port: int
>    @param user: User
>    @type  user: string
>    @param pwd: Password
>    @type  pwd: string
>    @param service: Service
>    @type  service: string
>    @param adapter: Adapter
>    @type  adapter: string
>    @param version: Version
>    @type  version: string
>    @param path: Path
>    @type  path: string
>    @param keyFile: ssl key file path
>    @type  keyFile: string
>    @param certFile: ssl cert file path
>    @type  certFile: string
>    @param thumbprint: host cert thumbprint
>    @type  thumbprint: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
>                                  closing the connections
>    @type  connectionPoolTimeout: int
>    """
> 
>    content, si, stub = __RetrieveContent(host, port, adapter, version, path,
>                                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
> 
>    # Get a ticket if we're connecting to localhost and password is not specified
>    if host == 'localhost' and not pwd:
>       try:
>          (user, pwd) = GetLocalTicket(si, user)
>       except:
>          pass # This is not supported against vCenter, and connecting
>               # with an empty password is fine in debug builds
> 
>    # Login
>    try:
>       x = content.sessionManager.Login(user, pwd, None)
>    except vim.fault.InvalidLogin:
>       raise
>    except Exception as e:
>       raise
>    return si, stub
> 
> ## Private method that performs LoginBySSPI and returns a
> ## connected service instance object.
> ## Copyright (c) 2015 Morgan Stanley.  All rights reserved.
> 
> def __LoginBySSPI(host, port, service, adapter, version, path,
>                   keyFile, certFile, thumbprint, sslContext, b64token,
>                   connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
>    """
>    Private method that performs the actual Connect and returns a
>    connected service instance object.
> 
>    @param host: Which host to connect to.
>    @type  host: string
>    @param port: Port
>    @type  port: int
>    @param service: Service
>    @type  service: string
>    @param adapter: Adapter
>    @type  adapter: string
>    @param version: Version
>    @type  version: string
>    @param path: Path
>    @type  path: string
>    @param keyFile: ssl key file path
>    @type  keyFile: string
>    @param certFile: ssl cert file path
>    @type  certFile: string
>    @param thumbprint: host cert thumbprint
>    @type  thumbprint: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    @param b64token: base64 encoded token
>    @type  b64token: string
>    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
>                                  closing the connections
>    @type  connectionPoolTimeout: int
>    """
> 
>    content, si, stub = __RetrieveContent(host, port, adapter, version, path,
>                                          keyFile, certFile, thumbprint, sslContext, connectionPoolTimeout)
> 
>    if b64token is None:
>       raise Exception('Token is not defined for sspi login')
> 
>    # Login
>    try:
>       x = content.sessionManager.LoginBySSPI(b64token)
>    except vim.fault.InvalidLogin:
>       raise
>    except Exception as e:
>       raise
>    return si, stub
> 
> ## Private method that performs the actual Disonnect
> 
> def __Logout(si):
>    """
>    Disconnect (logout) service instance
>    @param si: Service instance (returned from Connect)
>    """
>    try:
>       if si:
>          content = si.RetrieveContent()
>          content.sessionManager.Logout()
>    except Exception as e:
>       pass
> 
> ## Private method that returns the service content
> 
> def __RetrieveContent(host, port, adapter, version, path, keyFile, certFile,
>                       thumbprint, sslContext, connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC):
>    """
>    Retrieve service instance for connection.
>    @param host: Which host to connect to.
>    @type  host: string
>    @param port: Port
>    @type  port: int
>    @param adapter: Adapter
>    @type  adapter: string
>    @param version: Version
>    @type  version: string
>    @param path: Path
>    @type  path: string
>    @param keyFile: ssl key file path
>    @type  keyFile: string
>    @param certFile: ssl cert file path
>    @type  certFile: string
>    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
>                                  closing the connections
>    @type  connectionPoolTimeout: int
>    """
> 
>    # XXX remove the adapter and service arguments once dependent code is fixed
>    if adapter != "SOAP":
>       raise ValueError(adapter)
> 
>    # Create the SOAP stub adapter
>    stub = SoapStubAdapter(host, port, version=version, path=path,
>                           certKeyFile=keyFile, certFile=certFile,
>                           thumbprint=thumbprint, sslContext=sslContext,
>                           connectionPoolTimeout=connectionPoolTimeout)
> 
>    # Get Service instance
>    si = vim.ServiceInstance("ServiceInstance", stub)
>    content = None
>    try:
>       content = si.RetrieveContent()
>    except vmodl.MethodFault:
>       raise
>    except Exception as e:
>       # NOTE (hartsock): preserve the traceback for diagnostics
>       # pulling and preserving the traceback makes diagnosing connection
>       # failures easier since the fault will also include where inside the
>       # library the fault occurred. Without the traceback we have no idea
>       # why the connection failed beyond the message string.
>       (type, value, traceback) = sys.exc_info()
>       if traceback:
>          fault = vim.fault.HostConnectFault(msg=str(e))
>          reraise(vim.fault.HostConnectFault, fault, traceback)
>       else:
>           raise vim.fault.HostConnectFault(msg=str(e))
> 
>    return content, si, stub
> 
> 
> ## Get the saved service instance.
> 
> def GetSi():
>    """ Get the saved service instance. """
>    return _si
> 
> 
> ## Set the saved service instance.
> 
> def SetSi(si):
>    """ Set the saved service instance. """
> 
>    global _si
>    _si = si
> 
> 
> ## Get the global saved stub
> 
> def GetStub():
>    """ Get the global saved stub. """
>    si = GetSi()
>    if si:
>       return si._GetStub()
>    return None;
> 
> ## RAII-style class for managing connections
> 
> class Connection(object):
>    def __init__(self, *args, **kwargs):
>       self.args = args
>       self.kwargs = kwargs
>       self.si = None
> 
>    def __enter__(self):
>       self.si = Connect(*self.args, **self.kwargs)
>       return self.si
> 
>    def __exit__(self, *exc_info):
>       if self.si:
>          Disconnect(self.si)
>          self.si = None
> 
> class SmartConnection(object):
>    def __init__(self, *args, **kwargs):
>       self.args = args
>       self.kwargs = kwargs
>       self.si = None
> 
>    def __enter__(self):
>       self.si = SmartConnect(*self.args, **self.kwargs)
>       return self.si
> 
>    def __exit__(self, *exc_info):
>       if self.si:
>          Disconnect(self.si)
>          self.si = None
> 
> def __GetElementTree(protocol, server, port, path, sslContext, httpProxyHost=None, httpProxyPort=None):
>    """
>    Private method that returns a root from ElementTree for a remote XML document.
> 
>    @param protocol: What protocol to use for the connection (e.g. https or http).
>    @type  protocol: string
>    @param server: Which server to connect to.
>    @type  server: string
>    @param port: Port
>    @type  port: int
>    @param path: Path
>    @type  path: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    """
> 
>    if httpProxyHost:
>       kwargs = {"context": sslContext} if sslContext else {}
>       conn = http_client.HTTPSConnection(httpProxyHost, port=httpProxyPort, **kwargs)
>       conn.set_tunnel(server, port)
>    elif protocol == "https":
>       kwargs = {"context": sslContext} if sslContext else {}
>       conn = http_client.HTTPSConnection(server, port=port, **kwargs)
>    elif protocol == "http":
>       conn = http_client.HTTPConnection(server, port=port)
>    else:
>       raise Exception("Protocol " + protocol + " not supported.")
>    conn.request("GET", path)
>    response = conn.getresponse()
>    if response.status == 200:
>       try:
>          tree = ElementTree.fromstring(response.read())
>          return tree
>       except ExpatError:
>          pass
>    return None
> 
> ## Private method that returns an ElementTree describing the API versions
> ## supported by the specified server.  The result will be vimServiceVersions.xml
> ## if it exists, otherwise vimService.wsdl if it exists, otherwise None.
> 
> def __GetServiceVersionDescription(protocol, server, port, path, sslContext, httpProxyHost=None, httpProxyPort=None):
>    """
>    Private method that returns a root from an ElementTree describing the API versions
>    supported by the specified server.  The result will be vimServiceVersions.xml
>    if it exists, otherwise vimService.wsdl if it exists, otherwise None.
> 
>    @param protocol: What protocol to use for the connection (e.g. https or http).
>    @type  protocol: string
>    @param server: Which server to connect to.
>    @type  server: string
>    @param port: Port
>    @type  port: int
>    @param path: Path
>    @type  path: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    """
> 
>    tree = __GetElementTree(protocol, server, port,
>                            path + "/vimServiceVersions.xml", sslContext,
>                            httpProxyHost, httpProxyPort)
>    if tree is not None:
>       return tree
> 
>    tree = __GetElementTree(protocol, server, port,
>                            path + "/vimService.wsdl", sslContext,
>                            httpProxyHost, httpProxyPort)
>    return tree
> 
> 
> ## Private method that returns true if the service version description document
> ##  indicates that the desired version is supported
> 
> def __VersionIsSupported(desiredVersion, serviceVersionDescription):
>    """
>    Private method that returns true if the service version description document
>    indicates that the desired version is supported
> 
>    @param desiredVersion: The version we want to see if the server supports
>                           (eg. vim.version.version2.
>    @type  desiredVersion: string
>    @param serviceVersionDescription: A root ElementTree for vimServiceVersions.xml
>                                      or vimService.wsdl.
>    @type  serviceVersionDescription: root ElementTree
>    """
> 
>    root = serviceVersionDescription
>    if root.tag == 'namespaces':
>       # serviceVersionDescription appears to be a vimServiceVersions.xml document
>       if root.get('version') != '1.0':
>          raise RuntimeError('vimServiceVersions.xml has version %s,' \
>              ' which is not understood' % (root.get('version')))
>       desiredVersionId = versionIdMap[desiredVersion]
>       supportedVersion = None
>       for namespace in root.findall('namespace'):
>          versionId = namespace.findtext('version')
>          if versionId == desiredVersionId:
>             return True
>          else:
>             for versionId in namespace.findall('priorVersions/version'):
>                if versionId.text == desiredVersionId:
>                   return True
>    else:
>       # serviceVersionDescription must be a vimService.wsdl document
>       wsdlNS = 'http://schemas.xmlsoap.org/wsdl/'
>       importElement = serviceVersionDescription.find('.//{%s}import' % wsdlNS)
>       supportedVersion = versionMap[importElement.get('namespace')[4:]]
>       if IsChildVersion(supportedVersion, desiredVersion):
>          return True
>    return False
> 
> 
> ## Private method that returns the most preferred API version supported by the
> ## specified server,
> 
> def __FindSupportedVersion(protocol, server, port, path, preferredApiVersions, sslContext, httpProxyHost=None, httpProxyPort=None):
>    """
>    Private method that returns the most preferred API version supported by the
>    specified server,
> 
>    @param protocol: What protocol to use for the connection (e.g. https or http).
>    @type  protocol: string
>    @param server: Which server to connect to.
>    @type  server: string
>    @param port: Port
>    @type  port: int
>    @param path: Path
>    @type  path: string
>    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
>                                 If a list of versions is specified the versions should
>                                 be ordered from most to least preferred.
>    @type  preferredApiVersions: string or string list
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    """
> 
>    serviceVersionDescription = __GetServiceVersionDescription(protocol,
>                                                               server,
>                                                               port,
>                                                               path,
>                                                               sslContext,
>                                                               httpProxyHost,
>                                                               httpProxyPort)
>    if serviceVersionDescription is None:
>       return None
> 
>    if not isinstance(preferredApiVersions, list):
>       preferredApiVersions = [ preferredApiVersions ]
> 
>    for desiredVersion in preferredApiVersions:
>       if __VersionIsSupported(desiredVersion, serviceVersionDescription):
>          return desiredVersion
>    return None
> 
> def SmartStubAdapter(host='localhost', port=443, path='/sdk',
>                      url=None, sock=None, poolSize=5,
>                      certFile=None, certKeyFile=None,
>                      httpProxyHost=None, httpProxyPort=80, sslProxyPath=None,
>                      thumbprint=None, cacertsFile=None, preferredApiVersions=None,
>                      acceptCompressedResponses=True,
>                      connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
>                      samlToken=None, sslContext=None, disableSslCertValidation=False):
>    """
>    Determine the most preferred API version supported by the specified server,
>    then create a soap stub adapter using that version
> 
>    The parameters are the same as for pyVmomi.SoapStubAdapter except for
>    version which is renamed to prefferedApiVersions
> 
>    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
>                                 If a list of versions is specified the versions should
>                                 be ordered from most to least preferred.  If None is
>                                 specified, the list of versions support by pyVmomi will
>                                 be used.
>    @type  preferredApiVersions: string or string list
>    @type disableSslCertValidation: bool
>    @param disableSslCertValidation: Creates an unverified SSL context when True.
>    """
>    if preferredApiVersions is None:
>       preferredApiVersions = GetServiceVersions('vim25')
> 
>    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
> 
>    supportedVersion = __FindSupportedVersion('https' if port > 0 else 'http',
>                                              host,
>                                              port,
>                                              path,
>                                              preferredApiVersions,
>                                              sslContext,
>                                              httpProxyHost,
>                                              httpProxyPort
>                                              )
>    if supportedVersion is None:
>       raise Exception("%s:%s is not a VIM server" % (host, port))
> 
>    return SoapStubAdapter(host=host, port=port, path=path,
>                           url=url, sock=sock, poolSize=poolSize,
>                           certFile=certFile, certKeyFile=certKeyFile,
>                           httpProxyHost=httpProxyHost, httpProxyPort=httpProxyPort,
>                           sslProxyPath=sslProxyPath, thumbprint=thumbprint,
>                           cacertsFile=cacertsFile, version=supportedVersion,
>                           acceptCompressedResponses=acceptCompressedResponses,
>                           connectionPoolTimeout=connectionPoolTimeout,
>                           samlToken=samlToken, sslContext=sslContext)
> 
> def SmartConnect(protocol='https', host='localhost', port=443, user='root', pwd='',
>                  service="hostd", path="/sdk", connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
>                  preferredApiVersions=None, keyFile=None, certFile=None,
>                  thumbprint=None, sslContext=None, b64token=None, mechanism='userpass',
>                  disableSslCertValidation=False):
>    """
>    Determine the most preferred API version supported by the specified server,
>    then connect to the specified server using that API version, login and return
>    the service instance object.
> 
>    Throws any exception back to caller. The service instance object is
>    also saved in the library for easy access.
> 
>    Clients should modify the service parameter only when connecting to
>    a VMOMI server other than hostd/vpxd. For both of the latter, the
>    default value is fine.
> 
>    @param protocol: What protocol to use for the connection (e.g. https or http).
>    @type  protocol: string
>    @param host: Which host to connect to.
>    @type  host: string
>    @param port: Port
>    @type  port: int
>    @param user: User
>    @type  user: string
>    @param pwd: Password
>    @type  pwd: string
>    @param service: Service
>    @type  service: string
>    @param path: Path
>    @type  path: string
>    @param connectionPoolTimeout: Timeout in secs for idle connections to close, specify negative numbers for never
>                                  closing the connections
>    @type  connectionPoolTimeout: int
>    @param preferredApiVersions: Acceptable API version(s) (e.g. vim.version.version3)
>                                 If a list of versions is specified the versions should
>                                 be ordered from most to least preferred.  If None is
>                                 specified, the list of versions support by pyVmomi will
>                                 be used.
>    @type  preferredApiVersions: string or string list
>    @param keyFile: ssl key file path
>    @type  keyFile: string
>    @param certFile: ssl cert file path
>    @type  certFile: string
>    @param thumbprint: host cert thumbprint
>    @type  thumbprint: string
>    @param sslContext: SSL Context describing the various SSL options. It is only
>                       supported in Python 2.7.9 or higher.
>    @type  sslContext: SSL.Context
>    @type disableSslCertValidation: bool
>    @param disableSslCertValidation: Creates an unverified SSL context when True.
>    """
> 
>    if preferredApiVersions is None:
>       preferredApiVersions = GetServiceVersions('vim25')
> 
>    sslContext = getSslContext(host, sslContext, disableSslCertValidation)
> 
>    supportedVersion = __FindSupportedVersion(protocol,
>                                              host,
>                                              port,
>                                              path,
>                                              preferredApiVersions,
>                                              sslContext)
>    if supportedVersion is None:
>       raise Exception("%s:%s is not a VIM server" % (host, port))
> 
>    portNumber = protocol == "http" and -int(port) or int(port)
> 
>    return Connect(host=host,
>                   port=portNumber,
>                   user=user,
>                   pwd=pwd,
>                   service=service,
>                   adapter='SOAP',
>                   version=supportedVersion,
>                   path=path,
>                   connectionPoolTimeout=connectionPoolTimeout,
>                   keyFile=keyFile,
>                   certFile=certFile,
>                   thumbprint=thumbprint,
>                   sslContext=sslContext,
>                   b64token=b64token,
>                   mechanism=mechanism,
>                   disableSslCertValidation=disableSslCertValidation)
> 
> # SmartConnectNoSSL() is deprecated. Use SmartConnect(disableSslCertValidation=True).
> def SmartConnectNoSSL(protocol='https', host='localhost', port=443, user='root', pwd='',
>                       service="hostd", path="/sdk", connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
>                       preferredApiVersions=None, keyFile=None, certFile=None,
>                       thumbprint=None, b64token=None, mechanism='userpass'):
>    """
>    Provides a standard method for connecting to a specified server without SSL
>    verification. Useful when connecting to servers with self-signed certificates
>    or when you wish to ignore SSL altogether. Will attempt to create an unverified
>    SSL context and then connect via the SmartConnect method.
>    """
> 
>    sslContext = ssl._create_unverified_context()
> 
>    return SmartConnect(protocol=protocol,
>                        host=host,
>                        port=port,
>                        user=user,
>                        pwd=pwd,
>                        service=service,
>                        path=path,
>                        connectionPoolTimeout=connectionPoolTimeout,
>                        preferredApiVersions=preferredApiVersions,
>                        keyFile=keyFile,
>                        certFile=certFile,
>                        thumbprint=thumbprint,
>                        sslContext=sslContext,
>                        b64token=b64token,
>                        mechanism=mechanism)
> 
> def OpenUrlWithBasicAuth(url, user='root', pwd='', verify=True):
>    """
>    Open the specified URL, using HTTP basic authentication to provide
>    the specified credentials to the server as part of the request.
>    Returns the response as a file-like object.
>    """
>    return requests.get(url, auth=HTTPBasicAuth(user, pwd), verify=verify)
> 
> def OpenPathWithStub(path, stub, verify=True):
>    """
>    Open the specified path using HTTP, using the host/port/protocol
>    associated with the specified stub.  If the stub has a session cookie,
>    it is included with the HTTP request.  Returns the response as a
>    file-like object.
>    """
>    from six.moves import http_client
>    if not hasattr(stub, 'scheme'):
>       raise vmodl.fault.NotSupported()
>    elif stub.scheme == http_client.HTTPConnection:
>       protocol = 'http'
>       verify = False
>    elif stub.scheme == http_client.HTTPSConnection:
>       protocol = 'https'
>    else:
>       raise vmodl.fault.NotSupported()
>    hostPort = stub.host
>    url = '%s://%s%s' % (protocol, hostPort, path)
>    headers = {}
>    if stub.cookie:
>       headers["Cookie"] = stub.cookie
>    return requests.get(url, headers=headers, verify=verify)
> 
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/__init__.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/__init__.py
1,12c1,12
< ## @file pyVim/__init__.py
< ## @brief A client-side Python API that wraps pyVmomi.
< ##
< ##
< 
< ##
< ## @mainpage
< ##
< ## A client-side Python API that wraps pyVmomi.
< ##
< ##
< 
---
> ## @file pyVim/__init__.py
> ## @brief A client-side Python API that wraps pyVmomi.
> ##
> ##
> 
> ##
> ## @mainpage
> ##
> ## A client-side Python API that wraps pyVmomi.
> ##
> ##
> 
Only in source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim: pyVmomiFssAdapter.py
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/sso.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/sso.py
1,1225c1,1225
< """
< A python helper module to do SSO related operations.
< """
< 
< __author__ = 'VMware, Inc.'
< __copyright__ = 'Copyright 2012, 2017 VMware, Inc. All rights reserved.'
< 
< #Standard library imports.
< import six.moves.http_client
< import re
< from six import PY3
< if PY3:
<     from html import escape
< else:
<     from cgi import escape
< import sys
< import datetime
< import base64
< import hashlib
< 
< from pyVmomi import ThumbprintMismatchException
< 
< from uuid import uuid4
< from io import BytesIO
< from six.moves.urllib.parse import urlparse
< #Third-party imports.
< from lxml import etree
< from OpenSSL import crypto
< import ssl
< 
< UTF_8 = 'utf-8'
< SHA256 = 'sha256'
< SHA512 = 'sha512'
< 
< def _extract_certificate(cert):
<     '''
<     Extract DER certificate/private key from DER/base64-ed DER/PEM string.
< 
<     @type           cert: C{str}
<     @param          cert: Certificate/private key in one of three supported formats.
< 
<     @rtype: C{str}
<     @return: Certificate/private key in DER (binary ASN.1) format.
<     '''
<     if not cert:
<         raise IOError('Empty certificate')
<     signature = cert[0]
<     # DER certificate is sequence.  ASN.1 sequence is 0x30.
<     if signature == '\x30':
<         return cert
<     # PEM without preamble.  Base64-encoded 0x30 is 0x4D.
<     if signature == '\x4D':
<         return base64.b64decode(cert)
<     # PEM with preamble.  Starts with '-'.
<     if signature == '-':
<         return base64.b64decode(re.sub('-----[A-Z ]*-----', '', cert))
<     # Unknown format.
<     raise IOError('Invalid certificate file format')
< 
< #time.strftime() method returns 6 digit millisecond
< #Formatting time with 3 digit milliseconds
< def format_time(time):
<     return time[:-3] + 'Z'
< 
< class SoapException(Exception):
<     '''
<     Exception raised in case of STS request failure.
<     '''
<     def __init__(self, soap_msg, fault_code, fault_string):
<         '''
<         Initializer for SoapException.
< 
<         @type      soap_msg: C{str}
<         @param     soap_msg: the soap fault XML returned by STS
<         @type    fault_code: C{str}
<         @param   fault_code: The fault code returned by STS.
<         @type  fault_string: C{str}
<         @param fault_string: The fault string returned by STS.
<         '''
<         self._soap_msg = soap_msg
<         self._fault_code = fault_code
<         self._fault_string = fault_string
<         Exception.__init__(self)
< 
<     def __str__(self):
<         '''
<         Returns the string representation of SoapException.
< 
<         @rtype: C{str}
<         @return: string representation of SoapException
<         '''
<         return ("SoapException:\nfaultcode: %(_fault_code)s\n"
<                 "faultstring: %(_fault_string)s\n"
<                 "faultxml: %(_soap_msg)s" % self.__dict__)
< 
< 
< class SSOHTTPSConnection(six.moves.http_client.HTTPSConnection):
<     '''
<     An HTTPS class that verifies server's certificate on connect.
<     '''
<     def __init__(self, *args, **kwargs):
<         '''
<         Initializer.  See httplib.HTTPSConnection for other arguments
<         than thumbprint and server_cert.
< 
<         At least one of thumbprint, server_cert should be provided,
<         otherwise server certificate is not validated.
< 
<         @type           thumbprint: C(str)
<         @param          thumbprint: Expected SHA-1 thumbprint of the server
<                                     certificate.  May be None.
< 
<         @type          server_cert: C(str)
<         @param         server_cert: File with expected server certificate.
<                                     May be None.
<         '''
<         self.server_thumbprint = kwargs.pop('thumbprint')
<         if self.server_thumbprint is not None:
<             self.server_thumbprint = re.sub(':', '',
<                                             self.server_thumbprint.lower())
<         server_cert_path = kwargs.pop('server_cert')
<         if server_cert_path is not None:
<             with open(server_cert_path, 'rb') as f:
<                 server_cert = f.read().decode(UTF_8)
<             self.server_cert = _extract_certificate(server_cert)
<         else:
<             self.server_cert = None
<         six.moves.http_client.HTTPSConnection.__init__(self, *args, **kwargs)
< 
<     def _check_cert(self, peerCert):
<         '''
<         Verify that peer certificate matches one we expect.
< 
<         @type             peerCert: C(str)
<         @param            peerCert: Server certificate in DER format.
< 
<         @rtype: boolean
<         @return: True if peerCert is acceptable.  False otherwise.
<         '''
<         if self.server_cert is not None:
<             if peerCert != self.server_cert:
<                 self.sock.close()
<                 self.sock = None
<                 raise IOError("Invalid certificate")
<         if self.server_thumbprint is not None:
<             thumbprint = hashlib.sha1(peerCert).hexdigest().lower()  # pylint: disable=E1101
<             if thumbprint != self.server_thumbprint:
<                 self.sock.close()
<                 self.sock = None
<                 raise ThumbprintMismatchException(
<                    expected=self.server_thumbprint, actual=thumbprint)
< 
<     def connect(self):
<         '''
<         Connect method: connects to the remote system, and upon
<         successful connection validates certificate.
< 
<         Throws an exception when something is wrong.  See
<         httplib.HTTPSConnection.connect() for details.
<         '''
<         six.moves.http_client.HTTPSConnection.connect(self)
< 
<         self._check_cert(self.sock.getpeercert(True))
< 
< 
< class SsoAuthenticator(object):
<     '''
<     A class to handle the transport layer communication between the client and
<     the STS service.
<     '''
< 
<     def __init__(self,
<                  sts_url,
<                  sts_cert=None,
<                  thumbprint=None
<                  ):
<         '''
<         Initializer for SsoAuthenticator.
< 
<         @type           sts_url: C{str}
<         @param          sts_url: URL for the Security Token Service. Usually
<                                  obtained by querying Component Manager.
<         @type          sts_cert: C{str}
<         @param         sts_cert: The file with public key of the Security
<                                  Token Service.  Usually obtained from
<                                  Component Manager and written to the file.
<         @type        thumbprint: C{str}
<         @param       thumbprint: The SHA-1 thumbprint of the certificate used
<                                  by the Security Token Service.  It is same
<                                  thumbprint you can pass to pyVmomi SoapAdapter.
<         '''
<         self._sts_cert = sts_cert
<         self._sts_url = sts_url
<         self._sts_thumbprint = thumbprint
< 
<     def perform_request(self,
<                         soap_message,
<                         public_key=None,
<                         private_key=None,
<                         ssl_context=None):
<         '''
<         Performs a Holder-of-Key SAML token request using the service user's
<         certificates or a bearer token request using the user credentials.
< 
<         @type      soap_message: C{str}
<         @param     soap_message: Authentication SOAP request.
<         @type        public_key: C{str}
<         @param       public_key: File containing the public key for the service
<                                  user registered with SSO, in PEM format.
<         @type       private_key: C{str}
<         @param      private_key: File containing the private key for the service
<                                  user registered with SSO, in PEM format.
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: Response received from the STS after the HoK request.
<         '''
<         parsed = urlparse(self._sts_url)
<         host = parsed.netloc  # pylint: disable=E1101
<         encoded_message = soap_message.encode(UTF_8)
<         if hasattr(ssl, '_create_unverified_context'):
<             # Python 2.7.9 has stronger SSL certificate validation, so we need
<             # to pass in a context when dealing with self-signed certificates.
<             webservice = SSOHTTPSConnection(host=host,
<                                             key_file=private_key,
<                                             cert_file=public_key,
<                                             server_cert=self._sts_cert,
<                                             thumbprint=self._sts_thumbprint,
<                                             context=ssl_context)
<         else:
<             # Versions of Python before 2.7.9 don't support
<             # the context parameter, so don't pass it on.
<             webservice = SSOHTTPSConnection(host=host,
<                                             key_file=private_key,
<                                             cert_file=public_key,
<                                             server_cert=self._sts_cert,
<                                             thumbprint=self._sts_thumbprint)
< 
<         webservice.putrequest("POST", parsed.path, skip_host=True)  # pylint: disable=E1101
<         webservice.putheader("Host", host)
<         webservice.putheader("User-Agent", "VMware/pyVmomi")
<         webservice.putheader("Accept", "text/xml, multipart/related")
<         webservice.putheader("Content-type", "text/xml; charset=\"UTF-8\"")
<         webservice.putheader("Content-length", "%d" % len(encoded_message))
<         webservice.putheader("Connection", "keep-alive")
<         webservice.putheader("SOAPAction",
<             "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue")
<         webservice.endheaders()
<         webservice.send(encoded_message)
< 
<         saml_response = webservice.getresponse()
<         if saml_response.status != 200:
<             faultraw = saml_response.read()
<             # Hopefully it is utf-8 or us-ascii, not Apache error message in Shift-JIS.
<             fault = faultraw.decode(UTF_8)
<             # Best effort at figuring out a SOAP fault.
<             if saml_response.status == 500 and fault and 'faultcode' in fault:
<                 fault_xml = etree.fromstring(faultraw)
<                 parsed_fault = fault_xml.xpath("//text()")
<                 if len(parsed_fault) == 2:
<                     raise SoapException(fault, *parsed_fault)
<             raise Exception("Got response %s: %s\n%s" %
<                             (saml_response.status, saml_response.msg, fault))
<         return saml_response.read()
< 
<     def get_bearer_saml_assertion(self,
<                                   username,
<                                   password,
<                                   public_key=None,
<                                   private_key=None,
<                                   request_duration=60,
<                                   token_duration=600,
<                                   delegatable=False,
<                                   renewable=False,
<                                   ssl_context=None):
<         '''
<         Extracts the assertion from the Bearer Token received from the Security
<         Token Service.
< 
<         @type          username: C{str}
<         @param         username: Username for the user for which bearer token
<                                  needs to be requested.
<         @type          password: C{str}
<         @param         password: Password for the user for which bearer token
<                                  needs to be requested.
<         @type        public_key: C{str}
<         @param       public_key: File containing the public key for the service
<                                  user registered with SSO, in PEM format.
<         @type       private_key: C{str}
<         @param      private_key: File containing the private key for the service
<                                  user registered with SSO, in PEM format.
< 
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<                                  The default value is False
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: The SAML assertion in Unicode.
<         '''
<         request = SecurityTokenRequest(username=username,
<                                        password=password,
<                                        public_key=public_key,
<                                        private_key=private_key,
<                                        request_duration=request_duration,
<                                        token_duration=token_duration)
<         soap_message = request.construct_bearer_token_request(
<             delegatable=delegatable, renewable=renewable)
<         bearer_token = self.perform_request(soap_message,
<                                             public_key,
<                                             private_key,
<                                             ssl_context)
<         return etree.tostring(
<                     _extract_element(etree.fromstring(bearer_token),
<                         'Assertion',
<                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
<                         pretty_print=False).decode(UTF_8)
< 
<     def _get_gss_soap_response(self,
<                                binary_token,
<                                request_duration=60,
<                                token_duration=600,
<                                delegatable=False,
<                                renewable=False,
<                                ssl_context=None):
<         '''
<         Extracts the assertion from the Bearer Token received from the Security
<         Token Service using the binary token generated using either sspi or gss module.
< 
<         @type  binary_token: C{str}
<         @param binary_token: The security token in base64 encoded format
< 
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<                                  The default value is False
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: The SAML assertion.
<         '''
<         request = SecurityTokenRequest(request_duration=request_duration,
<                                        token_duration=token_duration,
<                                        gss_binary_token=binary_token)
<         soap_message = request.construct_bearer_token_request_with_binary_token(
<             delegatable=delegatable, renewable=renewable)
<         return self.perform_request(soap_message,
<                                     ssl_context=ssl_context)
< 
<     def _get_bearer_saml_assertion_win(self,
<                                        request_duration=60,
<                                        token_duration=600,
<                                        delegatable=False,
<                                        renewable=False,
<                                        ssl_context=None):
<         '''
<         Extracts the assertion from the Bearer Token received from the Security
<         Token Service using the SSPI module.
< 
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<                                  The default value is False
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: The SAML assertion.
<         '''
<         import sspi, win32api
<         spn = "sts/%s.com" % win32api.GetDomainName()
<         sspiclient = sspi.ClientAuth("Kerberos", targetspn=spn)
<         in_buf = None
<         err = True
<         # The following will keep running unless we receive a saml token or an error
<         while True:
<             err, out_buf = sspiclient.authorize(in_buf)
<             sectoken = base64.b64encode(out_buf[0].Buffer)
<             soap_response = self._get_gss_soap_response(sectoken,
<                                 request_duration, token_duration,
<                                 delegatable, renewable, ssl_context)
<             et = etree.fromstring(soap_response)
<             try:
<                 # Check if we have received a challenge token from the server
<                 element = _extract_element(et,
<                         'BinaryExchange',
<                         {'ns': "http://docs.oasis-open.org/ws-sx/ws-trust/200512"})
<                 negotiate_token = element.text
<                 out_buf[0].Buffer = base64.b64decode(negotiate_token)
<                 in_buf = out_buf
<             except KeyError:
<                 # Response does not contain the negotiate token.
<                 # It should contain SAML token then.
<                 saml_token = etree.tostring(
<                     _extract_element(
<                         et,
<                         'Assertion',
<                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
<                     pretty_print=False).decode(UTF_8)
<                 break
<         return saml_token
< 
<     def _get_bearer_saml_assertion_lin(self,
<                                        request_duration=60,
<                                        token_duration=600,
<                                        delegatable=False,
<                                        renewable=False):
<         '''
<         Extracts the assertion from the Bearer Token received from the Security
<         Token Service using kerberos.
< 
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<                                  The default value is False
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @rtype: C{str}
<         @return: The SAML assertion in Unicode.
<         '''
<         import kerberos, platform
<         service = 'host@%s' % platform.node()
<         _, context = kerberos.authGSSClientInit(service, 0)
<         challenge = ''
<         # The following will keep running unless we receive a saml token or an error
<         while True:
<             # Call GSS step
<             result = kerberos.authGSSClientStep(context, challenge)
<             if result < 0:
<                 break
<             sectoken = kerberos.authGSSClientResponse(context)
<             soap_response = self._get_gss_soap_response(sectoken,
<                                 request_duration, token_duration, delegatable,
<                                 renewable)
<             et = etree.fromstring(soap_response)
<             try:
<                 # Check if we have received a challenge token from the server
<                 element = _extract_element(et,
<                         'BinaryExchange',
<                         {'ns': "http://docs.oasis-open.org/ws-sx/ws-trust/200512"})
<                 negotiate_token = element.text
<                 challenge = negotiate_token
<             except KeyError:
<                 # Response does not contain the negotiate token.
<                 # It should contain SAML token then.
<                 saml_token = etree.tostring(
<                     _extract_element(
<                         et,
<                         'Assertion',
<                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
<                     pretty_print=False).decode(UTF_8)
<                 break
<         return saml_token
< 
<     def get_bearer_saml_assertion_gss_api(self,
<                                           request_duration=60,
<                                           token_duration=600,
<                                           delegatable=False,
<                                           renewable=False):
<         '''
<         Extracts the assertion from the Bearer Token received from the Security
<         Token Service using the GSS API.
< 
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<                                  The default value is False
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @rtype: C{str}
<         @return: The SAML assertion.
<         '''
<         if sys.platform == "win32":
<             saml_token = self._get_bearer_saml_assertion_win(request_duration,
<                             token_duration, delegatable, renewable)
<         else:
<             raise Exception("Currently, not supported on this platform")
<             ## TODO Remove this exception once SSO supports validation of tickets
<             #       generated against host machines
<             # saml_token = self._get_bearer_saml_assertion_lin(request_duration, token_duration, delegatable)
<         return saml_token
< 
<     def get_hok_saml_assertion(self,
<                                public_key,
<                                private_key,
<                                request_duration=60,
<                                token_duration=600,
<                                act_as_token=None,
<                                delegatable=False,
<                                renewable=False,
<                                ssl_context=None):
<         '''
<         Extracts the assertion from the response received from the Security
<         Token Service.
< 
<         @type        public_key: C{str}
<         @param       public_key: File containing the public key for the service
<                                  user registered with SSO, in PEM format.
<         @type       private_key: C{str}
<         @param      private_key: File containing the private key for the service
<                                  user registered with SSO, in PEM format.
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type      act_as_token: C{str}
<         @param     act_as_token: Bearer/Hok token which is delegatable
<         @type       delegatable: C{boolean}
<         @param      delegatable: Whether the generated token is delegatable or not
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: The SAML assertion in Unicode.
<         '''
<         request = SecurityTokenRequest(public_key=public_key,
<                                        private_key=private_key,
<                                        request_duration=request_duration,
<                                        token_duration=token_duration)
<         soap_message = request.construct_hok_request(delegatable=delegatable,
<                                                      act_as_token=act_as_token,
<                                                      renewable=renewable)
<         hok_token = self.perform_request(soap_message,
<                                          public_key,
<                                          private_key,
<                                          ssl_context)
<         return etree.tostring(
<             _extract_element(
<                 etree.fromstring(hok_token),
<                 'Assertion',
<                 {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
<             pretty_print=False).decode(UTF_8)
< 
<     def get_token_by_token(self,
<                            hok_token,
<                            private_key,
<                            request_duration=60,
<                            token_duration=600,
<                            delegatable=False,
<                            renewable=False,
<                            ssl_context=None):
<         """
<         Get Hok token by Hok token.
< 
<         @type       hok_token:   C{str}
<         @param      hok_token:   Hok token to be used to get another token
<         @type       private_key: C{str}
<         @param      private_key: File containing the private key for the service
<                                  user registered with SSO, in PEM format.
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<         @type    token_duration: C{long}
<         @param   token_duration: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         @type    delegatable: C{boolean}
<         @param   delegatable: Whether the generated token is delegatable or not.
<                               The default value is False.
<         @type         renewable: C{boolean}
<         @param        renewable: Whether the generated token is renewable or not
<                                  The default value is False
<         @type       ssl_context: C{ssl.SSLContext}
<         @param      ssl_context: SSL context describing the various SSL options.
<                                  It is only supported in Python 2.7.9 or higher.
<         @rtype: C{str}
<         @return: The Hok SAML assertion in Unicode.
<         """
<         request = SecurityTokenRequest(private_key=private_key,
<                                        request_duration=request_duration,
<                                        token_duration=token_duration,
<                                        hok_token=hok_token)
<         soap_message = request.construct_hok_by_hok_request(
<             delegatable=delegatable, renewable=renewable)
<         soap_message = add_saml_context(serialized_request=soap_message,
<                                         saml_token=hok_token,
<                                         private_key_file=private_key,
<                                         request_duration=request_duration)
< 
<         hok_token = self.perform_request(soap_message=soap_message,
<                                          ssl_context=ssl_context)
<         return etree.tostring(
<             _extract_element(
<                 etree.fromstring(hok_token),
<                 'Assertion',
<                 {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
<             pretty_print=False).decode(UTF_8)
< 
< class SecurityTokenRequest(object):
<     '''
<     SecurityTokenRequest class handles the serialization of request to the STS
<     for a SAML token.
<     '''
< 
<     #pylint: disable=R0902
<     def __init__(self,
<                  username=None,
<                  password=None,
<                  public_key=None,
<                  private_key=None,
<                  request_duration=60,
<                  token_duration=600,
<                  gss_binary_token=None,
<                  hok_token=None):
<         '''
<         Initializer for the SecurityToken Request class.
< 
<         @type          username: C{str}
<         @param         username: Username for the user for which bearer token
<                                  needs to be requested.
<         @type          password: C{str}
<         @param         password: Password for the user for which bearer token
<                                  needs to be requested.
<         @type        public_key: C{str}
<         @param       public_key: The file containing the public key of the
<                                  service account requesting the SAML token.
<         @type       private_key: C{str}
<         @param      private_key: The file containing the private key of the
<                                  service account requesting the SAML token.
<         @type  request_duration: C{long}
<         @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is specified in seconds and default is
<                                  60s.
<         @type    token_duration: C{long}
<         @param   token_duraiton: The duration for which the SAML token is issued
<                                  for. The duration is specified in seconds and
<                                  the default is 600s.
<         '''
<         self._timestamp_id = _generate_id()
<         self._signature_id = _generate_id()
<         self._request_id = _generate_id()
<         self._security_token_id = _generate_id()
<         current = datetime.datetime.utcnow()
<         self._created = format_time(current.strftime(TIME_FORMAT))
<         self._expires = format_time((current + datetime.timedelta(seconds=
<                                 token_duration)).strftime(TIME_FORMAT))
<         self._request_expires = format_time((current + datetime.timedelta(seconds=
<                                 request_duration)).strftime(TIME_FORMAT))
<         self._timestamp = TIMESTAMP_TEMPLATE % self.__dict__
<         self._username = escape(username) if username else username
<         self._password = escape(password) if password else password
<         self._public_key_file = public_key
<         self._private_key_file = private_key
<         self._act_as_token = None
<         self._renewable = str(False).lower()
<         self._delegatable = str(False).lower()
<         self._use_key = ""
<         self._private_key = None
<         self._binary_exchange = None
<         self._public_key = None
<         if gss_binary_token:
<             self._binary_exchange =  BINARY_EXCHANGE_TEMPLATE % gss_binary_token
<         #The following are populated later. Set to None here to keep in-line
<         #with PEP8.
<         self._binary_security_token = None
<         self._hok_token = hok_token
<         self._key_type = None
<         self._security_token = None
<         self._signature_text = None
<         self._signature = None
<         self._signed_info = None
<         self._timestamp_digest = None
<         self._signature_value = None
<         self._xml_text = None
<         self._xml = None
<         self._request_digest = None
< 
<         #These will only be populated if requesting an HoK token.
<         if self._private_key_file:
<             with open(self._private_key_file) as fp:
<                 self._private_key = fp.read()
< 
<         if self._public_key_file:
<             with open(self._public_key_file) as fp:
<                 self._public_key = fp.read()
< 
<     def construct_bearer_token_request(self, delegatable=False, renewable=False):
<         '''
<         Constructs the actual Bearer token SOAP request.
< 
<         @type  delegatable: C{boolean}
<         @param delegatable: Whether the generated token is delegatable or not
<         @type    renewable: C{boolean}
<         @param   renewable: Whether the generated token is renewable or not
<                             The default value is False
<         @rtype:  C{str}
<         @return: Bearer token SOAP request.
<         '''
<         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer"
<         self._security_token = USERNAME_TOKEN_TEMPLATE % self.__dict__
<         self._delegatable = str(delegatable).lower()
<         self._renewable = str(renewable).lower()
<         return _canonicalize(REQUEST_TEMPLATE % self.__dict__)
< 
<     def construct_bearer_token_request_with_binary_token(self,
<                                                          delegatable=False,
<                                                          renewable=False):
<         '''
<         Constructs the actual Bearer token SOAP request using the binary exchange GSS/SSPI token.
< 
<         @type  delegatable: C{boolean}
<         @param delegatable: Whether the generated token is delegatable or not
<         @type    renewable: C{boolean}
<         @param   renewable: Whether the generated token is renewable or not
<                             The default value is False
<         @rtype:  C{str}
<         @return: Bearer token SOAP request.
<         '''
<         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer"
<         self._delegatable = str(delegatable).lower()
<         self._renewable = str(renewable).lower()
<         return _canonicalize(GSS_REQUEST_TEMPLATE % self.__dict__)
< 
<     def construct_hok_request(self, delegatable=False, act_as_token=None,
<                               renewable=False):
<         '''
<         Constructs the actual HoK token SOAP request.
< 
<         @type   delegatable: C{boolean}
<         @param  delegatable: Whether the generated token is delegatable or not
<         @type  act_as_token: C{str}
<         @param act_as_token: Bearer/Hok token which is delegatable
<         @type    renewable: C{boolean}
<         @param   renewable: Whether the generated token is renewable or not
<                             The default value is False
<         @rtype: C{str}
<         @return: HoK token SOAP request in Unicode.
<         '''
<         self._binary_security_token = base64.b64encode(
<             _extract_certificate(self._public_key)).decode(UTF_8)
<         self._use_key = USE_KEY_TEMPLATE % self.__dict__
<         self._security_token = BINARY_SECURITY_TOKEN_TEMPLATE % self.__dict__
<         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey"
<         self._renewable = str(renewable).lower()
<         self._delegatable = str(delegatable).lower()
<         self._act_as_token = act_as_token
<         if act_as_token is None:
<             self._xml_text = _canonicalize(REQUEST_TEMPLATE % self.__dict__)
<         else:
<             self._xml_text = ACTAS_REQUEST_TEMPLATE % self.__dict__
<         self.sign_request()
<         return etree.tostring(self._xml, pretty_print=False).decode(UTF_8)
< 
<     def construct_hok_by_hok_request(self, delegatable=False, renewable=False):
<         """
<         @type    delegatable: C{boolean}
<         @param   delegatable: Whether the generated token is delegatable or not
<                             The default value is False
<         @type    renewable: C{boolean}
<         @param   renewable: Whether the generated token is renewable or not
<                             The default value is False
<         @rtype: C{str}
<         @return: HoK token SOAP request in Unicode.
<         """
<         self._delegatable = str(delegatable).lower()
<         self._renewable = str(renewable).lower()
<         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey"
<         return _canonicalize(REQUEST_TEMPLATE_TOKEN_BY_TOKEN) % self.__dict__
< 
<     def sign_request(self):
<         '''
<         Calculates the signature to the header of the SOAP request which can be
<         used by the STS to verify that the SOAP message originated from a
<         trusted service.
<         '''
<         base_xml = etree.fromstring(self._xml_text)
<         request_tree = _extract_element(base_xml,
<                             'Body',
<                             {'SOAP-ENV': "http://schemas.xmlsoap.org/soap/envelope/"})
<         request = _canonicalize(etree.tostring(request_tree))
<         request_tree = _extract_element(base_xml,
<                             'Timestamp',
<                             {'ns3': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"})
<         timestamp = _canonicalize(etree.tostring(request_tree))
<         self._request_digest = _make_hash(request.encode(UTF_8)).decode(UTF_8)  # pylint: disable=W0612
<         self._timestamp_digest = _make_hash(timestamp.encode(UTF_8)).decode(UTF_8)  # pylint: disable=W0612
<         self._algorithm = SHA256
<         self._signed_info = _canonicalize(SIGNED_INFO_TEMPLATE % self.__dict__)
<         self._signature_value = _sign(self._private_key, self._signed_info).decode(UTF_8)
<         self._signature_text = _canonicalize(SIGNATURE_TEMPLATE % self.__dict__)
<         self.embed_signature()
< 
<     def embed_signature(self):
<         '''
<         Embeds the signature in to the header of the SOAP request.
<         '''
<         self._xml = etree.fromstring(self._xml_text)
<         security = _extract_element(self._xml,
<                                    'Security',
<                                    {'ns6': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"})
<         self._signature = etree.fromstring(self._signature_text)
<         security.append(self._signature)
<         self._xml_text = etree.tostring(self._xml).decode(UTF_8)
< 
< 
< def add_saml_context(serialized_request, saml_token, private_key_file, request_duration=60):
<     '''
<     A helper method provided to sign the outgoing LoginByToken requests with the
<     HoK token.
< 
<     @type       serialized_request: C{str}
<     @param      serialized_request: SOAP request which needs to be signed.
<     @type               saml_token: C{str}
<     @param              saml_token: SAML assertion that will be added to the SOAP
<                                     request.
<     @type         private_key_file: C{str}
<     @param        private_key_file: Private key of the service user that will be
<                                     used to sign the request, in PEM format.
<     @type         request_duration: C{long}
<     @param request_duration: The duration for which the request is valid. If
<                                  the STS receives this request after this
<                                  duration, it is assumed to have expired. The
<                                  duration is in seconds and the default is 60s.
<     @rtype: C{str}
<     @return: signed SOAP request in Unicode.
<     '''
<     with open(private_key_file) as fp:
<         private_key = fp.read()
<     xml = etree.fromstring(serialized_request)
<     value_map = {}
<     value_map['_request_id'] = _generate_id()
<     request_body = _extract_element(xml,
<                                   'Body',
<                                   {'soapenv': "http://schemas.xmlsoap.org/soap/envelope/"})
<     request_body.nsmap["wsu"] = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<     request_body.set("{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Id", value_map['_request_id'])
<     value_map['_request_digest'] = _make_hash_sha512(
<                                     _canonicalize(etree.tostring(request_body))
<                                         .encode(UTF_8)).decode(UTF_8)
<     security = _extract_element(xml,
<                                'Security',
<                                {'ns6': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"})
<     current = datetime.datetime.utcnow()
<     value_map['_created'] = format_time(current.strftime(TIME_FORMAT))
<     value_map['_request_expires'] = format_time((current + datetime.timedelta(seconds=
<                                             request_duration)).strftime(TIME_FORMAT))
<     value_map['_timestamp_id'] = _generate_id()
<     timestamp = _canonicalize(TIMESTAMP_TEMPLATE % value_map)
<     value_map['_timestamp_digest'] = _make_hash_sha512(
<         timestamp.encode(UTF_8)).decode(UTF_8)
< 
<     security.append(etree.fromstring(timestamp))
<     value_map['_algorithm'] = SHA512
<     value_map['_signed_info'] = _canonicalize(SIGNED_INFO_TEMPLATE % value_map)
<     value_map['_signature_value'] = _sign(private_key,
<                                           value_map['_signed_info'],
<                                           SHA512).decode(UTF_8)
<     value_map['samlId'] = etree.fromstring(saml_token).get("ID")
<     signature = etree.fromstring(_canonicalize(REQUEST_SIGNATURE_TEMPLATE %
<                                                value_map))
<     security.append(signature)
<     return etree.tostring(xml, pretty_print=False).decode(UTF_8)
< 
< 
< def _generate_id():
<     '''
<     An internal helper method to generate UUIDs.
< 
<     @rtype: C{str}
<     @return: UUID
<     '''
<     return "_%s" % uuid4()
< 
< 
< def _load_private_key(der_key):
<     '''
<     An internal helper to load private key.
< 
<     @type  der_key: C{str}
<     @param der_key: The private key, in DER format.
< 
<     @rtype: crypto.privatekey
<     @return: Loaded private key.
<     '''
< 
<     # OpenSSL 0.9.8 does not handle correctly PKCS8 keys passed in DER format
<     # (only PKCS1 keys are understood in DER format).
< 
<     # Unencrypted PKCS8, or PKCS1 for OpenSSL 1.0.1, PKCS1 for OpenSSL 0.9.8
<     try:
<         return crypto.load_privatekey(crypto.FILETYPE_ASN1, der_key, b'')
<     except (crypto.Error, ValueError):
<         pass
<     # Unencrypted PKCS8 for OpenSSL 0.9.8, and PKCS1, just in case...
<     for key_type in ('PRIVATE KEY', 'RSA PRIVATE KEY'):
<         try:
<             return crypto.load_privatekey(crypto.FILETYPE_PEM,
<                                           '-----BEGIN ' + key_type + '-----\n' +
<                                           base64.encodestring(der_key).decode(UTF_8) +
<                                           '-----END ' + key_type + '-----\n',
<                                           b'')
<         except (crypto.Error, ValueError):
<             pass
<     # We could try 'ENCRYPTED PRIVATE KEY' here - but we do not know passphrase.
<     raise
< 
< def _sign(private_key, data, digest=SHA256):
<     '''
<     An internal helper method to sign the 'data' with the 'private_key'.
< 
<     @type  private_key: C{str}
<     @param private_key: The private key used to sign the 'data', in one of
<                         supported formats.
<     @type         data: C{str}
<     @param        data: The data that needs to be signed.
<     @type       digest: C{str}
<     @param      digest: Digest is a str naming a supported message digest type,
<                         for example 'sha256'.
< 
<     @rtype: C{str}
<     @return: Signed string.
<     '''
<     # Convert private key in arbitrary format into DER (DER is binary format
<     # so we get rid of \n / \r\n differences, and line breaks in PEM).
<     pkey = _load_private_key(_extract_certificate(private_key))
<     return base64.b64encode(crypto.sign(pkey, data.encode(UTF_8), digest))
< 
< def _canonicalize(xml_string):
<     '''
<     Given an xml string, canonicalize the string per
<     U{http://www.w3.org/2001/10/xml-exc-c14n#}
< 
<     @type  xml_string: C{str}
<     @param xml_string: The XML string that needs to be canonicalized.
< 
<     @rtype: C{str}
<     @return: Canonicalized string in Unicode.
<     '''
<     parser = etree.XMLParser(remove_blank_text=True)
<     tree = etree.fromstring(xml_string, parser=parser).getroottree()
<     string = BytesIO()
<     tree.write_c14n(string, exclusive=True, with_comments=False)
<     return string.getvalue().decode(UTF_8)
< 
< def _extract_element(xml, element_name, namespace):
<     '''
<     An internal method provided to extract an element from the given XML.
< 
<     @type           xml: C{str}
<     @param          xml: The XML string from which the element will be extracted.
<     @type  element_name: C{str}
<     @param element_name: The element that needs to be extracted from the XML.
<     @type     namespace: dict
<     @param    namespace: A dict containing the namespace of the element to be
<                          extracted.
< 
<     @rtype: etree element.
<     @return: The extracted element.
<     '''
<     assert(len(namespace) == 1)
<     result = xml.xpath("//%s:%s" % (list(namespace.keys())[0], element_name),
<                                     namespaces=namespace)
<     if result:
<         return result[0]
<     else:
<         raise KeyError("%s does not seem to be present in the XML." %
<                        element_name)
< 
< 
< def _make_hash(data):
<     '''
<     An internal method to calculate the sha256 hash of the data.
< 
<     @type  data: C{str}
<     @param data: The data for which the hash needs to be calculated.
< 
<     @rtype: C{str}
<     @return: Base64 encoded sha256 hash.
<     '''
<     return base64.b64encode(hashlib.sha256(data).digest())  # pylint: disable=E1101
< 
< 
< def _make_hash_sha512(data):
<     '''
<     An internal method to calculate the sha512 hash of the data.
< 
<     @type  data:      C{str}
<     @param data:      The data for which the hash needs to be calculated.
< 
<     @rtype: C{str}
<     @return: Base64 encoded sha512 hash.
<     '''
<     return base64.b64encode(hashlib.sha512(data).digest())  # pylint: disable=E1101
< 
< 
< TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"
< 
< #The SAML token requests usually contain an xmldsig which guarantees that the
< #message hasn't been tampered with during the transport. The following
< #SIGNED_INFO_TEMPLATE is used to construct the signedinfo part of the signature.
< SIGNED_INFO_TEMPLATE = """\
< <ds:SignedInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
< <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
< <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-%(_algorithm)s"/>
< <ds:Reference URI="#%(_request_id)s">
< <ds:Transforms>
< <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
< </ds:Transforms>
< <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#%(_algorithm)s"/>
< <ds:DigestValue>%(_request_digest)s</ds:DigestValue>
< </ds:Reference>
< <ds:Reference URI="#%(_timestamp_id)s">
< <ds:Transforms>
< <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
< </ds:Transforms>
< <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#%(_algorithm)s"/>
< <ds:DigestValue>%(_timestamp_digest)s</ds:DigestValue>
< </ds:Reference>
< </ds:SignedInfo>
< """
< 
< #The following template is used as the container for signed info in WS-Trust
< #SOAP requests signed with the SAML token. It contains the digest of the
< #signed info, signed with the private key of the Solution user and contains a
< #reference to the actual SAML token which contains the solution user's public
< #key.
< REQUEST_SIGNATURE_TEMPLATE = """\
< <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
< %(_signed_info)s
< <ds:SignatureValue>%(_signature_value)s</ds:SignatureValue>
< <ds:KeyInfo>
< <ns2:SecurityTokenReference xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
<                             xmlns:wsse11="http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd"
<                             wsse11:TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0">
< <ns2:KeyIdentifier ValueType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLID">%(samlId)s</ns2:KeyIdentifier>
< </ns2:SecurityTokenReference>
< </ds:KeyInfo>
< </ds:Signature>"""
< 
< #The following template is used as a signed info container for the actual SAML
< #token requests requesting a SAML token. It contains the digest of the signed
< #info signed with the Service User's private key.
< SIGNATURE_TEMPLATE = """\
< <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#" Id="%(_signature_id)s">
< %(_signed_info)s
< <ds:SignatureValue>%(_signature_value)s</ds:SignatureValue>
< <ds:KeyInfo>
< <ns2:SecurityTokenReference xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< <ns2:Reference URI="#%(_security_token_id)s" ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3"/>
< </ns2:SecurityTokenReference>
< </ds:KeyInfo>
< </ds:Signature>"""
< 
< #The following template is used to construct the token requests to the STS.
< REQUEST_TEMPLATE = """\
< <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
< <SOAP-ENV:Header>
< <ns6:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<               xmlns:ns2="http://www.w3.org/2005/08/addressing"
<               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<               xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< %(_timestamp)s
< %(_security_token)s
< </ns6:Security>
< </SOAP-ENV:Header>
< <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
< <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<                       xmlns:ns2="http://www.w3.org/2005/08/addressing"
<                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<                       xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
< <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
< <Lifetime>
< <ns3:Created>%(_created)s</ns3:Created>
< <ns3:Expires>%(_expires)s</ns3:Expires>
< </Lifetime>
< <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
< <Delegatable>%(_delegatable)s</Delegatable>
< <KeyType>%(_key_type)s</KeyType>
< <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>%(_use_key)s</RequestSecurityToken>
< </SOAP-ENV:Body>
< </SOAP-ENV:Envelope>"""
< 
< #The following template is used to construct the token-by-token requests to the STS.
< REQUEST_TEMPLATE_TOKEN_BY_TOKEN = """\
< <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
< <SOAP-ENV:Header>
< <ns5:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<               xmlns:ns5="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< %(_hok_token)s
< </ns5:Security>
< </SOAP-ENV:Header>
< <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
< <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">
< <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
< <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
< <Lifetime>
< <ns3:Created>%(_created)s</ns3:Created>
< <ns3:Expires>%(_expires)s</ns3:Expires>
< </Lifetime>
< <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
< <Delegatable>%(_delegatable)s</Delegatable>
< <KeyType>%(_key_type)s</KeyType>
< <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>
< </RequestSecurityToken>
< </SOAP-ENV:Body>
< </SOAP-ENV:Envelope>"""
< 
< GSS_REQUEST_TEMPLATE = """\
< <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
< <SOAP-ENV:Header>
< <ns6:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<               xmlns:ns2="http://www.w3.org/2005/08/addressing"
<               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<               xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< %(_timestamp)s
< </ns6:Security>
< </SOAP-ENV:Header>
< <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
< <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
<                       xmlns:ns2="http://www.w3.org/2005/08/addressing"
<                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<                       xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
< <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
< <Lifetime>
< <ns3:Created>%(_created)s</ns3:Created>
< <ns3:Expires>%(_expires)s</ns3:Expires>
< </Lifetime>
< <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
< <Delegatable>%(_delegatable)s</Delegatable>
< <KeyType>%(_key_type)s</KeyType>
< <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>
< %(_binary_exchange)s
< %(_use_key)s</RequestSecurityToken>
< </SOAP-ENV:Body>
< </SOAP-ENV:Envelope>"""
< 
< #Template container for the service user's public key when requesting an HoK
< #token.
< BINARY_SECURITY_TOKEN_TEMPLATE = """\
< <ns2:BinarySecurityToken xmlns:ns1="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
<                          xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
<                          EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"
<                          ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3"
<                          ns1:Id="%(_security_token_id)s">%(_binary_security_token)s</ns2:BinarySecurityToken>
< """
< 
< #Template container for user's credentials when requesting a bearer token.
< USERNAME_TOKEN_TEMPLATE = """\
< <ns2:UsernameToken xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
< <ns2:Username>%(_username)s</ns2:Username>
< <ns2:Password>%(_password)s</ns2:Password>
< </ns2:UsernameToken>"""
< 
< #Template containing the anchor to the signature.
< USE_KEY_TEMPLATE = """\
< <UseKey Sig="%(_signature_id)s"/>"""
< 
< #The follwoing template is used to create a timestamp for the various messages.
< #The timestamp is used to indicate the duration of the request itself.
< TIMESTAMP_TEMPLATE = """\
< <ns3:Timestamp xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" ns3:Id="%(_timestamp_id)s">
< <ns3:Created>%(_created)s</ns3:Created><ns3:Expires>%(_request_expires)s</ns3:Expires></ns3:Timestamp>"""
< 
< BINARY_EXCHANGE_TEMPLATE = """\
< <BinaryExchange EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary" ValueType="http://schemas.xmlsoap.org/ws/2005/02/trust/spnego">%s</BinaryExchange>"""
< 
< ACTAS_REQUEST_TEMPLATE = """<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"><SOAP-ENV:Header><ns6:Security xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"><ns3:Timestamp xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" ns3:Id="%(_timestamp_id)s"><ns3:Created>%(_created)s</ns3:Created><ns3:Expires>%(_request_expires)s</ns3:Expires></ns3:Timestamp><ns2:BinarySecurityToken xmlns:ns1="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary" ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3" ns1:Id="%(_security_token_id)s">%(_binary_security_token)s</ns2:BinarySecurityToken></ns6:Security></SOAP-ENV:Header><SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s"><RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"><TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType><RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType><Lifetime><ns3:Created xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">%(_created)s</ns3:Created><ns3:Expires xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">%(_expires)s</ns3:Expires></Lifetime><Renewing Allow="%(_renewable)s" OK="%(_renewable)s"></Renewing><Delegatable>%(_delegatable)s</Delegatable><ns4:ActAs xmlns:ns4="http://docs.oasis-open.org/ws-sx/ws-trust/200802">%(_act_as_token)s</ns4:ActAs><KeyType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey</KeyType><SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm><ns3:UseKey xmlns:ns3="http://docs.oasis-open.org/ws-sx/ws-trust/200512" Sig="%(_signature_id)s"></ns3:UseKey></RequestSecurityToken></SOAP-ENV:Body></SOAP-ENV:Envelope>"""
---
> """
> A python helper module to do SSO related operations.
> """
> 
> __author__ = 'VMware, Inc.'
> __copyright__ = 'Copyright 2012, 2017 VMware, Inc. All rights reserved.'
> 
> #Standard library imports.
> import six.moves.http_client
> import re
> from six import PY3
> if PY3:
>     from html import escape
> else:
>     from cgi import escape
> import sys
> import datetime
> import base64
> import hashlib
> 
> from pyVmomi import ThumbprintMismatchException
> 
> from uuid import uuid4
> from io import BytesIO
> from six.moves.urllib.parse import urlparse
> #Third-party imports.
> from lxml import etree
> from OpenSSL import crypto
> import ssl
> 
> UTF_8 = 'utf-8'
> SHA256 = 'sha256'
> SHA512 = 'sha512'
> 
> def _extract_certificate(cert):
>     '''
>     Extract DER certificate/private key from DER/base64-ed DER/PEM string.
> 
>     @type           cert: C{str}
>     @param          cert: Certificate/private key in one of three supported formats.
> 
>     @rtype: C{str}
>     @return: Certificate/private key in DER (binary ASN.1) format.
>     '''
>     if not cert:
>         raise IOError('Empty certificate')
>     signature = cert[0]
>     # DER certificate is sequence.  ASN.1 sequence is 0x30.
>     if signature == '\x30':
>         return cert
>     # PEM without preamble.  Base64-encoded 0x30 is 0x4D.
>     if signature == '\x4D':
>         return base64.b64decode(cert)
>     # PEM with preamble.  Starts with '-'.
>     if signature == '-':
>         return base64.b64decode(re.sub('-----[A-Z ]*-----', '', cert))
>     # Unknown format.
>     raise IOError('Invalid certificate file format')
> 
> #time.strftime() method returns 6 digit millisecond
> #Formatting time with 3 digit milliseconds
> def format_time(time):
>     return time[:-3] + 'Z'
> 
> class SoapException(Exception):
>     '''
>     Exception raised in case of STS request failure.
>     '''
>     def __init__(self, soap_msg, fault_code, fault_string):
>         '''
>         Initializer for SoapException.
> 
>         @type      soap_msg: C{str}
>         @param     soap_msg: the soap fault XML returned by STS
>         @type    fault_code: C{str}
>         @param   fault_code: The fault code returned by STS.
>         @type  fault_string: C{str}
>         @param fault_string: The fault string returned by STS.
>         '''
>         self._soap_msg = soap_msg
>         self._fault_code = fault_code
>         self._fault_string = fault_string
>         Exception.__init__(self)
> 
>     def __str__(self):
>         '''
>         Returns the string representation of SoapException.
> 
>         @rtype: C{str}
>         @return: string representation of SoapException
>         '''
>         return ("SoapException:\nfaultcode: %(_fault_code)s\n"
>                 "faultstring: %(_fault_string)s\n"
>                 "faultxml: %(_soap_msg)s" % self.__dict__)
> 
> 
> class SSOHTTPSConnection(six.moves.http_client.HTTPSConnection):
>     '''
>     An HTTPS class that verifies server's certificate on connect.
>     '''
>     def __init__(self, *args, **kwargs):
>         '''
>         Initializer.  See httplib.HTTPSConnection for other arguments
>         than thumbprint and server_cert.
> 
>         At least one of thumbprint, server_cert should be provided,
>         otherwise server certificate is not validated.
> 
>         @type           thumbprint: C(str)
>         @param          thumbprint: Expected SHA-1 thumbprint of the server
>                                     certificate.  May be None.
> 
>         @type          server_cert: C(str)
>         @param         server_cert: File with expected server certificate.
>                                     May be None.
>         '''
>         self.server_thumbprint = kwargs.pop('thumbprint')
>         if self.server_thumbprint is not None:
>             self.server_thumbprint = re.sub(':', '',
>                                             self.server_thumbprint.lower())
>         server_cert_path = kwargs.pop('server_cert')
>         if server_cert_path is not None:
>             with open(server_cert_path, 'rb') as f:
>                 server_cert = f.read().decode(UTF_8)
>             self.server_cert = _extract_certificate(server_cert)
>         else:
>             self.server_cert = None
>         six.moves.http_client.HTTPSConnection.__init__(self, *args, **kwargs)
> 
>     def _check_cert(self, peerCert):
>         '''
>         Verify that peer certificate matches one we expect.
> 
>         @type             peerCert: C(str)
>         @param            peerCert: Server certificate in DER format.
> 
>         @rtype: boolean
>         @return: True if peerCert is acceptable.  False otherwise.
>         '''
>         if self.server_cert is not None:
>             if peerCert != self.server_cert:
>                 self.sock.close()
>                 self.sock = None
>                 raise IOError("Invalid certificate")
>         if self.server_thumbprint is not None:
>             thumbprint = hashlib.sha1(peerCert).hexdigest().lower()  # pylint: disable=E1101
>             if thumbprint != self.server_thumbprint:
>                 self.sock.close()
>                 self.sock = None
>                 raise ThumbprintMismatchException(
>                    expected=self.server_thumbprint, actual=thumbprint)
> 
>     def connect(self):
>         '''
>         Connect method: connects to the remote system, and upon
>         successful connection validates certificate.
> 
>         Throws an exception when something is wrong.  See
>         httplib.HTTPSConnection.connect() for details.
>         '''
>         six.moves.http_client.HTTPSConnection.connect(self)
> 
>         self._check_cert(self.sock.getpeercert(True))
> 
> 
> class SsoAuthenticator(object):
>     '''
>     A class to handle the transport layer communication between the client and
>     the STS service.
>     '''
> 
>     def __init__(self,
>                  sts_url,
>                  sts_cert=None,
>                  thumbprint=None
>                  ):
>         '''
>         Initializer for SsoAuthenticator.
> 
>         @type           sts_url: C{str}
>         @param          sts_url: URL for the Security Token Service. Usually
>                                  obtained by querying Component Manager.
>         @type          sts_cert: C{str}
>         @param         sts_cert: The file with public key of the Security
>                                  Token Service.  Usually obtained from
>                                  Component Manager and written to the file.
>         @type        thumbprint: C{str}
>         @param       thumbprint: The SHA-1 thumbprint of the certificate used
>                                  by the Security Token Service.  It is same
>                                  thumbprint you can pass to pyVmomi SoapAdapter.
>         '''
>         self._sts_cert = sts_cert
>         self._sts_url = sts_url
>         self._sts_thumbprint = thumbprint
> 
>     def perform_request(self,
>                         soap_message,
>                         public_key=None,
>                         private_key=None,
>                         ssl_context=None):
>         '''
>         Performs a Holder-of-Key SAML token request using the service user's
>         certificates or a bearer token request using the user credentials.
> 
>         @type      soap_message: C{str}
>         @param     soap_message: Authentication SOAP request.
>         @type        public_key: C{str}
>         @param       public_key: File containing the public key for the service
>                                  user registered with SSO, in PEM format.
>         @type       private_key: C{str}
>         @param      private_key: File containing the private key for the service
>                                  user registered with SSO, in PEM format.
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: Response received from the STS after the HoK request.
>         '''
>         parsed = urlparse(self._sts_url)
>         host = parsed.netloc  # pylint: disable=E1101
>         encoded_message = soap_message.encode(UTF_8)
>         if hasattr(ssl, '_create_unverified_context'):
>             # Python 2.7.9 has stronger SSL certificate validation, so we need
>             # to pass in a context when dealing with self-signed certificates.
>             webservice = SSOHTTPSConnection(host=host,
>                                             key_file=private_key,
>                                             cert_file=public_key,
>                                             server_cert=self._sts_cert,
>                                             thumbprint=self._sts_thumbprint,
>                                             context=ssl_context)
>         else:
>             # Versions of Python before 2.7.9 don't support
>             # the context parameter, so don't pass it on.
>             webservice = SSOHTTPSConnection(host=host,
>                                             key_file=private_key,
>                                             cert_file=public_key,
>                                             server_cert=self._sts_cert,
>                                             thumbprint=self._sts_thumbprint)
> 
>         webservice.putrequest("POST", parsed.path, skip_host=True)  # pylint: disable=E1101
>         webservice.putheader("Host", host)
>         webservice.putheader("User-Agent", "VMware/pyVmomi")
>         webservice.putheader("Accept", "text/xml, multipart/related")
>         webservice.putheader("Content-type", "text/xml; charset=\"UTF-8\"")
>         webservice.putheader("Content-length", "%d" % len(encoded_message))
>         webservice.putheader("Connection", "keep-alive")
>         webservice.putheader("SOAPAction",
>             "http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue")
>         webservice.endheaders()
>         webservice.send(encoded_message)
> 
>         saml_response = webservice.getresponse()
>         if saml_response.status != 200:
>             faultraw = saml_response.read()
>             # Hopefully it is utf-8 or us-ascii, not Apache error message in Shift-JIS.
>             fault = faultraw.decode(UTF_8)
>             # Best effort at figuring out a SOAP fault.
>             if saml_response.status == 500 and fault and 'faultcode' in fault:
>                 fault_xml = etree.fromstring(faultraw)
>                 parsed_fault = fault_xml.xpath("//text()")
>                 if len(parsed_fault) == 2:
>                     raise SoapException(fault, *parsed_fault)
>             raise Exception("Got response %s: %s\n%s" %
>                             (saml_response.status, saml_response.msg, fault))
>         return saml_response.read()
> 
>     def get_bearer_saml_assertion(self,
>                                   username,
>                                   password,
>                                   public_key=None,
>                                   private_key=None,
>                                   request_duration=60,
>                                   token_duration=600,
>                                   delegatable=False,
>                                   renewable=False,
>                                   ssl_context=None):
>         '''
>         Extracts the assertion from the Bearer Token received from the Security
>         Token Service.
> 
>         @type          username: C{str}
>         @param         username: Username for the user for which bearer token
>                                  needs to be requested.
>         @type          password: C{str}
>         @param         password: Password for the user for which bearer token
>                                  needs to be requested.
>         @type        public_key: C{str}
>         @param       public_key: File containing the public key for the service
>                                  user registered with SSO, in PEM format.
>         @type       private_key: C{str}
>         @param      private_key: File containing the private key for the service
>                                  user registered with SSO, in PEM format.
> 
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>                                  The default value is False
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: The SAML assertion in Unicode.
>         '''
>         request = SecurityTokenRequest(username=username,
>                                        password=password,
>                                        public_key=public_key,
>                                        private_key=private_key,
>                                        request_duration=request_duration,
>                                        token_duration=token_duration)
>         soap_message = request.construct_bearer_token_request(
>             delegatable=delegatable, renewable=renewable)
>         bearer_token = self.perform_request(soap_message,
>                                             public_key,
>                                             private_key,
>                                             ssl_context)
>         return etree.tostring(
>                     _extract_element(etree.fromstring(bearer_token),
>                         'Assertion',
>                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
>                         pretty_print=False).decode(UTF_8)
> 
>     def _get_gss_soap_response(self,
>                                binary_token,
>                                request_duration=60,
>                                token_duration=600,
>                                delegatable=False,
>                                renewable=False,
>                                ssl_context=None):
>         '''
>         Extracts the assertion from the Bearer Token received from the Security
>         Token Service using the binary token generated using either sspi or gss module.
> 
>         @type  binary_token: C{str}
>         @param binary_token: The security token in base64 encoded format
> 
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>                                  The default value is False
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: The SAML assertion.
>         '''
>         request = SecurityTokenRequest(request_duration=request_duration,
>                                        token_duration=token_duration,
>                                        gss_binary_token=binary_token)
>         soap_message = request.construct_bearer_token_request_with_binary_token(
>             delegatable=delegatable, renewable=renewable)
>         return self.perform_request(soap_message,
>                                     ssl_context=ssl_context)
> 
>     def _get_bearer_saml_assertion_win(self,
>                                        request_duration=60,
>                                        token_duration=600,
>                                        delegatable=False,
>                                        renewable=False,
>                                        ssl_context=None):
>         '''
>         Extracts the assertion from the Bearer Token received from the Security
>         Token Service using the SSPI module.
> 
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>                                  The default value is False
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: The SAML assertion.
>         '''
>         import sspi, win32api
>         spn = "sts/%s.com" % win32api.GetDomainName()
>         sspiclient = sspi.ClientAuth("Kerberos", targetspn=spn)
>         in_buf = None
>         err = True
>         # The following will keep running unless we receive a saml token or an error
>         while True:
>             err, out_buf = sspiclient.authorize(in_buf)
>             sectoken = base64.b64encode(out_buf[0].Buffer)
>             soap_response = self._get_gss_soap_response(sectoken,
>                                 request_duration, token_duration,
>                                 delegatable, renewable, ssl_context)
>             et = etree.fromstring(soap_response)
>             try:
>                 # Check if we have received a challenge token from the server
>                 element = _extract_element(et,
>                         'BinaryExchange',
>                         {'ns': "http://docs.oasis-open.org/ws-sx/ws-trust/200512"})
>                 negotiate_token = element.text
>                 out_buf[0].Buffer = base64.b64decode(negotiate_token)
>                 in_buf = out_buf
>             except KeyError:
>                 # Response does not contain the negotiate token.
>                 # It should contain SAML token then.
>                 saml_token = etree.tostring(
>                     _extract_element(
>                         et,
>                         'Assertion',
>                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
>                     pretty_print=False).decode(UTF_8)
>                 break
>         return saml_token
> 
>     def _get_bearer_saml_assertion_lin(self,
>                                        request_duration=60,
>                                        token_duration=600,
>                                        delegatable=False,
>                                        renewable=False):
>         '''
>         Extracts the assertion from the Bearer Token received from the Security
>         Token Service using kerberos.
> 
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>                                  The default value is False
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @rtype: C{str}
>         @return: The SAML assertion in Unicode.
>         '''
>         import kerberos, platform
>         service = 'host@%s' % platform.node()
>         _, context = kerberos.authGSSClientInit(service, 0)
>         challenge = ''
>         # The following will keep running unless we receive a saml token or an error
>         while True:
>             # Call GSS step
>             result = kerberos.authGSSClientStep(context, challenge)
>             if result < 0:
>                 break
>             sectoken = kerberos.authGSSClientResponse(context)
>             soap_response = self._get_gss_soap_response(sectoken,
>                                 request_duration, token_duration, delegatable,
>                                 renewable)
>             et = etree.fromstring(soap_response)
>             try:
>                 # Check if we have received a challenge token from the server
>                 element = _extract_element(et,
>                         'BinaryExchange',
>                         {'ns': "http://docs.oasis-open.org/ws-sx/ws-trust/200512"})
>                 negotiate_token = element.text
>                 challenge = negotiate_token
>             except KeyError:
>                 # Response does not contain the negotiate token.
>                 # It should contain SAML token then.
>                 saml_token = etree.tostring(
>                     _extract_element(
>                         et,
>                         'Assertion',
>                         {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
>                     pretty_print=False).decode(UTF_8)
>                 break
>         return saml_token
> 
>     def get_bearer_saml_assertion_gss_api(self,
>                                           request_duration=60,
>                                           token_duration=600,
>                                           delegatable=False,
>                                           renewable=False):
>         '''
>         Extracts the assertion from the Bearer Token received from the Security
>         Token Service using the GSS API.
> 
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>                                  The default value is False
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @rtype: C{str}
>         @return: The SAML assertion.
>         '''
>         if sys.platform == "win32":
>             saml_token = self._get_bearer_saml_assertion_win(request_duration,
>                             token_duration, delegatable, renewable)
>         else:
>             raise Exception("Currently, not supported on this platform")
>             ## TODO Remove this exception once SSO supports validation of tickets
>             #       generated against host machines
>             # saml_token = self._get_bearer_saml_assertion_lin(request_duration, token_duration, delegatable)
>         return saml_token
> 
>     def get_hok_saml_assertion(self,
>                                public_key,
>                                private_key,
>                                request_duration=60,
>                                token_duration=600,
>                                act_as_token=None,
>                                delegatable=False,
>                                renewable=False,
>                                ssl_context=None):
>         '''
>         Extracts the assertion from the response received from the Security
>         Token Service.
> 
>         @type        public_key: C{str}
>         @param       public_key: File containing the public key for the service
>                                  user registered with SSO, in PEM format.
>         @type       private_key: C{str}
>         @param      private_key: File containing the private key for the service
>                                  user registered with SSO, in PEM format.
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type      act_as_token: C{str}
>         @param     act_as_token: Bearer/Hok token which is delegatable
>         @type       delegatable: C{boolean}
>         @param      delegatable: Whether the generated token is delegatable or not
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: The SAML assertion in Unicode.
>         '''
>         request = SecurityTokenRequest(public_key=public_key,
>                                        private_key=private_key,
>                                        request_duration=request_duration,
>                                        token_duration=token_duration)
>         soap_message = request.construct_hok_request(delegatable=delegatable,
>                                                      act_as_token=act_as_token,
>                                                      renewable=renewable)
>         hok_token = self.perform_request(soap_message,
>                                          public_key,
>                                          private_key,
>                                          ssl_context)
>         return etree.tostring(
>             _extract_element(
>                 etree.fromstring(hok_token),
>                 'Assertion',
>                 {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
>             pretty_print=False).decode(UTF_8)
> 
>     def get_token_by_token(self,
>                            hok_token,
>                            private_key,
>                            request_duration=60,
>                            token_duration=600,
>                            delegatable=False,
>                            renewable=False,
>                            ssl_context=None):
>         """
>         Get Hok token by Hok token.
> 
>         @type       hok_token:   C{str}
>         @param      hok_token:   Hok token to be used to get another token
>         @type       private_key: C{str}
>         @param      private_key: File containing the private key for the service
>                                  user registered with SSO, in PEM format.
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>         @type    token_duration: C{long}
>         @param   token_duration: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         @type    delegatable: C{boolean}
>         @param   delegatable: Whether the generated token is delegatable or not.
>                               The default value is False.
>         @type         renewable: C{boolean}
>         @param        renewable: Whether the generated token is renewable or not
>                                  The default value is False
>         @type       ssl_context: C{ssl.SSLContext}
>         @param      ssl_context: SSL context describing the various SSL options.
>                                  It is only supported in Python 2.7.9 or higher.
>         @rtype: C{str}
>         @return: The Hok SAML assertion in Unicode.
>         """
>         request = SecurityTokenRequest(private_key=private_key,
>                                        request_duration=request_duration,
>                                        token_duration=token_duration,
>                                        hok_token=hok_token)
>         soap_message = request.construct_hok_by_hok_request(
>             delegatable=delegatable, renewable=renewable)
>         soap_message = add_saml_context(serialized_request=soap_message,
>                                         saml_token=hok_token,
>                                         private_key_file=private_key,
>                                         request_duration=request_duration)
> 
>         hok_token = self.perform_request(soap_message=soap_message,
>                                          ssl_context=ssl_context)
>         return etree.tostring(
>             _extract_element(
>                 etree.fromstring(hok_token),
>                 'Assertion',
>                 {'saml2': "urn:oasis:names:tc:SAML:2.0:assertion"}),
>             pretty_print=False).decode(UTF_8)
> 
> class SecurityTokenRequest(object):
>     '''
>     SecurityTokenRequest class handles the serialization of request to the STS
>     for a SAML token.
>     '''
> 
>     #pylint: disable=R0902
>     def __init__(self,
>                  username=None,
>                  password=None,
>                  public_key=None,
>                  private_key=None,
>                  request_duration=60,
>                  token_duration=600,
>                  gss_binary_token=None,
>                  hok_token=None):
>         '''
>         Initializer for the SecurityToken Request class.
> 
>         @type          username: C{str}
>         @param         username: Username for the user for which bearer token
>                                  needs to be requested.
>         @type          password: C{str}
>         @param         password: Password for the user for which bearer token
>                                  needs to be requested.
>         @type        public_key: C{str}
>         @param       public_key: The file containing the public key of the
>                                  service account requesting the SAML token.
>         @type       private_key: C{str}
>         @param      private_key: The file containing the private key of the
>                                  service account requesting the SAML token.
>         @type  request_duration: C{long}
>         @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is specified in seconds and default is
>                                  60s.
>         @type    token_duration: C{long}
>         @param   token_duraiton: The duration for which the SAML token is issued
>                                  for. The duration is specified in seconds and
>                                  the default is 600s.
>         '''
>         self._timestamp_id = _generate_id()
>         self._signature_id = _generate_id()
>         self._request_id = _generate_id()
>         self._security_token_id = _generate_id()
>         current = datetime.datetime.utcnow()
>         self._created = format_time(current.strftime(TIME_FORMAT))
>         self._expires = format_time((current + datetime.timedelta(seconds=
>                                 token_duration)).strftime(TIME_FORMAT))
>         self._request_expires = format_time((current + datetime.timedelta(seconds=
>                                 request_duration)).strftime(TIME_FORMAT))
>         self._timestamp = TIMESTAMP_TEMPLATE % self.__dict__
>         self._username = escape(username) if username else username
>         self._password = escape(password) if password else password
>         self._public_key_file = public_key
>         self._private_key_file = private_key
>         self._act_as_token = None
>         self._renewable = str(False).lower()
>         self._delegatable = str(False).lower()
>         self._use_key = ""
>         self._private_key = None
>         self._binary_exchange = None
>         self._public_key = None
>         if gss_binary_token:
>             self._binary_exchange =  BINARY_EXCHANGE_TEMPLATE % gss_binary_token
>         #The following are populated later. Set to None here to keep in-line
>         #with PEP8.
>         self._binary_security_token = None
>         self._hok_token = hok_token
>         self._key_type = None
>         self._security_token = None
>         self._signature_text = None
>         self._signature = None
>         self._signed_info = None
>         self._timestamp_digest = None
>         self._signature_value = None
>         self._xml_text = None
>         self._xml = None
>         self._request_digest = None
> 
>         #These will only be populated if requesting an HoK token.
>         if self._private_key_file:
>             with open(self._private_key_file) as fp:
>                 self._private_key = fp.read()
> 
>         if self._public_key_file:
>             with open(self._public_key_file) as fp:
>                 self._public_key = fp.read()
> 
>     def construct_bearer_token_request(self, delegatable=False, renewable=False):
>         '''
>         Constructs the actual Bearer token SOAP request.
> 
>         @type  delegatable: C{boolean}
>         @param delegatable: Whether the generated token is delegatable or not
>         @type    renewable: C{boolean}
>         @param   renewable: Whether the generated token is renewable or not
>                             The default value is False
>         @rtype:  C{str}
>         @return: Bearer token SOAP request.
>         '''
>         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer"
>         self._security_token = USERNAME_TOKEN_TEMPLATE % self.__dict__
>         self._delegatable = str(delegatable).lower()
>         self._renewable = str(renewable).lower()
>         return _canonicalize(REQUEST_TEMPLATE % self.__dict__)
> 
>     def construct_bearer_token_request_with_binary_token(self,
>                                                          delegatable=False,
>                                                          renewable=False):
>         '''
>         Constructs the actual Bearer token SOAP request using the binary exchange GSS/SSPI token.
> 
>         @type  delegatable: C{boolean}
>         @param delegatable: Whether the generated token is delegatable or not
>         @type    renewable: C{boolean}
>         @param   renewable: Whether the generated token is renewable or not
>                             The default value is False
>         @rtype:  C{str}
>         @return: Bearer token SOAP request.
>         '''
>         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer"
>         self._delegatable = str(delegatable).lower()
>         self._renewable = str(renewable).lower()
>         return _canonicalize(GSS_REQUEST_TEMPLATE % self.__dict__)
> 
>     def construct_hok_request(self, delegatable=False, act_as_token=None,
>                               renewable=False):
>         '''
>         Constructs the actual HoK token SOAP request.
> 
>         @type   delegatable: C{boolean}
>         @param  delegatable: Whether the generated token is delegatable or not
>         @type  act_as_token: C{str}
>         @param act_as_token: Bearer/Hok token which is delegatable
>         @type    renewable: C{boolean}
>         @param   renewable: Whether the generated token is renewable or not
>                             The default value is False
>         @rtype: C{str}
>         @return: HoK token SOAP request in Unicode.
>         '''
>         self._binary_security_token = base64.b64encode(
>             _extract_certificate(self._public_key)).decode(UTF_8)
>         self._use_key = USE_KEY_TEMPLATE % self.__dict__
>         self._security_token = BINARY_SECURITY_TOKEN_TEMPLATE % self.__dict__
>         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey"
>         self._renewable = str(renewable).lower()
>         self._delegatable = str(delegatable).lower()
>         self._act_as_token = act_as_token
>         if act_as_token is None:
>             self._xml_text = _canonicalize(REQUEST_TEMPLATE % self.__dict__)
>         else:
>             self._xml_text = ACTAS_REQUEST_TEMPLATE % self.__dict__
>         self.sign_request()
>         return etree.tostring(self._xml, pretty_print=False).decode(UTF_8)
> 
>     def construct_hok_by_hok_request(self, delegatable=False, renewable=False):
>         """
>         @type    delegatable: C{boolean}
>         @param   delegatable: Whether the generated token is delegatable or not
>                             The default value is False
>         @type    renewable: C{boolean}
>         @param   renewable: Whether the generated token is renewable or not
>                             The default value is False
>         @rtype: C{str}
>         @return: HoK token SOAP request in Unicode.
>         """
>         self._delegatable = str(delegatable).lower()
>         self._renewable = str(renewable).lower()
>         self._key_type = "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey"
>         return _canonicalize(REQUEST_TEMPLATE_TOKEN_BY_TOKEN) % self.__dict__
> 
>     def sign_request(self):
>         '''
>         Calculates the signature to the header of the SOAP request which can be
>         used by the STS to verify that the SOAP message originated from a
>         trusted service.
>         '''
>         base_xml = etree.fromstring(self._xml_text)
>         request_tree = _extract_element(base_xml,
>                             'Body',
>                             {'SOAP-ENV': "http://schemas.xmlsoap.org/soap/envelope/"})
>         request = _canonicalize(etree.tostring(request_tree))
>         request_tree = _extract_element(base_xml,
>                             'Timestamp',
>                             {'ns3': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"})
>         timestamp = _canonicalize(etree.tostring(request_tree))
>         self._request_digest = _make_hash(request.encode(UTF_8)).decode(UTF_8)  # pylint: disable=W0612
>         self._timestamp_digest = _make_hash(timestamp.encode(UTF_8)).decode(UTF_8)  # pylint: disable=W0612
>         self._algorithm = SHA256
>         self._signed_info = _canonicalize(SIGNED_INFO_TEMPLATE % self.__dict__)
>         self._signature_value = _sign(self._private_key, self._signed_info).decode(UTF_8)
>         self._signature_text = _canonicalize(SIGNATURE_TEMPLATE % self.__dict__)
>         self.embed_signature()
> 
>     def embed_signature(self):
>         '''
>         Embeds the signature in to the header of the SOAP request.
>         '''
>         self._xml = etree.fromstring(self._xml_text)
>         security = _extract_element(self._xml,
>                                    'Security',
>                                    {'ns6': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"})
>         self._signature = etree.fromstring(self._signature_text)
>         security.append(self._signature)
>         self._xml_text = etree.tostring(self._xml).decode(UTF_8)
> 
> 
> def add_saml_context(serialized_request, saml_token, private_key_file, request_duration=60):
>     '''
>     A helper method provided to sign the outgoing LoginByToken requests with the
>     HoK token.
> 
>     @type       serialized_request: C{str}
>     @param      serialized_request: SOAP request which needs to be signed.
>     @type               saml_token: C{str}
>     @param              saml_token: SAML assertion that will be added to the SOAP
>                                     request.
>     @type         private_key_file: C{str}
>     @param        private_key_file: Private key of the service user that will be
>                                     used to sign the request, in PEM format.
>     @type         request_duration: C{long}
>     @param request_duration: The duration for which the request is valid. If
>                                  the STS receives this request after this
>                                  duration, it is assumed to have expired. The
>                                  duration is in seconds and the default is 60s.
>     @rtype: C{str}
>     @return: signed SOAP request in Unicode.
>     '''
>     with open(private_key_file) as fp:
>         private_key = fp.read()
>     xml = etree.fromstring(serialized_request)
>     value_map = {}
>     value_map['_request_id'] = _generate_id()
>     request_body = _extract_element(xml,
>                                   'Body',
>                                   {'soapenv': "http://schemas.xmlsoap.org/soap/envelope/"})
>     request_body.nsmap["wsu"] = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>     request_body.set("{http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd}Id", value_map['_request_id'])
>     value_map['_request_digest'] = _make_hash_sha512(
>                                     _canonicalize(etree.tostring(request_body))
>                                         .encode(UTF_8)).decode(UTF_8)
>     security = _extract_element(xml,
>                                'Security',
>                                {'ns6': "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"})
>     current = datetime.datetime.utcnow()
>     value_map['_created'] = format_time(current.strftime(TIME_FORMAT))
>     value_map['_request_expires'] = format_time((current + datetime.timedelta(seconds=
>                                             request_duration)).strftime(TIME_FORMAT))
>     value_map['_timestamp_id'] = _generate_id()
>     timestamp = _canonicalize(TIMESTAMP_TEMPLATE % value_map)
>     value_map['_timestamp_digest'] = _make_hash_sha512(
>         timestamp.encode(UTF_8)).decode(UTF_8)
> 
>     security.append(etree.fromstring(timestamp))
>     value_map['_algorithm'] = SHA512
>     value_map['_signed_info'] = _canonicalize(SIGNED_INFO_TEMPLATE % value_map)
>     value_map['_signature_value'] = _sign(private_key,
>                                           value_map['_signed_info'],
>                                           SHA512).decode(UTF_8)
>     value_map['samlId'] = etree.fromstring(saml_token).get("ID")
>     signature = etree.fromstring(_canonicalize(REQUEST_SIGNATURE_TEMPLATE %
>                                                value_map))
>     security.append(signature)
>     return etree.tostring(xml, pretty_print=False).decode(UTF_8)
> 
> 
> def _generate_id():
>     '''
>     An internal helper method to generate UUIDs.
> 
>     @rtype: C{str}
>     @return: UUID
>     '''
>     return "_%s" % uuid4()
> 
> 
> def _load_private_key(der_key):
>     '''
>     An internal helper to load private key.
> 
>     @type  der_key: C{str}
>     @param der_key: The private key, in DER format.
> 
>     @rtype: crypto.privatekey
>     @return: Loaded private key.
>     '''
> 
>     # OpenSSL 0.9.8 does not handle correctly PKCS8 keys passed in DER format
>     # (only PKCS1 keys are understood in DER format).
> 
>     # Unencrypted PKCS8, or PKCS1 for OpenSSL 1.0.1, PKCS1 for OpenSSL 0.9.8
>     try:
>         return crypto.load_privatekey(crypto.FILETYPE_ASN1, der_key, b'')
>     except (crypto.Error, ValueError):
>         pass
>     # Unencrypted PKCS8 for OpenSSL 0.9.8, and PKCS1, just in case...
>     for key_type in ('PRIVATE KEY', 'RSA PRIVATE KEY'):
>         try:
>             return crypto.load_privatekey(crypto.FILETYPE_PEM,
>                                           '-----BEGIN ' + key_type + '-----\n' +
>                                           base64.encodestring(der_key).decode(UTF_8) +
>                                           '-----END ' + key_type + '-----\n',
>                                           b'')
>         except (crypto.Error, ValueError):
>             pass
>     # We could try 'ENCRYPTED PRIVATE KEY' here - but we do not know passphrase.
>     raise
> 
> def _sign(private_key, data, digest=SHA256):
>     '''
>     An internal helper method to sign the 'data' with the 'private_key'.
> 
>     @type  private_key: C{str}
>     @param private_key: The private key used to sign the 'data', in one of
>                         supported formats.
>     @type         data: C{str}
>     @param        data: The data that needs to be signed.
>     @type       digest: C{str}
>     @param      digest: Digest is a str naming a supported message digest type,
>                         for example 'sha256'.
> 
>     @rtype: C{str}
>     @return: Signed string.
>     '''
>     # Convert private key in arbitrary format into DER (DER is binary format
>     # so we get rid of \n / \r\n differences, and line breaks in PEM).
>     pkey = _load_private_key(_extract_certificate(private_key))
>     return base64.b64encode(crypto.sign(pkey, data.encode(UTF_8), digest))
> 
> def _canonicalize(xml_string):
>     '''
>     Given an xml string, canonicalize the string per
>     U{http://www.w3.org/2001/10/xml-exc-c14n#}
> 
>     @type  xml_string: C{str}
>     @param xml_string: The XML string that needs to be canonicalized.
> 
>     @rtype: C{str}
>     @return: Canonicalized string in Unicode.
>     '''
>     parser = etree.XMLParser(remove_blank_text=True)
>     tree = etree.fromstring(xml_string, parser=parser).getroottree()
>     string = BytesIO()
>     tree.write_c14n(string, exclusive=True, with_comments=False)
>     return string.getvalue().decode(UTF_8)
> 
> def _extract_element(xml, element_name, namespace):
>     '''
>     An internal method provided to extract an element from the given XML.
> 
>     @type           xml: C{str}
>     @param          xml: The XML string from which the element will be extracted.
>     @type  element_name: C{str}
>     @param element_name: The element that needs to be extracted from the XML.
>     @type     namespace: dict
>     @param    namespace: A dict containing the namespace of the element to be
>                          extracted.
> 
>     @rtype: etree element.
>     @return: The extracted element.
>     '''
>     assert(len(namespace) == 1)
>     result = xml.xpath("//%s:%s" % (list(namespace.keys())[0], element_name),
>                                     namespaces=namespace)
>     if result:
>         return result[0]
>     else:
>         raise KeyError("%s does not seem to be present in the XML." %
>                        element_name)
> 
> 
> def _make_hash(data):
>     '''
>     An internal method to calculate the sha256 hash of the data.
> 
>     @type  data: C{str}
>     @param data: The data for which the hash needs to be calculated.
> 
>     @rtype: C{str}
>     @return: Base64 encoded sha256 hash.
>     '''
>     return base64.b64encode(hashlib.sha256(data).digest())  # pylint: disable=E1101
> 
> 
> def _make_hash_sha512(data):
>     '''
>     An internal method to calculate the sha512 hash of the data.
> 
>     @type  data:      C{str}
>     @param data:      The data for which the hash needs to be calculated.
> 
>     @rtype: C{str}
>     @return: Base64 encoded sha512 hash.
>     '''
>     return base64.b64encode(hashlib.sha512(data).digest())  # pylint: disable=E1101
> 
> 
> TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"
> 
> #The SAML token requests usually contain an xmldsig which guarantees that the
> #message hasn't been tampered with during the transport. The following
> #SIGNED_INFO_TEMPLATE is used to construct the signedinfo part of the signature.
> SIGNED_INFO_TEMPLATE = """\
> <ds:SignedInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
> <ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
> <ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-%(_algorithm)s"/>
> <ds:Reference URI="#%(_request_id)s">
> <ds:Transforms>
> <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
> </ds:Transforms>
> <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#%(_algorithm)s"/>
> <ds:DigestValue>%(_request_digest)s</ds:DigestValue>
> </ds:Reference>
> <ds:Reference URI="#%(_timestamp_id)s">
> <ds:Transforms>
> <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
> </ds:Transforms>
> <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#%(_algorithm)s"/>
> <ds:DigestValue>%(_timestamp_digest)s</ds:DigestValue>
> </ds:Reference>
> </ds:SignedInfo>
> """
> 
> #The following template is used as the container for signed info in WS-Trust
> #SOAP requests signed with the SAML token. It contains the digest of the
> #signed info, signed with the private key of the Solution user and contains a
> #reference to the actual SAML token which contains the solution user's public
> #key.
> REQUEST_SIGNATURE_TEMPLATE = """\
> <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
> %(_signed_info)s
> <ds:SignatureValue>%(_signature_value)s</ds:SignatureValue>
> <ds:KeyInfo>
> <ns2:SecurityTokenReference xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
>                             xmlns:wsse11="http://docs.oasis-open.org/wss/oasis-wss-wssecurity-secext-1.1.xsd"
>                             wsse11:TokenType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLV2.0">
> <ns2:KeyIdentifier ValueType="http://docs.oasis-open.org/wss/oasis-wss-saml-token-profile-1.1#SAMLID">%(samlId)s</ns2:KeyIdentifier>
> </ns2:SecurityTokenReference>
> </ds:KeyInfo>
> </ds:Signature>"""
> 
> #The following template is used as a signed info container for the actual SAML
> #token requests requesting a SAML token. It contains the digest of the signed
> #info signed with the Service User's private key.
> SIGNATURE_TEMPLATE = """\
> <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#" Id="%(_signature_id)s">
> %(_signed_info)s
> <ds:SignatureValue>%(_signature_value)s</ds:SignatureValue>
> <ds:KeyInfo>
> <ns2:SecurityTokenReference xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> <ns2:Reference URI="#%(_security_token_id)s" ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3"/>
> </ns2:SecurityTokenReference>
> </ds:KeyInfo>
> </ds:Signature>"""
> 
> #The following template is used to construct the token requests to the STS.
> REQUEST_TEMPLATE = """\
> <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
> <SOAP-ENV:Header>
> <ns6:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>               xmlns:ns2="http://www.w3.org/2005/08/addressing"
>               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>               xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> %(_timestamp)s
> %(_security_token)s
> </ns6:Security>
> </SOAP-ENV:Header>
> <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
> <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>                       xmlns:ns2="http://www.w3.org/2005/08/addressing"
>                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>                       xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
> <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
> <Lifetime>
> <ns3:Created>%(_created)s</ns3:Created>
> <ns3:Expires>%(_expires)s</ns3:Expires>
> </Lifetime>
> <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
> <Delegatable>%(_delegatable)s</Delegatable>
> <KeyType>%(_key_type)s</KeyType>
> <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>%(_use_key)s</RequestSecurityToken>
> </SOAP-ENV:Body>
> </SOAP-ENV:Envelope>"""
> 
> #The following template is used to construct the token-by-token requests to the STS.
> REQUEST_TEMPLATE_TOKEN_BY_TOKEN = """\
> <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
> <SOAP-ENV:Header>
> <ns5:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>               xmlns:ns5="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> %(_hok_token)s
> </ns5:Security>
> </SOAP-ENV:Header>
> <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
> <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">
> <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
> <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
> <Lifetime>
> <ns3:Created>%(_created)s</ns3:Created>
> <ns3:Expires>%(_expires)s</ns3:Expires>
> </Lifetime>
> <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
> <Delegatable>%(_delegatable)s</Delegatable>
> <KeyType>%(_key_type)s</KeyType>
> <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>
> </RequestSecurityToken>
> </SOAP-ENV:Body>
> </SOAP-ENV:Envelope>"""
> 
> GSS_REQUEST_TEMPLATE = """\
> <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
> <SOAP-ENV:Header>
> <ns6:Security xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>               xmlns:ns2="http://www.w3.org/2005/08/addressing"
>               xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>               xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> %(_timestamp)s
> </ns6:Security>
> </SOAP-ENV:Header>
> <SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s">
> <RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"
>                       xmlns:ns2="http://www.w3.org/2005/08/addressing"
>                       xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>                       xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> <TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType>
> <RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType>
> <Lifetime>
> <ns3:Created>%(_created)s</ns3:Created>
> <ns3:Expires>%(_expires)s</ns3:Expires>
> </Lifetime>
> <Renewing Allow="%(_renewable)s" OK="%(_renewable)s"/>
> <Delegatable>%(_delegatable)s</Delegatable>
> <KeyType>%(_key_type)s</KeyType>
> <SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm>
> %(_binary_exchange)s
> %(_use_key)s</RequestSecurityToken>
> </SOAP-ENV:Body>
> </SOAP-ENV:Envelope>"""
> 
> #Template container for the service user's public key when requesting an HoK
> #token.
> BINARY_SECURITY_TOKEN_TEMPLATE = """\
> <ns2:BinarySecurityToken xmlns:ns1="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"
>                          xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
>                          EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"
>                          ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3"
>                          ns1:Id="%(_security_token_id)s">%(_binary_security_token)s</ns2:BinarySecurityToken>
> """
> 
> #Template container for user's credentials when requesting a bearer token.
> USERNAME_TOKEN_TEMPLATE = """\
> <ns2:UsernameToken xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
> <ns2:Username>%(_username)s</ns2:Username>
> <ns2:Password>%(_password)s</ns2:Password>
> </ns2:UsernameToken>"""
> 
> #Template containing the anchor to the signature.
> USE_KEY_TEMPLATE = """\
> <UseKey Sig="%(_signature_id)s"/>"""
> 
> #The follwoing template is used to create a timestamp for the various messages.
> #The timestamp is used to indicate the duration of the request itself.
> TIMESTAMP_TEMPLATE = """\
> <ns3:Timestamp xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" ns3:Id="%(_timestamp_id)s">
> <ns3:Created>%(_created)s</ns3:Created><ns3:Expires>%(_request_expires)s</ns3:Expires></ns3:Timestamp>"""
> 
> BINARY_EXCHANGE_TEMPLATE = """\
> <BinaryExchange EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary" ValueType="http://schemas.xmlsoap.org/ws/2005/02/trust/spnego">%s</BinaryExchange>"""
> 
> ACTAS_REQUEST_TEMPLATE = """<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"><SOAP-ENV:Header><ns6:Security xmlns:ns6="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"><ns3:Timestamp xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" ns3:Id="%(_timestamp_id)s"><ns3:Created>%(_created)s</ns3:Created><ns3:Expires>%(_request_expires)s</ns3:Expires></ns3:Timestamp><ns2:BinarySecurityToken xmlns:ns1="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:ns2="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary" ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3" ns1:Id="%(_security_token_id)s">%(_binary_security_token)s</ns2:BinarySecurityToken></ns6:Security></SOAP-ENV:Header><SOAP-ENV:Body xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="%(_request_id)s"><RequestSecurityToken xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512"><TokenType>urn:oasis:names:tc:SAML:2.0:assertion</TokenType><RequestType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue</RequestType><Lifetime><ns3:Created xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">%(_created)s</ns3:Created><ns3:Expires xmlns:ns3="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">%(_expires)s</ns3:Expires></Lifetime><Renewing Allow="%(_renewable)s" OK="%(_renewable)s"></Renewing><Delegatable>%(_delegatable)s</Delegatable><ns4:ActAs xmlns:ns4="http://docs.oasis-open.org/ws-sx/ws-trust/200802">%(_act_as_token)s</ns4:ActAs><KeyType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey</KeyType><SignatureAlgorithm>http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</SignatureAlgorithm><ns3:UseKey xmlns:ns3="http://docs.oasis-open.org/ws-sx/ws-trust/200512" Sig="%(_signature_id)s"></ns3:UseKey></RequestSecurityToken></SOAP-ENV:Body></SOAP-ENV:Envelope>"""
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/task.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVim/task.py
1,311c1,311
< # VMware vSphere Python SDK
< # Copyright (c) 2016 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< ## @file task.py
< ## @brief Task functions
< ##
< ## This module provies synchronization of client/server operations
< ## since many VIM operations return 'tasks' which can have
< ## varying completion times.
< 
< """
< Task functions
< 
< This module provies synchronization of client/server operations since
< many VIM operations return 'tasks' which can have varying completion
< times.
< """
< 
< from pyVmomi import vmodl, vim
< 
< 
< ##
< ## @brief Exception class to represent when task is blocked (e.g.:
< ## waiting for an answer to a question.
< ##
< class TaskBlocked(Exception):
<     """
<     Exception class to represent when task is blocked (e.g.: waiting
<     for an answer to a question.
<     """
<     pass
< 
< 
< #
< # TaskUpdates
< #     verbose information about task progress
< #
< def TaskUpdatesVerbose(task, progress):
<     if isinstance(task.info.progress, int):
<         info = task.info
<         if not isinstance(progress, str):
<             progress = '%d%% (%s)' % (info.progress, info.state)
<         print('Task %s (key:%s, desc:%s) - %s' % (
<             info.name.info.name, info.key, info.description, progress))
< 
< 
< globalTaskUpdate = None
< 
< 
< def SetTasksVerbose(verbose=True):
<     global globalTaskUpdate
<     if verbose:
<         globalTaskUpdate = TaskUpdatesVerbose
<     else:
<         globalTaskUpdate = None
< 
< 
< ##
< ## @param raiseOnError [in] Any exception thrown is thrown up to the caller if
< ## raiseOnError is set to true
< ## @param si [in] ServiceInstance to use. If set to None, use the default one.
< ## @param pc [in] property collector to use else retrieve one from cache
< ## @param onProgressUpdate [in] callable to call with task progress updates.
< ##    For example:
< ##
< ##    def OnTaskProgressUpdate(task, percentDone):
< ##       sys.stderr.write('# Task %s: %d%% complete ...\n' % (task, percentDone))
< ##
< ## Given a task object and a service instance, wait for the task completion
< ##
< ## @return state as either "success" or "error". To look at any errors, the
< ## user should reexamine the task object.
< ##
< ## NOTE: This is a blocking call.
< ##
< def WaitForTask(task,
<                 raiseOnError=True,
<                 si=None,
<                 pc=None,
<                 onProgressUpdate=None):
<     """
<     Wait for task to complete.
< 
<     @type  raiseOnError      : bool
<     @param raiseOnError      : Any exception thrown is thrown up to the caller
<                                if raiseOnError is set to true.
<     @type  si                : ManagedObjectReference to a ServiceInstance.
<     @param si                : ServiceInstance to use. If None, use the
<                                information from the task.
<     @type  pc                : ManagedObjectReference to a PropertyCollector.
<     @param pc                : Property collector to use. If None, get it from
<                                the ServiceInstance.
<     @type  onProgressUpdate  : callable
<     @param onProgressUpdate  : Callable to call with task progress updates.
< 
<         For example::
< 
<             def OnTaskProgressUpdate(task, percentDone):
<                 print 'Task %s is %d%% complete.' % (task, percentDone)
<     """
< 
<     if si is None:
<         si = vim.ServiceInstance("ServiceInstance", task._stub)
<     if pc is None:
<         pc = si.content.propertyCollector
< 
<     progressUpdater = ProgressUpdater(task, onProgressUpdate)
<     progressUpdater.Update('created')
< 
<     filter = CreateFilter(pc, task)
< 
<     version, state = None, None
<     # Loop looking for updates till the state moves to a completed state.
<     while state not in (vim.TaskInfo.State.success, vim.TaskInfo.State.error):
<         try:
<             version, state = GetTaskStatus(task, version, pc)
<             progressUpdater.UpdateIfNeeded()
<         except vmodl.fault.ManagedObjectNotFound as e:
<             print("Task object has been deleted: %s" % e.obj)
<             break
< 
<     filter.Destroy()
< 
<     if state == "error":
<         progressUpdater.Update('error: %s' % str(task.info.error))
<         if raiseOnError:
<             raise task.info.error
<         else:
<             print("Task reported error: " + str(task.info.error))
<     else:
<         progressUpdater.Update('completed')
< 
<     return state
< 
< 
< ## Wait for multiple tasks to complete
< #  See WaitForTask for detail
< #
< #  Difference: WaitForTasks won't return the state of tasks. User can check
< #  tasks state directly with task.info.state
< #
< #  TODO: Did not check for question pending
< def WaitForTasks(tasks,
<                  raiseOnError=True,
<                  si=None,
<                  pc=None,
<                  onProgressUpdate=None,
<                  results=None):
<     """
<     Wait for mulitiple tasks to complete. Much faster than calling WaitForTask
<     N times
<     """
< 
<     if not tasks:
<         return
< 
<     if si is None:
<         si = vim.ServiceInstance("ServiceInstance", tasks[0]._stub)
<     if pc is None:
<         pc = si.content.propertyCollector
<     if results is None:
<         results = []
< 
<     progressUpdaters = {}
<     for task in tasks:
<         progressUpdater = ProgressUpdater(task, onProgressUpdate)
<         progressUpdater.Update('created')
<         progressUpdaters[str(task)] = progressUpdater
< 
<     filter = CreateTasksFilter(pc, tasks)
< 
<     try:
<         version, state = None, None
< 
<         # Loop looking for updates till the state moves to a completed state.
<         while len(progressUpdaters):
<             update = pc.WaitForUpdates(version)
<             for filterSet in update.filterSet:
<                 for objSet in filterSet.objectSet:
<                     task = objSet.obj
<                     taskId = str(task)
<                     for change in objSet.changeSet:
<                         if change.name == 'info':
<                             state = change.val.state
<                         elif change.name == 'info.state':
<                             state = change.val
<                         else:
<                             continue
< 
<                         progressUpdater = progressUpdaters.get(taskId)
<                         if not progressUpdater:
<                             continue
< 
<                         if state == vim.TaskInfo.State.success:
<                             progressUpdater.Update('completed')
<                             progressUpdaters.pop(taskId)
<                             # cache the results, as task objects could expire if one
<                             # of the tasks take a longer time to complete
<                             results.append(task.info.result)
<                         elif state == vim.TaskInfo.State.error:
<                             err = task.info.error
<                             progressUpdater.Update('error: %s' % str(err))
<                             if raiseOnError:
<                                 raise err
<                             else:
<                                 print("Task %s reported error: %s" % (taskId, str(err)))
<                                 progressUpdaters.pop(taskId)
<                         else:
<                             if onProgressUpdate:
<                                 progressUpdater.UpdateIfNeeded()
<             # Move to next version
<             version = update.version
<     finally:
<         if filter:
<             filter.Destroy()
<     return
< 
< 
< def GetTaskStatus(task, version, pc):
<     update = pc.WaitForUpdates(version)
<     state = task.info.state
< 
<     if (state == 'running' and task.info.name is not None and task.info.name.info.name != "Destroy"
<         and task.info.name.info.name != "Relocate"):
<         CheckForQuestionPending(task)
< 
<     return update.version, state
< 
< 
< def CreateFilter(pc, task):
<     """ Create property collector filter for task """
<     return CreateTasksFilter(pc, [task])
< 
< 
< def CreateTasksFilter(pc, tasks):
<     """ Create property collector filter for tasks """
<     if not tasks:
<         return None
< 
<     # First create the object specification as the task object.
<     objspecs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task)
<                 for task in tasks]
< 
<     # Next, create the property specification as the state.
<     propspec = vmodl.query.PropertyCollector.PropertySpec(
<         type=vim.Task, pathSet=[], all=True)
< 
<     # Create a filter spec with the specified object and property spec.
<     filterspec = vmodl.query.PropertyCollector.FilterSpec()
<     filterspec.objectSet = objspecs
<     filterspec.propSet = [propspec]
< 
<     # Create the filter
<     return pc.CreateFilter(filterspec, True)
< 
< 
< def CheckForQuestionPending(task):
<     """
<     Check to see if VM needs to ask a question, throw exception
<     """
< 
<     vm = task.info.entity
<     if vm is not None and isinstance(vm, vim.VirtualMachine):
<         qst = vm.runtime.question
<         if qst is not None:
<             raise TaskBlocked("Task blocked, User Intervention required")
< 
< 
< ##
< ## @brief Class that keeps track of task percentage complete and calls
< ## a provided callback when it changes.
< ##
< class ProgressUpdater(object):
<     """
<     Class that keeps track of task percentage complete and calls a
<     provided callback when it changes.
<     """
< 
<     def __init__(self, task, onProgressUpdate):
<         self.task = task
<         self.onProgressUpdate = onProgressUpdate
<         self.prevProgress = 0
<         self.progress = 0
< 
<     def Update(self, state):
<         global globalTaskUpdate
<         taskUpdate = globalTaskUpdate
<         if self.onProgressUpdate:
<             taskUpdate = self.onProgressUpdate
<         if taskUpdate:
<             taskUpdate(self.task, state)
< 
<     def UpdateIfNeeded(self):
<         self.progress = self.task.info.progress
< 
<         if self.progress != self.prevProgress:
<             self.Update(self.progress)
< 
<         self.prevProgress = self.progress
---
> # VMware vSphere Python SDK
> # Copyright (c) 2016 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> ## @file task.py
> ## @brief Task functions
> ##
> ## This module provies synchronization of client/server operations
> ## since many VIM operations return 'tasks' which can have
> ## varying completion times.
> 
> """
> Task functions
> 
> This module provies synchronization of client/server operations since
> many VIM operations return 'tasks' which can have varying completion
> times.
> """
> 
> from pyVmomi import vmodl, vim
> 
> 
> ##
> ## @brief Exception class to represent when task is blocked (e.g.:
> ## waiting for an answer to a question.
> ##
> class TaskBlocked(Exception):
>     """
>     Exception class to represent when task is blocked (e.g.: waiting
>     for an answer to a question.
>     """
>     pass
> 
> 
> #
> # TaskUpdates
> #     verbose information about task progress
> #
> def TaskUpdatesVerbose(task, progress):
>     if isinstance(task.info.progress, int):
>         info = task.info
>         if not isinstance(progress, str):
>             progress = '%d%% (%s)' % (info.progress, info.state)
>         print('Task %s (key:%s, desc:%s) - %s' % (
>             info.name.info.name, info.key, info.description, progress))
> 
> 
> globalTaskUpdate = None
> 
> 
> def SetTasksVerbose(verbose=True):
>     global globalTaskUpdate
>     if verbose:
>         globalTaskUpdate = TaskUpdatesVerbose
>     else:
>         globalTaskUpdate = None
> 
> 
> ##
> ## @param raiseOnError [in] Any exception thrown is thrown up to the caller if
> ## raiseOnError is set to true
> ## @param si [in] ServiceInstance to use. If set to None, use the default one.
> ## @param pc [in] property collector to use else retrieve one from cache
> ## @param onProgressUpdate [in] callable to call with task progress updates.
> ##    For example:
> ##
> ##    def OnTaskProgressUpdate(task, percentDone):
> ##       sys.stderr.write('# Task %s: %d%% complete ...\n' % (task, percentDone))
> ##
> ## Given a task object and a service instance, wait for the task completion
> ##
> ## @return state as either "success" or "error". To look at any errors, the
> ## user should reexamine the task object.
> ##
> ## NOTE: This is a blocking call.
> ##
> def WaitForTask(task,
>                 raiseOnError=True,
>                 si=None,
>                 pc=None,
>                 onProgressUpdate=None):
>     """
>     Wait for task to complete.
> 
>     @type  raiseOnError      : bool
>     @param raiseOnError      : Any exception thrown is thrown up to the caller
>                                if raiseOnError is set to true.
>     @type  si                : ManagedObjectReference to a ServiceInstance.
>     @param si                : ServiceInstance to use. If None, use the
>                                information from the task.
>     @type  pc                : ManagedObjectReference to a PropertyCollector.
>     @param pc                : Property collector to use. If None, get it from
>                                the ServiceInstance.
>     @type  onProgressUpdate  : callable
>     @param onProgressUpdate  : Callable to call with task progress updates.
> 
>         For example::
> 
>             def OnTaskProgressUpdate(task, percentDone):
>                 print 'Task %s is %d%% complete.' % (task, percentDone)
>     """
> 
>     if si is None:
>         si = vim.ServiceInstance("ServiceInstance", task._stub)
>     if pc is None:
>         pc = si.content.propertyCollector
> 
>     progressUpdater = ProgressUpdater(task, onProgressUpdate)
>     progressUpdater.Update('created')
> 
>     filter = CreateFilter(pc, task)
> 
>     version, state = None, None
>     # Loop looking for updates till the state moves to a completed state.
>     while state not in (vim.TaskInfo.State.success, vim.TaskInfo.State.error):
>         try:
>             version, state = GetTaskStatus(task, version, pc)
>             progressUpdater.UpdateIfNeeded()
>         except vmodl.fault.ManagedObjectNotFound as e:
>             print("Task object has been deleted: %s" % e.obj)
>             break
> 
>     filter.Destroy()
> 
>     if state == "error":
>         progressUpdater.Update('error: %s' % str(task.info.error))
>         if raiseOnError:
>             raise task.info.error
>         else:
>             print("Task reported error: " + str(task.info.error))
>     else:
>         progressUpdater.Update('completed')
> 
>     return state
> 
> 
> ## Wait for multiple tasks to complete
> #  See WaitForTask for detail
> #
> #  Difference: WaitForTasks won't return the state of tasks. User can check
> #  tasks state directly with task.info.state
> #
> #  TODO: Did not check for question pending
> def WaitForTasks(tasks,
>                  raiseOnError=True,
>                  si=None,
>                  pc=None,
>                  onProgressUpdate=None,
>                  results=None):
>     """
>     Wait for mulitiple tasks to complete. Much faster than calling WaitForTask
>     N times
>     """
> 
>     if not tasks:
>         return
> 
>     if si is None:
>         si = vim.ServiceInstance("ServiceInstance", tasks[0]._stub)
>     if pc is None:
>         pc = si.content.propertyCollector
>     if results is None:
>         results = []
> 
>     progressUpdaters = {}
>     for task in tasks:
>         progressUpdater = ProgressUpdater(task, onProgressUpdate)
>         progressUpdater.Update('created')
>         progressUpdaters[str(task)] = progressUpdater
> 
>     filter = CreateTasksFilter(pc, tasks)
> 
>     try:
>         version, state = None, None
> 
>         # Loop looking for updates till the state moves to a completed state.
>         while len(progressUpdaters):
>             update = pc.WaitForUpdates(version)
>             for filterSet in update.filterSet:
>                 for objSet in filterSet.objectSet:
>                     task = objSet.obj
>                     taskId = str(task)
>                     for change in objSet.changeSet:
>                         if change.name == 'info':
>                             state = change.val.state
>                         elif change.name == 'info.state':
>                             state = change.val
>                         else:
>                             continue
> 
>                         progressUpdater = progressUpdaters.get(taskId)
>                         if not progressUpdater:
>                             continue
> 
>                         if state == vim.TaskInfo.State.success:
>                             progressUpdater.Update('completed')
>                             progressUpdaters.pop(taskId)
>                             # cache the results, as task objects could expire if one
>                             # of the tasks take a longer time to complete
>                             results.append(task.info.result)
>                         elif state == vim.TaskInfo.State.error:
>                             err = task.info.error
>                             progressUpdater.Update('error: %s' % str(err))
>                             if raiseOnError:
>                                 raise err
>                             else:
>                                 print("Task %s reported error: %s" % (taskId, str(err)))
>                                 progressUpdaters.pop(taskId)
>                         else:
>                             if onProgressUpdate:
>                                 progressUpdater.UpdateIfNeeded()
>             # Move to next version
>             version = update.version
>     finally:
>         if filter:
>             filter.Destroy()
>     return
> 
> 
> def GetTaskStatus(task, version, pc):
>     update = pc.WaitForUpdates(version)
>     state = task.info.state
> 
>     if (state == 'running' and task.info.name is not None and task.info.name.info.name != "Destroy"
>         and task.info.name.info.name != "Relocate"):
>         CheckForQuestionPending(task)
> 
>     return update.version, state
> 
> 
> def CreateFilter(pc, task):
>     """ Create property collector filter for task """
>     return CreateTasksFilter(pc, [task])
> 
> 
> def CreateTasksFilter(pc, tasks):
>     """ Create property collector filter for tasks """
>     if not tasks:
>         return None
> 
>     # First create the object specification as the task object.
>     objspecs = [vmodl.query.PropertyCollector.ObjectSpec(obj=task)
>                 for task in tasks]
> 
>     # Next, create the property specification as the state.
>     propspec = vmodl.query.PropertyCollector.PropertySpec(
>         type=vim.Task, pathSet=[], all=True)
> 
>     # Create a filter spec with the specified object and property spec.
>     filterspec = vmodl.query.PropertyCollector.FilterSpec()
>     filterspec.objectSet = objspecs
>     filterspec.propSet = [propspec]
> 
>     # Create the filter
>     return pc.CreateFilter(filterspec, True)
> 
> 
> def CheckForQuestionPending(task):
>     """
>     Check to see if VM needs to ask a question, throw exception
>     """
> 
>     vm = task.info.entity
>     if vm is not None and isinstance(vm, vim.VirtualMachine):
>         qst = vm.runtime.question
>         if qst is not None:
>             raise TaskBlocked("Task blocked, User Intervention required")
> 
> 
> ##
> ## @brief Class that keeps track of task percentage complete and calls
> ## a provided callback when it changes.
> ##
> class ProgressUpdater(object):
>     """
>     Class that keeps track of task percentage complete and calls a
>     provided callback when it changes.
>     """
> 
>     def __init__(self, task, onProgressUpdate):
>         self.task = task
>         self.onProgressUpdate = onProgressUpdate
>         self.prevProgress = 0
>         self.progress = 0
> 
>     def Update(self, state):
>         global globalTaskUpdate
>         taskUpdate = globalTaskUpdate
>         if self.onProgressUpdate:
>             taskUpdate = self.onProgressUpdate
>         if taskUpdate:
>             taskUpdate(self.task, state)
> 
>     def UpdateIfNeeded(self):
>         self.progress = self.task.info.progress
> 
>         if self.progress != self.prevProgress:
>             self.Update(self.progress)
> 
>         self.prevProgress = self.progress
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Cache.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Cache.py
1,42c1,42
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< """
< This module implements the cache decorator
< """
< __author__ = "VMware, Inc."
< 
< def Cache(fn):
<    """ Function cache decorator """
<    def fnCache(*args, **kwargs):
<       """ Cache function """
<       key = (args and tuple(args) or None,
<              kwargs and frozenset(kwargs.items()) or None)
<       if key not in fn.__cached__:
<          fn.__cached__[key] = cache = fn(*args, **kwargs)
<       else:
<          cache = fn.__cached__[key]
<       return cache
< 
<    def ResetCache():
<       """ Reset cache """
<       fn.__cached__ = {}
< 
<    setattr(fn, "__cached__", {})
<    setattr(fn, "__resetcache__", ResetCache)
<    fnCache.__name__ = fn.__name__
<    fnCache.__doc__ = fn.__doc__
<    fnCache.__dict__.update(fn.__dict__)
<    return fnCache
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> """
> This module implements the cache decorator
> """
> __author__ = "VMware, Inc."
> 
> def Cache(fn):
>    """ Function cache decorator """
>    def fnCache(*args, **kwargs):
>       """ Cache function """
>       key = (args and tuple(args) or None,
>              kwargs and frozenset(kwargs.items()) or None)
>       if key not in fn.__cached__:
>          fn.__cached__[key] = cache = fn(*args, **kwargs)
>       else:
>          cache = fn.__cached__[key]
>       return cache
> 
>    def ResetCache():
>       """ Reset cache """
>       fn.__cached__ = {}
> 
>    setattr(fn, "__cached__", {})
>    setattr(fn, "__resetcache__", ResetCache)
>    fnCache.__name__ = fn.__name__
>    fnCache.__doc__ = fn.__doc__
>    fnCache.__dict__.update(fn.__dict__)
>    return fnCache
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Differ.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Differ.py
1,229c1,229
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< ## Diff any two objects
< import six
< from six.moves import zip
< 
< from pyVmomi import VmomiSupport, types
< import logging
< from VmomiSupport import GetWsdlName, Type
< 
< __Log__ = logging.getLogger('ObjDiffer')
< 
< def LogIf(condition, message):
<    """Log a message if the condition is met"""
<    if condition:
<       __Log__.debug(message)
< 
< def IsPrimitiveType(obj):
<    """See if the passed in type is a Primitive Type"""
<    return (isinstance(obj, types.bool) or isinstance(obj, types.byte) or
<       isinstance(obj, types.short) or isinstance(obj, six.integer_types) or
<       isinstance(obj, types.double) or isinstance(obj, types.float) or
<       isinstance(obj, six.string_types) or
<       isinstance(obj, types.PropertyPath) or
<       isinstance(obj, types.ManagedMethod) or
<       isinstance(obj, types.datetime) or
<       isinstance(obj, types.URI) or isinstance(obj, type))
< 
< 
< class Differ:
<    """Class for comparing two Objects"""
<    def __init__(self, looseMatch=False, ignoreArrayOrder=True):
<       self._looseMatch = looseMatch
<       self._ignoreArrayOrder = ignoreArrayOrder
< 
<    def DiffAnyObjects(self, oldObj, newObj, isObjLink=False):
<       """Diff any two Objects"""
<       if oldObj == newObj:
<          return True
<       if not oldObj or not newObj:
<          __Log__.debug('DiffAnyObjects: One of the objects is unset.')
<          return self._looseMatch
<       oldObjInstance = oldObj
<       newObjInstance = newObj
<       if isinstance(oldObj, list):
<          oldObjInstance = oldObj[0]
<       if isinstance(newObj, list):
<          newObjInstance = newObj[0]
<       # Need to see if it is a primitive type first since type information
<       #   will not be available for them.
<       if (IsPrimitiveType(oldObj) and IsPrimitiveType(newObj)
<          and oldObj.__class__.__name__ == newObj.__class__.__name__):
<          if oldObj == newObj:
<             return True
<          elif oldObj == None or newObj == None:
<             __Log__.debug('DiffAnyObjects: One of the objects in None')
<          return False
<       oldType = Type(oldObjInstance)
<       newType = Type(newObjInstance)
<       if oldType != newType:
<          __Log__.debug('DiffAnyObjects: Types do not match %s != %s' %
<             (repr(GetWsdlName(oldObjInstance.__class__)),
<              repr(GetWsdlName(newObjInstance.__class__))))
<          return False
<       elif isinstance(oldObj, list):
<          return self.DiffArrayObjects(oldObj, newObj, isObjLink)
<       elif isinstance(oldObjInstance, types.ManagedObject):
<          return (not oldObj and not newObj) or (oldObj and newObj
<             and oldObj._moId == newObj._moId)
<       elif isinstance(oldObjInstance, types.DataObject):
<          if isObjLink:
<             bMatch = oldObj.GetKey() == newObj.GetKey()
<             LogIf(not bMatch, 'DiffAnyObjects: Keys do not match %s != %s'
<                % (oldObj.GetKey(), newObj.GetKey()))
<             return bMatch
<          return self.DiffDataObjects(oldObj, newObj)
< 
<       else:
<          raise TypeError("Unknown type: "+repr(GetWsdlName(oldObj.__class__)))
< 
<    def DiffDoArrays(self, oldObj, newObj, isElementLinks):
<       """Diff two DataObject arrays"""
<       if len(oldObj) != len(newObj):
<          __Log__.debug('DiffDoArrays: Array lengths do not match %d != %d'
<             % (len(oldObj), len(newObj)))
<          return False
<       for i, j in zip(oldObj, newObj):
<          if isElementLinks:
<             if i.GetKey() != j.GetKey():
<                __Log__.debug('DiffDoArrays: Keys do not match %s != %s'
<                   % (i.GetKey(), j.GetKey()))
<                return False
<          else:
<             if not self.DiffDataObjects(i, j):
<                __Log__.debug(
<                   'DiffDoArrays: one of the elements do not match')
<                return False
<       return True
< 
<    def DiffAnyArrays(self, oldObj, newObj, isElementLinks):
<       """Diff two arrays which contain Any objects"""
<       if len(oldObj) != len(newObj):
<          __Log__.debug('DiffAnyArrays: Array lengths do not match. %d != %d'
<             % (len(oldObj), len(newObj)))
<          return False
<       for i, j in zip(oldObj, newObj):
<          if not self.DiffAnyObjects(i, j, isElementLinks):
<             __Log__.debug('DiffAnyArrays: One of the elements do not match.')
<             return False
<       return True
< 
<    def DiffPrimitiveArrays(self, oldObj, newObj):
<       """Diff two primitive arrays"""
<       if len(oldObj) != len(newObj):
<          __Log__.debug('DiffDoArrays: Array lengths do not match %d != %d'
<             % (len(oldObj), len(newObj)))
<          return False
<       match = True
<       if self._ignoreArrayOrder:
<          oldSet = oldObj and frozenset(oldObj) or frozenset()
<          newSet = newObj and frozenset(newObj) or frozenset()
<          match = (oldSet == newSet)
<       else:
<          for i, j in zip(oldObj, newObj):
<             if i != j:
<                match = False
<                break
<       if not match:
<          __Log__.debug(
<             'DiffPrimitiveArrays: One of the elements do not match.')
<          return False
<       return True
< 
< 
<    def DiffArrayObjects(self, oldObj, newObj, isElementLinks=False):
<       """Method which deligates the diffing of arrays based on the type"""
<       if oldObj == newObj:
<          return True
<       if not oldObj or not newObj:
<          return False
<       if len(oldObj) != len(newObj):
<          __Log__.debug('DiffArrayObjects: Array lengths do not match %d != %d'
<             % (len(oldObj), len(newObj)))
<          return False
<       firstObj = oldObj[0]
<       if IsPrimitiveType(firstObj):
<          return self.DiffPrimitiveArrays(oldObj, newObj)
<       elif isinstance(firstObj, types.ManagedObject):
<          return self.DiffAnyArrays(oldObj, newObj, isElementLinks)
<       elif isinstance(firstObj, types.DataObject):
<          return self.DiffDoArrays(oldObj, newObj, isElementLinks)
<       else:
<          raise TypeError("Unknown type: %s" % oldObj.__class__)
< 
< 
<    def DiffDataObjects(self, oldObj, newObj):
<       """Diff Data Objects"""
<       if oldObj == newObj:
<          return True
<       if not oldObj or not newObj:
<          __Log__.debug('DiffDataObjects: One of the objects in None')
<          return False
<       oldType = Type(oldObj)
<       newType = Type(newObj)
<       if oldType != newType:
<          __Log__.debug(
<             'DiffDataObjects: Types do not match for dataobjects. %s != %s'
<             % (oldObj._wsdlName, newObj._wsdlName))
<          return False
<       for prop in oldObj._GetPropertyList():
<          oldProp = getattr(oldObj, prop.name)
<          newProp = getattr(newObj, prop.name)
<          propType = oldObj._GetPropertyInfo(prop.name).type
<          if not oldProp and not newProp:
<             continue
<          elif ((prop.flags & VmomiSupport.F_OPTIONAL) and
<                self._looseMatch and (not newProp or not oldProp)):
<             continue
<          elif not oldProp or not newProp:
<             __Log__.debug(
<                'DiffDataObjects: One of the objects has property %s unset'
<                % prop.name)
<             return False
< 
<          bMatch = True
<          if IsPrimitiveType(oldProp):
<             bMatch = oldProp == newProp
<          elif isinstance(oldProp, types.ManagedObject):
<             bMatch = self.DiffAnyObjects(oldProp, newProp, prop.flags
<                & VmomiSupport.F_LINK)
<          elif isinstance(oldProp, types.DataObject):
<             if prop.flags & VmomiSupport.F_LINK:
<                bMatch = oldObj.GetKey() == newObj.GetKey()
<                LogIf(not bMatch, 'DiffDataObjects: Key match failed %s != %s'
<                   % (oldObj.GetKey(), newObj.GetKey()))
<             else:
<                bMatch = self.DiffAnyObjects(oldProp, newProp, prop.flags
<                   & VmomiSupport.F_LINK)
<          elif isinstance(oldProp, list):
<             bMatch = self.DiffArrayObjects(oldProp, newProp, prop.flags
<                & VmomiSupport.F_LINK)
<          else:
<             raise TypeError("Unknown type: "+repr(propType))
< 
<          if not bMatch:
<             __Log__.debug('DiffDataObjects: Objects differ in property %s'
<                % prop.name)
<             return False
<       return True
< 
< 
< def DiffAnys(obj1, obj2, looseMatch=False, ignoreArrayOrder=True):
<    """Diff any two objects. Objects can either be primitive type
<       or DataObjects"""
<    differ = Differ(looseMatch = looseMatch, ignoreArrayOrder = ignoreArrayOrder)
<    return differ.DiffAnyObjects(obj1, obj2)
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> ## Diff any two objects
> import six
> from six.moves import zip
> 
> from pyVmomi import VmomiSupport, types
> import logging
> from VmomiSupport import GetWsdlName, Type
> 
> __Log__ = logging.getLogger('ObjDiffer')
> 
> def LogIf(condition, message):
>    """Log a message if the condition is met"""
>    if condition:
>       __Log__.debug(message)
> 
> def IsPrimitiveType(obj):
>    """See if the passed in type is a Primitive Type"""
>    return (isinstance(obj, types.bool) or isinstance(obj, types.byte) or
>       isinstance(obj, types.short) or isinstance(obj, six.integer_types) or
>       isinstance(obj, types.double) or isinstance(obj, types.float) or
>       isinstance(obj, six.string_types) or
>       isinstance(obj, types.PropertyPath) or
>       isinstance(obj, types.ManagedMethod) or
>       isinstance(obj, types.datetime) or
>       isinstance(obj, types.URI) or isinstance(obj, type))
> 
> 
> class Differ:
>    """Class for comparing two Objects"""
>    def __init__(self, looseMatch=False, ignoreArrayOrder=True):
>       self._looseMatch = looseMatch
>       self._ignoreArrayOrder = ignoreArrayOrder
> 
>    def DiffAnyObjects(self, oldObj, newObj, isObjLink=False):
>       """Diff any two Objects"""
>       if oldObj == newObj:
>          return True
>       if not oldObj or not newObj:
>          __Log__.debug('DiffAnyObjects: One of the objects is unset.')
>          return self._looseMatch
>       oldObjInstance = oldObj
>       newObjInstance = newObj
>       if isinstance(oldObj, list):
>          oldObjInstance = oldObj[0]
>       if isinstance(newObj, list):
>          newObjInstance = newObj[0]
>       # Need to see if it is a primitive type first since type information
>       #   will not be available for them.
>       if (IsPrimitiveType(oldObj) and IsPrimitiveType(newObj)
>          and oldObj.__class__.__name__ == newObj.__class__.__name__):
>          if oldObj == newObj:
>             return True
>          elif oldObj == None or newObj == None:
>             __Log__.debug('DiffAnyObjects: One of the objects in None')
>          return False
>       oldType = Type(oldObjInstance)
>       newType = Type(newObjInstance)
>       if oldType != newType:
>          __Log__.debug('DiffAnyObjects: Types do not match %s != %s' %
>             (repr(GetWsdlName(oldObjInstance.__class__)),
>              repr(GetWsdlName(newObjInstance.__class__))))
>          return False
>       elif isinstance(oldObj, list):
>          return self.DiffArrayObjects(oldObj, newObj, isObjLink)
>       elif isinstance(oldObjInstance, types.ManagedObject):
>          return (not oldObj and not newObj) or (oldObj and newObj
>             and oldObj._moId == newObj._moId)
>       elif isinstance(oldObjInstance, types.DataObject):
>          if isObjLink:
>             bMatch = oldObj.GetKey() == newObj.GetKey()
>             LogIf(not bMatch, 'DiffAnyObjects: Keys do not match %s != %s'
>                % (oldObj.GetKey(), newObj.GetKey()))
>             return bMatch
>          return self.DiffDataObjects(oldObj, newObj)
> 
>       else:
>          raise TypeError("Unknown type: "+repr(GetWsdlName(oldObj.__class__)))
> 
>    def DiffDoArrays(self, oldObj, newObj, isElementLinks):
>       """Diff two DataObject arrays"""
>       if len(oldObj) != len(newObj):
>          __Log__.debug('DiffDoArrays: Array lengths do not match %d != %d'
>             % (len(oldObj), len(newObj)))
>          return False
>       for i, j in zip(oldObj, newObj):
>          if isElementLinks:
>             if i.GetKey() != j.GetKey():
>                __Log__.debug('DiffDoArrays: Keys do not match %s != %s'
>                   % (i.GetKey(), j.GetKey()))
>                return False
>          else:
>             if not self.DiffDataObjects(i, j):
>                __Log__.debug(
>                   'DiffDoArrays: one of the elements do not match')
>                return False
>       return True
> 
>    def DiffAnyArrays(self, oldObj, newObj, isElementLinks):
>       """Diff two arrays which contain Any objects"""
>       if len(oldObj) != len(newObj):
>          __Log__.debug('DiffAnyArrays: Array lengths do not match. %d != %d'
>             % (len(oldObj), len(newObj)))
>          return False
>       for i, j in zip(oldObj, newObj):
>          if not self.DiffAnyObjects(i, j, isElementLinks):
>             __Log__.debug('DiffAnyArrays: One of the elements do not match.')
>             return False
>       return True
> 
>    def DiffPrimitiveArrays(self, oldObj, newObj):
>       """Diff two primitive arrays"""
>       if len(oldObj) != len(newObj):
>          __Log__.debug('DiffDoArrays: Array lengths do not match %d != %d'
>             % (len(oldObj), len(newObj)))
>          return False
>       match = True
>       if self._ignoreArrayOrder:
>          oldSet = oldObj and frozenset(oldObj) or frozenset()
>          newSet = newObj and frozenset(newObj) or frozenset()
>          match = (oldSet == newSet)
>       else:
>          for i, j in zip(oldObj, newObj):
>             if i != j:
>                match = False
>                break
>       if not match:
>          __Log__.debug(
>             'DiffPrimitiveArrays: One of the elements do not match.')
>          return False
>       return True
> 
> 
>    def DiffArrayObjects(self, oldObj, newObj, isElementLinks=False):
>       """Method which deligates the diffing of arrays based on the type"""
>       if oldObj == newObj:
>          return True
>       if not oldObj or not newObj:
>          return False
>       if len(oldObj) != len(newObj):
>          __Log__.debug('DiffArrayObjects: Array lengths do not match %d != %d'
>             % (len(oldObj), len(newObj)))
>          return False
>       firstObj = oldObj[0]
>       if IsPrimitiveType(firstObj):
>          return self.DiffPrimitiveArrays(oldObj, newObj)
>       elif isinstance(firstObj, types.ManagedObject):
>          return self.DiffAnyArrays(oldObj, newObj, isElementLinks)
>       elif isinstance(firstObj, types.DataObject):
>          return self.DiffDoArrays(oldObj, newObj, isElementLinks)
>       else:
>          raise TypeError("Unknown type: %s" % oldObj.__class__)
> 
> 
>    def DiffDataObjects(self, oldObj, newObj):
>       """Diff Data Objects"""
>       if oldObj == newObj:
>          return True
>       if not oldObj or not newObj:
>          __Log__.debug('DiffDataObjects: One of the objects in None')
>          return False
>       oldType = Type(oldObj)
>       newType = Type(newObj)
>       if oldType != newType:
>          __Log__.debug(
>             'DiffDataObjects: Types do not match for dataobjects. %s != %s'
>             % (oldObj._wsdlName, newObj._wsdlName))
>          return False
>       for prop in oldObj._GetPropertyList():
>          oldProp = getattr(oldObj, prop.name)
>          newProp = getattr(newObj, prop.name)
>          propType = oldObj._GetPropertyInfo(prop.name).type
>          if not oldProp and not newProp:
>             continue
>          elif ((prop.flags & VmomiSupport.F_OPTIONAL) and
>                self._looseMatch and (not newProp or not oldProp)):
>             continue
>          elif not oldProp or not newProp:
>             __Log__.debug(
>                'DiffDataObjects: One of the objects has property %s unset'
>                % prop.name)
>             return False
> 
>          bMatch = True
>          if IsPrimitiveType(oldProp):
>             bMatch = oldProp == newProp
>          elif isinstance(oldProp, types.ManagedObject):
>             bMatch = self.DiffAnyObjects(oldProp, newProp, prop.flags
>                & VmomiSupport.F_LINK)
>          elif isinstance(oldProp, types.DataObject):
>             if prop.flags & VmomiSupport.F_LINK:
>                bMatch = oldObj.GetKey() == newObj.GetKey()
>                LogIf(not bMatch, 'DiffDataObjects: Key match failed %s != %s'
>                   % (oldObj.GetKey(), newObj.GetKey()))
>             else:
>                bMatch = self.DiffAnyObjects(oldProp, newProp, prop.flags
>                   & VmomiSupport.F_LINK)
>          elif isinstance(oldProp, list):
>             bMatch = self.DiffArrayObjects(oldProp, newProp, prop.flags
>                & VmomiSupport.F_LINK)
>          else:
>             raise TypeError("Unknown type: "+repr(propType))
> 
>          if not bMatch:
>             __Log__.debug('DiffDataObjects: Objects differ in property %s'
>                % prop.name)
>             return False
>       return True
> 
> 
> def DiffAnys(obj1, obj2, looseMatch=False, ignoreArrayOrder=True):
>    """Diff any two objects. Objects can either be primitive type
>       or DataObjects"""
>    differ = Differ(looseMatch = looseMatch, ignoreArrayOrder = ignoreArrayOrder)
>    return differ.DiffAnyObjects(obj1, obj2)
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/DynamicTypeManagerHelper.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/DynamicTypeManagerHelper.py
1,289c1,289
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< """
< This module is a converter from dynamic type to pyVmomi type
< """
< __author__ = "VMware, Inc."
< 
< from pyVmomi import VmomiSupport, vmodl
< from Cache import Cache
< 
< ## Dynamic type importer
< #
< class DynamicTypeImporter:
<    """ Dynamic type importer  """
< 
<    ## Constructor
<    #
<    # @param  stub Server stub
<    def __init__(self, stub, hostSystem=None):
<       self.stub = stub
<       self.hostSystem = hostSystem
< 
<    ## Get dynamic type manager
<    #
<    # @return moRef to dynamic type manager
<    @Cache
<    def GetTypeManager(self):
<       """ Get dynamic type manager """
<       dynTypeMgr = None
<       if self.hostSystem:
<          try:
<             dynTypeMgr = self.hostSystem.RetrieveDynamicTypeManager()
<          except vmodl.fault.MethodNotFound as err:
<             pass
< 
<       if not dynTypeMgr:
<          # Older host not support RetrieveDynamicTypeManager
<          cmdlineTypesMoId = "ha-dynamic-type-manager"
<          dynTypeMgr = vmodl.reflect.DynamicTypeManager(cmdlineTypesMoId,
<                                                        self.stub)
<       return dynTypeMgr
< 
<    ## Import dynamic types
<    #
<    # @param  prefix Only types with the specified prefix are imported
<    # @return dynamic types
<    @Cache
<    def ImportTypes(self, prefix=''):
<       """ Build dynamic types """
<       # Use QueryTypeInfo to get all types
<       dynTypeMgr = self.GetTypeManager()
<       filterSpec = None
<       if prefix != '':
<          filterSpec = vmodl.reflect.DynamicTypeManager.TypeFilterSpec(
<                                                               typeSubstr=prefix)
<       allTypes = dynTypeMgr.QueryTypeInfo(filterSpec)
< 
<       ## Convert dynamic types to pyVmomi types
<       #
<       DynamicTypeConstructor().CreateTypes(allTypes)
<       return allTypes
< 
< 
< ## Construct pyVmomi types from dynamic types definition
< #
< class DynamicTypeConstructor:
<    """ Dynamic type constructor  """
< 
<    _mapFlags = { "optional": VmomiSupport.F_OPTIONAL,
<                  "linkable": VmomiSupport.F_LINKABLE,
<                  "link":     VmomiSupport.F_LINK,
<                  "secret":   VmomiSupport.F_SECRET }
< 
<    ## Constructor
<    #
<    def __init__(self):
<       """ Constructor """
<       pass
< 
<    ## Create pyVmomi types from vmodl.reflect.DynamicTypeManager.AllTypeInfo
<    #
<    # @param  allTypes vmodl.reflect.DynamicTypeManager.AllTypeInfo
<    def CreateTypes(self, allTypes):
<       """
<       Create pyVmomi types from vmodl.reflect.DynamicTypeManager.AllTypeInfo
<       """
<       enumTypes, dataTypes, managedTypes = self._ConvertAllTypes(allTypes)
<       self._CreateAllTypes(enumTypes, dataTypes, managedTypes)
< 
<    ## Convert all dynamic types to pyVmomi type definitions
<    #
<    # @param  allTypes vmodl.reflect.DynamicTypeManager.AllTypeInfo
<    # @return a tuple of (enumTypes, dataTypes, managedTypes)
<    def _ConvertAllTypes(self, allTypes):
<       """ Convert all dynamic types to pyVmomi type definitions """
<       # Generate lists good for VmomiSupport.CreateXYZType
<       enumTypes = self._Filter(self._ConvertEnumType, allTypes.enumTypeInfo)
<       dataTypes = self._Filter(self._ConvertDataType, allTypes.dataTypeInfo)
<       managedTypes = self._Filter(self._ConvertManagedType,
<                                   allTypes.managedTypeInfo)
<       retAllTypes = (enumTypes, dataTypes, managedTypes)
<       return retAllTypes
< 
<    ## Create pyVmomi types from pyVmomi type definitions
<    #
<    # @param  enumTypes pyVmomi enum type definitions
<    # @param  dataTypes pyVmomi data type definitions
<    # @param  managedTypes pyVmomi managed type definitions
<    def _CreateAllTypes(self, enumTypes, dataTypes, managedTypes):
<       """ Create pyVmomi types from pyVmomi type definitions """
< 
<       # Create versions
<       for typeInfo in managedTypes:
<          name = typeInfo[0]
<          version = typeInfo[3]
<          VmomiSupport.AddVersion(version, '', '1.0', 0, name)
<          VmomiSupport.AddVersionParent(version, 'vmodl.version.version0')
<          VmomiSupport.AddVersionParent(version, 'vmodl.version.version1')
<          VmomiSupport.AddVersionParent(version, version)
< 
<       # Create partial types
<       for fn, infos in (VmomiSupport.CreateEnumType, enumTypes), \
<                        (VmomiSupport.CreateDataType, dataTypes), \
<                        (VmomiSupport.CreateManagedType, managedTypes):
<          for typeInfo in infos:
<             try:
<                fn(*typeInfo)
<             except Exception as err:
<                #Ignore errors due to duplicate importing
<                pass
< 
<    def _ConvertAnnotations(self, annotations):
<       """ Convert annotations to pyVmomi flags """
<       flags = 0
<       if annotations:
<          for annotation in annotations:
<             flags |= self._mapFlags.get(annotation.name, 0)
<       return flags
< 
<    @staticmethod
<    def _Filter(fn, types):
<       """ Call fn for each non null element in types. Similiar to filter """
<       if types:
<          return [fn(prop) for prop in types if prop is not None]
<       else:
<          return []
< 
<    def _ConvertParamType(self, paramType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.ParamTypeInfo to pyVmomi param
<       definition
<       """
<       if paramType:
<          name = paramType.name
<          version = paramType.version
<          aType = paramType.type
<          flags = self._ConvertAnnotations(paramType.annotation)
<          privId = paramType.privId
<          param = (name, aType, version, flags, privId)
<       else:
<          param = None
<       return param
< 
<    def _ConvertMethodType(self, methodType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.MethodTypeInfo to pyVmomi method
<       definition
<       """
<       if methodType:
<          name = methodType.name
<          wsdlName = methodType.wsdlName
<          version = methodType.version
<          params = self._Filter(self._ConvertParamType, methodType.paramTypeInfo)
<          privId = methodType.privId
<          faults = methodType.fault
< 
<          # Figure out reture info
<          if methodType.returnTypeInfo:
<             returnTypeInfo = methodType.returnTypeInfo
<             retFlags = self._ConvertAnnotations(returnTypeInfo.annotation)
<             methodRetType = returnTypeInfo.type
<          else:
<             retFlags = 0
<             methodRetType = "void"
<          if wsdlName.endswith("_Task"):
<             # TODO: Need a seperate task return type for task, instead of
<             #       hardcode vim.Task as return type
<             retType = "vim.Task"
<          else:
<             retType = methodRetType
<          retInfo = (retFlags, retType, methodRetType)
< 
<          method = (name, wsdlName, version, params, retInfo, privId, faults)
<       else:
<          method = None
<       return method
< 
<    def _ConvertManagedPropertyType(self, propType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.PropertyTypeInfo to pyVmomi
<       managed property definition
<       """
<       if propType:
<          name = propType.name
<          version = propType.version
<          aType = propType.type
<          flags = self._ConvertAnnotations(propType.annotation)
<          privId = propType.privId
<          prop = (name, aType, version, flags, privId)
<       else:
<          prop = None
<       return prop
< 
<    def _ConvertManagedType(self, managedType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.ManagedTypeInfo to pyVmomi
<       managed type definition
<       """
<       if managedType:
<          vmodlName = managedType.name
<          wsdlName = managedType.wsdlName
<          version = managedType.version
<          parent = managedType.base[0]
<          props = self._Filter(self._ConvertManagedPropertyType, managedType.property)
<          methods = self._Filter(self._ConvertMethodType, managedType.method)
<          moType = (vmodlName, wsdlName, parent, version, props, methods)
<       else:
<          moType = None
<       return moType
< 
<    def _ConvertDataPropertyType(self, propType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.PropertyTypeInfo to pyVmomi
<       data property definition
<       """
<       if propType:
<          name = propType.name
<          version = propType.version
<          aType = propType.type
<          flags = self._ConvertAnnotations(propType.annotation)
<          prop = (name, aType, version, flags)
<       else:
<          prop = None
<       return prop
< 
<    def _ConvertDataType(self, dataType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.DataTypeInfo to pyVmomi data
<       type definition
<       """
<       if dataType:
<          vmodlName = dataType.name
<          wsdlName = dataType.wsdlName
<          version = dataType.version
<          parent = dataType.base[0]
<          props = self._Filter(self._ConvertDataPropertyType, dataType.property)
<          doType = (vmodlName, wsdlName, parent, version, props)
<       else:
<          doType = None
<       return doType
< 
<    def _ConvertEnumType(self, enumType):
<       """
<       Convert vmodl.reflect.DynamicTypeManager.EnumTypeInfo to pyVmomi enum
<       type definition
<       """
<       if enumType:
<          vmodlName = enumType.name
<          wsdlName = enumType.wsdlName
<          version = enumType.version
<          values = enumType.value
<          enumType = (vmodlName, wsdlName, version, values)
<       else:
<          enumType = None
<       return enumType
< 
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> """
> This module is a converter from dynamic type to pyVmomi type
> """
> __author__ = "VMware, Inc."
> 
> from pyVmomi import VmomiSupport, vmodl
> from Cache import Cache
> 
> ## Dynamic type importer
> #
> class DynamicTypeImporter:
>    """ Dynamic type importer  """
> 
>    ## Constructor
>    #
>    # @param  stub Server stub
>    def __init__(self, stub, hostSystem=None):
>       self.stub = stub
>       self.hostSystem = hostSystem
> 
>    ## Get dynamic type manager
>    #
>    # @return moRef to dynamic type manager
>    @Cache
>    def GetTypeManager(self):
>       """ Get dynamic type manager """
>       dynTypeMgr = None
>       if self.hostSystem:
>          try:
>             dynTypeMgr = self.hostSystem.RetrieveDynamicTypeManager()
>          except vmodl.fault.MethodNotFound as err:
>             pass
> 
>       if not dynTypeMgr:
>          # Older host not support RetrieveDynamicTypeManager
>          cmdlineTypesMoId = "ha-dynamic-type-manager"
>          dynTypeMgr = vmodl.reflect.DynamicTypeManager(cmdlineTypesMoId,
>                                                        self.stub)
>       return dynTypeMgr
> 
>    ## Import dynamic types
>    #
>    # @param  prefix Only types with the specified prefix are imported
>    # @return dynamic types
>    @Cache
>    def ImportTypes(self, prefix=''):
>       """ Build dynamic types """
>       # Use QueryTypeInfo to get all types
>       dynTypeMgr = self.GetTypeManager()
>       filterSpec = None
>       if prefix != '':
>          filterSpec = vmodl.reflect.DynamicTypeManager.TypeFilterSpec(
>                                                               typeSubstr=prefix)
>       allTypes = dynTypeMgr.QueryTypeInfo(filterSpec)
> 
>       ## Convert dynamic types to pyVmomi types
>       #
>       DynamicTypeConstructor().CreateTypes(allTypes)
>       return allTypes
> 
> 
> ## Construct pyVmomi types from dynamic types definition
> #
> class DynamicTypeConstructor:
>    """ Dynamic type constructor  """
> 
>    _mapFlags = { "optional": VmomiSupport.F_OPTIONAL,
>                  "linkable": VmomiSupport.F_LINKABLE,
>                  "link":     VmomiSupport.F_LINK,
>                  "secret":   VmomiSupport.F_SECRET }
> 
>    ## Constructor
>    #
>    def __init__(self):
>       """ Constructor """
>       pass
> 
>    ## Create pyVmomi types from vmodl.reflect.DynamicTypeManager.AllTypeInfo
>    #
>    # @param  allTypes vmodl.reflect.DynamicTypeManager.AllTypeInfo
>    def CreateTypes(self, allTypes):
>       """
>       Create pyVmomi types from vmodl.reflect.DynamicTypeManager.AllTypeInfo
>       """
>       enumTypes, dataTypes, managedTypes = self._ConvertAllTypes(allTypes)
>       self._CreateAllTypes(enumTypes, dataTypes, managedTypes)
> 
>    ## Convert all dynamic types to pyVmomi type definitions
>    #
>    # @param  allTypes vmodl.reflect.DynamicTypeManager.AllTypeInfo
>    # @return a tuple of (enumTypes, dataTypes, managedTypes)
>    def _ConvertAllTypes(self, allTypes):
>       """ Convert all dynamic types to pyVmomi type definitions """
>       # Generate lists good for VmomiSupport.CreateXYZType
>       enumTypes = self._Filter(self._ConvertEnumType, allTypes.enumTypeInfo)
>       dataTypes = self._Filter(self._ConvertDataType, allTypes.dataTypeInfo)
>       managedTypes = self._Filter(self._ConvertManagedType,
>                                   allTypes.managedTypeInfo)
>       retAllTypes = (enumTypes, dataTypes, managedTypes)
>       return retAllTypes
> 
>    ## Create pyVmomi types from pyVmomi type definitions
>    #
>    # @param  enumTypes pyVmomi enum type definitions
>    # @param  dataTypes pyVmomi data type definitions
>    # @param  managedTypes pyVmomi managed type definitions
>    def _CreateAllTypes(self, enumTypes, dataTypes, managedTypes):
>       """ Create pyVmomi types from pyVmomi type definitions """
> 
>       # Create versions
>       for typeInfo in managedTypes:
>          name = typeInfo[0]
>          version = typeInfo[3]
>          VmomiSupport.AddVersion(version, '', '1.0', 0, name)
>          VmomiSupport.AddVersionParent(version, 'vmodl.version.version0')
>          VmomiSupport.AddVersionParent(version, 'vmodl.version.version1')
>          VmomiSupport.AddVersionParent(version, version)
> 
>       # Create partial types
>       for fn, infos in (VmomiSupport.CreateEnumType, enumTypes), \
>                        (VmomiSupport.CreateDataType, dataTypes), \
>                        (VmomiSupport.CreateManagedType, managedTypes):
>          for typeInfo in infos:
>             try:
>                fn(*typeInfo)
>             except Exception as err:
>                #Ignore errors due to duplicate importing
>                pass
> 
>    def _ConvertAnnotations(self, annotations):
>       """ Convert annotations to pyVmomi flags """
>       flags = 0
>       if annotations:
>          for annotation in annotations:
>             flags |= self._mapFlags.get(annotation.name, 0)
>       return flags
> 
>    @staticmethod
>    def _Filter(fn, types):
>       """ Call fn for each non null element in types. Similiar to filter """
>       if types:
>          return [fn(prop) for prop in types if prop is not None]
>       else:
>          return []
> 
>    def _ConvertParamType(self, paramType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.ParamTypeInfo to pyVmomi param
>       definition
>       """
>       if paramType:
>          name = paramType.name
>          version = paramType.version
>          aType = paramType.type
>          flags = self._ConvertAnnotations(paramType.annotation)
>          privId = paramType.privId
>          param = (name, aType, version, flags, privId)
>       else:
>          param = None
>       return param
> 
>    def _ConvertMethodType(self, methodType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.MethodTypeInfo to pyVmomi method
>       definition
>       """
>       if methodType:
>          name = methodType.name
>          wsdlName = methodType.wsdlName
>          version = methodType.version
>          params = self._Filter(self._ConvertParamType, methodType.paramTypeInfo)
>          privId = methodType.privId
>          faults = methodType.fault
> 
>          # Figure out reture info
>          if methodType.returnTypeInfo:
>             returnTypeInfo = methodType.returnTypeInfo
>             retFlags = self._ConvertAnnotations(returnTypeInfo.annotation)
>             methodRetType = returnTypeInfo.type
>          else:
>             retFlags = 0
>             methodRetType = "void"
>          if wsdlName.endswith("_Task"):
>             # TODO: Need a seperate task return type for task, instead of
>             #       hardcode vim.Task as return type
>             retType = "vim.Task"
>          else:
>             retType = methodRetType
>          retInfo = (retFlags, retType, methodRetType)
> 
>          method = (name, wsdlName, version, params, retInfo, privId, faults)
>       else:
>          method = None
>       return method
> 
>    def _ConvertManagedPropertyType(self, propType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.PropertyTypeInfo to pyVmomi
>       managed property definition
>       """
>       if propType:
>          name = propType.name
>          version = propType.version
>          aType = propType.type
>          flags = self._ConvertAnnotations(propType.annotation)
>          privId = propType.privId
>          prop = (name, aType, version, flags, privId)
>       else:
>          prop = None
>       return prop
> 
>    def _ConvertManagedType(self, managedType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.ManagedTypeInfo to pyVmomi
>       managed type definition
>       """
>       if managedType:
>          vmodlName = managedType.name
>          wsdlName = managedType.wsdlName
>          version = managedType.version
>          parent = managedType.base[0]
>          props = self._Filter(self._ConvertManagedPropertyType, managedType.property)
>          methods = self._Filter(self._ConvertMethodType, managedType.method)
>          moType = (vmodlName, wsdlName, parent, version, props, methods)
>       else:
>          moType = None
>       return moType
> 
>    def _ConvertDataPropertyType(self, propType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.PropertyTypeInfo to pyVmomi
>       data property definition
>       """
>       if propType:
>          name = propType.name
>          version = propType.version
>          aType = propType.type
>          flags = self._ConvertAnnotations(propType.annotation)
>          prop = (name, aType, version, flags)
>       else:
>          prop = None
>       return prop
> 
>    def _ConvertDataType(self, dataType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.DataTypeInfo to pyVmomi data
>       type definition
>       """
>       if dataType:
>          vmodlName = dataType.name
>          wsdlName = dataType.wsdlName
>          version = dataType.version
>          parent = dataType.base[0]
>          props = self._Filter(self._ConvertDataPropertyType, dataType.property)
>          doType = (vmodlName, wsdlName, parent, version, props)
>       else:
>          doType = None
>       return doType
> 
>    def _ConvertEnumType(self, enumType):
>       """
>       Convert vmodl.reflect.DynamicTypeManager.EnumTypeInfo to pyVmomi enum
>       type definition
>       """
>       if enumType:
>          vmodlName = enumType.name
>          wsdlName = enumType.wsdlName
>          version = enumType.version
>          values = enumType.value
>          enumType = (vmodlName, wsdlName, version, values)
>       else:
>          enumType = None
>       return enumType
> 
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/__init__.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/__init__.py
1,67c1,67
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< from __future__ import absolute_import
< # In VmomiSupport, to support dynamic type loading, all the data types are
< # wrapped around using a meta type which can intercept attribute access and
< # load the necessary nested classes. This can be implemented only in python 2.5
< # version or more.
< import sys
< if sys.version_info < (2,5):
<    sys.stderr.write("You need Python 2.5 or later to import pyVmomi module\n")
<    sys.exit(1)
< 
< import pyVmomi.VmomiSupport
< import pyVmomi._typeinfo_core
< import pyVmomi._typeinfo_query
< import pyVmomi._typeinfo_vim
< import pyVmomi._typeinfo_pbm
< import pyVmomi._typeinfo_sms
< import pyVmomi._typeinfo_eam
< 
< # All data object types and fault types have DynamicData as an ancestor
< # As well load it proactively.
< # Note: This should be done before importing SoapAdapter as it uses
< # some fault types
< pyVmomi.VmomiSupport.GetVmodlType("vmodl.DynamicData")
< 
< from pyVmomi.SoapAdapter import SoapStubAdapter, StubAdapterBase, SoapCmdStubAdapter, \
<     SessionOrientedStub, ThumbprintMismatchException
< 
< types = pyVmomi.VmomiSupport.types
< 
< # This will allow files to use Create** functions
< # directly from pyVmomi
< CreateEnumType = pyVmomi.VmomiSupport.CreateEnumType
< CreateDataType = pyVmomi.VmomiSupport.CreateDataType
< CreateManagedType = pyVmomi.VmomiSupport.CreateManagedType
< 
< # For all the top level names, creating a LazyModule object
< # in the global namespace of pyVmomi. Files can just import the
< # top level namespace and we will figure out what to load and when
< # Examples:
< # ALLOWED: from pyVmomi import vim
< # NOT ALLOWED: from pyVmomi import vim.host
< _globals = globals()
< for name in pyVmomi.VmomiSupport._topLevelNames:
<    upperCaseName = pyVmomi.VmomiSupport.Capitalize(name)
<    obj = pyVmomi.VmomiSupport.LazyModule(name)
<    _globals[name] = obj
<    if pyVmomi.VmomiSupport._allowCapitalizedNames:
<       _globals[upperCaseName] = obj
<    if not hasattr(pyVmomi.VmomiSupport.types, name):
<       setattr(pyVmomi.VmomiSupport.types, name, obj)
<       if pyVmomi.VmomiSupport._allowCapitalizedNames:
<          setattr(pyVmomi.VmomiSupport.types, upperCaseName, obj)
< del _globals
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> from __future__ import absolute_import
> # In VmomiSupport, to support dynamic type loading, all the data types are
> # wrapped around using a meta type which can intercept attribute access and
> # load the necessary nested classes. This can be implemented only in python 2.5
> # version or more.
> import sys
> if sys.version_info < (2,5):
>    sys.stderr.write("You need Python 2.5 or later to import pyVmomi module\n")
>    sys.exit(1)
> 
> import pyVmomi.VmomiSupport
> import pyVmomi._typeinfo_core
> import pyVmomi._typeinfo_query
> import pyVmomi._typeinfo_vim
> import pyVmomi._typeinfo_pbm
> import pyVmomi._typeinfo_sms
> import pyVmomi._typeinfo_eam
> 
> # All data object types and fault types have DynamicData as an ancestor
> # As well load it proactively.
> # Note: This should be done before importing SoapAdapter as it uses
> # some fault types
> pyVmomi.VmomiSupport.GetVmodlType("vmodl.DynamicData")
> 
> from pyVmomi.SoapAdapter import SoapStubAdapter, StubAdapterBase, SoapCmdStubAdapter, \
>     SessionOrientedStub, ThumbprintMismatchException
> 
> types = pyVmomi.VmomiSupport.types
> 
> # This will allow files to use Create** functions
> # directly from pyVmomi
> CreateEnumType = pyVmomi.VmomiSupport.CreateEnumType
> CreateDataType = pyVmomi.VmomiSupport.CreateDataType
> CreateManagedType = pyVmomi.VmomiSupport.CreateManagedType
> 
> # For all the top level names, creating a LazyModule object
> # in the global namespace of pyVmomi. Files can just import the
> # top level namespace and we will figure out what to load and when
> # Examples:
> # ALLOWED: from pyVmomi import vim
> # NOT ALLOWED: from pyVmomi import vim.host
> _globals = globals()
> for name in pyVmomi.VmomiSupport._topLevelNames:
>    upperCaseName = pyVmomi.VmomiSupport.Capitalize(name)
>    obj = pyVmomi.VmomiSupport.LazyModule(name)
>    _globals[name] = obj
>    if pyVmomi.VmomiSupport._allowCapitalizedNames:
>       _globals[upperCaseName] = obj
>    if not hasattr(pyVmomi.VmomiSupport.types, name):
>       setattr(pyVmomi.VmomiSupport.types, name, obj)
>       if pyVmomi.VmomiSupport._allowCapitalizedNames:
>          setattr(pyVmomi.VmomiSupport.types, upperCaseName, obj)
> del _globals
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Iso8601.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/Iso8601.py
1,359c1,359
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< from __future__ import print_function
< # TODO (hartsocks): Introduce logging to remove the need for print function.
< """
< This module is for ISO 8601 parsing
< """
< __author__ = 'VMware, Inc.'
< 
< from six import iteritems
< import time
< from datetime import datetime, timedelta, tzinfo
< import re
< 
< """ Regular expression to parse a subset of ISO 8601 format """
< _dtExpr = re.compile(
<    # XMLSchema datetime. Mandatory to have - and :
<    # See: http://www.w3.org/TR/xmlschema-2/#isoformats
<    # Note: python datetime cannot handle the following:
<    #       - leap second, ie. 0-60 seconds (not 0-59)
<    #       - BC (negative years)
<    # year [-]0000..9999
<    r'(?P<year>-?\d{4})' \
<    # month 01..12
<    r'(-(?P<month>(0[1-9]|1[0-2]))' \
<     # day 01..31
<     r'(-(?P<day>(0[1-9]|[1-2]\d|3[01])))?)?' \
<    # time separator 'T'
<    r'(T' \
<     # hour 00..24
<     r'(?P<hour>([01]\d|2[0-4]))' \
<     # minute 00..59
<     r'((:(?P<minute>[0-5]\d))' \
<      # seconds 00..60 (leap second ok)
<      r'(:(?P<second>([0-5]\d|60))' \
<       # microsecond. max 16 digits
<       # - Should not allows trailing zeros. But python isoformat() put zeros
<       #   after microseconds. Oh well, allows trailing zeros, quite harmless
<       r'(\.(?P<microsecond>\d{1,16}))?)?)?' \
<     # UTC 'Z', or...
<     r'((?P<tzutc>Z)' \
<     # tz [+-]00..13:0..59|14:00
<     r'|((?P<tzhr>[+-](([0]\d)|(1[0-3])|(?P<tzlimit>)14))' \
<       r'(:(?P<tzmin>(?(tzlimit)00|([0-5]\d))))?))?' \
<    r')?$')
< 
< """ Default date time val. Key should match the tags in _dtExpr """
< _dtExprKeyDefValMap = {'year' : None, 'month' : 1, 'day' : 1,
<                        'hour' : 0, 'minute' : 0, 'second' : 0,
<                        'microsecond' : 0}
< 
< class TZInfo(tzinfo):
<    """ Timezone info class """
< 
<    timedelta0 = timedelta(hours=0)
<    timedelta1 = timedelta(hours=1)
< 
<    def __init__(self, tzname='UTC', utcOffset=None, dst=None):
<       self._tzname = tzname
<       if not utcOffset:
<          utcOffset = self.timedelta0
<       self._utcOffset = utcOffset
<       if not dst:
<          dst = None
<       self._dst = dst
< 
<    def utcoffset(self, dt):
<       return self._utcOffset + self.dst(dt)
< 
<    def tzname(self, dt):
<       return self._tzname
< 
<    def dst(self, dt):
<       ret = self.timedelta0
<       if self._dst:
<          if self._dst[0] <= dt.replace(tzinfo=None) < self._dst[1]:
<             ret = self.timedelta1
<       return ret
< 
< 
< class TZManager:
<    """ Time zone manager """
<    _tzInfos = {}
< 
<    @staticmethod
<    def GetTZInfo(tzname='UTC', utcOffset=None, dst=None):
<       """ Get / Add timezone info """
<       key = (tzname, utcOffset, dst)
<       tzInfo = TZManager._tzInfos.get(key)
<       if not tzInfo:
<          tzInfo = TZInfo(tzname, utcOffset, dst)
<          TZManager._tzInfos[key] = tzInfo
<       return tzInfo
< 
< 
< def ParseISO8601(datetimeStr):
<    """
<    Parse ISO 8601 date time from string.
<    Returns datetime if ok, None otherwise
<    Note: Allows YYYY / YYYY-MM, but truncate YYYY -> YYYY-01-01,
<                                              YYYY-MM -> YYYY-MM-01
<          Truncate microsecond to most significant 6 digits
<    """
<    datetimeVal = None
<    match = _dtExpr.match(datetimeStr)
<    if match:
<       try:
<          dt = {}
<          for key, defaultVal in iteritems(_dtExprKeyDefValMap):
<             val = match.group(key)
<             if val:
<                if key == 'microsecond':
<                   val = val[:6] + '0' * (6 - len(val))
<                dt[key] = int(val)
<             elif defaultVal:
<                dt[key] = defaultVal
< 
<          # Orig. XMLSchema don't allow all zeros year. But newer draft is ok
<          #if dt['year'] == 0:
<          #   # Year cannot be all zeros
<          #   raise Exception('Year cannot be all zeros')
< 
<          # 24 is a special case. It is actually represented as next day 00:00
<          delta = None
<          if dt.get('hour', 0) == 24:
<             # Must be 24:00:00.0
<             if dt.get('minute', 0) == 0 and dt.get('second', 0) == 0 and \
<                dt.get('microsecond', 0) == 0:
<                dt['hour'] = 23
<                delta = timedelta(hours=1)
<             else:
<                return None
< 
<          # Set tzinfo
<          # TODO: dst
<          tzInfo = None
<          val = match.group('tzutc')
<          if val:
<             tzInfo = TZManager.GetTZInfo()
<          else:
<             val = match.group('tzhr')
<             if val:
<                # tz hours offset
<                tzhr = int(val)
<                utcsign = val[0]
< 
<                # tz minutes offset
<                tzmin = 0
<                val = match.group('tzmin')
<                if val:
<                   tzmin = tzhr >= 0 and int(val) or -int(val)
< 
<                # Better tzname (map UTC +-00:00 to UTC)
<                tzname = 'UTC'
<                if tzhr != 0 or tzmin != 0:
<                   tzname += ' %s%02d:%02d' % (utcsign, abs(tzhr), abs(tzmin))
< 
<                tzInfo = TZManager.GetTZInfo(tzname=tzname,
<                                             utcOffset=timedelta(hours=tzhr,
<                                                                 minutes=tzmin))
<          if tzInfo:
<             dt['tzinfo'] = tzInfo
< 
<          datetimeVal = datetime(**dt)
<          if delta:
<             datetimeVal += delta
<       except Exception as e:
<          pass
<    return datetimeVal
< 
< 
< def ISO8601Format(dt):
<    """
<    Python datetime isoformat() has the following problems:
<    - leave trailing 0 at the end of microseconds (violates XMLSchema rule)
<    - tz print +00:00 instead of Z
<    - Missing timezone offset for datetime without tzinfo
<    """
<    isoStr = dt.strftime('%Y-%m-%dT%H:%M:%S')
<    if dt.microsecond:
<       isoStr += ('.%06d' % dt.microsecond).rstrip('0')
<    if dt.tzinfo:
<       tz = dt.strftime('%z')
<    else:
<       if time.daylight and time.localtime().tm_isdst:
<          utcOffset_minutes = -time.altzone / 60
<       else:
<          utcOffset_minutes = -time.timezone / 60
<       tz = "%+.2d%.2d" % (utcOffset_minutes / 60, (abs(utcOffset_minutes) % 60))
<    if tz == '+0000':
<       return isoStr + 'Z'
<    elif tz:
<       return isoStr + tz[:3] + ':' + tz[3:]
<    else:
<       # Local offset is unknown
<       return isoStr + '-00:00'
< 
< 
< # Testing
< if __name__ == '__main__':
<    # Valid entries
<    for testStr in [
<          '1971', # 1971-01-01
<          '1971-11', # 1971-11-01
<          '1971-11-02',
<          '1971-11-02T23',
<          '1971-11-02T23Z',
<          '1971-11-02T23:04',
<          '1971-11-02T23:04Z',
<          '1971-11-02T23:04:15',
<          '1971-11-02T23:04:15Z',
<          '1971-11-02T23:04:15.1',
<          '1971-11-02T23:04:15.01',
<          '1971-11-02T23:04:15.023456',
<          '1971-11-02T23:04:15.103456Z',
<          '1971-11-02T23:04:15.123456+11',
<          '1971-11-02T23:04:15.123456-11',
<          '1971-11-02T23:04:15.123456+11:30',
<          '1971-11-02T23:04:15.123456-11:30',
<          '1971-11-02T23:04:15.123456+00:00', # Same as Z
<          '1971-11-02T23:04:15.123456-00:00', # Same as Z
< 
<          '1971-01-02T23:04:15+14',
<          '1971-01-02T23:04:15+14:00',
<          '1971-01-02T23:04:15-14',
<          '1971-01-02T23:04:15-14:00',
< 
<          # Valid: Truncate microsec to 6 digits
<          '1971-01-02T23:04:15.123456891+11',
< 
<          '1971-01-02T24', # 24 is valid. It should represent the 00:00 the
<                           # next day
<          '1971-01-02T24:00',
<          '1971-01-02T24:00:00',
<          '1971-01-02T24:00:00.0',
< 
<          # Should NOT be valid but python isoformat adding trailing zeros
<          '1971-01-02T23:04:15.123430', # Microseconds ends in zero
<          '1971-01-02T23:04:15.0', # Microseconds ends in zero
< 
<          # Should be valid but python datetime don't support it
<          #'2005-12-31T23:59:60Z', # Leap second
<          #'-0001', # BC 1
<         ]:
<       dt = ParseISO8601(testStr)
<       if dt == None:
<          print('Failed to parse ({0})'.format(testStr))
<          assert(False)
< 
<       # Make sure we can translate back
<       isoformat = ISO8601Format(dt)
<       dt1 = ParseISO8601(isoformat)
<       if dt.tzinfo is None:
<          dt = dt.replace(tzinfo=dt1.tzinfo)
<       if dt1 != dt:
<          print('ParseISO8601 -> ISO8601Format -> ParseISO8601 failed ({0})'.format(testStr))
<          assert(False)
< 
<       # Make sure we can parse python isoformat()
<       dt2 = ParseISO8601(dt.isoformat())
<       if dt2 == None:
<          print('ParseISO8601("{0}".isoformat()) failed'.format(testStr))
<          assert(False)
< 
<       print(testStr, '->', dt, isoformat)
< 
<    # Basic form
<    for testStr in [
<          '197111', # 1971-11-01
<          '19711102',
<          '19711102T23',
<          '19711102T23Z',
<          '19711102T2304',
<          '19711102T2304Z',
<          '19711102T230415',
<          '19711102T230415Z',
<          '19711102T230415.123456',
<          '19711102T230415.123456Z',
<          '19711102T230415.123456+11',
<          '19711102T230415.123456-11',
<          '19711102T230415.123456+1130',
<          '19711102T230415.123456-1130',
<         ]:
<       # Reject for now
<       dt = ParseISO8601(testStr)
<       if dt != None:
<          print('ParseISO8601 ({0}) should fail, but it did not'.format(testStr))
<          assert(False)
<       #print testStr, '->', dt
<       #assert(dt != None)
< 
<    # Invalid entries
<    for testStr in [
<          # Xml schema reject year 0
<          '0000', # 0 years are not allowed
<          '+0001', # Leading + is not allowed
< 
<          '', # Empty datetime str
<          '09', # Years must be at least 4 digits
<          '1971-01-02T', # T not follow by time
<          '1971-01-02TZ', # T not follow by time
<          '1971-01-02T+10', # T not follow by time
<          '1971-01-02T-10', # T not follow by time
<          '1971-01-02T23:', # extra :
<          '1971-01-02T23:04:', # extra :
<          '1971-01-02T23:0d', # 0d
<          '1971-01-02T23:04:15.', # Dot not follows by microsec
<          '1971-01-02+12', # time without T
<          '1971Z', # Z without T
<          '1971-01-02T23:04:15.123456Z+11', # Z follows by +
<          '1971-01-02T23:04:15.123456Z-11', # Z follows by -
<          '1971-01-02T23:04:15.123456+:30', # extra :
<          '1971-01-02T23:04:15.123456+30:', # extra :
<          '1971-01-02T23:04:15.01234567890123456789', # Too many microseconds digits
< 
<          # Python isoformat leave trailing zeros in microseconds
<          # Relax regular expression to accept it
<          #'1971-01-02T23:04:15.123430', # Microseconds ends in zero
<          #'1971-01-02T23:04:15.0', # Microseconds ends in zero
< 
<          # Timezone must be between +14 / -14
<          '1971-01-02T23:04:15+15',
<          '1971-01-02T23:04:15-15',
<          '1971-01-02T23:04:15+14:01',
<          '1971-01-02T23:04:15-14:01',
< 
<          # Mix basic form with extended format
<          '197101-02T23:04:15.123456',
<          '19710102T23:04:15.123456',
<          '19710102T230415.123456+11:30',
<          '1971-01-02T230415.123456',
<          '1971-01-02T23:04:15.123456+1130',
< 
<          # Error captured by datetime class
<          '1971-00-02', # Less than 1 month
<          '1971-13-02', # Larger than 12 months
<          '1971-01-00', # Less than 1 day
<          '1971-11-32', # Larger than 30 days for Nov
<          '1971-12-32', # Larger than 31 days
<          '1971-01-02T24:01', # Larger than 23 hr
<          '1971-01-02T23:61', # Larger than 60 min
<          '1971-01-02T23:60:61', # Larger than 61 sec
<         ]:
<       dt = ParseISO8601(testStr)
<       if dt != None:
<          print('ParseISO8601 ({0}) should fail, but it did not'.format(testStr))
<          assert(False)
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> from __future__ import print_function
> # TODO (hartsocks): Introduce logging to remove the need for print function.
> """
> This module is for ISO 8601 parsing
> """
> __author__ = 'VMware, Inc.'
> 
> from six import iteritems
> import time
> from datetime import datetime, timedelta, tzinfo
> import re
> 
> """ Regular expression to parse a subset of ISO 8601 format """
> _dtExpr = re.compile(
>    # XMLSchema datetime. Mandatory to have - and :
>    # See: http://www.w3.org/TR/xmlschema-2/#isoformats
>    # Note: python datetime cannot handle the following:
>    #       - leap second, ie. 0-60 seconds (not 0-59)
>    #       - BC (negative years)
>    # year [-]0000..9999
>    r'(?P<year>-?\d{4})' \
>    # month 01..12
>    r'(-(?P<month>(0[1-9]|1[0-2]))' \
>     # day 01..31
>     r'(-(?P<day>(0[1-9]|[1-2]\d|3[01])))?)?' \
>    # time separator 'T'
>    r'(T' \
>     # hour 00..24
>     r'(?P<hour>([01]\d|2[0-4]))' \
>     # minute 00..59
>     r'((:(?P<minute>[0-5]\d))' \
>      # seconds 00..60 (leap second ok)
>      r'(:(?P<second>([0-5]\d|60))' \
>       # microsecond. max 16 digits
>       # - Should not allows trailing zeros. But python isoformat() put zeros
>       #   after microseconds. Oh well, allows trailing zeros, quite harmless
>       r'(\.(?P<microsecond>\d{1,16}))?)?)?' \
>     # UTC 'Z', or...
>     r'((?P<tzutc>Z)' \
>     # tz [+-]00..13:0..59|14:00
>     r'|((?P<tzhr>[+-](([0]\d)|(1[0-3])|(?P<tzlimit>)14))' \
>       r'(:(?P<tzmin>(?(tzlimit)00|([0-5]\d))))?))?' \
>    r')?$')
> 
> """ Default date time val. Key should match the tags in _dtExpr """
> _dtExprKeyDefValMap = {'year' : None, 'month' : 1, 'day' : 1,
>                        'hour' : 0, 'minute' : 0, 'second' : 0,
>                        'microsecond' : 0}
> 
> class TZInfo(tzinfo):
>    """ Timezone info class """
> 
>    timedelta0 = timedelta(hours=0)
>    timedelta1 = timedelta(hours=1)
> 
>    def __init__(self, tzname='UTC', utcOffset=None, dst=None):
>       self._tzname = tzname
>       if not utcOffset:
>          utcOffset = self.timedelta0
>       self._utcOffset = utcOffset
>       if not dst:
>          dst = None
>       self._dst = dst
> 
>    def utcoffset(self, dt):
>       return self._utcOffset + self.dst(dt)
> 
>    def tzname(self, dt):
>       return self._tzname
> 
>    def dst(self, dt):
>       ret = self.timedelta0
>       if self._dst:
>          if self._dst[0] <= dt.replace(tzinfo=None) < self._dst[1]:
>             ret = self.timedelta1
>       return ret
> 
> 
> class TZManager:
>    """ Time zone manager """
>    _tzInfos = {}
> 
>    @staticmethod
>    def GetTZInfo(tzname='UTC', utcOffset=None, dst=None):
>       """ Get / Add timezone info """
>       key = (tzname, utcOffset, dst)
>       tzInfo = TZManager._tzInfos.get(key)
>       if not tzInfo:
>          tzInfo = TZInfo(tzname, utcOffset, dst)
>          TZManager._tzInfos[key] = tzInfo
>       return tzInfo
> 
> 
> def ParseISO8601(datetimeStr):
>    """
>    Parse ISO 8601 date time from string.
>    Returns datetime if ok, None otherwise
>    Note: Allows YYYY / YYYY-MM, but truncate YYYY -> YYYY-01-01,
>                                              YYYY-MM -> YYYY-MM-01
>          Truncate microsecond to most significant 6 digits
>    """
>    datetimeVal = None
>    match = _dtExpr.match(datetimeStr)
>    if match:
>       try:
>          dt = {}
>          for key, defaultVal in iteritems(_dtExprKeyDefValMap):
>             val = match.group(key)
>             if val:
>                if key == 'microsecond':
>                   val = val[:6] + '0' * (6 - len(val))
>                dt[key] = int(val)
>             elif defaultVal:
>                dt[key] = defaultVal
> 
>          # Orig. XMLSchema don't allow all zeros year. But newer draft is ok
>          #if dt['year'] == 0:
>          #   # Year cannot be all zeros
>          #   raise Exception('Year cannot be all zeros')
> 
>          # 24 is a special case. It is actually represented as next day 00:00
>          delta = None
>          if dt.get('hour', 0) == 24:
>             # Must be 24:00:00.0
>             if dt.get('minute', 0) == 0 and dt.get('second', 0) == 0 and \
>                dt.get('microsecond', 0) == 0:
>                dt['hour'] = 23
>                delta = timedelta(hours=1)
>             else:
>                return None
> 
>          # Set tzinfo
>          # TODO: dst
>          tzInfo = None
>          val = match.group('tzutc')
>          if val:
>             tzInfo = TZManager.GetTZInfo()
>          else:
>             val = match.group('tzhr')
>             if val:
>                # tz hours offset
>                tzhr = int(val)
>                utcsign = val[0]
> 
>                # tz minutes offset
>                tzmin = 0
>                val = match.group('tzmin')
>                if val:
>                   tzmin = tzhr >= 0 and int(val) or -int(val)
> 
>                # Better tzname (map UTC +-00:00 to UTC)
>                tzname = 'UTC'
>                if tzhr != 0 or tzmin != 0:
>                   tzname += ' %s%02d:%02d' % (utcsign, abs(tzhr), abs(tzmin))
> 
>                tzInfo = TZManager.GetTZInfo(tzname=tzname,
>                                             utcOffset=timedelta(hours=tzhr,
>                                                                 minutes=tzmin))
>          if tzInfo:
>             dt['tzinfo'] = tzInfo
> 
>          datetimeVal = datetime(**dt)
>          if delta:
>             datetimeVal += delta
>       except Exception as e:
>          pass
>    return datetimeVal
> 
> 
> def ISO8601Format(dt):
>    """
>    Python datetime isoformat() has the following problems:
>    - leave trailing 0 at the end of microseconds (violates XMLSchema rule)
>    - tz print +00:00 instead of Z
>    - Missing timezone offset for datetime without tzinfo
>    """
>    isoStr = dt.strftime('%Y-%m-%dT%H:%M:%S')
>    if dt.microsecond:
>       isoStr += ('.%06d' % dt.microsecond).rstrip('0')
>    if dt.tzinfo:
>       tz = dt.strftime('%z')
>    else:
>       if time.daylight and time.localtime().tm_isdst:
>          utcOffset_minutes = -time.altzone / 60
>       else:
>          utcOffset_minutes = -time.timezone / 60
>       tz = "%+.2d%.2d" % (utcOffset_minutes / 60, (abs(utcOffset_minutes) % 60))
>    if tz == '+0000':
>       return isoStr + 'Z'
>    elif tz:
>       return isoStr + tz[:3] + ':' + tz[3:]
>    else:
>       # Local offset is unknown
>       return isoStr + '-00:00'
> 
> 
> # Testing
> if __name__ == '__main__':
>    # Valid entries
>    for testStr in [
>          '1971', # 1971-01-01
>          '1971-11', # 1971-11-01
>          '1971-11-02',
>          '1971-11-02T23',
>          '1971-11-02T23Z',
>          '1971-11-02T23:04',
>          '1971-11-02T23:04Z',
>          '1971-11-02T23:04:15',
>          '1971-11-02T23:04:15Z',
>          '1971-11-02T23:04:15.1',
>          '1971-11-02T23:04:15.01',
>          '1971-11-02T23:04:15.023456',
>          '1971-11-02T23:04:15.103456Z',
>          '1971-11-02T23:04:15.123456+11',
>          '1971-11-02T23:04:15.123456-11',
>          '1971-11-02T23:04:15.123456+11:30',
>          '1971-11-02T23:04:15.123456-11:30',
>          '1971-11-02T23:04:15.123456+00:00', # Same as Z
>          '1971-11-02T23:04:15.123456-00:00', # Same as Z
> 
>          '1971-01-02T23:04:15+14',
>          '1971-01-02T23:04:15+14:00',
>          '1971-01-02T23:04:15-14',
>          '1971-01-02T23:04:15-14:00',
> 
>          # Valid: Truncate microsec to 6 digits
>          '1971-01-02T23:04:15.123456891+11',
> 
>          '1971-01-02T24', # 24 is valid. It should represent the 00:00 the
>                           # next day
>          '1971-01-02T24:00',
>          '1971-01-02T24:00:00',
>          '1971-01-02T24:00:00.0',
> 
>          # Should NOT be valid but python isoformat adding trailing zeros
>          '1971-01-02T23:04:15.123430', # Microseconds ends in zero
>          '1971-01-02T23:04:15.0', # Microseconds ends in zero
> 
>          # Should be valid but python datetime don't support it
>          #'2005-12-31T23:59:60Z', # Leap second
>          #'-0001', # BC 1
>         ]:
>       dt = ParseISO8601(testStr)
>       if dt == None:
>          print('Failed to parse ({0})'.format(testStr))
>          assert(False)
> 
>       # Make sure we can translate back
>       isoformat = ISO8601Format(dt)
>       dt1 = ParseISO8601(isoformat)
>       if dt.tzinfo is None:
>          dt = dt.replace(tzinfo=dt1.tzinfo)
>       if dt1 != dt:
>          print('ParseISO8601 -> ISO8601Format -> ParseISO8601 failed ({0})'.format(testStr))
>          assert(False)
> 
>       # Make sure we can parse python isoformat()
>       dt2 = ParseISO8601(dt.isoformat())
>       if dt2 == None:
>          print('ParseISO8601("{0}".isoformat()) failed'.format(testStr))
>          assert(False)
> 
>       print(testStr, '->', dt, isoformat)
> 
>    # Basic form
>    for testStr in [
>          '197111', # 1971-11-01
>          '19711102',
>          '19711102T23',
>          '19711102T23Z',
>          '19711102T2304',
>          '19711102T2304Z',
>          '19711102T230415',
>          '19711102T230415Z',
>          '19711102T230415.123456',
>          '19711102T230415.123456Z',
>          '19711102T230415.123456+11',
>          '19711102T230415.123456-11',
>          '19711102T230415.123456+1130',
>          '19711102T230415.123456-1130',
>         ]:
>       # Reject for now
>       dt = ParseISO8601(testStr)
>       if dt != None:
>          print('ParseISO8601 ({0}) should fail, but it did not'.format(testStr))
>          assert(False)
>       #print testStr, '->', dt
>       #assert(dt != None)
> 
>    # Invalid entries
>    for testStr in [
>          # Xml schema reject year 0
>          '0000', # 0 years are not allowed
>          '+0001', # Leading + is not allowed
> 
>          '', # Empty datetime str
>          '09', # Years must be at least 4 digits
>          '1971-01-02T', # T not follow by time
>          '1971-01-02TZ', # T not follow by time
>          '1971-01-02T+10', # T not follow by time
>          '1971-01-02T-10', # T not follow by time
>          '1971-01-02T23:', # extra :
>          '1971-01-02T23:04:', # extra :
>          '1971-01-02T23:0d', # 0d
>          '1971-01-02T23:04:15.', # Dot not follows by microsec
>          '1971-01-02+12', # time without T
>          '1971Z', # Z without T
>          '1971-01-02T23:04:15.123456Z+11', # Z follows by +
>          '1971-01-02T23:04:15.123456Z-11', # Z follows by -
>          '1971-01-02T23:04:15.123456+:30', # extra :
>          '1971-01-02T23:04:15.123456+30:', # extra :
>          '1971-01-02T23:04:15.01234567890123456789', # Too many microseconds digits
> 
>          # Python isoformat leave trailing zeros in microseconds
>          # Relax regular expression to accept it
>          #'1971-01-02T23:04:15.123430', # Microseconds ends in zero
>          #'1971-01-02T23:04:15.0', # Microseconds ends in zero
> 
>          # Timezone must be between +14 / -14
>          '1971-01-02T23:04:15+15',
>          '1971-01-02T23:04:15-15',
>          '1971-01-02T23:04:15+14:01',
>          '1971-01-02T23:04:15-14:01',
> 
>          # Mix basic form with extended format
>          '197101-02T23:04:15.123456',
>          '19710102T23:04:15.123456',
>          '19710102T230415.123456+11:30',
>          '1971-01-02T230415.123456',
>          '1971-01-02T23:04:15.123456+1130',
> 
>          # Error captured by datetime class
>          '1971-00-02', # Less than 1 month
>          '1971-13-02', # Larger than 12 months
>          '1971-01-00', # Less than 1 day
>          '1971-11-32', # Larger than 30 days for Nov
>          '1971-12-32', # Larger than 31 days
>          '1971-01-02T24:01', # Larger than 23 hr
>          '1971-01-02T23:61', # Larger than 60 min
>          '1971-01-02T23:60:61', # Larger than 61 sec
>         ]:
>       dt = ParseISO8601(testStr)
>       if dt != None:
>          print('ParseISO8601 ({0}) should fail, but it did not'.format(testStr))
>          assert(False)
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/ManagedMethodExecutorHelper.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/ManagedMethodExecutorHelper.py
1,118c1,118
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< """
< This module provides convinent fns related to ManagedMethodExecutor
< """
< __author__ = "VMware, Inc."
< 
< from pyVmomi import VmomiSupport, SoapAdapter, vmodl
< from .SoapAdapter import SoapStubAdapterBase, SerializeToUnicode, Deserialize
< 
< ## ManagedMethodExecutor soap stub adapter
< #
< class MMESoapStubAdapter(SoapStubAdapterBase):
<    """ Managed method executor stub adapter  """
< 
<    ## Constructor
<    #
<    # The endpoint can be specified individually as either a host/port
<    # combination, or with a URL (using a url= keyword).
<    #
<    # @param self self
<    # @param mme  managed method executor
<    def __init__(self, mme):
<       stub = mme._stub
<       SoapStubAdapterBase.__init__(self, version=stub.version)
<       self.mme = mme
< 
<    ## Compute the version information for the specified namespace
<    #
<    # @param ns the namespace
<    def ComputeVersionInfo(self, version):
<       SoapStubAdapterBase.ComputeVersionInfo(self, version)
<       self.versionId = self.versionId[1:-1]
< 
<    ## Invoke a managed method, with _ExecuteSoap. Wohooo!
<    #
<    # @param self self
<    # @param mo the 'this'
<    # @param info method info
<    # @param args arguments
<    def InvokeMethod(self, mo, info, args):
<       # Serialize parameters to soap parameters
<       methodArgs = None
<       if info.params:
<          methodArgs = vmodl.Reflect.ManagedMethodExecutor.SoapArgument.Array()
<          for param, arg in zip(info.params, args):
<             if arg is not None:
<                # Serialize parameters to soap snippets
<                soapVal = SerializeToUnicode(val=arg, info=param, version=self.version)
< 
<                # Insert argument
<                soapArg = vmodl.Reflect.ManagedMethodExecutor.SoapArgument(
<                                                   name=param.name, val=soapVal)
<                methodArgs.append(soapArg)
< 
<       moid = mo._GetMoId()
<       version = self.versionId
<       methodName = VmomiSupport.GetVmodlName(info.type) + "." + info.name
< 
<       # Execute method
<       result = self.mme.ExecuteSoap(moid=moid,
<                                     version=version,
<                                     method=methodName,
<                                     argument=methodArgs)
<       return self._DeserializeExecutorResult(result, info.result)
< 
<    ## Invoke a managed property accessor
<    #
<    # @param self self
<    # @param mo the 'this'
<    # @param info property info
<    def InvokeAccessor(self, mo, info):
<       moid = mo._GetMoId()
<       version = self.versionId
<       prop = info.name
< 
<       # Fetch property
<       result = self.mme.FetchSoap(moid=moid, version=version, prop=prop)
<       return self._DeserializeExecutorResult(result, info.type)
< 
<    ## Deserialize result from ExecuteSoap / FetchSoap
<    #
<    # @param self self
<    # @param result result from ExecuteSoap / FetchSoap
<    # @param resultType Expected result type
<    def _DeserializeExecutorResult(self, result, resultType):
<       obj = None
<       if result:
<          # Parse the return soap snippet. If fault, raise exception
<          if result.response:
<             # Deserialize back to result
<             obj = Deserialize(result.response, resultType, stub=self)
<          elif result.fault:
<             # Deserialize back to fault (or vmomi fault)
<             fault = Deserialize(result.fault.faultDetail,
<                                 object,
<                                 stub=self)
<             # Silent pylint
<             raise fault # pylint: disable-msg=E0702
<          else:
<             # Unexpected: result should have either response or fault
<             msg = "Unexpected execute/fetchSoap error"
<             reason = "execute/fetchSoap did not return response or fault"
<             raise vmodl.Fault.SystemError(msg=msg, reason=reason)
<       return obj
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> """
> This module provides convinent fns related to ManagedMethodExecutor
> """
> __author__ = "VMware, Inc."
> 
> from pyVmomi import VmomiSupport, SoapAdapter, vmodl
> from .SoapAdapter import SoapStubAdapterBase, SerializeToUnicode, Deserialize
> 
> ## ManagedMethodExecutor soap stub adapter
> #
> class MMESoapStubAdapter(SoapStubAdapterBase):
>    """ Managed method executor stub adapter  """
> 
>    ## Constructor
>    #
>    # The endpoint can be specified individually as either a host/port
>    # combination, or with a URL (using a url= keyword).
>    #
>    # @param self self
>    # @param mme  managed method executor
>    def __init__(self, mme):
>       stub = mme._stub
>       SoapStubAdapterBase.__init__(self, version=stub.version)
>       self.mme = mme
> 
>    ## Compute the version information for the specified namespace
>    #
>    # @param ns the namespace
>    def ComputeVersionInfo(self, version):
>       SoapStubAdapterBase.ComputeVersionInfo(self, version)
>       self.versionId = self.versionId[1:-1]
> 
>    ## Invoke a managed method, with _ExecuteSoap. Wohooo!
>    #
>    # @param self self
>    # @param mo the 'this'
>    # @param info method info
>    # @param args arguments
>    def InvokeMethod(self, mo, info, args):
>       # Serialize parameters to soap parameters
>       methodArgs = None
>       if info.params:
>          methodArgs = vmodl.Reflect.ManagedMethodExecutor.SoapArgument.Array()
>          for param, arg in zip(info.params, args):
>             if arg is not None:
>                # Serialize parameters to soap snippets
>                soapVal = SerializeToUnicode(val=arg, info=param, version=self.version)
> 
>                # Insert argument
>                soapArg = vmodl.Reflect.ManagedMethodExecutor.SoapArgument(
>                                                   name=param.name, val=soapVal)
>                methodArgs.append(soapArg)
> 
>       moid = mo._GetMoId()
>       version = self.versionId
>       methodName = VmomiSupport.GetVmodlName(info.type) + "." + info.name
> 
>       # Execute method
>       result = self.mme.ExecuteSoap(moid=moid,
>                                     version=version,
>                                     method=methodName,
>                                     argument=methodArgs)
>       return self._DeserializeExecutorResult(result, info.result)
> 
>    ## Invoke a managed property accessor
>    #
>    # @param self self
>    # @param mo the 'this'
>    # @param info property info
>    def InvokeAccessor(self, mo, info):
>       moid = mo._GetMoId()
>       version = self.versionId
>       prop = info.name
> 
>       # Fetch property
>       result = self.mme.FetchSoap(moid=moid, version=version, prop=prop)
>       return self._DeserializeExecutorResult(result, info.type)
> 
>    ## Deserialize result from ExecuteSoap / FetchSoap
>    #
>    # @param self self
>    # @param result result from ExecuteSoap / FetchSoap
>    # @param resultType Expected result type
>    def _DeserializeExecutorResult(self, result, resultType):
>       obj = None
>       if result:
>          # Parse the return soap snippet. If fault, raise exception
>          if result.response:
>             # Deserialize back to result
>             obj = Deserialize(result.response, resultType, stub=self)
>          elif result.fault:
>             # Deserialize back to fault (or vmomi fault)
>             fault = Deserialize(result.fault.faultDetail,
>                                 object,
>                                 stub=self)
>             # Silent pylint
>             raise fault # pylint: disable-msg=E0702
>          else:
>             # Unexpected: result should have either response or fault
>             msg = "Unexpected execute/fetchSoap error"
>             reason = "execute/fetchSoap did not return response or fault"
>             raise vmodl.Fault.SystemError(msg=msg, reason=reason)
>       return obj
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/pyVmomiSettings.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/pyVmomiSettings.py
1,17c1,17
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< allowGetSet = False
< allowCapitalizedNames = False
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> allowGetSet = False
> allowCapitalizedNames = False
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/SoapAdapter.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/SoapAdapter.py
1,1702c1,1702
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< # http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< from __future__ import absolute_import
< 
< import six
< from six import reraise
< from six.moves import http_client
< from six.moves import StringIO
< from six.moves import zip
< from six import u
< from six import iteritems
< 
< import sys
< import os
< import platform
< import socket
< import subprocess
< import time
< from six.moves.urllib.parse import urlparse
< from datetime import datetime
< from xml.parsers.expat import ParserCreate
< # We have our own escape functionality.
< # from xml.sax.saxutils import escape
< 
< from pyVmomi.VmomiSupport import *
< from pyVmomi.StubAdapterAccessorImpl import StubAdapterAccessorMixin
< import pyVmomi.Iso8601
< import base64
< from xml.parsers.expat import ExpatError
< import copy
< import contextlib
< 
< try:
<    USERWORLD = os.uname()[0] == 'VMkernel'
< except:
<    USERWORLD = False
< 
< # Timeout value used for idle connections in client connection pool.
< # Default value is 900 seconds (15 minutes).
< CONNECTION_POOL_IDLE_TIMEOUT_SEC = 900
< 
< NS_SEP = " "
< 
< XML_ENCODING = 'UTF-8'
< XML_HEADER = '<?xml version="1.0" encoding="{0}"?>'.format(XML_ENCODING)
< 
< XMLNS_SOAPENC = "http://schemas.xmlsoap.org/soap/encoding/"
< XMLNS_SOAPENV = "http://schemas.xmlsoap.org/soap/envelope/"
< 
< XSI_TYPE = XMLNS_XSI + NS_SEP + u('type')
< 
< # Note: Must make a copy to use the SOAP_NSMAP
< # TODO: Change to frozendict, if available
< SOAP_NSMAP = { XMLNS_SOAPENC: 'soapenc', XMLNS_SOAPENV: 'soapenv',
<                XMLNS_XSI: 'xsi', XMLNS_XSD: 'xsd' }
< 
< SOAP_ENVELOPE_TAG = "{0}:Envelope".format(SOAP_NSMAP[XMLNS_SOAPENV])
< SOAP_HEADER_TAG = "{0}:Header".format(SOAP_NSMAP[XMLNS_SOAPENV])
< SOAP_FAULT_TAG = "{0}:Fault".format(SOAP_NSMAP[XMLNS_SOAPENV])
< SOAP_BODY_TAG = "{0}:Body".format(SOAP_NSMAP[XMLNS_SOAPENV])
< 
< SOAP_ENVELOPE_START = '<{0} '.format(SOAP_ENVELOPE_TAG) + \
<                       ' '.join(['xmlns:' + prefix + '="' + urn + '"' \
<                                 for urn, prefix in iteritems(SOAP_NSMAP)]) + \
<                       '>\n'
< SOAP_ENVELOPE_END = "\n</{0}>".format(SOAP_ENVELOPE_TAG)
< SOAP_HEADER_START = "<{0}>".format(SOAP_HEADER_TAG)
< SOAP_HEADER_END = "</{0}>".format(SOAP_HEADER_TAG)
< SOAP_BODY_START = "<{0}>".format(SOAP_BODY_TAG)
< SOAP_BODY_END = "</{0}>".format(SOAP_BODY_TAG)
< SOAP_START = SOAP_ENVELOPE_START + SOAP_BODY_START + '\n'
< SOAP_END = '\n' + SOAP_BODY_END + SOAP_ENVELOPE_END
< 
< WSSE_PREFIX = "wsse"
< WSSE_HEADER_TAG = "{0}:Security".format(WSSE_PREFIX)
< WSSE_NS_URL = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
< WSSE_NS = 'xmlns:{0}="{1}"'.format(WSSE_PREFIX, WSSE_NS_URL)
< WSSE_HEADER_START = "<{0} {1}>".format(WSSE_HEADER_TAG, WSSE_NS)
< WSSE_HEADER_END = "</{0}>".format(WSSE_HEADER_TAG)
< 
< ## MethodFault type
< MethodFault = GetVmodlType("vmodl.MethodFault")
< ## Localized MethodFault type
< LocalizedMethodFault = GetVmodlType("vmodl.LocalizedMethodFault")
< 
< # These info are included in the http user-agent header
< PYTHON_VERSION = platform.python_version()
< OS_NAME = platform.uname()[0]
< OS_VERSION = platform.uname()[2]
< OS_ARCH = platform.uname()[4]
< 
< SOAP_ADAPTER_ARGS = [
<    "server_side", "cert_reqs", "ssl_version", "ca_certs", "do_handshake_on_connect",
<    "suppress_ragged_eofs", "ciphers"]
< 
< 
< ## Thumbprint mismatch exception
< #
< class ThumbprintMismatchException(Exception):
<    def __init__(self, expected, actual):
<       Exception.__init__(self, "Server has wrong SHA1 thumbprint: %s "
<                                "(required) != %s (server)" % (
<                                  expected, actual))
< 
<       self.expected = expected
<       self.actual = actual
< 
< ## Escape <, >, &
< def XmlEscape(xmlStr):
<     escaped = xmlStr.replace("&", "&amp;").replace(">", "&gt;").replace("<", "&lt;")
<     return escaped
< 
< ## Get the start tag, end tag, and text handlers of a class
< def GetHandlers(obj):
<    return (obj.StartElementHandler,
<            obj.EndElementHandler,
<            obj.CharacterDataHandler,
<            obj.StartNamespaceDeclHandler,
<            obj.EndNamespaceDeclHandler)
< 
< ## Set the start tag, end tag, and text handlers of a parser
< def SetHandlers(obj, handlers):
<    (obj.StartElementHandler,
<     obj.EndElementHandler,
<     obj.CharacterDataHandler,
<     obj.StartNamespaceDeclHandler,
<     obj.EndNamespaceDeclHandler) = handlers
< 
< ## Serialize an object to bytes
< #
< # This function assumes CheckField(info, val) was already called
< # @param val the value to serialize
< # @param info the field
< # @param version the version
< # @param nsMap a dict of xml ns -> prefix
< # @return the serialized object as bytes
< # @param encoding Deprecated this is not used during serialization since we always
< #        use utf-8 to encode a request message. We didn't remove the
< #        parameter so it is still compatible with clients that are still using it.
< def Serialize(val, info=None, version=None, nsMap=None, encoding=None):
<    return _SerializeToUnicode(val, info=info, version=version, nsMap=nsMap).encode(XML_ENCODING)
< 
< ## Serialize an object to unicode
< #
< # This function assumes CheckField(info, val) was already called
< # @param val the value to serialize
< # @param info the field
< # @param version the version
< # @param nsMap a dict of xml ns -> prefix
< # @return the serialized object as unicode
< def SerializeToUnicode(val, info=None, version=None, nsMap=None):
<    return _SerializeToUnicode(val, info=info, version=version, nsMap=nsMap)
< 
< ## Serialize an object to unicode
< #
< # This function assumes CheckField(info, val) was already called
< # @param val the value to serialize
< # @param info the field
< # @param version the version
< # @param nsMap a dict of xml ns -> prefix
< # @return the serialized object as unicode
< def _SerializeToUnicode(val, info=None, version=None, nsMap=None):
<    if version is None:
<       try:
<          if isinstance(val, list):
<             itemType = val.Item
<             version = itemType._version
<          else:
<             if val is None:
<                # neither val nor version is given
<                return ''
<             # Pick up the version from val
<             version = val._version
<       except AttributeError:
<          version = BASE_VERSION
<    if info is None:
<       info = Object(name="object", type=object, version=version, flags=0)
< 
<    writer = StringIO()
<    SoapSerializer(writer, version, nsMap).Serialize(val, info)
<    return writer.getvalue()
< 
< ## Serialize fault detail
< #
< # Serializes a fault as the content of the detail element in a
< # soapenv:Fault (i.e. without a LocalizedMethodFault wrapper).
< #
< # This function assumes CheckField(info, val) was already called
< # @param val the value to serialize
< # @param info the field
< # @param version the version
< # @param nsMap a dict of xml ns -> prefix
< # @return the serialized object as a unicode string
< def SerializeFaultDetail(val, info=None, version=None, nsMap=None, encoding=None):
<    if version is None:
<       try:
<          if not isinstance(val, MethodFault):
<             raise TypeError('{0} is not a MethodFault'.format(str(val)))
<          version = val._version
<       except AttributeError:
<          version = BASE_VERSION
<    if info is None:
<       info = Object(name="object", type=object, version=version, flags=0)
< 
<    writer = StringIO()
<    SoapSerializer(writer, version, nsMap, encoding).SerializeFaultDetail(val, info)
<    return writer.getvalue()
< 
< ## SOAP serializer
< #
< class SoapSerializer:
<    """ SoapSerializer """
<    ## Serializer constructor
<    #
<    # @param writer File writer
<    # @param version the version
<    # @param nsMap a dict of xml ns -> prefix
<    # @param encoding Deprecated this is not used during serialization since we always
<    #        use utf-8 to encode a request message. We didn't remove the
<    #        parameter so it is still compatible with clients that are still using it.
<    def __init__(self, writer, version, nsMap, encoding=None):
<       """ Constructor """
<       self.writer = writer
<       self.version = version
<       self.nsMap = nsMap and nsMap or {}
<       for ns, prefix in iteritems(self.nsMap):
<          if prefix == '':
<             self.defaultNS = ns
<             break
<       else:
<          self.defaultNS = ''
< 
<       # Additional attr for outermost tag
<       self.outermostAttrs = ''
< 
<       # Fill in required xmlns, if not defined
<       for nsPrefix, ns, attrName in [('xsi', XMLNS_XSI, 'xsiPrefix'),
<                                      ('xsd', XMLNS_XSD, 'xsdPrefix')]:
<          prefix = self.nsMap.get(ns)
<          if not prefix:
<             prefix = nsPrefix
<             self.outermostAttrs += ' xmlns:{0}="{1}"'.format(prefix, ns)
<             self.nsMap = self.nsMap.copy()
<             self.nsMap[ns] = prefix
<          setattr(self, attrName, prefix + ":")
< 
< 
<    ## Serialize an object
<    #
<    # This function assumes CheckField(info, val) was already called
<    # @param val the value to serialize
<    # @param info the field
<    def Serialize(self, val, info):
<       """ Serialize an object """
<       self._Serialize(val, info, self.defaultNS)
< 
<    ## Serialize fault detail
<    #
<    # Serializes a fault as the content of the detail element in a
<    # soapenv:Fault (i.e. without a LocalizedMethodFault wrapper).
<    #
<    # This function assumes CheckField(info, val) was already called
<    # @param val the value to serialize
<    # @param info the field
<    def SerializeFaultDetail(self, val, info):
<       """ Serialize an object """
<       self._SerializeDataObject(val, info, ' xsi:typ="{1}"'.format(val._wsdlName), self.defaultNS)
< 
<    def _NSPrefix(self, ns):
<       """ Get xml ns prefix. self.nsMap must be set """
<       if ns == self.defaultNS:
<          return ''
<       prefix = self.nsMap[ns]
<       return prefix and prefix + ':' or ''
< 
<    def _QName(self, typ, defNS):
<       """ Get fully qualified wsdl name (prefix:name) """
<       attr = ''
<       ns, name = GetQualifiedWsdlName(typ)
<       if ns == defNS:
<          prefix = ''
<       else:
<          try:
<             prefix = self.nsMap[ns]
<          except KeyError:
<             # We have not seen this ns before
<             prefix = ns.split(':', 1)[-1]
<             attr = ' xmlns:{0}="{1}"'.format(prefix, ns)
<       return attr, prefix and prefix + ':' + name or name
< 
<    ## Serialize an object to unicode (internal)
<    #
<    # @param val the value to serialize
<    # @param info the field
<    # @param defNS the default namespace
<    def _Serialize(self, val, info, defNS):
<       """ Serialize an object """
<       if not IsChildVersion(self.version, info.version):
<          return
< 
<       if val is None:
<          if info.flags & F_OPTIONAL:
<             return
<          else:
<             raise TypeError('Field "{0}" is not optional'.format(info.name))
<       elif isinstance(val, list) and len(val) == 0:
<          if info.type is object:
<             # Make sure an empty array assigned to Any is typed
<             if not isinstance(val, Array):
<                raise TypeError('Field "{0}": Cannot assign empty native python array to an Any'.format(info.name))
<          elif info.flags & F_OPTIONAL:
<             # Skip optional non-Any
<             return
<          else:
<              raise TypeError('Field "{0}" not optional'.format(info.name))
< 
<       if self.outermostAttrs:
<          attr = self.outermostAttrs
<          self.outermostAttrs = None
<       else:
<          attr = ''
<       currDefNS = defNS
<       # Emit default ns if tag ns is not the same
<       currTagNS = GetWsdlNamespace(info.version)
<       if currTagNS != defNS:
<          attr += ' xmlns="{0}"'.format(currTagNS)
<          currDefNS = currTagNS
< 
<       if isinstance(val, DataObject):
<          if isinstance(val, MethodFault):
<             newVal = LocalizedMethodFault(fault=val, localizedMessage=val.msg)
<             if info.type is object:
<                faultType = object
<             else:
<                faultType = LocalizedMethodFault
<             newInfo = Object(name=info.name, type=faultType,
<                              version=info.version, flags=info.flags)
<             self._SerializeDataObject(newVal, newInfo, attr, currDefNS)
<          else:
<             self._SerializeDataObject(val, info, attr, currDefNS)
<       elif isinstance(val, ManagedObject):
<          if info.type is object:
<             nsattr, qName = self._QName(ManagedObject, currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          if val._serverGuid is not None:
<             attr += ' serverGuid="{0}"'.format(val._serverGuid)
<          # val in vim type attr is not namespace qualified
<          # TODO: Add a new "typens" attr?
<          ns, name = GetQualifiedWsdlName(Type(val))
<          attr += ' type="{0}"'.format(name)
<          self.writer.write('<{0}{1}>{2}</{3}>'.format(info.name, attr,
<                                               val._moId,
<                                               info.name))
<       elif isinstance(val, list):
<          if info.type is object:
<             itemType = val.Item
<             if (itemType is ManagedMethod or itemType is PropertyPath
<             or  itemType is type):
<                tag = 'string'
<                typ = GetVmodlType("string[]")
<             elif issubclass(itemType, ManagedObject):
<                tag = 'ManagedObjectReference'
<                typ = ManagedObject.Array
<             else:
<                tag = GetWsdlName(itemType)
<                typ = Type(val)
<             nsattr, qName = self._QName(typ, currDefNS)
< 
<             # For WSDL, since we set tag of ManagedObjects to ManagedObjectReferences,
<             # the name of its array should be ArrayOfManagedObjectReference
<             if qName.endswith("ArrayOfManagedObject"):
<                qName += "Reference"
< 
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<             self.writer.write('<{0}{1}>'.format(info.name, attr))
< 
<             itemInfo = Object(name=tag, type=itemType,
<                               version=info.version, flags=info.flags)
<             for it in val:
<                self._Serialize(it, itemInfo, currDefNS)
<             self.writer.write('</{0}>'.format(info.name))
<          else:
<             itemType = info.type.Item
<             itemInfo = Object(name=info.name, type=itemType,
<                               version=info.version, flags=info.flags)
<             for it in val:
<                self._Serialize(it, itemInfo, defNS)
<       elif isinstance(val, type) or isinstance(val, type(Exception)):
<          if info.type is object:
<             attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(
<                            info.name, attr, GetWsdlName(val)))
<       elif isinstance(val, ManagedMethod):
<          if info.type is object:
<             attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(
<                               info.name, attr, val.info.wsdlName))
<       elif isinstance(val, datetime):
<          if info.type is object:
<             nsattr, qName = self._QName(Type(val), currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          result = Iso8601.ISO8601Format(val)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
<       elif isinstance(val, binary):
<          if info.type is object:
<             nsattr, qName = self._QName(Type(val), currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          result = base64.b64encode(val)
<          if PY3:
<             # In python3 the bytes result after the base64 encoding has a
<             # leading 'b' which causes error when we use it to construct the
<             # soap message. Workaround the issue by converting the result to
<             # string. Since the result of base64 encoding contains only subset
<             # of ASCII chars, converting to string will not change the value.
<             result = str(result, XML_ENCODING)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
<       elif isinstance(val, bool):
<          if info.type is object:
<             nsattr, qName = self._QName(Type(val), currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          result = val and "true" or "false"
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
<       elif isinstance(val, six.integer_types) or isinstance(val, float):
<          if info.type is object:
<             nsattr, qName = self._QName(Type(val), currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          result = six.text_type(val)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
<       elif isinstance(val, Enum):
<          if info.type is object:
<             nsattr, qName = self._QName(Type(val), currDefNS)
<             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, val))
<       else:
<          if info.type is object:
<             if isinstance(val, PropertyPath):
<                attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
<             else:
<                nsattr, qName = self._QName(Type(val), currDefNS)
<                attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
< 
<          if isinstance(val, six.binary_type):
<             # Use UTF-8 rather than self.encoding.  self.encoding is for
<             # output of serializer, while 'val' is our input.  And regardless
<             # of what our output is, our input should be always UTF-8.  Yes,
<             # it means that if you emit output in other encoding than UTF-8,
<             # you cannot serialize it again once more.  That's feature, not
<             # a bug.
<             val = val.decode(XML_ENCODING)
<          result = XmlEscape(val)
<          self.writer.write(u'<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
< 
<    ## Serialize a a data object (internal)
<    #
<    # @param val the value to serialize
<    # @param info the field
<    # @param attr attributes to serialized in the outermost elementt
<    # @param currDefNS the current default namespace
<    def _SerializeDataObject(self, val, info, attr, currDefNS):
<       if info.flags & F_LINK:
<          # Attribute is a link and Object is present instead of its key.
<          # We need to serialize just the key and not the entire object
<          self._Serialize(val.key, info, currDefNS)
<          return
<       dynType = GetCompatibleType(Type(val), self.version)
<       if dynType != info.type:
<          nsattr, qName = self._QName(dynType, currDefNS)
<          attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
<       self.writer.write('<{0}{1}>'.format(info.name, attr))
<       if dynType is LocalizedMethodFault:
<          # Serialize a MethodFault as LocalizedMethodFault on wire
<          # See PR 670229
<          for prop in val._GetPropertyList():
<             propVal = getattr(val, prop.name)
<             if prop.name == 'fault':
<                propVal = copy.copy(propVal)
<                propVal.msg = None
<                self._SerializeDataObject(propVal, prop, '', currDefNS)
<             else:
<                self._Serialize(propVal, prop, currDefNS)
<       else:
<          for prop in val._GetPropertyList():
<             self._Serialize(getattr(val, prop.name), prop, currDefNS)
< 
<       self.writer.write('</{0}>'.format(info.name))
< 
< 
< class ParserError(KeyError):
<     # NOTE (hartsock): extends KeyError since parser logic is written to
<     # catch KeyError types. Normally, I would want PerserError to be a root
<     # type for all parser faults.
<     pass
< 
< def ParseData(parser, data):
<    # NOTE (hartsock): maintaining library internal consistency here, this is
<    # a refactoring that rolls up some repeated code blocks into a method so
<    # that we can refactor XML parsing behavior in a single place.
<    try:
<       if isinstance(data, six.binary_type) or isinstance(data, six.text_type):
<          parser.Parse(data)
<       else:
<          parser.ParseFile(data)
<    except Exception:
<       # wrap all parser faults with additional information for later
<       # bug reporting on the XML parser code itself.
<       (ec, ev, tb) = sys.exc_info()
<       line = parser.CurrentLineNumber
<       col = parser.CurrentColumnNumber
<       pe = ParserError("xml document: "
<                        "{0} parse error at: "
<                        "line:{1}, col:{2}".format(data, line, col))
<       # use six.reraise for python 2.x and 3.x compatability
<       reraise(ParserError, pe, tb)
< 
< ## Deserialize an object from a file or string
< #
< # This function will deserialize one top-level XML node.
< # @param data the data to deserialize (a file object or string)
< # @param resultType expected result type
< # @param stub stub for moRef deserialization
< # @return the deserialized object
< def Deserialize(data, resultType=object, stub=None):
<    parser = ParserCreate(namespace_separator=NS_SEP)
<    ds = SoapDeserializer(stub)
<    ds.Deserialize(parser, resultType)
<    ParseData(parser, data)
<    return ds.GetResult()
< 
< 
< ## Expat deserializer namespace handler
< class ExpatDeserializerNSHandlers:
<    def __init__(self, nsMap=None):
<       # nsMap is a dict of ns prefix to a stack (list) of namespaces
<       # The last element of the stack is current namespace
<       if not nsMap:
<          nsMap = {}
<       self.nsMap = nsMap
< 
<    ## Get current default ns
<    def GetCurrDefNS(self):
<       return self._GetNamespaceFromPrefix()
< 
<    ## Get namespace and wsdl name from tag
<    def GetNSAndWsdlname(self, tag):
<       """ Map prefix:name tag into ns, name """
<       idx = tag.find(":")
<       if idx >= 0:
<          prefix, name = tag[:idx], tag[idx + 1:]
<       else:
<          prefix, name = None, tag
<       # Map prefix to ns
<       ns = self._GetNamespaceFromPrefix(prefix)
<       return ns, name
< 
<    def _GetNamespaceFromPrefix(self, prefix = None):
<       namespaces = self.nsMap.get(prefix)
<       if namespaces:
<          ns = namespaces[-1]
<       else:
<          ns = ""
<       return ns
< 
<    ## Handle namespace begin
<    def StartNamespaceDeclHandler(self, prefix, uri):
<       namespaces = self.nsMap.get(prefix)
<       if namespaces:
<          namespaces.append(uri)
<       else:
<          self.nsMap[prefix] = [uri]
< 
<    ## Handle namespace end
<    def EndNamespaceDeclHandler(self, prefix):
<       self.nsMap[prefix].pop()
< 
< 
< ## SOAP -> Python Deserializer
< class SoapDeserializer(ExpatDeserializerNSHandlers):
<    ## Constructor
<    #
<    # @param self self
<    # @param stub Stub adapter to use for deserializing moRefs
<    def __init__(self, stub=None, version=None):
<       ExpatDeserializerNSHandlers.__init__(self)
<       self.stub = stub
<       if version:
<          self.version = version
<       elif self.stub:
<          self.version = self.stub.version
<       else:
<          self.version = None
<       self.result = None
< 
<    ## Deserialize a SOAP object
<    #
<    # @param self self
<    # @param parser an expat parser
<    # @param resultType the static type of the result
<    # @param isFault true if the response is a fault response
<    # @param nsMap a dict of prefix -> [xml ns stack]
<    # @return the deserialized object
<    def Deserialize(self, parser, resultType=object, isFault=False, nsMap=None):
<       self.isFault = isFault
<       self.parser = parser
<       self.origHandlers = GetHandlers(parser)
<       SetHandlers(parser, GetHandlers(self))
<       self.resultType = resultType
<       self.stack = []
<       self.data = ""
<       self.serverGuid = None
<       if issubclass(resultType, list):
<          self.result = resultType()
<       else:
<          self.result = None
<       if not nsMap:
<          nsMap = {}
<       self.nsMap = nsMap
< 
<    ## Get the result of deserialization
<    #  The links will not be resolved. User needs to explicitly resolve them
<    #  using LinkResolver.
<    def GetResult(self):
<       return self.result
< 
<    def SplitTag(self, tag):
<       """ Split tag into ns, name """
<       idx = tag.find(NS_SEP)
<       if idx >= 0:
<          return tag[:idx], tag[idx + 1:]
<       else:
<          return "", tag
< 
<    def LookupWsdlType(self, ns, name, allowManagedObjectReference=False):
<       """ Lookup wsdl type. Handle special case for some vmodl version """
<       try:
<          return GetWsdlType(ns, name)
<       except KeyError:
<          if allowManagedObjectReference:
<             if name.endswith('ManagedObjectReference') and ns == XMLNS_VMODL_BASE:
<                return GetWsdlType(ns, name[:-len('Reference')])
<          # WARNING!!! This is a temporary hack to get around server not
<          # honoring @service tag (see bug 521744). Once it is fix, I am
<          # going to back out this change
<          if name.endswith('ManagedObjectReference') and allowManagedObjectReference:
<             return GetWsdlType(XMLNS_VMODL_BASE, name[:-len('Reference')])
<          return GuessWsdlType(name)
< 
<    ## Handle an opening XML tag
<    def StartElementHandler(self, tag, attr):
<       self.data = ""
<       self.serverGuid = None
<       deserializeAsLocalizedMethodFault = True
<       if not self.stack:
<          if self.isFault:
<             ns, name = self.SplitTag(tag)
<             objType = self.LookupWsdlType(ns, name[:-5])
<             # Only top level soap fault should be deserialized as method fault
<             deserializeAsLocalizedMethodFault = False
<          else:
<             objType = self.resultType
<       elif isinstance(self.stack[-1], list):
<          objType = self.stack[-1].Item
<       elif isinstance(self.stack[-1], DataObject):
<          # TODO: Check ns matches DataObject's namespace
<          ns, name = self.SplitTag(tag)
<          objType = self.stack[-1]._GetPropertyInfo(name).type
< 
<          # LocalizedMethodFault <fault> tag should be deserialized as method fault
<          if name == "fault" and isinstance(self.stack[-1], LocalizedMethodFault):
<             deserializeAsLocalizedMethodFault = False
<       else:
<          raise TypeError("Invalid type for tag {0}".format(tag))
< 
<       xsiType = attr.get(XSI_TYPE)
<       if xsiType:
<          # Ignore dynamic type for TypeName, MethodName, PropertyPath
<          # @bug 150459
<          if not (objType is type or objType is ManagedMethod or \
<                                     objType is PropertyPath):
<             ns, name = self.GetNSAndWsdlname(xsiType)
<             dynType = self.LookupWsdlType(ns, name, allowManagedObjectReference=True)
<             # TODO: Should be something like...
<             #   dynType must be narrower than objType, except for
<             #   ManagedObjectReference
<             if not (issubclass(dynType, list) and issubclass(objType, list)):
<                objType = dynType
<       else:
<          if issubclass(objType, list):
<             objType = objType.Item
< 
<       if self.version:
<          objType = GetCompatibleType(objType, self.version)
<       if issubclass(objType, ManagedObject):
<          typeAttr = attr[u('type')]
<          # val in vim type attr is not namespace qualified
<          # However, this doesn't hurt to strip out namespace
<          # TODO: Get the ns from "typens" attr?
<          ns, name = self.GetNSAndWsdlname(typeAttr)
<          if u('serverGuid') in attr:
<             self.serverGuid = attr[u('serverGuid')]
<          self.stack.append(GuessWsdlType(name))
<       elif issubclass(objType, DataObject) or issubclass(objType, list):
<          if deserializeAsLocalizedMethodFault and issubclass(objType, Exception):
<             objType = LocalizedMethodFault
<          self.stack.append(objType())
<       else:
<          self.stack.append(objType)
< 
<    ## Handle a closing XML tag
<    def EndElementHandler(self, tag):
<       try:
<          obj = self.stack.pop()
<       except IndexError:
<          SetHandlers(self.parser, self.origHandlers)
<          handler = self.parser.EndElementHandler
<          del self.parser, self.origHandlers, self.stack, self.resultType
<          if handler:
<             return handler(tag)
<          return
< 
<       data = self.data
<       if isinstance(obj, type) or isinstance(obj, type(Exception)):
<          if obj is type:
<             if data is None or data == '':
<                obj = None
<             else:
<                try:
<                   # val in type val is not namespace qualified
<                   # However, this doesn't hurt to strip out namespace
<                   ns, name = self.GetNSAndWsdlname(data)
<                   obj = GuessWsdlType(name)
<                except KeyError:
<                   raise TypeError(data)
<          elif obj is ManagedMethod:
<             # val in Method val is not namespace qualified
<             # However, this doesn't hurt to strip out namespace
<             ns, name = self.GetNSAndWsdlname(data)
<             try:
<                obj = GuessWsdlMethod(name)
<             except KeyError:
<                obj = UncallableManagedMethod(name)
<          elif obj is bool:
<             if data == "0" or data.lower() == "false":
<                obj = bool(False)
<             elif data == "1" or data.lower() == "true":
<                obj = bool(True)
<             else:
<                raise TypeError(data)
<          elif obj is binary:
<             # Raise type error if decode failed
<             obj = obj(base64.b64decode(data))
<          elif obj is str:
<             try:
<                obj = str(data)
<             except ValueError:
<                obj = data
<          elif obj is datetime:
<             obj = pyVmomi.Iso8601.ParseISO8601(data)
<             if not obj:
<                raise TypeError(data)
<          # issubclass is very expensive. Test last
<          elif issubclass(obj, ManagedObject):
<             obj = obj(data, self.stub, self.serverGuid)
<          elif issubclass(obj, Enum):
<             obj = getattr(obj, data)
<          else:
<             obj = obj(data)
<       elif isinstance(obj, LocalizedMethodFault):
<          obj.fault.msg = obj.localizedMessage
<          obj = obj.fault
< 
<       if self.stack:
<          top = self.stack[-1]
<          if isinstance(top, list):
<             top.append(obj)
<          elif isinstance(top, DataObject):
<             ns, name = self.SplitTag(tag)
<             info = top._GetPropertyInfo(name)
< 
<             if not isinstance(obj, list) and issubclass(info.type, list):
<                getattr(top, info.name).append(obj)
<             else:
<                setattr(top, info.name, obj)
<          else:
<             ns, name = self.SplitTag(tag)
<             setattr(top, name, obj)
<       else:
<          if not isinstance(obj, list) and issubclass(self.resultType, list):
<             self.result.append(obj)
<          else:
<             self.result = obj
<             SetHandlers(self.parser, self.origHandlers)
<             del self.parser, self.origHandlers, self.stack, self.resultType
< 
<    ## Handle text data
<    def CharacterDataHandler(self, data):
<       self.data += data
< 
< 
< ## SOAP Response Deserializer class
< class SoapResponseDeserializer(ExpatDeserializerNSHandlers):
<    ## Constructor
<    #
<    # @param self self
<    # @param stub Stub adapter to use for deserializing moRefs
<    def __init__(self, stub):
<       ExpatDeserializerNSHandlers.__init__(self)
<       self.stub = stub
<       self.deser = SoapDeserializer(stub)
<       self.soapFaultTag = XMLNS_SOAPENV + NS_SEP + "Fault"
< 
<    ## Deserialize a SOAP response
<    #
<    # @param self self
<    # @param response the response (a file object or a string)
<    # @param resultType expected result type
<    # @param nsMap a dict of prefix -> [xml ns stack]
<    # @return the deserialized object
<    def Deserialize(self, response, resultType, nsMap=None):
<       self.resultType = resultType
<       self.stack = []
<       self.msg = ""
<       self.deser.result = None
<       self.isFault = False
<       self.parser = ParserCreate(namespace_separator=NS_SEP)
<       try: # buffer_text only in python >= 2.3
<          self.parser.buffer_text = True
<       except AttributeError:
<          pass
<       if not nsMap:
<          nsMap = {}
<       self.nsMap = nsMap
<       SetHandlers(self.parser, GetHandlers(self))
<       ParseData(self.parser, response)
<       result = self.deser.GetResult()
<       if self.isFault:
<          if result is None:
<             result = GetVmodlType("vmodl.RuntimeFault")()
<          result.msg = self.msg
<       del self.resultType, self.stack, self.parser, self.msg, self.data, self.nsMap
<       return result
< 
<    ## Handle an opening XML tag
<    def StartElementHandler(self, tag, attr):
<       self.data = ""
<       if tag == self.soapFaultTag:
<          self.isFault = True
<       elif self.isFault and tag == "detail":
<          self.deser.Deserialize(self.parser, object, True, self.nsMap)
<       elif tag.endswith("Response"):
<          self.deser.Deserialize(self.parser, self.resultType, False, self.nsMap)
< 
<    ## Handle text data
<    def CharacterDataHandler(self, data):
<       self.data += data
< 
<    ## Handle a closing XML tag
<    def EndElementHandler(self, tag):
<       if self.isFault and tag == "faultstring":
<          try:
<             self.msg = str(self.data)
<          except ValueError:
<             self.msg = self.data
< 
< ## Base class that implements common functionality for stub adapters.
< ## Method that must be provided by the implementation class:
< ## -- InvokeMethod(ManagedObject mo, Object methodInfo, Object[] args)
< class StubAdapterBase(StubAdapterAccessorMixin):
<    def __init__(self, version):
<       StubAdapterAccessorMixin.__init__(self)
<       self.ComputeVersionInfo(version)
< 
<    ## Compute the version information for the specified namespace
<    #
<    # @param ns the namespace
<    def ComputeVersionInfo(self, version):
<       # Make sure we do NOT fallback to an older version
<       if hasattr(self, 'version') and IsChildVersion(self.version, version):
<          # print("WARNING: stub degrading: " + self.version + " -> " + version)
<          return
< 
<       versionNS = GetVersionNamespace(version)
<       if versionNS.find("/") >= 0:
<          self.versionId = '"urn:{0}"'.format(versionNS)
<       else:
<          self.versionId = ''
<       self.version = version
< 
< ## Base class that implements common functionality for SOAP-based stub adapters.
< ## Method that must be provided by the implementation class:
< ## -- InvokeMethod(ManagedObject mo, Object methodInfo, Object[] args)
< class SoapStubAdapterBase(StubAdapterBase):
<    ## Serialize a VMOMI request to SOAP
<    #
<    # @param version API version
<    # @param mo the 'this'
<    # @param info method info
<    # @param args method arguments
<    # @return the serialized request
<    def SerializeRequest(self, mo, info, args):
<       if not IsChildVersion(self.version, info.version):
<          raise GetVmodlType("vmodl.fault.MethodNotFound")(receiver=mo,
<                                                           method=info.name)
<       nsMap = SOAP_NSMAP.copy()
<       defaultNS = GetWsdlNamespace(self.version)
<       nsMap[defaultNS] = ''
< 
<       # Add xml header and soap envelope
<       result = [XML_HEADER, '\n', SOAP_ENVELOPE_START]
< 
<       # Add request context and samlToken to soap header, if exists
<       reqContexts = GetRequestContext()
<       if self.requestContext:
<          reqContexts.update(self.requestContext)
<       samlToken = getattr(self, 'samlToken', None)
< 
<       if reqContexts or samlToken:
<          result.append(SOAP_HEADER_START)
<          for key, val in iteritems(reqContexts):
<             # Note: Support req context of string type only
<             if not isinstance(val, six.string_types):
<                raise TypeError("Request context key ({0}) has non-string value ({1}) of {2}".format(key, val, type(val)))
<             ret = _SerializeToUnicode(val,
<                             Object(name=key, type=str, version=self.version),
<                             self.version,
<                             nsMap)
<             result.append(ret)
<          if samlToken:
<             result.append('{0} {1} {2}'.format(WSSE_HEADER_START,
<                                                samlToken,
<                                                WSSE_HEADER_END))
<          result.append(SOAP_HEADER_END)
<          result.append('\n')
< 
<       # Serialize soap body
<       result.extend([SOAP_BODY_START,
<                        '<{0} xmlns="{1}">'.format(info.wsdlName, defaultNS),
<                        _SerializeToUnicode(mo, Object(name="_this", type=ManagedObject,
<                                             version=self.version),
<                                  self.version, nsMap)])
< 
<       # Serialize soap request parameters
<       for (param, arg) in zip(info.params, args):
<          result.append(_SerializeToUnicode(arg, param, self.version, nsMap))
<       result.extend(['</{0}>'.format(info.wsdlName), SOAP_BODY_END, SOAP_ENVELOPE_END])
<       return ''.join(result).encode(XML_ENCODING)
< 
< ## Subclass of HTTPConnection that connects over a Unix domain socket
< ## instead of a TCP port.  The path of the socket is passed in place of
< ## the hostname.  Fairly gross but does the job.
< class UnixSocketConnection(http_client.HTTPConnection):
<    # The HTTPConnection ctor expects a single argument, which it interprets
<    # as the host to connect to; for UnixSocketConnection, we instead interpret
<    # the parameter as the filesystem path of the Unix domain socket.
<    def __init__(self, path):
<       # Pass '' as the host to HTTPConnection; it doesn't really matter
<       # what we pass (since we've overridden the connect method) as long
<       # as it's a valid string.
<       http_client.HTTPConnection.__init__(self, '')
<       self.path = path
< 
<    def connect(self):
<       # Hijack the connect method of HTTPConnection to connect to the
<       # specified Unix domain socket instead.  Obey the same contract
<       # as HTTPConnection.connect, which puts the socket in self.sock.
<       sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
<       sock.connect(self.path)
<       self.sock = sock
< 
< try:
<    # The ssl module is not available in python versions less than 2.6
<    SSL_THUMBPRINTS_SUPPORTED = True
< 
<    import ssl
<    import hashlib
< 
<    def _VerifyThumbprint(thumbprint, connection):
<       '''If there is a thumbprint, connect to the server and verify that the
<       SSL certificate matches the given thumbprint.  An exception is thrown
<       if there is a mismatch.'''
<       if thumbprint and isinstance(connection, http_client.HTTPSConnection):
<          if not connection.sock:
<             connection.connect()
<          derCert = connection.sock.getpeercert(True)
<          sha1 = hashlib.sha1()
<          sha1.update(derCert)
<          sha1Digest = sha1.hexdigest().lower()
<          if sha1Digest != thumbprint:
<             raise ThumbprintMismatchException(thumbprint, sha1Digest)
< 
<    # Function used to wrap sockets with SSL
<    _SocketWrapper = ssl.wrap_socket
< 
< except ImportError:
<    SSL_THUMBPRINTS_SUPPORTED = False
< 
<    def _VerifyThumbprint(thumbprint, connection):
<       if thumbprint and isinstance(connection, http_client.HTTPSConnection):
<          raise Exception(
<             "Thumbprint verification not supported on python < 2.6")
< 
<    def _SocketWrapper(rawSocket, keyfile, certfile, *args, **kwargs):
<       wrappedSocket = socket.ssl(rawSocket, keyfile, certfile)
<       return http_client.FakeSocket(rawSocket, wrappedSocket)
< 
< 
< ## Internal version of https connection
< #
< # Support ssl.wrap_socket params which are missing from httplib
< # HTTPSConnection (e.g. ca_certs)
< # Note: Only works if the ssl params are passing in as kwargs
< class _HTTPSConnection(http_client.HTTPSConnection):
<    def __init__(self, *args, **kwargs):
<       # Extract ssl.wrap_socket param unknown to httplib.HTTPSConnection,
<       # and push back the params in connect()
<       self._sslArgs = {}
<       tmpKwargs = kwargs.copy()
<       for key in SOAP_ADAPTER_ARGS:
<          if key in tmpKwargs:
<             self._sslArgs[key] = tmpKwargs.pop(key)
<       http_client.HTTPSConnection.__init__(self, *args, **tmpKwargs)
< 
<    ## Override connect to allow us to pass in additional ssl paramters to
<    #  ssl.wrap_socket (e.g. cert_reqs, ca_certs for ca cert verification)
<    def connect(self):
<       if len(self._sslArgs) == 0:
<          # No override
<          http_client.HTTPSConnection.connect(self)
<          return
< 
<       # Big hack. We have to copy and paste the httplib connect fn for
<       # each python version in order to handle extra ssl paramters. Yuk!
<       if hasattr(self, "source_address"):
<          # Python 2.7
<          sock = socket.create_connection((self.host, self.port),
<                                          self.timeout, self.source_address)
<          if self._tunnel_host:
<             self.sock = sock
<             self._tunnel()
<          self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
<                                      **self._sslArgs)
<       elif hasattr(self, "timeout"):
<          # Python 2.6
<          sock = socket.create_connection((self.host, self.port), self.timeout)
<          self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
<                                      **self._sslArgs)
<       else:
<          # Unknown python version. Do nothing
<          http_client.HTTPSConnection.connect(self)
<          return
< 
<          # TODO: Additional verification of peer cert if needed
<          # cert_reqs = self._sslArgs.get("cert_reqs", ssl.CERT_NONE)
<          # ca_certs = self._sslArgs.get("ca_certs", None)
<          # if cert_reqs != ssl.CERT_NONE and ca_certs:
<          #   if hasattr(self.sock, "getpeercert"):
<          #      # TODO: verify peer cert
<          #      dercert = self.sock.getpeercert(False)
<          #      # pemcert = ssl.DER_cert_to_PEM_cert(dercert)
< 
< 
< ## Stand-in for the HTTPSConnection class that will connect to a SSL proxy,
< ## VCenter's /sdkTunnel endpoint. It will issue a CONNECT command to start
< ## an SSL tunnel.
< class SSLTunnelConnection(object):
<    # @param proxyPath The path to pass to the CONNECT command.
<    def __init__(self, proxyPath):
<       self.proxyPath = proxyPath
< 
<    # Connects to a proxy server and initiates a tunnel to the destination
<    # specified by proxyPath.  If successful, a new HTTPSConnection is returned.
<    #
<    # @param path The destination URL path.
<    # @param key_file The SSL key file to use when wrapping the socket.
<    # @param cert_file The SSL certificate file to use when wrapping the socket.
<    # @param kwargs In case caller passed in extra parameters not handled by
<    #        SSLTunnelConnection
<    def __call__(self, path, key_file=None, cert_file=None, **kwargs):
<       # Only pass in the named arguments that HTTPConnection constructor
<       # understands
<       tmpKwargs = {}
<       for key in http_client.HTTPConnection.__init__.__code__.co_varnames:
<          if key in kwargs and key != 'self':
<             tmpKwargs[key] = kwargs[key]
<       tunnel = http_client.HTTPConnection(path, **tmpKwargs)
<       tunnel.request('CONNECT', self.proxyPath)
<       resp = tunnel.getresponse()
<       if resp.status != 200:
<         raise http_client.HTTPException("{0} {1}".format(resp.status, resp.reason))
<       retval = http_client.HTTPSConnection(path)
<       retval.sock = _SocketWrapper(tunnel.sock,
<                                    keyfile=key_file, certfile=cert_file)
<       return retval
< 
< 
< ## Stand-in for the HTTPSConnection class that will connect to a regular HTTP
< ## proxy.
< class HTTPProxyConnection(object):
<    # @param proxyPath The path to pass to the CONNECT command.
<    def __init__(self, proxyPath):
<       self.proxyPath = proxyPath
< 
<    # Connects to a HTTP proxy server and initiates a tunnel to the destination
<    # specified by proxyPath.  If successful, a new HTTPSConnection is returned.
<    #
<    # @param path The destination URL path.
<    # @param args Arguments are ignored
<    # @param kwargs Arguments for HTTPSConnection
<    def __call__(self, path, *args, **kwargs):
<       httpsConnArgs = {k: kwargs[k] for k in kwargs if k not in SOAP_ADAPTER_ARGS}
<       conn = http_client.HTTPSConnection(path, **httpsConnArgs)
<       conn.set_tunnel(self.proxyPath)
<       return conn
< 
< class GzipReader:
<    GZIP        = 1
<    DEFLATE     = 2
< 
<    def __init__(self, rfile, encoding=GZIP, readChunkSize=512):
<       self.rfile = rfile
<       self.chunks = []
<       self.bufSize = 0 # Remaining buffer
<       assert(encoding in (GzipReader.GZIP, GzipReader.DEFLATE))
<       self.encoding = encoding
<       self.unzip = None
<       self.readChunkSize = readChunkSize
< 
<    def _CreateUnzip(self, firstChunk):
<       import zlib
<       if self.encoding == GzipReader.GZIP:
<          wbits = zlib.MAX_WBITS + 16
<       elif self.encoding == GzipReader.DEFLATE:
<          # Sniff out real deflate format
<          chunkLen = len(firstChunk)
<          # Assume raw deflate
<          wbits = -zlib.MAX_WBITS
<          if firstChunk[:3] == ['\x1f', '\x8b', '\x08']:
<             # gzip: Apache mod_deflate will send gzip. Yurk!
<             wbits = zlib.MAX_WBITS + 16
<          elif chunkLen >= 2:
<             b0 = ord(firstChunk[0])
<             b1 = ord(firstChunk[1])
<             if (b0 & 0xf) == 8 and (((b0 * 256 + b1)) % 31) == 0:
<                # zlib deflate
<                wbits = min(((b0 & 0xf0) >> 4) + 8, zlib.MAX_WBITS)
<       else:
<          assert(False)
<       self.unzip = zlib.decompressobj(wbits)
<       return self.unzip
< 
<    def read(self, bytes=-1):
<       chunks = self.chunks
<       bufSize = self.bufSize
< 
<       while bufSize < bytes or bytes == -1:
<          # Read and decompress
<          chunk = self.rfile.read(self.readChunkSize)
< 
<          if self.unzip == None:
<             self._CreateUnzip(chunk)
< 
<          if chunk:
<             inflatedChunk = self.unzip.decompress(chunk)
<             bufSize += len(inflatedChunk)
<             chunks.append(inflatedChunk)
<          else:
<             # Returns whatever we have
<             break
< 
<       if bufSize <= bytes or bytes == -1:
<          leftoverBytes = 0
<          leftoverChunks = []
<       else:
<          leftoverBytes = bufSize - bytes
<          # Adjust last chunk to hold only the left over bytes
<          lastChunk = chunks.pop()
<          chunks.append(lastChunk[:-leftoverBytes])
<          leftoverChunks = [lastChunk[-leftoverBytes:]]
< 
<       self.chunks = leftoverChunks
<       self.bufSize = leftoverBytes
< 
<       buf = b"".join(chunks)
<       return buf
< 
< ## SOAP stub adapter object
< class SoapStubAdapter(SoapStubAdapterBase):
<    ## Constructor
<    #
<    # The endpoint can be specified individually as either a host/port
<    # combination, or with a URL (using a url= keyword).
<    #
<    # @param self self
<    # @param host host
<    # @param port port (pass negative port number for no SSL)
<    # @param **** Deprecated. Please use version instead **** ns API namespace
<    # @param path location of SOAP VMOMI service
<    # @param url URL (overrides host, port, path if set)
<    # @param sock unix domain socket path (overrides host, port, url if set)
<    # @param poolSize size of HTTP connection pool
<    # @param certKeyFile The path to the PEM-encoded SSL private key file.
<    # @param certFile The path to the PEM-encoded SSL certificate file.
<    # @param httpProxyHost The host name of the proxy server.
<    # @param httpProxyPort The proxy server port.
<    # @param sslProxyPath Path to use when tunneling through VC's reverse proxy.
<    # @param thumbprint The SHA1 thumbprint of the server's SSL certificate.
<    #   Some use a thumbprint of the form xx:xx:xx..:xx.  We ignore the ":"
<    #   characters.  If set to None, any thumbprint is accepted.
<    # @param cacertsFile CA certificates file in PEM format
<    # @param version API version
<    # @param connectionPoolTimeout Timeout in secs for idle connections in client pool. Use -1 to disable any timeout.
<    # @param samlToken SAML Token that should be used in SOAP security header for login
<    # @param sslContext SSL Context describing the various SSL options. It is only
<    #                   supported in Python 2.7.9 or higher.
<    def __init__(self, host='localhost', port=443, ns=None, path='/sdk',
<                 url=None, sock=None, poolSize=5,
<                 certFile=None, certKeyFile=None,
<                 httpProxyHost=None, httpProxyPort=80, sslProxyPath=None,
<                 thumbprint=None, cacertsFile=None, version=None,
<                 acceptCompressedResponses=True,
<                 connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
<                 samlToken=None, sslContext=None, requestContext=None):
<       if ns:
<          assert(version is None)
<          version = versionMap[ns]
<       elif not version:
<          version = 'vim.version.version1'
<       SoapStubAdapterBase.__init__(self, version=version)
<       self.cookie = ""
<       if sock:
<          self.scheme = UnixSocketConnection
<          # Store sock in the host member variable because that's where
<          # the UnixSocketConnection ctor expects to find it -- see above
<          self.host = sock
<       elif url:
<          scheme, self.host, urlpath = urlparse(url)[:3]
<          # Only use the URL path if it's sensible, otherwise use the path
<          # keyword argument as passed in.
<          if urlpath not in ('', '/'):
<             path = urlpath
<          self.scheme = scheme == "http" and http_client.HTTPConnection \
<                     or scheme == "https" and _HTTPSConnection
<       else:
<          port, self.scheme = port < 0 and (-port, http_client.HTTPConnection) \
<                                        or (port, _HTTPSConnection)
<          if host.find(':') != -1:  # is IPv6?
<             host = '[' + host + ']'
<          self.host = '{0}:{1}'.format(host, port)
< 
<       self.path = path
<       if thumbprint:
<          self.thumbprint = thumbprint.replace(":", "").lower()
<          if len(self.thumbprint) != 40:
<            raise Exception("Invalid SHA1 thumbprint -- {0}".format(thumbprint))
<       else:
<          self.thumbprint = None
< 
<       self.is_tunnel = False
<       if sslProxyPath:
<          self.scheme = SSLTunnelConnection(sslProxyPath)
<          self.is_tunnel = True
<       elif httpProxyHost:
<          self.scheme = HTTPProxyConnection(self.host)
<          self.is_tunnel = True
<          self.host = "{0}:{1}".format(httpProxyHost, httpProxyPort)
<       self.poolSize = poolSize
<       self.pool = []
<       self.connectionPoolTimeout = connectionPoolTimeout
<       self.lock = threading.Lock()
<       self.schemeArgs = {}
<       if certKeyFile:
<          self.schemeArgs['key_file'] = certKeyFile
<       if certFile:
<          self.schemeArgs['cert_file'] = certFile
<       if cacertsFile:
<          self.schemeArgs['ca_certs'] = cacertsFile
<          self.schemeArgs['cert_reqs'] = ssl.CERT_REQUIRED
<       if sslContext:
<          self.schemeArgs['context'] = sslContext
<       self.samlToken = samlToken
<       self.requestContext = requestContext
<       self.requestModifierList = []
<       self._acceptCompressedResponses = acceptCompressedResponses
< 
<    # Force a socket shutdown. Before python 2.7, ssl will fail to close
<    # the socket (http://bugs.python.org/issue10127).
<    # Not making this a part of the actual _HTTPSConnection since the internals
<    # of the httplib.HTTP*Connection seem to pass around the descriptors and
<    # depend on the behavior that close() still leaves the socket semi-functional.
<    if sys.version_info[:2] < (2,7):
<       def _CloseConnection(self, conn):
<          if self.scheme == _HTTPSConnection and conn.sock:
<            conn.sock.shutdown(socket.SHUT_RDWR)
<          conn.close()
<    else:
<       def _CloseConnection(self, conn):
<          conn.close()
< 
<    # Context modifier used to modify the SOAP request.
<    # @param func The func that takes in the serialized message and modifies the
<    #   the request. The func is appended to the requestModifierList and then
<    #   popped after the request is modified.
<    @contextlib.contextmanager
<    def requestModifier(self, func):
<       self.requestModifierList.append(func)
<       try:
<          yield
<       finally:
<          self.requestModifierList.pop()
<    ## Invoke a managed method
<    #
<    # @param self self
<    # @param mo the 'this'
<    # @param info method info
<    # @param args arguments
<    # @param outerStub If not-None, this should be a reference to the wrapping
<    #   stub adapter.  Any ManagedObject references returned from this method
<    #   will have outerStub in their _stub field.  Note that this also changes
<    #   the return type to a tuple containing the HTTP status and the
<    #   deserialized object so that it's easier to distinguish an API error from
<    #   a connection error.
<    def InvokeMethod(self, mo, info, args, outerStub=None):
<       if outerStub is None:
<          outerStub = self
< 
<       headers = {'Cookie' : self.cookie,
<                  'SOAPAction' : self.versionId,
<                  'Content-Type': 'text/xml; charset={0}'.format(XML_ENCODING),
<                  'User-Agent': 'pyvmomi Python/{0} ({1}; {2}; {3})'.
<                     format(PYTHON_VERSION, OS_NAME, OS_VERSION, OS_ARCH)}
<       if self._acceptCompressedResponses:
<          headers['Accept-Encoding'] = 'gzip, deflate'
< 
<       req = self.SerializeRequest(mo, info, args)
<       for modifier in self.requestModifierList:
<          req = modifier(req)
<       conn = self.GetConnection()
<       try:
<          conn.request('POST', self.path, req, headers)
<          resp = conn.getresponse()
<       except (socket.error, http_client.HTTPException):
<          # The server is probably sick, drop all of the cached connections.
<          self.DropConnections()
<          raise
<       # NOTE (hartsocks): this cookie handling code should go away in a future
<       # release. The string 'set-cookie' and 'Set-Cookie' but both are
<       # acceptable, but the supporting library may have a bug making it
<       # case sensitive when it shouldn't be. The term 'set-cookie' will occur
<       # more frequently than 'Set-Cookie' based on practical testing.
<       cookie = resp.getheader('set-cookie')
<       if cookie is None:
<           # try case-sensitive header for compatibility
<           cookie = resp.getheader('Set-Cookie')
<       status = resp.status
< 
<       if cookie:
<          self.cookie = cookie
<       if status == 200 or status == 500:
<          try:
<             fd = resp
<             encoding = resp.getheader('Content-Encoding', 'identity').lower()
<             if encoding == 'gzip':
<                fd = GzipReader(resp, encoding=GzipReader.GZIP)
<             elif encoding == 'deflate':
<                fd = GzipReader(resp, encoding=GzipReader.DEFLATE)
<             deserializer = SoapResponseDeserializer(outerStub)
<             obj = deserializer.Deserialize(fd, info.result)
<          except Exception as exc:
<             self._CloseConnection(conn)
<             # NOTE (hartsock): This feels out of place. As a rule the lexical
<             # context that opens a connection should also close it. However,
<             # in this code the connection is passed around and closed in other
<             # contexts (ie: methods) that we are blind to here. Refactor this.
< 
<             # The server might be sick, drop all of the cached connections.
<             self.DropConnections()
<             raise exc
<          else:
<             resp.read()
<             self.ReturnConnection(conn)
<          if outerStub != self:
<             return (status, obj)
<          if status == 200:
<             return obj
<          else:
<             raise obj # pylint: disable-msg=E0702
<       else:
<          self._CloseConnection(conn)
<          raise http_client.HTTPException("{0} {1}".format(resp.status, resp.reason))
< 
<    ## Clean up connection pool to throw away idle timed-out connections
<    #  SoapStubAdapter lock must be acquired before this method is called.
<    def _CloseIdleConnections(self):
<       if self.connectionPoolTimeout >= 0:
<          currentTime = time.time()
<          idleConnections = []
<          for conn, lastAccessTime in self.pool:
<             idleTime = currentTime - lastAccessTime
<             if idleTime >= self.connectionPoolTimeout:
<                i = self.pool.index((conn, lastAccessTime))
<                idleConnections = self.pool[i:]
<                self.pool = self.pool[:i]
<                break
< 
<          for conn, _ in idleConnections:
<             self._CloseConnection(conn)
< 
<    ## Get a HTTP connection from the pool
<    def GetConnection(self):
<       self.lock.acquire()
<       self._CloseIdleConnections()
<       if self.pool:
<          result, _ = self.pool.pop(0)
<          self.lock.release()
<       else:
<          self.lock.release()
<          result = self.scheme(self.host, **self.schemeArgs)
< 
<          # Always disable NAGLE algorithm
<          #
<          # Python httplib (2.6 and below) is splitting a http request into 2
<          # packets (header and body). It first send the header, but will not
<          # send the body until it receives the ack (for header) from server
<          # [NAGLE at work]. The delayed ack time on ESX is around 40 - 100 ms
<          # (depends on version) and can go up to 200 ms. This effectively slow
<          # down each pyVmomi call by the same amount of time.
<          #
<          # Disable NAGLE on client will force both header and body packets to
<          # get out immediately, and eliminated the delay
<          #
<          # This bug is fixed in python 2.7, however, only if the request
<          # body is a string (which is true for now)
<          if sys.version_info[:2] < (2,7):
<             self.DisableNagle(result)
< 
<          _VerifyThumbprint(self.thumbprint, result)
< 
<       return result
< 
<    ## Drop all cached connections to the server.
<    def DropConnections(self):
<       self.lock.acquire()
<       oldConnections = self.pool
<       self.pool = []
<       self.lock.release()
<       for conn, _ in oldConnections:
<          self._CloseConnection(conn)
< 
<    ## Return a HTTP connection to the pool
<    def ReturnConnection(self, conn):
<       self.lock.acquire()
<       self._CloseIdleConnections()
<       # In case of ssl tunneling, only add the conn if the conn has not been closed
<       if len(self.pool) < self.poolSize and (not self.is_tunnel or conn.sock):
<          self.pool.insert(0, (conn, time.time()))
<          self.lock.release()
<       else:
<          self.lock.release()
<          # NOTE (hartsock): this seems to violate good coding practice in that
<          # the lexical context that opens a connection should also be the
<          # same context responsible for closing it.
<          self._CloseConnection(conn)
< 
<    ## Disable nagle on a http connections
<    def DisableNagle(self, conn):
<       # Override connections' connect function to force disable NAGLE
<       if self.scheme != UnixSocketConnection and getattr(conn, "connect"):
<          orgConnect = conn.connect
<          def ConnectDisableNagle(*args, **kwargs):
<             orgConnect(*args, **kwargs)
<             sock = getattr(conn, "sock")
<             if sock:
<                try:
<                   sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
<                except Exception:
<                   pass
<          conn.connect = ConnectDisableNagle
< 
< ## Need to override the depcopy method. Since, the stub is not deep copyable
< #  due to the thread lock and connection pool, deep copy of a managed object
< #  fails. Further different instances of a managed object still share the
< #  same soap stub. Hence, returning self here is fine.
< def __deepcopy__(self, memo):
<    return self
< 
< HEADER_SECTION_END = '\r\n\r\n'
< 
< ## Parse an HTTP response into its headers and body
< def ParseHttpResponse(httpResponse):
<    headerEnd = httpResponse.find(HEADER_SECTION_END)
<    if headerEnd == -1:
<       return ('', '')
<    headerEnd += len(HEADER_SECTION_END)
<    headerText = httpResponse[:headerEnd]
<    bodyText = httpResponse[headerEnd:]
<    return (headerText, bodyText)
< 
< 
< ## SOAP-over-stdio stub adapter object
< class SoapCmdStubAdapter(SoapStubAdapterBase):
<    ## Constructor
<    #
<    # @param self self
<    # @param cmd command to execute
<    # @param ns API namespace
<    def __init__(self, cmd, version='vim.version.version1'):
<       SoapStubAdapterBase.__init__(self, version=version)
<       self.cmd = cmd
<       self.systemError = GetVmodlType('vmodl.fault.SystemError')
< 
<    ## Invoke a managed method
<    #
<    # @param self self
<    # @param mo the 'this'
<    # @param info method info
<    # @param args arguments
<    def InvokeMethod(self, mo, info, args):
<       argv = self.cmd.split()
<       req = self.SerializeRequest(mo, info, args)
<       env = dict(os.environ)
<       env['REQUEST_METHOD'] = 'POST'
<       env['CONTENT_LENGTH'] = str(len(req))
<       env['HTTP_SOAPACTION'] = self.versionId[1:-1]
<       p = subprocess.Popen(argv,
<                            stdin=subprocess.PIPE,
<                            stdout=subprocess.PIPE,
<                            stderr=subprocess.PIPE,
<                            env=env)
<       (outText, errText) = p.communicate(req)
<       if p.returncode < 0:
<          # Process died with a signal
<          errText = "Process terminated with signal {0}\n{1}".format(-p.returncode, errText)
<          raise self.systemError(msg=errText, reason=errText)
< 
<       try:
<          (responseHeaders, responseBody) = ParseHttpResponse(outText)
<          obj = SoapResponseDeserializer(self).Deserialize(responseBody, info.result)
<       except:
<          errText = "Failure parsing SOAP response ({0})\n{1}}".format(outText, errText)
<          raise self.systemError(msg=errText, reason=errText)
< 
<       if p.returncode == 0:
<          return obj
<       elif obj is None:
<          raise self.systemError(msg=errText, reason=errText)
<       else:
<          raise obj # pylint: disable-msg=E0702
< 
< 
< class SessionOrientedStub(StubAdapterBase):
<    '''A session-oriented stub adapter that will relogin to the destination if a
<    session-oriented exception is thrown.
< 
< 
<    Here's an example.  First, we setup the communication substrate:
< 
<    >>> soapStub = SoapStubAdapter(host="192.168.1.2", ns="vim25/5.0")
< 
<    Create a SessionOrientedStub that uses the stub we just created for talking
<    to the server:
< 
<    >>> from pyVim.connect import VimSessionOrientedStub
<    >>> sessionStub = VimSessionOrientedStub(
<    ...     soapStub,
<    ...     VimSessionOrientedStub.makeUserLoginMethod("root", "vmware"))
< 
<    Perform some privileged operations without needing to explicitly login:
< 
<    >>> si = Vim.ServiceInstance("ServiceInstance", sessionStub)
<    >>> si.content.sessionManager.sessionList
<    >>> si.content.sessionManager.Logout()
<    >>> si.content.sessionManager.sessionList
<    '''
< 
<    STATE_UNAUTHENTICATED = 0
<    STATE_AUTHENTICATED = 1
< 
<    SESSION_EXCEPTIONS = tuple()
< 
<    def __init__(self, soapStub, loginMethod, retryDelay=0.1, retryCount=4):
<       '''Construct a SessionOrientedStub.
< 
<       The stub starts off in the "unauthenticated" state, so it will call the
<       loginMethod on the first invocation of a method.  If a communication error
<       is encountered, the stub will wait for retryDelay seconds and then try to
<       call the method again.  If the server throws an exception that is in the
<       SESSION_EXCEPTIONS tuple, it will be caught and the stub will transition
<       back into the "unauthenticated" state so that another login will be
<       performed.
< 
<       @param soapStub The communication substrate.
<       @param loginMethod A function that takes a single parameter, soapStub, and
<         performs the necessary operations to authenticate with the server.
<       @param retryDelay The amount of time to sleep before retrying after a
<         communication error.
<       @param retryCount The number of times to retry connecting to the server.
<       '''
<       assert callable(loginMethod)
<       assert retryCount >= 0
<       StubAdapterBase.__init__(self, version=soapStub.version)
< 
<       self.lock = threading.Lock()
<       self.soapStub = soapStub
<       self.state = self.STATE_UNAUTHENTICATED
< 
<       self.loginMethod = loginMethod
<       self.retryDelay = retryDelay
<       self.retryCount = retryCount
< 
<    def InvokeMethod(self, mo, info, args):
<       # This retry logic is replicated in InvokeAccessor and the two copies need
<       # to be in sync
<       retriesLeft = self.retryCount
<       while retriesLeft > 0:
<          try:
<             if self.state == self.STATE_UNAUTHENTICATED:
<                self._CallLoginMethod()
<             # Invoke the method
<             status, obj = self.soapStub.InvokeMethod(mo, info, args, self)
<          except (socket.error, http_client.HTTPException, ExpatError):
<             if self.retryDelay and retriesLeft:
<                time.sleep(self.retryDelay)
<             retriesLeft -= 1
<             continue
< 
<          if status == 200:
<             # Normal return from the server, return the object to the caller.
<             return obj
< 
<          # An exceptional return from the server
<          if isinstance(obj, self.SESSION_EXCEPTIONS):
<             # Our session might've timed out, change our state and retry.
<             self._SetStateUnauthenticated()
<          else:
<             # It's an exception from the method that was called, send it up.
<             raise obj
< 
<       # Raise any socket/httplib errors caught above.
<       raise SystemError()
< 
<    ## Retrieve a managed property
<    #
<    # @param self self
<    # @param mo managed object
<    # @param info property info
<    def InvokeAccessor(self, mo, info):
<       # This retry logic is replicated in InvokeMethod and the two copies need
<       # to be in sync
<       retriesLeft = self.retryCount
<       while retriesLeft > 0:
<          try:
<             if self.state == self.STATE_UNAUTHENTICATED:
<                self._CallLoginMethod()
<             # Invoke the method
<             obj = StubAdapterBase.InvokeAccessor(self, mo, info)
<          except (socket.error, http_client.HTTPException, ExpatError):
<             if self.retryDelay and retriesLeft:
<                time.sleep(self.retryDelay)
<             retriesLeft -= 1
<             continue
<          except Exception as e:
<             if isinstance(e, self.SESSION_EXCEPTIONS):
<                # Our session might've timed out, change our state and retry.
<                self._SetStateUnauthenticated()
<                retriesLeft -= 1
<                continue
<             else:
<                raise e
<          return obj
<       # Raise any socket/httplib errors caught above.
<       raise SystemError()
< 
<    ## Handle the login method call
<    #
<    #  This method calls the login method on the soap stub and changes the state
<    #  to authenticated
<    def _CallLoginMethod(self):
<       try:
<          self.lock.acquire()
<          if self.state == self.STATE_UNAUTHENTICATED:
<             self.loginMethod(self.soapStub)
<             self.state = self.STATE_AUTHENTICATED
<       finally:
<          self.lock.release()
< 
<    ## Change the state to unauthenticated
<    def _SetStateUnauthenticated(self):
<       self.lock.acquire()
<       if self.state == self.STATE_AUTHENTICATED:
<          self.state = self.STATE_UNAUTHENTICATED
<       self.lock.release()
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2016 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> # http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> from __future__ import absolute_import
> 
> import six
> from six import reraise
> from six.moves import http_client
> from six.moves import StringIO
> from six.moves import zip
> from six import u
> from six import iteritems
> 
> import sys
> import os
> import platform
> import socket
> import subprocess
> import time
> from six.moves.urllib.parse import urlparse
> from datetime import datetime
> from xml.parsers.expat import ParserCreate
> # We have our own escape functionality.
> # from xml.sax.saxutils import escape
> 
> from pyVmomi.VmomiSupport import *
> from pyVmomi.StubAdapterAccessorImpl import StubAdapterAccessorMixin
> import pyVmomi.Iso8601
> import base64
> from xml.parsers.expat import ExpatError
> import copy
> import contextlib
> 
> try:
>    USERWORLD = os.uname()[0] == 'VMkernel'
> except:
>    USERWORLD = False
> 
> # Timeout value used for idle connections in client connection pool.
> # Default value is 900 seconds (15 minutes).
> CONNECTION_POOL_IDLE_TIMEOUT_SEC = 900
> 
> NS_SEP = " "
> 
> XML_ENCODING = 'UTF-8'
> XML_HEADER = '<?xml version="1.0" encoding="{0}"?>'.format(XML_ENCODING)
> 
> XMLNS_SOAPENC = "http://schemas.xmlsoap.org/soap/encoding/"
> XMLNS_SOAPENV = "http://schemas.xmlsoap.org/soap/envelope/"
> 
> XSI_TYPE = XMLNS_XSI + NS_SEP + u('type')
> 
> # Note: Must make a copy to use the SOAP_NSMAP
> # TODO: Change to frozendict, if available
> SOAP_NSMAP = { XMLNS_SOAPENC: 'soapenc', XMLNS_SOAPENV: 'soapenv',
>                XMLNS_XSI: 'xsi', XMLNS_XSD: 'xsd' }
> 
> SOAP_ENVELOPE_TAG = "{0}:Envelope".format(SOAP_NSMAP[XMLNS_SOAPENV])
> SOAP_HEADER_TAG = "{0}:Header".format(SOAP_NSMAP[XMLNS_SOAPENV])
> SOAP_FAULT_TAG = "{0}:Fault".format(SOAP_NSMAP[XMLNS_SOAPENV])
> SOAP_BODY_TAG = "{0}:Body".format(SOAP_NSMAP[XMLNS_SOAPENV])
> 
> SOAP_ENVELOPE_START = '<{0} '.format(SOAP_ENVELOPE_TAG) + \
>                       ' '.join(['xmlns:' + prefix + '="' + urn + '"' \
>                                 for urn, prefix in iteritems(SOAP_NSMAP)]) + \
>                       '>\n'
> SOAP_ENVELOPE_END = "\n</{0}>".format(SOAP_ENVELOPE_TAG)
> SOAP_HEADER_START = "<{0}>".format(SOAP_HEADER_TAG)
> SOAP_HEADER_END = "</{0}>".format(SOAP_HEADER_TAG)
> SOAP_BODY_START = "<{0}>".format(SOAP_BODY_TAG)
> SOAP_BODY_END = "</{0}>".format(SOAP_BODY_TAG)
> SOAP_START = SOAP_ENVELOPE_START + SOAP_BODY_START + '\n'
> SOAP_END = '\n' + SOAP_BODY_END + SOAP_ENVELOPE_END
> 
> WSSE_PREFIX = "wsse"
> WSSE_HEADER_TAG = "{0}:Security".format(WSSE_PREFIX)
> WSSE_NS_URL = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd"
> WSSE_NS = 'xmlns:{0}="{1}"'.format(WSSE_PREFIX, WSSE_NS_URL)
> WSSE_HEADER_START = "<{0} {1}>".format(WSSE_HEADER_TAG, WSSE_NS)
> WSSE_HEADER_END = "</{0}>".format(WSSE_HEADER_TAG)
> 
> ## MethodFault type
> MethodFault = GetVmodlType("vmodl.MethodFault")
> ## Localized MethodFault type
> LocalizedMethodFault = GetVmodlType("vmodl.LocalizedMethodFault")
> 
> # These info are included in the http user-agent header
> PYTHON_VERSION = platform.python_version()
> OS_NAME = platform.uname()[0]
> OS_VERSION = platform.uname()[2]
> OS_ARCH = platform.uname()[4]
> 
> SOAP_ADAPTER_ARGS = [
>    "server_side", "cert_reqs", "ssl_version", "ca_certs", "do_handshake_on_connect",
>    "suppress_ragged_eofs", "ciphers"]
> 
> 
> ## Thumbprint mismatch exception
> #
> class ThumbprintMismatchException(Exception):
>    def __init__(self, expected, actual):
>       Exception.__init__(self, "Server has wrong SHA1 thumbprint: %s "
>                                "(required) != %s (server)" % (
>                                  expected, actual))
> 
>       self.expected = expected
>       self.actual = actual
> 
> ## Escape <, >, &
> def XmlEscape(xmlStr):
>     escaped = xmlStr.replace("&", "&amp;").replace(">", "&gt;").replace("<", "&lt;")
>     return escaped
> 
> ## Get the start tag, end tag, and text handlers of a class
> def GetHandlers(obj):
>    return (obj.StartElementHandler,
>            obj.EndElementHandler,
>            obj.CharacterDataHandler,
>            obj.StartNamespaceDeclHandler,
>            obj.EndNamespaceDeclHandler)
> 
> ## Set the start tag, end tag, and text handlers of a parser
> def SetHandlers(obj, handlers):
>    (obj.StartElementHandler,
>     obj.EndElementHandler,
>     obj.CharacterDataHandler,
>     obj.StartNamespaceDeclHandler,
>     obj.EndNamespaceDeclHandler) = handlers
> 
> ## Serialize an object to bytes
> #
> # This function assumes CheckField(info, val) was already called
> # @param val the value to serialize
> # @param info the field
> # @param version the version
> # @param nsMap a dict of xml ns -> prefix
> # @return the serialized object as bytes
> # @param encoding Deprecated this is not used during serialization since we always
> #        use utf-8 to encode a request message. We didn't remove the
> #        parameter so it is still compatible with clients that are still using it.
> def Serialize(val, info=None, version=None, nsMap=None, encoding=None):
>    return _SerializeToUnicode(val, info=info, version=version, nsMap=nsMap).encode(XML_ENCODING)
> 
> ## Serialize an object to unicode
> #
> # This function assumes CheckField(info, val) was already called
> # @param val the value to serialize
> # @param info the field
> # @param version the version
> # @param nsMap a dict of xml ns -> prefix
> # @return the serialized object as unicode
> def SerializeToUnicode(val, info=None, version=None, nsMap=None):
>    return _SerializeToUnicode(val, info=info, version=version, nsMap=nsMap)
> 
> ## Serialize an object to unicode
> #
> # This function assumes CheckField(info, val) was already called
> # @param val the value to serialize
> # @param info the field
> # @param version the version
> # @param nsMap a dict of xml ns -> prefix
> # @return the serialized object as unicode
> def _SerializeToUnicode(val, info=None, version=None, nsMap=None):
>    if version is None:
>       try:
>          if isinstance(val, list):
>             itemType = val.Item
>             version = itemType._version
>          else:
>             if val is None:
>                # neither val nor version is given
>                return ''
>             # Pick up the version from val
>             version = val._version
>       except AttributeError:
>          version = BASE_VERSION
>    if info is None:
>       info = Object(name="object", type=object, version=version, flags=0)
> 
>    writer = StringIO()
>    SoapSerializer(writer, version, nsMap).Serialize(val, info)
>    return writer.getvalue()
> 
> ## Serialize fault detail
> #
> # Serializes a fault as the content of the detail element in a
> # soapenv:Fault (i.e. without a LocalizedMethodFault wrapper).
> #
> # This function assumes CheckField(info, val) was already called
> # @param val the value to serialize
> # @param info the field
> # @param version the version
> # @param nsMap a dict of xml ns -> prefix
> # @return the serialized object as a unicode string
> def SerializeFaultDetail(val, info=None, version=None, nsMap=None, encoding=None):
>    if version is None:
>       try:
>          if not isinstance(val, MethodFault):
>             raise TypeError('{0} is not a MethodFault'.format(str(val)))
>          version = val._version
>       except AttributeError:
>          version = BASE_VERSION
>    if info is None:
>       info = Object(name="object", type=object, version=version, flags=0)
> 
>    writer = StringIO()
>    SoapSerializer(writer, version, nsMap, encoding).SerializeFaultDetail(val, info)
>    return writer.getvalue()
> 
> ## SOAP serializer
> #
> class SoapSerializer:
>    """ SoapSerializer """
>    ## Serializer constructor
>    #
>    # @param writer File writer
>    # @param version the version
>    # @param nsMap a dict of xml ns -> prefix
>    # @param encoding Deprecated this is not used during serialization since we always
>    #        use utf-8 to encode a request message. We didn't remove the
>    #        parameter so it is still compatible with clients that are still using it.
>    def __init__(self, writer, version, nsMap, encoding=None):
>       """ Constructor """
>       self.writer = writer
>       self.version = version
>       self.nsMap = nsMap and nsMap or {}
>       for ns, prefix in iteritems(self.nsMap):
>          if prefix == '':
>             self.defaultNS = ns
>             break
>       else:
>          self.defaultNS = ''
> 
>       # Additional attr for outermost tag
>       self.outermostAttrs = ''
> 
>       # Fill in required xmlns, if not defined
>       for nsPrefix, ns, attrName in [('xsi', XMLNS_XSI, 'xsiPrefix'),
>                                      ('xsd', XMLNS_XSD, 'xsdPrefix')]:
>          prefix = self.nsMap.get(ns)
>          if not prefix:
>             prefix = nsPrefix
>             self.outermostAttrs += ' xmlns:{0}="{1}"'.format(prefix, ns)
>             self.nsMap = self.nsMap.copy()
>             self.nsMap[ns] = prefix
>          setattr(self, attrName, prefix + ":")
> 
> 
>    ## Serialize an object
>    #
>    # This function assumes CheckField(info, val) was already called
>    # @param val the value to serialize
>    # @param info the field
>    def Serialize(self, val, info):
>       """ Serialize an object """
>       self._Serialize(val, info, self.defaultNS)
> 
>    ## Serialize fault detail
>    #
>    # Serializes a fault as the content of the detail element in a
>    # soapenv:Fault (i.e. without a LocalizedMethodFault wrapper).
>    #
>    # This function assumes CheckField(info, val) was already called
>    # @param val the value to serialize
>    # @param info the field
>    def SerializeFaultDetail(self, val, info):
>       """ Serialize an object """
>       self._SerializeDataObject(val, info, ' xsi:typ="{1}"'.format(val._wsdlName), self.defaultNS)
> 
>    def _NSPrefix(self, ns):
>       """ Get xml ns prefix. self.nsMap must be set """
>       if ns == self.defaultNS:
>          return ''
>       prefix = self.nsMap[ns]
>       return prefix and prefix + ':' or ''
> 
>    def _QName(self, typ, defNS):
>       """ Get fully qualified wsdl name (prefix:name) """
>       attr = ''
>       ns, name = GetQualifiedWsdlName(typ)
>       if ns == defNS:
>          prefix = ''
>       else:
>          try:
>             prefix = self.nsMap[ns]
>          except KeyError:
>             # We have not seen this ns before
>             prefix = ns.split(':', 1)[-1]
>             attr = ' xmlns:{0}="{1}"'.format(prefix, ns)
>       return attr, prefix and prefix + ':' + name or name
> 
>    ## Serialize an object to unicode (internal)
>    #
>    # @param val the value to serialize
>    # @param info the field
>    # @param defNS the default namespace
>    def _Serialize(self, val, info, defNS):
>       """ Serialize an object """
>       if not IsChildVersion(self.version, info.version):
>          return
> 
>       if val is None:
>          if info.flags & F_OPTIONAL:
>             return
>          else:
>             raise TypeError('Field "{0}" is not optional'.format(info.name))
>       elif isinstance(val, list) and len(val) == 0:
>          if info.type is object:
>             # Make sure an empty array assigned to Any is typed
>             if not isinstance(val, Array):
>                raise TypeError('Field "{0}": Cannot assign empty native python array to an Any'.format(info.name))
>          elif info.flags & F_OPTIONAL:
>             # Skip optional non-Any
>             return
>          else:
>              raise TypeError('Field "{0}" not optional'.format(info.name))
> 
>       if self.outermostAttrs:
>          attr = self.outermostAttrs
>          self.outermostAttrs = None
>       else:
>          attr = ''
>       currDefNS = defNS
>       # Emit default ns if tag ns is not the same
>       currTagNS = GetWsdlNamespace(info.version)
>       if currTagNS != defNS:
>          attr += ' xmlns="{0}"'.format(currTagNS)
>          currDefNS = currTagNS
> 
>       if isinstance(val, DataObject):
>          if isinstance(val, MethodFault):
>             newVal = LocalizedMethodFault(fault=val, localizedMessage=val.msg)
>             if info.type is object:
>                faultType = object
>             else:
>                faultType = LocalizedMethodFault
>             newInfo = Object(name=info.name, type=faultType,
>                              version=info.version, flags=info.flags)
>             self._SerializeDataObject(newVal, newInfo, attr, currDefNS)
>          else:
>             self._SerializeDataObject(val, info, attr, currDefNS)
>       elif isinstance(val, ManagedObject):
>          if info.type is object:
>             nsattr, qName = self._QName(ManagedObject, currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          if val._serverGuid is not None:
>             attr += ' serverGuid="{0}"'.format(val._serverGuid)
>          # val in vim type attr is not namespace qualified
>          # TODO: Add a new "typens" attr?
>          ns, name = GetQualifiedWsdlName(Type(val))
>          attr += ' type="{0}"'.format(name)
>          self.writer.write('<{0}{1}>{2}</{3}>'.format(info.name, attr,
>                                               val._moId,
>                                               info.name))
>       elif isinstance(val, list):
>          if info.type is object:
>             itemType = val.Item
>             if (itemType is ManagedMethod or itemType is PropertyPath
>             or  itemType is type):
>                tag = 'string'
>                typ = GetVmodlType("string[]")
>             elif issubclass(itemType, ManagedObject):
>                tag = 'ManagedObjectReference'
>                typ = ManagedObject.Array
>             else:
>                tag = GetWsdlName(itemType)
>                typ = Type(val)
>             nsattr, qName = self._QName(typ, currDefNS)
> 
>             # For WSDL, since we set tag of ManagedObjects to ManagedObjectReferences,
>             # the name of its array should be ArrayOfManagedObjectReference
>             if qName.endswith("ArrayOfManagedObject"):
>                qName += "Reference"
> 
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>             self.writer.write('<{0}{1}>'.format(info.name, attr))
> 
>             itemInfo = Object(name=tag, type=itemType,
>                               version=info.version, flags=info.flags)
>             for it in val:
>                self._Serialize(it, itemInfo, currDefNS)
>             self.writer.write('</{0}>'.format(info.name))
>          else:
>             itemType = info.type.Item
>             itemInfo = Object(name=info.name, type=itemType,
>                               version=info.version, flags=info.flags)
>             for it in val:
>                self._Serialize(it, itemInfo, defNS)
>       elif isinstance(val, type) or isinstance(val, type(Exception)):
>          if info.type is object:
>             attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(
>                            info.name, attr, GetWsdlName(val)))
>       elif isinstance(val, ManagedMethod):
>          if info.type is object:
>             attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(
>                               info.name, attr, val.info.wsdlName))
>       elif isinstance(val, datetime):
>          if info.type is object:
>             nsattr, qName = self._QName(Type(val), currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          result = Iso8601.ISO8601Format(val)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
>       elif isinstance(val, binary):
>          if info.type is object:
>             nsattr, qName = self._QName(Type(val), currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          result = base64.b64encode(val)
>          if PY3:
>             # In python3 the bytes result after the base64 encoding has a
>             # leading 'b' which causes error when we use it to construct the
>             # soap message. Workaround the issue by converting the result to
>             # string. Since the result of base64 encoding contains only subset
>             # of ASCII chars, converting to string will not change the value.
>             result = str(result, XML_ENCODING)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
>       elif isinstance(val, bool):
>          if info.type is object:
>             nsattr, qName = self._QName(Type(val), currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          result = val and "true" or "false"
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
>       elif isinstance(val, six.integer_types) or isinstance(val, float):
>          if info.type is object:
>             nsattr, qName = self._QName(Type(val), currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          result = six.text_type(val)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
>       elif isinstance(val, Enum):
>          if info.type is object:
>             nsattr, qName = self._QName(Type(val), currDefNS)
>             attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>          self.writer.write('<{0}{1}>{2}</{0}>'.format(info.name, attr, val))
>       else:
>          if info.type is object:
>             if isinstance(val, PropertyPath):
>                attr += ' {0}type="{1}string"'.format(self.xsiPrefix, self.xsdPrefix)
>             else:
>                nsattr, qName = self._QName(Type(val), currDefNS)
>                attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
> 
>          if isinstance(val, six.binary_type):
>             # Use UTF-8 rather than self.encoding.  self.encoding is for
>             # output of serializer, while 'val' is our input.  And regardless
>             # of what our output is, our input should be always UTF-8.  Yes,
>             # it means that if you emit output in other encoding than UTF-8,
>             # you cannot serialize it again once more.  That's feature, not
>             # a bug.
>             val = val.decode(XML_ENCODING)
>          result = XmlEscape(val)
>          self.writer.write(u'<{0}{1}>{2}</{0}>'.format(info.name, attr, result))
> 
>    ## Serialize a a data object (internal)
>    #
>    # @param val the value to serialize
>    # @param info the field
>    # @param attr attributes to serialized in the outermost elementt
>    # @param currDefNS the current default namespace
>    def _SerializeDataObject(self, val, info, attr, currDefNS):
>       if info.flags & F_LINK:
>          # Attribute is a link and Object is present instead of its key.
>          # We need to serialize just the key and not the entire object
>          self._Serialize(val.key, info, currDefNS)
>          return
>       dynType = GetCompatibleType(Type(val), self.version)
>       if dynType != info.type:
>          nsattr, qName = self._QName(dynType, currDefNS)
>          attr += '{0} {1}type="{2}"'.format(nsattr, self.xsiPrefix, qName)
>       self.writer.write('<{0}{1}>'.format(info.name, attr))
>       if dynType is LocalizedMethodFault:
>          # Serialize a MethodFault as LocalizedMethodFault on wire
>          # See PR 670229
>          for prop in val._GetPropertyList():
>             propVal = getattr(val, prop.name)
>             if prop.name == 'fault':
>                propVal = copy.copy(propVal)
>                propVal.msg = None
>                self._SerializeDataObject(propVal, prop, '', currDefNS)
>             else:
>                self._Serialize(propVal, prop, currDefNS)
>       else:
>          for prop in val._GetPropertyList():
>             self._Serialize(getattr(val, prop.name), prop, currDefNS)
> 
>       self.writer.write('</{0}>'.format(info.name))
> 
> 
> class ParserError(KeyError):
>     # NOTE (hartsock): extends KeyError since parser logic is written to
>     # catch KeyError types. Normally, I would want PerserError to be a root
>     # type for all parser faults.
>     pass
> 
> def ParseData(parser, data):
>    # NOTE (hartsock): maintaining library internal consistency here, this is
>    # a refactoring that rolls up some repeated code blocks into a method so
>    # that we can refactor XML parsing behavior in a single place.
>    try:
>       if isinstance(data, six.binary_type) or isinstance(data, six.text_type):
>          parser.Parse(data)
>       else:
>          parser.ParseFile(data)
>    except Exception:
>       # wrap all parser faults with additional information for later
>       # bug reporting on the XML parser code itself.
>       (ec, ev, tb) = sys.exc_info()
>       line = parser.CurrentLineNumber
>       col = parser.CurrentColumnNumber
>       pe = ParserError("xml document: "
>                        "{0} parse error at: "
>                        "line:{1}, col:{2}".format(data, line, col))
>       # use six.reraise for python 2.x and 3.x compatability
>       reraise(ParserError, pe, tb)
> 
> ## Deserialize an object from a file or string
> #
> # This function will deserialize one top-level XML node.
> # @param data the data to deserialize (a file object or string)
> # @param resultType expected result type
> # @param stub stub for moRef deserialization
> # @return the deserialized object
> def Deserialize(data, resultType=object, stub=None):
>    parser = ParserCreate(namespace_separator=NS_SEP)
>    ds = SoapDeserializer(stub)
>    ds.Deserialize(parser, resultType)
>    ParseData(parser, data)
>    return ds.GetResult()
> 
> 
> ## Expat deserializer namespace handler
> class ExpatDeserializerNSHandlers:
>    def __init__(self, nsMap=None):
>       # nsMap is a dict of ns prefix to a stack (list) of namespaces
>       # The last element of the stack is current namespace
>       if not nsMap:
>          nsMap = {}
>       self.nsMap = nsMap
> 
>    ## Get current default ns
>    def GetCurrDefNS(self):
>       return self._GetNamespaceFromPrefix()
> 
>    ## Get namespace and wsdl name from tag
>    def GetNSAndWsdlname(self, tag):
>       """ Map prefix:name tag into ns, name """
>       idx = tag.find(":")
>       if idx >= 0:
>          prefix, name = tag[:idx], tag[idx + 1:]
>       else:
>          prefix, name = None, tag
>       # Map prefix to ns
>       ns = self._GetNamespaceFromPrefix(prefix)
>       return ns, name
> 
>    def _GetNamespaceFromPrefix(self, prefix = None):
>       namespaces = self.nsMap.get(prefix)
>       if namespaces:
>          ns = namespaces[-1]
>       else:
>          ns = ""
>       return ns
> 
>    ## Handle namespace begin
>    def StartNamespaceDeclHandler(self, prefix, uri):
>       namespaces = self.nsMap.get(prefix)
>       if namespaces:
>          namespaces.append(uri)
>       else:
>          self.nsMap[prefix] = [uri]
> 
>    ## Handle namespace end
>    def EndNamespaceDeclHandler(self, prefix):
>       self.nsMap[prefix].pop()
> 
> 
> ## SOAP -> Python Deserializer
> class SoapDeserializer(ExpatDeserializerNSHandlers):
>    ## Constructor
>    #
>    # @param self self
>    # @param stub Stub adapter to use for deserializing moRefs
>    def __init__(self, stub=None, version=None):
>       ExpatDeserializerNSHandlers.__init__(self)
>       self.stub = stub
>       if version:
>          self.version = version
>       elif self.stub:
>          self.version = self.stub.version
>       else:
>          self.version = None
>       self.result = None
> 
>    ## Deserialize a SOAP object
>    #
>    # @param self self
>    # @param parser an expat parser
>    # @param resultType the static type of the result
>    # @param isFault true if the response is a fault response
>    # @param nsMap a dict of prefix -> [xml ns stack]
>    # @return the deserialized object
>    def Deserialize(self, parser, resultType=object, isFault=False, nsMap=None):
>       self.isFault = isFault
>       self.parser = parser
>       self.origHandlers = GetHandlers(parser)
>       SetHandlers(parser, GetHandlers(self))
>       self.resultType = resultType
>       self.stack = []
>       self.data = ""
>       self.serverGuid = None
>       if issubclass(resultType, list):
>          self.result = resultType()
>       else:
>          self.result = None
>       if not nsMap:
>          nsMap = {}
>       self.nsMap = nsMap
> 
>    ## Get the result of deserialization
>    #  The links will not be resolved. User needs to explicitly resolve them
>    #  using LinkResolver.
>    def GetResult(self):
>       return self.result
> 
>    def SplitTag(self, tag):
>       """ Split tag into ns, name """
>       idx = tag.find(NS_SEP)
>       if idx >= 0:
>          return tag[:idx], tag[idx + 1:]
>       else:
>          return "", tag
> 
>    def LookupWsdlType(self, ns, name, allowManagedObjectReference=False):
>       """ Lookup wsdl type. Handle special case for some vmodl version """
>       try:
>          return GetWsdlType(ns, name)
>       except KeyError:
>          if allowManagedObjectReference:
>             if name.endswith('ManagedObjectReference') and ns == XMLNS_VMODL_BASE:
>                return GetWsdlType(ns, name[:-len('Reference')])
>          # WARNING!!! This is a temporary hack to get around server not
>          # honoring @service tag (see bug 521744). Once it is fix, I am
>          # going to back out this change
>          if name.endswith('ManagedObjectReference') and allowManagedObjectReference:
>             return GetWsdlType(XMLNS_VMODL_BASE, name[:-len('Reference')])
>          return GuessWsdlType(name)
> 
>    ## Handle an opening XML tag
>    def StartElementHandler(self, tag, attr):
>       self.data = ""
>       self.serverGuid = None
>       deserializeAsLocalizedMethodFault = True
>       if not self.stack:
>          if self.isFault:
>             ns, name = self.SplitTag(tag)
>             objType = self.LookupWsdlType(ns, name[:-5])
>             # Only top level soap fault should be deserialized as method fault
>             deserializeAsLocalizedMethodFault = False
>          else:
>             objType = self.resultType
>       elif isinstance(self.stack[-1], list):
>          objType = self.stack[-1].Item
>       elif isinstance(self.stack[-1], DataObject):
>          # TODO: Check ns matches DataObject's namespace
>          ns, name = self.SplitTag(tag)
>          objType = self.stack[-1]._GetPropertyInfo(name).type
> 
>          # LocalizedMethodFault <fault> tag should be deserialized as method fault
>          if name == "fault" and isinstance(self.stack[-1], LocalizedMethodFault):
>             deserializeAsLocalizedMethodFault = False
>       else:
>          raise TypeError("Invalid type for tag {0}".format(tag))
> 
>       xsiType = attr.get(XSI_TYPE)
>       if xsiType:
>          # Ignore dynamic type for TypeName, MethodName, PropertyPath
>          # @bug 150459
>          if not (objType is type or objType is ManagedMethod or \
>                                     objType is PropertyPath):
>             ns, name = self.GetNSAndWsdlname(xsiType)
>             dynType = self.LookupWsdlType(ns, name, allowManagedObjectReference=True)
>             # TODO: Should be something like...
>             #   dynType must be narrower than objType, except for
>             #   ManagedObjectReference
>             if not (issubclass(dynType, list) and issubclass(objType, list)):
>                objType = dynType
>       else:
>          if issubclass(objType, list):
>             objType = objType.Item
> 
>       if self.version:
>          objType = GetCompatibleType(objType, self.version)
>       if issubclass(objType, ManagedObject):
>          typeAttr = attr[u('type')]
>          # val in vim type attr is not namespace qualified
>          # However, this doesn't hurt to strip out namespace
>          # TODO: Get the ns from "typens" attr?
>          ns, name = self.GetNSAndWsdlname(typeAttr)
>          if u('serverGuid') in attr:
>             self.serverGuid = attr[u('serverGuid')]
>          self.stack.append(GuessWsdlType(name))
>       elif issubclass(objType, DataObject) or issubclass(objType, list):
>          if deserializeAsLocalizedMethodFault and issubclass(objType, Exception):
>             objType = LocalizedMethodFault
>          self.stack.append(objType())
>       else:
>          self.stack.append(objType)
> 
>    ## Handle a closing XML tag
>    def EndElementHandler(self, tag):
>       try:
>          obj = self.stack.pop()
>       except IndexError:
>          SetHandlers(self.parser, self.origHandlers)
>          handler = self.parser.EndElementHandler
>          del self.parser, self.origHandlers, self.stack, self.resultType
>          if handler:
>             return handler(tag)
>          return
> 
>       data = self.data
>       if isinstance(obj, type) or isinstance(obj, type(Exception)):
>          if obj is type:
>             if data is None or data == '':
>                obj = None
>             else:
>                try:
>                   # val in type val is not namespace qualified
>                   # However, this doesn't hurt to strip out namespace
>                   ns, name = self.GetNSAndWsdlname(data)
>                   obj = GuessWsdlType(name)
>                except KeyError:
>                   raise TypeError(data)
>          elif obj is ManagedMethod:
>             # val in Method val is not namespace qualified
>             # However, this doesn't hurt to strip out namespace
>             ns, name = self.GetNSAndWsdlname(data)
>             try:
>                obj = GuessWsdlMethod(name)
>             except KeyError:
>                obj = UncallableManagedMethod(name)
>          elif obj is bool:
>             if data == "0" or data.lower() == "false":
>                obj = bool(False)
>             elif data == "1" or data.lower() == "true":
>                obj = bool(True)
>             else:
>                raise TypeError(data)
>          elif obj is binary:
>             # Raise type error if decode failed
>             obj = obj(base64.b64decode(data))
>          elif obj is str:
>             try:
>                obj = str(data)
>             except ValueError:
>                obj = data
>          elif obj is datetime:
>             obj = pyVmomi.Iso8601.ParseISO8601(data)
>             if not obj:
>                raise TypeError(data)
>          # issubclass is very expensive. Test last
>          elif issubclass(obj, ManagedObject):
>             obj = obj(data, self.stub, self.serverGuid)
>          elif issubclass(obj, Enum):
>             obj = getattr(obj, data)
>          else:
>             obj = obj(data)
>       elif isinstance(obj, LocalizedMethodFault):
>          obj.fault.msg = obj.localizedMessage
>          obj = obj.fault
> 
>       if self.stack:
>          top = self.stack[-1]
>          if isinstance(top, list):
>             top.append(obj)
>          elif isinstance(top, DataObject):
>             ns, name = self.SplitTag(tag)
>             info = top._GetPropertyInfo(name)
> 
>             if not isinstance(obj, list) and issubclass(info.type, list):
>                getattr(top, info.name).append(obj)
>             else:
>                setattr(top, info.name, obj)
>          else:
>             ns, name = self.SplitTag(tag)
>             setattr(top, name, obj)
>       else:
>          if not isinstance(obj, list) and issubclass(self.resultType, list):
>             self.result.append(obj)
>          else:
>             self.result = obj
>             SetHandlers(self.parser, self.origHandlers)
>             del self.parser, self.origHandlers, self.stack, self.resultType
> 
>    ## Handle text data
>    def CharacterDataHandler(self, data):
>       self.data += data
> 
> 
> ## SOAP Response Deserializer class
> class SoapResponseDeserializer(ExpatDeserializerNSHandlers):
>    ## Constructor
>    #
>    # @param self self
>    # @param stub Stub adapter to use for deserializing moRefs
>    def __init__(self, stub):
>       ExpatDeserializerNSHandlers.__init__(self)
>       self.stub = stub
>       self.deser = SoapDeserializer(stub)
>       self.soapFaultTag = XMLNS_SOAPENV + NS_SEP + "Fault"
> 
>    ## Deserialize a SOAP response
>    #
>    # @param self self
>    # @param response the response (a file object or a string)
>    # @param resultType expected result type
>    # @param nsMap a dict of prefix -> [xml ns stack]
>    # @return the deserialized object
>    def Deserialize(self, response, resultType, nsMap=None):
>       self.resultType = resultType
>       self.stack = []
>       self.msg = ""
>       self.deser.result = None
>       self.isFault = False
>       self.parser = ParserCreate(namespace_separator=NS_SEP)
>       try: # buffer_text only in python >= 2.3
>          self.parser.buffer_text = True
>       except AttributeError:
>          pass
>       if not nsMap:
>          nsMap = {}
>       self.nsMap = nsMap
>       SetHandlers(self.parser, GetHandlers(self))
>       ParseData(self.parser, response)
>       result = self.deser.GetResult()
>       if self.isFault:
>          if result is None:
>             result = GetVmodlType("vmodl.RuntimeFault")()
>          result.msg = self.msg
>       del self.resultType, self.stack, self.parser, self.msg, self.data, self.nsMap
>       return result
> 
>    ## Handle an opening XML tag
>    def StartElementHandler(self, tag, attr):
>       self.data = ""
>       if tag == self.soapFaultTag:
>          self.isFault = True
>       elif self.isFault and tag == "detail":
>          self.deser.Deserialize(self.parser, object, True, self.nsMap)
>       elif tag.endswith("Response"):
>          self.deser.Deserialize(self.parser, self.resultType, False, self.nsMap)
> 
>    ## Handle text data
>    def CharacterDataHandler(self, data):
>       self.data += data
> 
>    ## Handle a closing XML tag
>    def EndElementHandler(self, tag):
>       if self.isFault and tag == "faultstring":
>          try:
>             self.msg = str(self.data)
>          except ValueError:
>             self.msg = self.data
> 
> ## Base class that implements common functionality for stub adapters.
> ## Method that must be provided by the implementation class:
> ## -- InvokeMethod(ManagedObject mo, Object methodInfo, Object[] args)
> class StubAdapterBase(StubAdapterAccessorMixin):
>    def __init__(self, version):
>       StubAdapterAccessorMixin.__init__(self)
>       self.ComputeVersionInfo(version)
> 
>    ## Compute the version information for the specified namespace
>    #
>    # @param ns the namespace
>    def ComputeVersionInfo(self, version):
>       # Make sure we do NOT fallback to an older version
>       if hasattr(self, 'version') and IsChildVersion(self.version, version):
>          # print("WARNING: stub degrading: " + self.version + " -> " + version)
>          return
> 
>       versionNS = GetVersionNamespace(version)
>       if versionNS.find("/") >= 0:
>          self.versionId = '"urn:{0}"'.format(versionNS)
>       else:
>          self.versionId = ''
>       self.version = version
> 
> ## Base class that implements common functionality for SOAP-based stub adapters.
> ## Method that must be provided by the implementation class:
> ## -- InvokeMethod(ManagedObject mo, Object methodInfo, Object[] args)
> class SoapStubAdapterBase(StubAdapterBase):
>    ## Serialize a VMOMI request to SOAP
>    #
>    # @param version API version
>    # @param mo the 'this'
>    # @param info method info
>    # @param args method arguments
>    # @return the serialized request
>    def SerializeRequest(self, mo, info, args):
>       if not IsChildVersion(self.version, info.version):
>          raise GetVmodlType("vmodl.fault.MethodNotFound")(receiver=mo,
>                                                           method=info.name)
>       nsMap = SOAP_NSMAP.copy()
>       defaultNS = GetWsdlNamespace(self.version)
>       nsMap[defaultNS] = ''
> 
>       # Add xml header and soap envelope
>       result = [XML_HEADER, '\n', SOAP_ENVELOPE_START]
> 
>       # Add request context and samlToken to soap header, if exists
>       reqContexts = GetRequestContext()
>       if self.requestContext:
>          reqContexts.update(self.requestContext)
>       samlToken = getattr(self, 'samlToken', None)
> 
>       if reqContexts or samlToken:
>          result.append(SOAP_HEADER_START)
>          for key, val in iteritems(reqContexts):
>             # Note: Support req context of string type only
>             if not isinstance(val, six.string_types):
>                raise TypeError("Request context key ({0}) has non-string value ({1}) of {2}".format(key, val, type(val)))
>             ret = _SerializeToUnicode(val,
>                             Object(name=key, type=str, version=self.version),
>                             self.version,
>                             nsMap)
>             result.append(ret)
>          if samlToken:
>             result.append('{0} {1} {2}'.format(WSSE_HEADER_START,
>                                                samlToken,
>                                                WSSE_HEADER_END))
>          result.append(SOAP_HEADER_END)
>          result.append('\n')
> 
>       # Serialize soap body
>       result.extend([SOAP_BODY_START,
>                        '<{0} xmlns="{1}">'.format(info.wsdlName, defaultNS),
>                        _SerializeToUnicode(mo, Object(name="_this", type=ManagedObject,
>                                             version=self.version),
>                                  self.version, nsMap)])
> 
>       # Serialize soap request parameters
>       for (param, arg) in zip(info.params, args):
>          result.append(_SerializeToUnicode(arg, param, self.version, nsMap))
>       result.extend(['</{0}>'.format(info.wsdlName), SOAP_BODY_END, SOAP_ENVELOPE_END])
>       return ''.join(result).encode(XML_ENCODING)
> 
> ## Subclass of HTTPConnection that connects over a Unix domain socket
> ## instead of a TCP port.  The path of the socket is passed in place of
> ## the hostname.  Fairly gross but does the job.
> class UnixSocketConnection(http_client.HTTPConnection):
>    # The HTTPConnection ctor expects a single argument, which it interprets
>    # as the host to connect to; for UnixSocketConnection, we instead interpret
>    # the parameter as the filesystem path of the Unix domain socket.
>    def __init__(self, path):
>       # Pass '' as the host to HTTPConnection; it doesn't really matter
>       # what we pass (since we've overridden the connect method) as long
>       # as it's a valid string.
>       http_client.HTTPConnection.__init__(self, '')
>       self.path = path
> 
>    def connect(self):
>       # Hijack the connect method of HTTPConnection to connect to the
>       # specified Unix domain socket instead.  Obey the same contract
>       # as HTTPConnection.connect, which puts the socket in self.sock.
>       sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
>       sock.connect(self.path)
>       self.sock = sock
> 
> try:
>    # The ssl module is not available in python versions less than 2.6
>    SSL_THUMBPRINTS_SUPPORTED = True
> 
>    import ssl
>    import hashlib
> 
>    def _VerifyThumbprint(thumbprint, connection):
>       '''If there is a thumbprint, connect to the server and verify that the
>       SSL certificate matches the given thumbprint.  An exception is thrown
>       if there is a mismatch.'''
>       if thumbprint and isinstance(connection, http_client.HTTPSConnection):
>          if not connection.sock:
>             connection.connect()
>          derCert = connection.sock.getpeercert(True)
>          sha1 = hashlib.sha1()
>          sha1.update(derCert)
>          sha1Digest = sha1.hexdigest().lower()
>          if sha1Digest != thumbprint:
>             raise ThumbprintMismatchException(thumbprint, sha1Digest)
> 
>    # Function used to wrap sockets with SSL
>    _SocketWrapper = ssl.wrap_socket
> 
> except ImportError:
>    SSL_THUMBPRINTS_SUPPORTED = False
> 
>    def _VerifyThumbprint(thumbprint, connection):
>       if thumbprint and isinstance(connection, http_client.HTTPSConnection):
>          raise Exception(
>             "Thumbprint verification not supported on python < 2.6")
> 
>    def _SocketWrapper(rawSocket, keyfile, certfile, *args, **kwargs):
>       wrappedSocket = socket.ssl(rawSocket, keyfile, certfile)
>       return http_client.FakeSocket(rawSocket, wrappedSocket)
> 
> 
> ## Internal version of https connection
> #
> # Support ssl.wrap_socket params which are missing from httplib
> # HTTPSConnection (e.g. ca_certs)
> # Note: Only works if the ssl params are passing in as kwargs
> class _HTTPSConnection(http_client.HTTPSConnection):
>    def __init__(self, *args, **kwargs):
>       # Extract ssl.wrap_socket param unknown to httplib.HTTPSConnection,
>       # and push back the params in connect()
>       self._sslArgs = {}
>       tmpKwargs = kwargs.copy()
>       for key in SOAP_ADAPTER_ARGS:
>          if key in tmpKwargs:
>             self._sslArgs[key] = tmpKwargs.pop(key)
>       http_client.HTTPSConnection.__init__(self, *args, **tmpKwargs)
> 
>    ## Override connect to allow us to pass in additional ssl paramters to
>    #  ssl.wrap_socket (e.g. cert_reqs, ca_certs for ca cert verification)
>    def connect(self):
>       if len(self._sslArgs) == 0:
>          # No override
>          http_client.HTTPSConnection.connect(self)
>          return
> 
>       # Big hack. We have to copy and paste the httplib connect fn for
>       # each python version in order to handle extra ssl paramters. Yuk!
>       if hasattr(self, "source_address"):
>          # Python 2.7
>          sock = socket.create_connection((self.host, self.port),
>                                          self.timeout, self.source_address)
>          if self._tunnel_host:
>             self.sock = sock
>             self._tunnel()
>          self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
>                                      **self._sslArgs)
>       elif hasattr(self, "timeout"):
>          # Python 2.6
>          sock = socket.create_connection((self.host, self.port), self.timeout)
>          self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
>                                      **self._sslArgs)
>       else:
>          # Unknown python version. Do nothing
>          http_client.HTTPSConnection.connect(self)
>          return
> 
>          # TODO: Additional verification of peer cert if needed
>          # cert_reqs = self._sslArgs.get("cert_reqs", ssl.CERT_NONE)
>          # ca_certs = self._sslArgs.get("ca_certs", None)
>          # if cert_reqs != ssl.CERT_NONE and ca_certs:
>          #   if hasattr(self.sock, "getpeercert"):
>          #      # TODO: verify peer cert
>          #      dercert = self.sock.getpeercert(False)
>          #      # pemcert = ssl.DER_cert_to_PEM_cert(dercert)
> 
> 
> ## Stand-in for the HTTPSConnection class that will connect to a SSL proxy,
> ## VCenter's /sdkTunnel endpoint. It will issue a CONNECT command to start
> ## an SSL tunnel.
> class SSLTunnelConnection(object):
>    # @param proxyPath The path to pass to the CONNECT command.
>    def __init__(self, proxyPath):
>       self.proxyPath = proxyPath
> 
>    # Connects to a proxy server and initiates a tunnel to the destination
>    # specified by proxyPath.  If successful, a new HTTPSConnection is returned.
>    #
>    # @param path The destination URL path.
>    # @param key_file The SSL key file to use when wrapping the socket.
>    # @param cert_file The SSL certificate file to use when wrapping the socket.
>    # @param kwargs In case caller passed in extra parameters not handled by
>    #        SSLTunnelConnection
>    def __call__(self, path, key_file=None, cert_file=None, **kwargs):
>       # Only pass in the named arguments that HTTPConnection constructor
>       # understands
>       tmpKwargs = {}
>       for key in http_client.HTTPConnection.__init__.__code__.co_varnames:
>          if key in kwargs and key != 'self':
>             tmpKwargs[key] = kwargs[key]
>       tunnel = http_client.HTTPConnection(path, **tmpKwargs)
>       tunnel.request('CONNECT', self.proxyPath)
>       resp = tunnel.getresponse()
>       if resp.status != 200:
>         raise http_client.HTTPException("{0} {1}".format(resp.status, resp.reason))
>       retval = http_client.HTTPSConnection(path)
>       retval.sock = _SocketWrapper(tunnel.sock,
>                                    keyfile=key_file, certfile=cert_file)
>       return retval
> 
> 
> ## Stand-in for the HTTPSConnection class that will connect to a regular HTTP
> ## proxy.
> class HTTPProxyConnection(object):
>    # @param proxyPath The path to pass to the CONNECT command.
>    def __init__(self, proxyPath):
>       self.proxyPath = proxyPath
> 
>    # Connects to a HTTP proxy server and initiates a tunnel to the destination
>    # specified by proxyPath.  If successful, a new HTTPSConnection is returned.
>    #
>    # @param path The destination URL path.
>    # @param args Arguments are ignored
>    # @param kwargs Arguments for HTTPSConnection
>    def __call__(self, path, *args, **kwargs):
>       httpsConnArgs = {k: kwargs[k] for k in kwargs if k not in SOAP_ADAPTER_ARGS}
>       conn = http_client.HTTPSConnection(path, **httpsConnArgs)
>       conn.set_tunnel(self.proxyPath)
>       return conn
> 
> class GzipReader:
>    GZIP        = 1
>    DEFLATE     = 2
> 
>    def __init__(self, rfile, encoding=GZIP, readChunkSize=512):
>       self.rfile = rfile
>       self.chunks = []
>       self.bufSize = 0 # Remaining buffer
>       assert(encoding in (GzipReader.GZIP, GzipReader.DEFLATE))
>       self.encoding = encoding
>       self.unzip = None
>       self.readChunkSize = readChunkSize
> 
>    def _CreateUnzip(self, firstChunk):
>       import zlib
>       if self.encoding == GzipReader.GZIP:
>          wbits = zlib.MAX_WBITS + 16
>       elif self.encoding == GzipReader.DEFLATE:
>          # Sniff out real deflate format
>          chunkLen = len(firstChunk)
>          # Assume raw deflate
>          wbits = -zlib.MAX_WBITS
>          if firstChunk[:3] == ['\x1f', '\x8b', '\x08']:
>             # gzip: Apache mod_deflate will send gzip. Yurk!
>             wbits = zlib.MAX_WBITS + 16
>          elif chunkLen >= 2:
>             b0 = ord(firstChunk[0])
>             b1 = ord(firstChunk[1])
>             if (b0 & 0xf) == 8 and (((b0 * 256 + b1)) % 31) == 0:
>                # zlib deflate
>                wbits = min(((b0 & 0xf0) >> 4) + 8, zlib.MAX_WBITS)
>       else:
>          assert(False)
>       self.unzip = zlib.decompressobj(wbits)
>       return self.unzip
> 
>    def read(self, bytes=-1):
>       chunks = self.chunks
>       bufSize = self.bufSize
> 
>       while bufSize < bytes or bytes == -1:
>          # Read and decompress
>          chunk = self.rfile.read(self.readChunkSize)
> 
>          if self.unzip == None:
>             self._CreateUnzip(chunk)
> 
>          if chunk:
>             inflatedChunk = self.unzip.decompress(chunk)
>             bufSize += len(inflatedChunk)
>             chunks.append(inflatedChunk)
>          else:
>             # Returns whatever we have
>             break
> 
>       if bufSize <= bytes or bytes == -1:
>          leftoverBytes = 0
>          leftoverChunks = []
>       else:
>          leftoverBytes = bufSize - bytes
>          # Adjust last chunk to hold only the left over bytes
>          lastChunk = chunks.pop()
>          chunks.append(lastChunk[:-leftoverBytes])
>          leftoverChunks = [lastChunk[-leftoverBytes:]]
> 
>       self.chunks = leftoverChunks
>       self.bufSize = leftoverBytes
> 
>       buf = b"".join(chunks)
>       return buf
> 
> ## SOAP stub adapter object
> class SoapStubAdapter(SoapStubAdapterBase):
>    ## Constructor
>    #
>    # The endpoint can be specified individually as either a host/port
>    # combination, or with a URL (using a url= keyword).
>    #
>    # @param self self
>    # @param host host
>    # @param port port (pass negative port number for no SSL)
>    # @param **** Deprecated. Please use version instead **** ns API namespace
>    # @param path location of SOAP VMOMI service
>    # @param url URL (overrides host, port, path if set)
>    # @param sock unix domain socket path (overrides host, port, url if set)
>    # @param poolSize size of HTTP connection pool
>    # @param certKeyFile The path to the PEM-encoded SSL private key file.
>    # @param certFile The path to the PEM-encoded SSL certificate file.
>    # @param httpProxyHost The host name of the proxy server.
>    # @param httpProxyPort The proxy server port.
>    # @param sslProxyPath Path to use when tunneling through VC's reverse proxy.
>    # @param thumbprint The SHA1 thumbprint of the server's SSL certificate.
>    #   Some use a thumbprint of the form xx:xx:xx..:xx.  We ignore the ":"
>    #   characters.  If set to None, any thumbprint is accepted.
>    # @param cacertsFile CA certificates file in PEM format
>    # @param version API version
>    # @param connectionPoolTimeout Timeout in secs for idle connections in client pool. Use -1 to disable any timeout.
>    # @param samlToken SAML Token that should be used in SOAP security header for login
>    # @param sslContext SSL Context describing the various SSL options. It is only
>    #                   supported in Python 2.7.9 or higher.
>    def __init__(self, host='localhost', port=443, ns=None, path='/sdk',
>                 url=None, sock=None, poolSize=5,
>                 certFile=None, certKeyFile=None,
>                 httpProxyHost=None, httpProxyPort=80, sslProxyPath=None,
>                 thumbprint=None, cacertsFile=None, version=None,
>                 acceptCompressedResponses=True,
>                 connectionPoolTimeout=CONNECTION_POOL_IDLE_TIMEOUT_SEC,
>                 samlToken=None, sslContext=None, requestContext=None):
>       if ns:
>          assert(version is None)
>          version = versionMap[ns]
>       elif not version:
>          version = 'vim.version.version1'
>       SoapStubAdapterBase.__init__(self, version=version)
>       self.cookie = ""
>       if sock:
>          self.scheme = UnixSocketConnection
>          # Store sock in the host member variable because that's where
>          # the UnixSocketConnection ctor expects to find it -- see above
>          self.host = sock
>       elif url:
>          scheme, self.host, urlpath = urlparse(url)[:3]
>          # Only use the URL path if it's sensible, otherwise use the path
>          # keyword argument as passed in.
>          if urlpath not in ('', '/'):
>             path = urlpath
>          self.scheme = scheme == "http" and http_client.HTTPConnection \
>                     or scheme == "https" and _HTTPSConnection
>       else:
>          port, self.scheme = port < 0 and (-port, http_client.HTTPConnection) \
>                                        or (port, _HTTPSConnection)
>          if host.find(':') != -1:  # is IPv6?
>             host = '[' + host + ']'
>          self.host = '{0}:{1}'.format(host, port)
> 
>       self.path = path
>       if thumbprint:
>          self.thumbprint = thumbprint.replace(":", "").lower()
>          if len(self.thumbprint) != 40:
>            raise Exception("Invalid SHA1 thumbprint -- {0}".format(thumbprint))
>       else:
>          self.thumbprint = None
> 
>       self.is_tunnel = False
>       if sslProxyPath:
>          self.scheme = SSLTunnelConnection(sslProxyPath)
>          self.is_tunnel = True
>       elif httpProxyHost:
>          self.scheme = HTTPProxyConnection(self.host)
>          self.is_tunnel = True
>          self.host = "{0}:{1}".format(httpProxyHost, httpProxyPort)
>       self.poolSize = poolSize
>       self.pool = []
>       self.connectionPoolTimeout = connectionPoolTimeout
>       self.lock = threading.Lock()
>       self.schemeArgs = {}
>       if certKeyFile:
>          self.schemeArgs['key_file'] = certKeyFile
>       if certFile:
>          self.schemeArgs['cert_file'] = certFile
>       if cacertsFile:
>          self.schemeArgs['ca_certs'] = cacertsFile
>          self.schemeArgs['cert_reqs'] = ssl.CERT_REQUIRED
>       if sslContext:
>          self.schemeArgs['context'] = sslContext
>       self.samlToken = samlToken
>       self.requestContext = requestContext
>       self.requestModifierList = []
>       self._acceptCompressedResponses = acceptCompressedResponses
> 
>    # Force a socket shutdown. Before python 2.7, ssl will fail to close
>    # the socket (http://bugs.python.org/issue10127).
>    # Not making this a part of the actual _HTTPSConnection since the internals
>    # of the httplib.HTTP*Connection seem to pass around the descriptors and
>    # depend on the behavior that close() still leaves the socket semi-functional.
>    if sys.version_info[:2] < (2,7):
>       def _CloseConnection(self, conn):
>          if self.scheme == _HTTPSConnection and conn.sock:
>            conn.sock.shutdown(socket.SHUT_RDWR)
>          conn.close()
>    else:
>       def _CloseConnection(self, conn):
>          conn.close()
> 
>    # Context modifier used to modify the SOAP request.
>    # @param func The func that takes in the serialized message and modifies the
>    #   the request. The func is appended to the requestModifierList and then
>    #   popped after the request is modified.
>    @contextlib.contextmanager
>    def requestModifier(self, func):
>       self.requestModifierList.append(func)
>       try:
>          yield
>       finally:
>          self.requestModifierList.pop()
>    ## Invoke a managed method
>    #
>    # @param self self
>    # @param mo the 'this'
>    # @param info method info
>    # @param args arguments
>    # @param outerStub If not-None, this should be a reference to the wrapping
>    #   stub adapter.  Any ManagedObject references returned from this method
>    #   will have outerStub in their _stub field.  Note that this also changes
>    #   the return type to a tuple containing the HTTP status and the
>    #   deserialized object so that it's easier to distinguish an API error from
>    #   a connection error.
>    def InvokeMethod(self, mo, info, args, outerStub=None):
>       if outerStub is None:
>          outerStub = self
> 
>       headers = {'Cookie' : self.cookie,
>                  'SOAPAction' : self.versionId,
>                  'Content-Type': 'text/xml; charset={0}'.format(XML_ENCODING),
>                  'User-Agent': 'pyvmomi Python/{0} ({1}; {2}; {3})'.
>                     format(PYTHON_VERSION, OS_NAME, OS_VERSION, OS_ARCH)}
>       if self._acceptCompressedResponses:
>          headers['Accept-Encoding'] = 'gzip, deflate'
> 
>       req = self.SerializeRequest(mo, info, args)
>       for modifier in self.requestModifierList:
>          req = modifier(req)
>       conn = self.GetConnection()
>       try:
>          conn.request('POST', self.path, req, headers)
>          resp = conn.getresponse()
>       except (socket.error, http_client.HTTPException):
>          # The server is probably sick, drop all of the cached connections.
>          self.DropConnections()
>          raise
>       # NOTE (hartsocks): this cookie handling code should go away in a future
>       # release. The string 'set-cookie' and 'Set-Cookie' but both are
>       # acceptable, but the supporting library may have a bug making it
>       # case sensitive when it shouldn't be. The term 'set-cookie' will occur
>       # more frequently than 'Set-Cookie' based on practical testing.
>       cookie = resp.getheader('set-cookie')
>       if cookie is None:
>           # try case-sensitive header for compatibility
>           cookie = resp.getheader('Set-Cookie')
>       status = resp.status
> 
>       if cookie:
>          self.cookie = cookie
>       if status == 200 or status == 500:
>          try:
>             fd = resp
>             encoding = resp.getheader('Content-Encoding', 'identity').lower()
>             if encoding == 'gzip':
>                fd = GzipReader(resp, encoding=GzipReader.GZIP)
>             elif encoding == 'deflate':
>                fd = GzipReader(resp, encoding=GzipReader.DEFLATE)
>             deserializer = SoapResponseDeserializer(outerStub)
>             obj = deserializer.Deserialize(fd, info.result)
>          except Exception as exc:
>             self._CloseConnection(conn)
>             # NOTE (hartsock): This feels out of place. As a rule the lexical
>             # context that opens a connection should also close it. However,
>             # in this code the connection is passed around and closed in other
>             # contexts (ie: methods) that we are blind to here. Refactor this.
> 
>             # The server might be sick, drop all of the cached connections.
>             self.DropConnections()
>             raise exc
>          else:
>             resp.read()
>             self.ReturnConnection(conn)
>          if outerStub != self:
>             return (status, obj)
>          if status == 200:
>             return obj
>          else:
>             raise obj # pylint: disable-msg=E0702
>       else:
>          self._CloseConnection(conn)
>          raise http_client.HTTPException("{0} {1}".format(resp.status, resp.reason))
> 
>    ## Clean up connection pool to throw away idle timed-out connections
>    #  SoapStubAdapter lock must be acquired before this method is called.
>    def _CloseIdleConnections(self):
>       if self.connectionPoolTimeout >= 0:
>          currentTime = time.time()
>          idleConnections = []
>          for conn, lastAccessTime in self.pool:
>             idleTime = currentTime - lastAccessTime
>             if idleTime >= self.connectionPoolTimeout:
>                i = self.pool.index((conn, lastAccessTime))
>                idleConnections = self.pool[i:]
>                self.pool = self.pool[:i]
>                break
> 
>          for conn, _ in idleConnections:
>             self._CloseConnection(conn)
> 
>    ## Get a HTTP connection from the pool
>    def GetConnection(self):
>       self.lock.acquire()
>       self._CloseIdleConnections()
>       if self.pool:
>          result, _ = self.pool.pop(0)
>          self.lock.release()
>       else:
>          self.lock.release()
>          result = self.scheme(self.host, **self.schemeArgs)
> 
>          # Always disable NAGLE algorithm
>          #
>          # Python httplib (2.6 and below) is splitting a http request into 2
>          # packets (header and body). It first send the header, but will not
>          # send the body until it receives the ack (for header) from server
>          # [NAGLE at work]. The delayed ack time on ESX is around 40 - 100 ms
>          # (depends on version) and can go up to 200 ms. This effectively slow
>          # down each pyVmomi call by the same amount of time.
>          #
>          # Disable NAGLE on client will force both header and body packets to
>          # get out immediately, and eliminated the delay
>          #
>          # This bug is fixed in python 2.7, however, only if the request
>          # body is a string (which is true for now)
>          if sys.version_info[:2] < (2,7):
>             self.DisableNagle(result)
> 
>          _VerifyThumbprint(self.thumbprint, result)
> 
>       return result
> 
>    ## Drop all cached connections to the server.
>    def DropConnections(self):
>       self.lock.acquire()
>       oldConnections = self.pool
>       self.pool = []
>       self.lock.release()
>       for conn, _ in oldConnections:
>          self._CloseConnection(conn)
> 
>    ## Return a HTTP connection to the pool
>    def ReturnConnection(self, conn):
>       self.lock.acquire()
>       self._CloseIdleConnections()
>       # In case of ssl tunneling, only add the conn if the conn has not been closed
>       if len(self.pool) < self.poolSize and (not self.is_tunnel or conn.sock):
>          self.pool.insert(0, (conn, time.time()))
>          self.lock.release()
>       else:
>          self.lock.release()
>          # NOTE (hartsock): this seems to violate good coding practice in that
>          # the lexical context that opens a connection should also be the
>          # same context responsible for closing it.
>          self._CloseConnection(conn)
> 
>    ## Disable nagle on a http connections
>    def DisableNagle(self, conn):
>       # Override connections' connect function to force disable NAGLE
>       if self.scheme != UnixSocketConnection and getattr(conn, "connect"):
>          orgConnect = conn.connect
>          def ConnectDisableNagle(*args, **kwargs):
>             orgConnect(*args, **kwargs)
>             sock = getattr(conn, "sock")
>             if sock:
>                try:
>                   sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
>                except Exception:
>                   pass
>          conn.connect = ConnectDisableNagle
> 
> ## Need to override the depcopy method. Since, the stub is not deep copyable
> #  due to the thread lock and connection pool, deep copy of a managed object
> #  fails. Further different instances of a managed object still share the
> #  same soap stub. Hence, returning self here is fine.
> def __deepcopy__(self, memo):
>    return self
> 
> HEADER_SECTION_END = '\r\n\r\n'
> 
> ## Parse an HTTP response into its headers and body
> def ParseHttpResponse(httpResponse):
>    headerEnd = httpResponse.find(HEADER_SECTION_END)
>    if headerEnd == -1:
>       return ('', '')
>    headerEnd += len(HEADER_SECTION_END)
>    headerText = httpResponse[:headerEnd]
>    bodyText = httpResponse[headerEnd:]
>    return (headerText, bodyText)
> 
> 
> ## SOAP-over-stdio stub adapter object
> class SoapCmdStubAdapter(SoapStubAdapterBase):
>    ## Constructor
>    #
>    # @param self self
>    # @param cmd command to execute
>    # @param ns API namespace
>    def __init__(self, cmd, version='vim.version.version1'):
>       SoapStubAdapterBase.__init__(self, version=version)
>       self.cmd = cmd
>       self.systemError = GetVmodlType('vmodl.fault.SystemError')
> 
>    ## Invoke a managed method
>    #
>    # @param self self
>    # @param mo the 'this'
>    # @param info method info
>    # @param args arguments
>    def InvokeMethod(self, mo, info, args):
>       argv = self.cmd.split()
>       req = self.SerializeRequest(mo, info, args)
>       env = dict(os.environ)
>       env['REQUEST_METHOD'] = 'POST'
>       env['CONTENT_LENGTH'] = str(len(req))
>       env['HTTP_SOAPACTION'] = self.versionId[1:-1]
>       p = subprocess.Popen(argv,
>                            stdin=subprocess.PIPE,
>                            stdout=subprocess.PIPE,
>                            stderr=subprocess.PIPE,
>                            env=env)
>       (outText, errText) = p.communicate(req)
>       if p.returncode < 0:
>          # Process died with a signal
>          errText = "Process terminated with signal {0}\n{1}".format(-p.returncode, errText)
>          raise self.systemError(msg=errText, reason=errText)
> 
>       try:
>          (responseHeaders, responseBody) = ParseHttpResponse(outText)
>          obj = SoapResponseDeserializer(self).Deserialize(responseBody, info.result)
>       except:
>          errText = "Failure parsing SOAP response ({0})\n{1}}".format(outText, errText)
>          raise self.systemError(msg=errText, reason=errText)
> 
>       if p.returncode == 0:
>          return obj
>       elif obj is None:
>          raise self.systemError(msg=errText, reason=errText)
>       else:
>          raise obj # pylint: disable-msg=E0702
> 
> 
> class SessionOrientedStub(StubAdapterBase):
>    '''A session-oriented stub adapter that will relogin to the destination if a
>    session-oriented exception is thrown.
> 
> 
>    Here's an example.  First, we setup the communication substrate:
> 
>    >>> soapStub = SoapStubAdapter(host="192.168.1.2", ns="vim25/5.0")
> 
>    Create a SessionOrientedStub that uses the stub we just created for talking
>    to the server:
> 
>    >>> from pyVim.connect import VimSessionOrientedStub
>    >>> sessionStub = VimSessionOrientedStub(
>    ...     soapStub,
>    ...     VimSessionOrientedStub.makeUserLoginMethod("root", "vmware"))
> 
>    Perform some privileged operations without needing to explicitly login:
> 
>    >>> si = Vim.ServiceInstance("ServiceInstance", sessionStub)
>    >>> si.content.sessionManager.sessionList
>    >>> si.content.sessionManager.Logout()
>    >>> si.content.sessionManager.sessionList
>    '''
> 
>    STATE_UNAUTHENTICATED = 0
>    STATE_AUTHENTICATED = 1
> 
>    SESSION_EXCEPTIONS = tuple()
> 
>    def __init__(self, soapStub, loginMethod, retryDelay=0.1, retryCount=4):
>       '''Construct a SessionOrientedStub.
> 
>       The stub starts off in the "unauthenticated" state, so it will call the
>       loginMethod on the first invocation of a method.  If a communication error
>       is encountered, the stub will wait for retryDelay seconds and then try to
>       call the method again.  If the server throws an exception that is in the
>       SESSION_EXCEPTIONS tuple, it will be caught and the stub will transition
>       back into the "unauthenticated" state so that another login will be
>       performed.
> 
>       @param soapStub The communication substrate.
>       @param loginMethod A function that takes a single parameter, soapStub, and
>         performs the necessary operations to authenticate with the server.
>       @param retryDelay The amount of time to sleep before retrying after a
>         communication error.
>       @param retryCount The number of times to retry connecting to the server.
>       '''
>       assert callable(loginMethod)
>       assert retryCount >= 0
>       StubAdapterBase.__init__(self, version=soapStub.version)
> 
>       self.lock = threading.Lock()
>       self.soapStub = soapStub
>       self.state = self.STATE_UNAUTHENTICATED
> 
>       self.loginMethod = loginMethod
>       self.retryDelay = retryDelay
>       self.retryCount = retryCount
> 
>    def InvokeMethod(self, mo, info, args):
>       # This retry logic is replicated in InvokeAccessor and the two copies need
>       # to be in sync
>       retriesLeft = self.retryCount
>       while retriesLeft > 0:
>          try:
>             if self.state == self.STATE_UNAUTHENTICATED:
>                self._CallLoginMethod()
>             # Invoke the method
>             status, obj = self.soapStub.InvokeMethod(mo, info, args, self)
>          except (socket.error, http_client.HTTPException, ExpatError):
>             if self.retryDelay and retriesLeft:
>                time.sleep(self.retryDelay)
>             retriesLeft -= 1
>             continue
> 
>          if status == 200:
>             # Normal return from the server, return the object to the caller.
>             return obj
> 
>          # An exceptional return from the server
>          if isinstance(obj, self.SESSION_EXCEPTIONS):
>             # Our session might've timed out, change our state and retry.
>             self._SetStateUnauthenticated()
>          else:
>             # It's an exception from the method that was called, send it up.
>             raise obj
> 
>       # Raise any socket/httplib errors caught above.
>       raise SystemError()
> 
>    ## Retrieve a managed property
>    #
>    # @param self self
>    # @param mo managed object
>    # @param info property info
>    def InvokeAccessor(self, mo, info):
>       # This retry logic is replicated in InvokeMethod and the two copies need
>       # to be in sync
>       retriesLeft = self.retryCount
>       while retriesLeft > 0:
>          try:
>             if self.state == self.STATE_UNAUTHENTICATED:
>                self._CallLoginMethod()
>             # Invoke the method
>             obj = StubAdapterBase.InvokeAccessor(self, mo, info)
>          except (socket.error, http_client.HTTPException, ExpatError):
>             if self.retryDelay and retriesLeft:
>                time.sleep(self.retryDelay)
>             retriesLeft -= 1
>             continue
>          except Exception as e:
>             if isinstance(e, self.SESSION_EXCEPTIONS):
>                # Our session might've timed out, change our state and retry.
>                self._SetStateUnauthenticated()
>                retriesLeft -= 1
>                continue
>             else:
>                raise e
>          return obj
>       # Raise any socket/httplib errors caught above.
>       raise SystemError()
> 
>    ## Handle the login method call
>    #
>    #  This method calls the login method on the soap stub and changes the state
>    #  to authenticated
>    def _CallLoginMethod(self):
>       try:
>          self.lock.acquire()
>          if self.state == self.STATE_UNAUTHENTICATED:
>             self.loginMethod(self.soapStub)
>             self.state = self.STATE_AUTHENTICATED
>       finally:
>          self.lock.release()
> 
>    ## Change the state to unauthenticated
>    def _SetStateUnauthenticated(self):
>       self.lock.acquire()
>       if self.state == self.STATE_AUTHENTICATED:
>          self.state = self.STATE_UNAUTHENTICATED
>       self.lock.release()
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/StubAdapterAccessorImpl.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/StubAdapterAccessorImpl.py
1,48c1,48
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< from __future__ import absolute_import
< from pyVmomi.VmomiSupport import GetVmodlType
< 
< class StubAdapterAccessorMixin:
<    def __init__(self):
<       self._pc = None
<       self._pcType = GetVmodlType("vmodl.query.PropertyCollector")
<       self._siType = GetVmodlType("vim.ServiceInstance")
< 
<    ## Retrieve a managed property
<    #
<    # @param self self
<    # @param mo managed object
<    # @param info property info
<    def InvokeAccessor(self, mo, info):
<       filterSpec = self._pcType.FilterSpec(
<          objectSet=[self._pcType.ObjectSpec(obj=mo, skip=False)],
<          propSet=[self._pcType.PropertySpec(all=False, type=mo.__class__,
<                                                  pathSet=[info.name])],
<          )
<       ## Cache the property collector if it isn't already
<       #  No need to lock _pc since multiple instances of PropertyCollector on
<       #  the client will talk to the same instance on the server.
<       if not self._pc:
<          si = self._siType("ServiceInstance", self)
<          self._pc = si.RetrieveContent().propertyCollector
<       result = self._pc.RetrievePropertiesEx(specSet=[filterSpec],
<                                              options=self._pcType.RetrieveOptions(maxObjects=1))
<       objectContent = result.objects[0]
<       if len(objectContent.propSet) > 0:
<          return objectContent.propSet[0].val
<       if len(objectContent.missingSet) > 0 and objectContent.missingSet[0].fault:
<          raise objectContent.missingSet[0].fault
<       return None
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2015 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> from __future__ import absolute_import
> from pyVmomi.VmomiSupport import GetVmodlType
> 
> class StubAdapterAccessorMixin:
>    def __init__(self):
>       self._pc = None
>       self._pcType = GetVmodlType("vmodl.query.PropertyCollector")
>       self._siType = GetVmodlType("vim.ServiceInstance")
> 
>    ## Retrieve a managed property
>    #
>    # @param self self
>    # @param mo managed object
>    # @param info property info
>    def InvokeAccessor(self, mo, info):
>       filterSpec = self._pcType.FilterSpec(
>          objectSet=[self._pcType.ObjectSpec(obj=mo, skip=False)],
>          propSet=[self._pcType.PropertySpec(all=False, type=mo.__class__,
>                                                  pathSet=[info.name])],
>          )
>       ## Cache the property collector if it isn't already
>       #  No need to lock _pc since multiple instances of PropertyCollector on
>       #  the client will talk to the same instance on the server.
>       if not self._pc:
>          si = self._siType("ServiceInstance", self)
>          self._pc = si.RetrieveContent().propertyCollector
>       result = self._pc.RetrievePropertiesEx(specSet=[filterSpec],
>                                              options=self._pcType.RetrieveOptions(maxObjects=1))
>       objectContent = result.objects[0]
>       if len(objectContent.propSet) > 0:
>          return objectContent.propSet[0].val
>       if len(objectContent.missingSet) > 0 and objectContent.missingSet[0].fault:
>          raise objectContent.missingSet[0].fault
>       return None
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_core.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_core.py
1,54c1,54
< # VMware vSphere Python SDK
< # Copyright (c) 2008-2020 VMware, Inc. All Rights Reserved.
< #
< # Licensed under the Apache License, Version 2.0 (the "License");
< # you may not use this file except in compliance with the License.
< # You may obtain a copy of the License at
< #
< #     http://www.apache.org/licenses/LICENSE-2.0
< #
< # Unless required by applicable law or agreed to in writing, software
< # distributed under the License is distributed on an "AS IS" BASIS,
< # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< # See the License for the specific language governing permissions and
< # limitations under the License.
< 
< # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
< from __future__ import absolute_import
< from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType, AddVersion, AddVersionParent, F_LINK, F_LINKABLE, F_OPTIONAL, F_SECRET
< from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions
< 
< AddVersion("vmodl.version.version0", "", "", 0, "vim25")
< AddVersion("vmodl.version.version1", "", "", 0, "vim25")
< AddVersion("vmodl.version.version2", "", "", 0, "vim25")
< AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
< 
< newestVersions.Add("vmodl.version.version2")
< publicVersions.Add("vmodl.version.version2")
< oldestVersions.Add("vmodl.version.version0")
< 
< CreateDataType("vmodl.DynamicArray", "DynamicArray", "vmodl.DataObject", "vmodl.version.version0", [("dynamicType", "string", "vmodl.version.version0", F_OPTIONAL), ("val", "anyType[]", "vmodl.version.version0", 0)])
< CreateDataType("vmodl.DynamicData", "DynamicData", "vmodl.DataObject", "vmodl.version.version0", [("dynamicType", "string", "vmodl.version.version0", F_OPTIONAL), ("dynamicProperty", "vmodl.DynamicProperty[]", "vmodl.version.version0", F_OPTIONAL)])
< CreateDataType("vmodl.DynamicProperty", "DynamicProperty", "vmodl.DataObject", "vmodl.version.version0", [("name", "vmodl.PropertyPath", "vmodl.version.version0", 0), ("val", "anyType", "vmodl.version.version0", 0)])
< CreateDataType("vmodl.KeyAnyValue", "KeyAnyValue", "vmodl.DynamicData", "vmodl.version.version1", [("key", "string", "vmodl.version.version1", 0), ("value", "anyType", "vmodl.version.version1", 0)])
< CreateDataType("vmodl.LocalizableMessage", "LocalizableMessage", "vmodl.DynamicData", "vmodl.version.version1", [("key", "string", "vmodl.version.version1", 0), ("arg", "vmodl.KeyAnyValue[]", "vmodl.version.version1", F_OPTIONAL), ("message", "string", "vmodl.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.fault.HostCommunication", "HostCommunication", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.HostNotConnected", "HostNotConnected", "vmodl.fault.HostCommunication", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.HostNotReachable", "HostNotReachable", "vmodl.fault.HostCommunication", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.InvalidArgument", "InvalidArgument", "vmodl.RuntimeFault", "vmodl.version.version0", [("invalidProperty", "vmodl.PropertyPath", "vmodl.version.version0", F_OPTIONAL)])
< CreateDataType("vmodl.fault.InvalidRequest", "InvalidRequest", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.InvalidType", "InvalidType", "vmodl.fault.InvalidRequest", "vmodl.version.version0", [("argument", "vmodl.PropertyPath", "vmodl.version.version0", F_OPTIONAL)])
< CreateDataType("vmodl.fault.ManagedObjectNotFound", "ManagedObjectNotFound", "vmodl.RuntimeFault", "vmodl.version.version0", [("obj", "vmodl.ManagedObject", "vmodl.version.version0", 0)])
< CreateDataType("vmodl.fault.MethodNotFound", "MethodNotFound", "vmodl.fault.InvalidRequest", "vmodl.version.version0", [("receiver", "vmodl.ManagedObject", "vmodl.version.version0", 0), ("method", "string", "vmodl.version.version0", 0)])
< CreateDataType("vmodl.fault.NotEnoughLicenses", "NotEnoughLicenses", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.NotImplemented", "NotImplemented", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.NotSupported", "NotSupported", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.RequestCanceled", "RequestCanceled", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.SecurityError", "SecurityError", "vmodl.RuntimeFault", "vmodl.version.version0", None)
< CreateDataType("vmodl.fault.SystemError", "SystemError", "vmodl.RuntimeFault", "vmodl.version.version0", [("reason", "string", "vmodl.version.version0", 0)])
< CreateDataType("vmodl.fault.UnexpectedFault", "UnexpectedFault", "vmodl.RuntimeFault", "vmodl.version.version0", [("faultName", "vmodl.TypeName", "vmodl.version.version0", 0), ("fault", "vmodl.MethodFault", "vmodl.version.version0", F_OPTIONAL)])
---
> # VMware vSphere Python SDK
> # Copyright (c) 2008-2020 VMware, Inc. All Rights Reserved.
> #
> # Licensed under the Apache License, Version 2.0 (the "License");
> # you may not use this file except in compliance with the License.
> # You may obtain a copy of the License at
> #
> #     http://www.apache.org/licenses/LICENSE-2.0
> #
> # Unless required by applicable law or agreed to in writing, software
> # distributed under the License is distributed on an "AS IS" BASIS,
> # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
> # See the License for the specific language governing permissions and
> # limitations under the License.
> 
> # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
> from __future__ import absolute_import
> from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType, AddVersion, AddVersionParent, F_LINK, F_LINKABLE, F_OPTIONAL, F_SECRET
> from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions
> 
> AddVersion("vmodl.version.version0", "", "", 0, "vim25")
> AddVersion("vmodl.version.version1", "", "", 0, "vim25")
> AddVersion("vmodl.version.version2", "", "", 0, "vim25")
> AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
> 
> newestVersions.Add("vmodl.version.version2")
> publicVersions.Add("vmodl.version.version2")
> oldestVersions.Add("vmodl.version.version0")
> 
> CreateDataType("vmodl.DynamicArray", "DynamicArray", "vmodl.DataObject", "vmodl.version.version0", [("dynamicType", "string", "vmodl.version.version0", F_OPTIONAL), ("val", "anyType[]", "vmodl.version.version0", 0)])
> CreateDataType("vmodl.DynamicData", "DynamicData", "vmodl.DataObject", "vmodl.version.version0", [("dynamicType", "string", "vmodl.version.version0", F_OPTIONAL), ("dynamicProperty", "vmodl.DynamicProperty[]", "vmodl.version.version0", F_OPTIONAL)])
> CreateDataType("vmodl.DynamicProperty", "DynamicProperty", "vmodl.DataObject", "vmodl.version.version0", [("name", "vmodl.PropertyPath", "vmodl.version.version0", 0), ("val", "anyType", "vmodl.version.version0", 0)])
> CreateDataType("vmodl.KeyAnyValue", "KeyAnyValue", "vmodl.DynamicData", "vmodl.version.version1", [("key", "string", "vmodl.version.version1", 0), ("value", "anyType", "vmodl.version.version1", 0)])
> CreateDataType("vmodl.LocalizableMessage", "LocalizableMessage", "vmodl.DynamicData", "vmodl.version.version1", [("key", "string", "vmodl.version.version1", 0), ("arg", "vmodl.KeyAnyValue[]", "vmodl.version.version1", F_OPTIONAL), ("message", "string", "vmodl.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.fault.HostCommunication", "HostCommunication", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.HostNotConnected", "HostNotConnected", "vmodl.fault.HostCommunication", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.HostNotReachable", "HostNotReachable", "vmodl.fault.HostCommunication", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.InvalidArgument", "InvalidArgument", "vmodl.RuntimeFault", "vmodl.version.version0", [("invalidProperty", "vmodl.PropertyPath", "vmodl.version.version0", F_OPTIONAL)])
> CreateDataType("vmodl.fault.InvalidRequest", "InvalidRequest", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.InvalidType", "InvalidType", "vmodl.fault.InvalidRequest", "vmodl.version.version0", [("argument", "vmodl.PropertyPath", "vmodl.version.version0", F_OPTIONAL)])
> CreateDataType("vmodl.fault.ManagedObjectNotFound", "ManagedObjectNotFound", "vmodl.RuntimeFault", "vmodl.version.version0", [("obj", "vmodl.ManagedObject", "vmodl.version.version0", 0)])
> CreateDataType("vmodl.fault.MethodNotFound", "MethodNotFound", "vmodl.fault.InvalidRequest", "vmodl.version.version0", [("receiver", "vmodl.ManagedObject", "vmodl.version.version0", 0), ("method", "string", "vmodl.version.version0", 0)])
> CreateDataType("vmodl.fault.NotEnoughLicenses", "NotEnoughLicenses", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.NotImplemented", "NotImplemented", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.NotSupported", "NotSupported", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.RequestCanceled", "RequestCanceled", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.SecurityError", "SecurityError", "vmodl.RuntimeFault", "vmodl.version.version0", None)
> CreateDataType("vmodl.fault.SystemError", "SystemError", "vmodl.RuntimeFault", "vmodl.version.version0", [("reason", "string", "vmodl.version.version0", 0)])
> CreateDataType("vmodl.fault.UnexpectedFault", "UnexpectedFault", "vmodl.RuntimeFault", "vmodl.version.version0", [("faultName", "vmodl.TypeName", "vmodl.version.version0", 0), ("fault", "vmodl.MethodFault", "vmodl.version.version0", F_OPTIONAL)])
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_eam.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_eam.py
1,814c1,814
< # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
< from .VmomiSupport import CreateDataType, CreateManagedType
< from .VmomiSupport import CreateEnumType
< from .VmomiSupport import AddVersion, AddVersionParent
< from .VmomiSupport import AddBreakingChangesInfo
< from .VmomiSupport import F_LINK, F_LINKABLE
< from .VmomiSupport import F_OPTIONAL, F_SECRET
< from .VmomiSupport import newestVersions
< from .VmomiSupport import publicVersions, dottedVersions
< from .VmomiSupport import oldestVersions
< 
< AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
< AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
< AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
< AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
< AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
< AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
< AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
< AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
< AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
< AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
< AddVersion("vmodl.version.version0", "", "", 0, "vim25")
< AddVersion("vmodl.version.version1", "", "", 0, "vim25")
< AddVersion("vmodl.version.version2", "", "", 0, "vim25")
< AddVersion("eam.version.version2_5", "eam", "2_5", 0, "eam")
< AddVersion("eam.version.version6_5", "eam", "6.5", 0, "eam")
< AddVersion("eam.version.version6_8", "eam", "6.8", 0, "eam")
< AddVersion("eam.version.version6_9", "eam", "6.9", 0, "eam")
< AddVersion("eam.version.version6_7", "eam", "6.7", 0, "eam")
< AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
< AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
< AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
< AddVersion("eam.version.version7_3", "eam", "7.3", 0, "eam")
< AddVersion("eam.version.version1", "eam", "1.0", 0, "eam")
< AddVersion("eam.version.version2", "eam", "2.0", 0, "eam")
< AddVersion("eam.version.version7_4", "eam", "7.4", 0, "eam")
< AddVersion("eam.version.version7_1", "eam", "7.1", 0, "eam")
< AddVersion("eam.version.version3", "eam", "3.0", 0, "eam")
< AddVersion("eam.version.version7_2", "eam", "7.2", 0, "eam")
< AddVersion("eam.version.version7_5", "eam", "7.5", 0, "eam")
< AddVersion("eam.version.version7_6", "eam", "7.6", 0, "eam")
< AddVersion("eam.version.version6", "eam", "6.0", 0, "eam")
< AddVersion("eam.version.version7", "eam", "7.0", 0, "eam")
< AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
< AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
< AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version8")
< AddVersionParent("vim.version.version8", "vim.version.version6")
< AddVersionParent("vim.version.version8", "vim.version.version7")
< AddVersionParent("vim.version.version8", "vim.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version4")
< AddVersionParent("vim.version.version8", "vim.version.version5")
< AddVersionParent("vim.version.version8", "vim.version.version2")
< AddVersionParent("vim.version.version8", "vim.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.version.version0")
< AddVersionParent("vim.version.version8", "vmodl.version.version1")
< AddVersionParent("vim.version.version8", "vmodl.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version8")
< AddVersionParent("vim.version.version9", "vim.version.version9")
< AddVersionParent("vim.version.version9", "vim.version.version6")
< AddVersionParent("vim.version.version9", "vim.version.version7")
< AddVersionParent("vim.version.version9", "vim.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version4")
< AddVersionParent("vim.version.version9", "vim.version.version5")
< AddVersionParent("vim.version.version9", "vim.version.version2")
< AddVersionParent("vim.version.version9", "vim.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.version.version0")
< AddVersionParent("vim.version.version9", "vmodl.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version6")
< AddVersionParent("vim.version.version6", "vim.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version4")
< AddVersionParent("vim.version.version6", "vim.version.version5")
< AddVersionParent("vim.version.version6", "vim.version.version2")
< AddVersionParent("vim.version.version6", "vim.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.version.version0")
< AddVersionParent("vim.version.version6", "vmodl.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version6")
< AddVersionParent("vim.version.version7", "vim.version.version7")
< AddVersionParent("vim.version.version7", "vim.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version4")
< AddVersionParent("vim.version.version7", "vim.version.version5")
< AddVersionParent("vim.version.version7", "vim.version.version2")
< AddVersionParent("vim.version.version7", "vim.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.version.version0")
< AddVersionParent("vim.version.version7", "vmodl.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version1", "vim.version.version1")
< AddVersionParent("vim.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version4", "vim.version.version1")
< AddVersionParent("vim.version.version4", "vim.version.version4")
< AddVersionParent("vim.version.version4", "vim.version.version2")
< AddVersionParent("vim.version.version4", "vim.version.version3")
< AddVersionParent("vim.version.version4", "vmodl.version.version0")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version4")
< AddVersionParent("vim.version.version5", "vim.version.version5")
< AddVersionParent("vim.version.version5", "vim.version.version2")
< AddVersionParent("vim.version.version5", "vim.version.version3")
< AddVersionParent("vim.version.version5", "vmodl.version.version0")
< AddVersionParent("vim.version.version5", "vmodl.version.version1")
< AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version2", "vim.version.version1")
< AddVersionParent("vim.version.version2", "vim.version.version2")
< AddVersionParent("vim.version.version2", "vmodl.version.version0")
< AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version3", "vim.version.version1")
< AddVersionParent("vim.version.version3", "vim.version.version2")
< AddVersionParent("vim.version.version3", "vim.version.version3")
< AddVersionParent("vim.version.version3", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
< AddVersionParent("eam.version.version2_5", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version2_5", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version2_5", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version2_5", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version2_5", "vim.version.version8")
< AddVersionParent("eam.version.version2_5", "vim.version.version6")
< AddVersionParent("eam.version.version2_5", "vim.version.version7")
< AddVersionParent("eam.version.version2_5", "vim.version.version1")
< AddVersionParent("eam.version.version2_5", "vim.version.version4")
< AddVersionParent("eam.version.version2_5", "vim.version.version5")
< AddVersionParent("eam.version.version2_5", "vim.version.version2")
< AddVersionParent("eam.version.version2_5", "vim.version.version3")
< AddVersionParent("eam.version.version2_5", "vmodl.version.version0")
< AddVersionParent("eam.version.version2_5", "vmodl.version.version1")
< AddVersionParent("eam.version.version2_5", "vmodl.version.version2")
< AddVersionParent("eam.version.version2_5", "eam.version.version2_5")
< AddVersionParent("eam.version.version2_5", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version2_5", "eam.version.version1")
< AddVersionParent("eam.version.version2_5", "eam.version.version2")
< AddVersionParent("eam.version.version6_5", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version6_5", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version6_5", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version6_5", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version6_5", "vim.version.version8")
< AddVersionParent("eam.version.version6_5", "vim.version.version6")
< AddVersionParent("eam.version.version6_5", "vim.version.version7")
< AddVersionParent("eam.version.version6_5", "vim.version.version1")
< AddVersionParent("eam.version.version6_5", "vim.version.version4")
< AddVersionParent("eam.version.version6_5", "vim.version.version5")
< AddVersionParent("eam.version.version6_5", "vim.version.version2")
< AddVersionParent("eam.version.version6_5", "vim.version.version3")
< AddVersionParent("eam.version.version6_5", "vmodl.version.version0")
< AddVersionParent("eam.version.version6_5", "vmodl.version.version1")
< AddVersionParent("eam.version.version6_5", "vmodl.version.version2")
< AddVersionParent("eam.version.version6_5", "eam.version.version2_5")
< AddVersionParent("eam.version.version6_5", "eam.version.version6_5")
< AddVersionParent("eam.version.version6_5", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version6_5", "eam.version.version1")
< AddVersionParent("eam.version.version6_5", "eam.version.version2")
< AddVersionParent("eam.version.version6_5", "eam.version.version3")
< AddVersionParent("eam.version.version6_5", "eam.version.version6")
< AddVersionParent("eam.version.version6_8", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version6_8", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version6_8", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version6_8", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version6_8", "vim.version.version8")
< AddVersionParent("eam.version.version6_8", "vim.version.version6")
< AddVersionParent("eam.version.version6_8", "vim.version.version7")
< AddVersionParent("eam.version.version6_8", "vim.version.version1")
< AddVersionParent("eam.version.version6_8", "vim.version.version4")
< AddVersionParent("eam.version.version6_8", "vim.version.version5")
< AddVersionParent("eam.version.version6_8", "vim.version.version2")
< AddVersionParent("eam.version.version6_8", "vim.version.version3")
< AddVersionParent("eam.version.version6_8", "vmodl.version.version0")
< AddVersionParent("eam.version.version6_8", "vmodl.version.version1")
< AddVersionParent("eam.version.version6_8", "vmodl.version.version2")
< AddVersionParent("eam.version.version6_8", "eam.version.version2_5")
< AddVersionParent("eam.version.version6_8", "eam.version.version6_5")
< AddVersionParent("eam.version.version6_8", "eam.version.version6_8")
< AddVersionParent("eam.version.version6_8", "eam.version.version6_7")
< AddVersionParent("eam.version.version6_8", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version6_8", "eam.version.version1")
< AddVersionParent("eam.version.version6_8", "eam.version.version2")
< AddVersionParent("eam.version.version6_8", "eam.version.version3")
< AddVersionParent("eam.version.version6_8", "eam.version.version6")
< AddVersionParent("eam.version.version6_9", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version6_9", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version6_9", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version6_9", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version6_9", "vim.version.version8")
< AddVersionParent("eam.version.version6_9", "vim.version.version6")
< AddVersionParent("eam.version.version6_9", "vim.version.version7")
< AddVersionParent("eam.version.version6_9", "vim.version.version1")
< AddVersionParent("eam.version.version6_9", "vim.version.version4")
< AddVersionParent("eam.version.version6_9", "vim.version.version5")
< AddVersionParent("eam.version.version6_9", "vim.version.version2")
< AddVersionParent("eam.version.version6_9", "vim.version.version3")
< AddVersionParent("eam.version.version6_9", "vmodl.version.version0")
< AddVersionParent("eam.version.version6_9", "vmodl.version.version1")
< AddVersionParent("eam.version.version6_9", "vmodl.version.version2")
< AddVersionParent("eam.version.version6_9", "eam.version.version2_5")
< AddVersionParent("eam.version.version6_9", "eam.version.version6_5")
< AddVersionParent("eam.version.version6_9", "eam.version.version6_8")
< AddVersionParent("eam.version.version6_9", "eam.version.version6_9")
< AddVersionParent("eam.version.version6_9", "eam.version.version6_7")
< AddVersionParent("eam.version.version6_9", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version6_9", "eam.version.version1")
< AddVersionParent("eam.version.version6_9", "eam.version.version2")
< AddVersionParent("eam.version.version6_9", "eam.version.version3")
< AddVersionParent("eam.version.version6_9", "eam.version.version6")
< AddVersionParent("eam.version.version6_7", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version6_7", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version6_7", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version6_7", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version6_7", "vim.version.version8")
< AddVersionParent("eam.version.version6_7", "vim.version.version6")
< AddVersionParent("eam.version.version6_7", "vim.version.version7")
< AddVersionParent("eam.version.version6_7", "vim.version.version1")
< AddVersionParent("eam.version.version6_7", "vim.version.version4")
< AddVersionParent("eam.version.version6_7", "vim.version.version5")
< AddVersionParent("eam.version.version6_7", "vim.version.version2")
< AddVersionParent("eam.version.version6_7", "vim.version.version3")
< AddVersionParent("eam.version.version6_7", "vmodl.version.version0")
< AddVersionParent("eam.version.version6_7", "vmodl.version.version1")
< AddVersionParent("eam.version.version6_7", "vmodl.version.version2")
< AddVersionParent("eam.version.version6_7", "eam.version.version2_5")
< AddVersionParent("eam.version.version6_7", "eam.version.version6_5")
< AddVersionParent("eam.version.version6_7", "eam.version.version6_7")
< AddVersionParent("eam.version.version6_7", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version6_7", "eam.version.version1")
< AddVersionParent("eam.version.version6_7", "eam.version.version2")
< AddVersionParent("eam.version.version6_7", "eam.version.version3")
< AddVersionParent("eam.version.version6_7", "eam.version.version6")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version13", "vim.version.version8")
< AddVersionParent("vim.version.version13", "vim.version.version9")
< AddVersionParent("vim.version.version13", "vim.version.version6")
< AddVersionParent("vim.version.version13", "vim.version.version7")
< AddVersionParent("vim.version.version13", "vim.version.version1")
< AddVersionParent("vim.version.version13", "vim.version.version4")
< AddVersionParent("vim.version.version13", "vim.version.version5")
< AddVersionParent("vim.version.version13", "vim.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.version.version0")
< AddVersionParent("vim.version.version13", "vmodl.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version13")
< AddVersionParent("vim.version.version13", "vim.version.version10")
< AddVersionParent("vim.version.version13", "vim.version.version11")
< AddVersionParent("vim.version.version13", "vim.version.version12")
< AddVersionParent("eam.version.version7_3", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_3", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_3", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_3", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_3", "vim.version.version8")
< AddVersionParent("eam.version.version7_3", "vim.version.version9")
< AddVersionParent("eam.version.version7_3", "vim.version.version6")
< AddVersionParent("eam.version.version7_3", "vim.version.version7")
< AddVersionParent("eam.version.version7_3", "vim.version.version1")
< AddVersionParent("eam.version.version7_3", "vim.version.version4")
< AddVersionParent("eam.version.version7_3", "vim.version.version5")
< AddVersionParent("eam.version.version7_3", "vim.version.version2")
< AddVersionParent("eam.version.version7_3", "vim.version.version3")
< AddVersionParent("eam.version.version7_3", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_3", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_3", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_3", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_3", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_3", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_3", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_3", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_3", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_3", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_3", "vim.version.version13")
< AddVersionParent("eam.version.version7_3", "eam.version.version7_3")
< AddVersionParent("eam.version.version7_3", "eam.version.version1")
< AddVersionParent("eam.version.version7_3", "eam.version.version2")
< AddVersionParent("eam.version.version7_3", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_3", "eam.version.version3")
< AddVersionParent("eam.version.version7_3", "eam.version.version7_2")
< AddVersionParent("eam.version.version7_3", "eam.version.version6")
< AddVersionParent("eam.version.version7_3", "eam.version.version7")
< AddVersionParent("eam.version.version7_3", "vim.version.version10")
< AddVersionParent("eam.version.version7_3", "vim.version.version11")
< AddVersionParent("eam.version.version7_3", "vim.version.version12")
< AddVersionParent("eam.version.version1", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version1", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version1", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version1", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version1", "vim.version.version8")
< AddVersionParent("eam.version.version1", "vim.version.version6")
< AddVersionParent("eam.version.version1", "vim.version.version7")
< AddVersionParent("eam.version.version1", "vim.version.version1")
< AddVersionParent("eam.version.version1", "vim.version.version4")
< AddVersionParent("eam.version.version1", "vim.version.version5")
< AddVersionParent("eam.version.version1", "vim.version.version2")
< AddVersionParent("eam.version.version1", "vim.version.version3")
< AddVersionParent("eam.version.version1", "vmodl.version.version0")
< AddVersionParent("eam.version.version1", "vmodl.version.version1")
< AddVersionParent("eam.version.version1", "vmodl.version.version2")
< AddVersionParent("eam.version.version1", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version1", "eam.version.version1")
< AddVersionParent("eam.version.version2", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version2", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version2", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version2", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version2", "vim.version.version8")
< AddVersionParent("eam.version.version2", "vim.version.version6")
< AddVersionParent("eam.version.version2", "vim.version.version7")
< AddVersionParent("eam.version.version2", "vim.version.version1")
< AddVersionParent("eam.version.version2", "vim.version.version4")
< AddVersionParent("eam.version.version2", "vim.version.version5")
< AddVersionParent("eam.version.version2", "vim.version.version2")
< AddVersionParent("eam.version.version2", "vim.version.version3")
< AddVersionParent("eam.version.version2", "vmodl.version.version0")
< AddVersionParent("eam.version.version2", "vmodl.version.version1")
< AddVersionParent("eam.version.version2", "vmodl.version.version2")
< AddVersionParent("eam.version.version2", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version2", "eam.version.version1")
< AddVersionParent("eam.version.version2", "eam.version.version2")
< AddVersionParent("eam.version.version7_4", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_4", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_4", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_4", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_4", "vim.version.version8")
< AddVersionParent("eam.version.version7_4", "vim.version.version9")
< AddVersionParent("eam.version.version7_4", "vim.version.version6")
< AddVersionParent("eam.version.version7_4", "vim.version.version7")
< AddVersionParent("eam.version.version7_4", "vim.version.version1")
< AddVersionParent("eam.version.version7_4", "vim.version.version4")
< AddVersionParent("eam.version.version7_4", "vim.version.version5")
< AddVersionParent("eam.version.version7_4", "vim.version.version2")
< AddVersionParent("eam.version.version7_4", "vim.version.version3")
< AddVersionParent("eam.version.version7_4", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_4", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_4", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_4", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_4", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_4", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_4", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_4", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_4", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_4", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_4", "vim.version.version13")
< AddVersionParent("eam.version.version7_4", "eam.version.version7_3")
< AddVersionParent("eam.version.version7_4", "eam.version.version1")
< AddVersionParent("eam.version.version7_4", "eam.version.version2")
< AddVersionParent("eam.version.version7_4", "eam.version.version7_4")
< AddVersionParent("eam.version.version7_4", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_4", "eam.version.version3")
< AddVersionParent("eam.version.version7_4", "eam.version.version7_2")
< AddVersionParent("eam.version.version7_4", "eam.version.version6")
< AddVersionParent("eam.version.version7_4", "eam.version.version7")
< AddVersionParent("eam.version.version7_4", "vim.version.version10")
< AddVersionParent("eam.version.version7_4", "vim.version.version11")
< AddVersionParent("eam.version.version7_4", "vim.version.version12")
< AddVersionParent("eam.version.version7_1", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_1", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_1", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_1", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_1", "vim.version.version8")
< AddVersionParent("eam.version.version7_1", "vim.version.version9")
< AddVersionParent("eam.version.version7_1", "vim.version.version6")
< AddVersionParent("eam.version.version7_1", "vim.version.version7")
< AddVersionParent("eam.version.version7_1", "vim.version.version1")
< AddVersionParent("eam.version.version7_1", "vim.version.version4")
< AddVersionParent("eam.version.version7_1", "vim.version.version5")
< AddVersionParent("eam.version.version7_1", "vim.version.version2")
< AddVersionParent("eam.version.version7_1", "vim.version.version3")
< AddVersionParent("eam.version.version7_1", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_1", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_1", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_1", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_1", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_1", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_1", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_1", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_1", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_1", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_1", "vim.version.version13")
< AddVersionParent("eam.version.version7_1", "eam.version.version1")
< AddVersionParent("eam.version.version7_1", "eam.version.version2")
< AddVersionParent("eam.version.version7_1", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_1", "eam.version.version3")
< AddVersionParent("eam.version.version7_1", "eam.version.version6")
< AddVersionParent("eam.version.version7_1", "eam.version.version7")
< AddVersionParent("eam.version.version7_1", "vim.version.version10")
< AddVersionParent("eam.version.version7_1", "vim.version.version11")
< AddVersionParent("eam.version.version7_1", "vim.version.version12")
< AddVersionParent("eam.version.version3", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version3", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version3", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version3", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version3", "vim.version.version8")
< AddVersionParent("eam.version.version3", "vim.version.version6")
< AddVersionParent("eam.version.version3", "vim.version.version7")
< AddVersionParent("eam.version.version3", "vim.version.version1")
< AddVersionParent("eam.version.version3", "vim.version.version4")
< AddVersionParent("eam.version.version3", "vim.version.version5")
< AddVersionParent("eam.version.version3", "vim.version.version2")
< AddVersionParent("eam.version.version3", "vim.version.version3")
< AddVersionParent("eam.version.version3", "vmodl.version.version0")
< AddVersionParent("eam.version.version3", "vmodl.version.version1")
< AddVersionParent("eam.version.version3", "vmodl.version.version2")
< AddVersionParent("eam.version.version3", "eam.version.version2_5")
< AddVersionParent("eam.version.version3", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version3", "eam.version.version1")
< AddVersionParent("eam.version.version3", "eam.version.version2")
< AddVersionParent("eam.version.version3", "eam.version.version3")
< AddVersionParent("eam.version.version7_2", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_2", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_2", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_2", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_2", "vim.version.version8")
< AddVersionParent("eam.version.version7_2", "vim.version.version9")
< AddVersionParent("eam.version.version7_2", "vim.version.version6")
< AddVersionParent("eam.version.version7_2", "vim.version.version7")
< AddVersionParent("eam.version.version7_2", "vim.version.version1")
< AddVersionParent("eam.version.version7_2", "vim.version.version4")
< AddVersionParent("eam.version.version7_2", "vim.version.version5")
< AddVersionParent("eam.version.version7_2", "vim.version.version2")
< AddVersionParent("eam.version.version7_2", "vim.version.version3")
< AddVersionParent("eam.version.version7_2", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_2", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_2", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_2", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_2", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_2", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_2", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_2", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_2", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_2", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_2", "vim.version.version13")
< AddVersionParent("eam.version.version7_2", "eam.version.version1")
< AddVersionParent("eam.version.version7_2", "eam.version.version2")
< AddVersionParent("eam.version.version7_2", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_2", "eam.version.version3")
< AddVersionParent("eam.version.version7_2", "eam.version.version7_2")
< AddVersionParent("eam.version.version7_2", "eam.version.version6")
< AddVersionParent("eam.version.version7_2", "eam.version.version7")
< AddVersionParent("eam.version.version7_2", "vim.version.version10")
< AddVersionParent("eam.version.version7_2", "vim.version.version11")
< AddVersionParent("eam.version.version7_2", "vim.version.version12")
< AddVersionParent("eam.version.version7_5", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_5", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_5", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_5", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_5", "vim.version.version8")
< AddVersionParent("eam.version.version7_5", "vim.version.version9")
< AddVersionParent("eam.version.version7_5", "vim.version.version6")
< AddVersionParent("eam.version.version7_5", "vim.version.version7")
< AddVersionParent("eam.version.version7_5", "vim.version.version1")
< AddVersionParent("eam.version.version7_5", "vim.version.version4")
< AddVersionParent("eam.version.version7_5", "vim.version.version5")
< AddVersionParent("eam.version.version7_5", "vim.version.version2")
< AddVersionParent("eam.version.version7_5", "vim.version.version3")
< AddVersionParent("eam.version.version7_5", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_5", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_5", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_5", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_5", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_5", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_5", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_5", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_5", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_5", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_5", "vim.version.version13")
< AddVersionParent("eam.version.version7_5", "eam.version.version7_3")
< AddVersionParent("eam.version.version7_5", "eam.version.version1")
< AddVersionParent("eam.version.version7_5", "eam.version.version2")
< AddVersionParent("eam.version.version7_5", "eam.version.version7_4")
< AddVersionParent("eam.version.version7_5", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_5", "eam.version.version3")
< AddVersionParent("eam.version.version7_5", "eam.version.version7_2")
< AddVersionParent("eam.version.version7_5", "eam.version.version7_5")
< AddVersionParent("eam.version.version7_5", "eam.version.version6")
< AddVersionParent("eam.version.version7_5", "eam.version.version7")
< AddVersionParent("eam.version.version7_5", "vim.version.version10")
< AddVersionParent("eam.version.version7_5", "vim.version.version11")
< AddVersionParent("eam.version.version7_5", "vim.version.version12")
< AddVersionParent("eam.version.version7_6", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7_6", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7_6", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7_6", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7_6", "vim.version.version8")
< AddVersionParent("eam.version.version7_6", "vim.version.version9")
< AddVersionParent("eam.version.version7_6", "vim.version.version6")
< AddVersionParent("eam.version.version7_6", "vim.version.version7")
< AddVersionParent("eam.version.version7_6", "vim.version.version1")
< AddVersionParent("eam.version.version7_6", "vim.version.version4")
< AddVersionParent("eam.version.version7_6", "vim.version.version5")
< AddVersionParent("eam.version.version7_6", "vim.version.version2")
< AddVersionParent("eam.version.version7_6", "vim.version.version3")
< AddVersionParent("eam.version.version7_6", "vmodl.version.version0")
< AddVersionParent("eam.version.version7_6", "vmodl.version.version1")
< AddVersionParent("eam.version.version7_6", "vmodl.version.version2")
< AddVersionParent("eam.version.version7_6", "eam.version.version2_5")
< AddVersionParent("eam.version.version7_6", "eam.version.version6_5")
< AddVersionParent("eam.version.version7_6", "eam.version.version6_8")
< AddVersionParent("eam.version.version7_6", "eam.version.version6_9")
< AddVersionParent("eam.version.version7_6", "eam.version.version6_7")
< AddVersionParent("eam.version.version7_6", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7_6", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7_6", "vim.version.version13")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_3")
< AddVersionParent("eam.version.version7_6", "eam.version.version1")
< AddVersionParent("eam.version.version7_6", "eam.version.version2")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_4")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_1")
< AddVersionParent("eam.version.version7_6", "eam.version.version3")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_2")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_5")
< AddVersionParent("eam.version.version7_6", "eam.version.version7_6")
< AddVersionParent("eam.version.version7_6", "eam.version.version6")
< AddVersionParent("eam.version.version7_6", "eam.version.version7")
< AddVersionParent("eam.version.version7_6", "vim.version.version10")
< AddVersionParent("eam.version.version7_6", "vim.version.version11")
< AddVersionParent("eam.version.version7_6", "vim.version.version12")
< AddVersionParent("eam.version.version6", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version6", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version6", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version6", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version6", "vim.version.version8")
< AddVersionParent("eam.version.version6", "vim.version.version6")
< AddVersionParent("eam.version.version6", "vim.version.version7")
< AddVersionParent("eam.version.version6", "vim.version.version1")
< AddVersionParent("eam.version.version6", "vim.version.version4")
< AddVersionParent("eam.version.version6", "vim.version.version5")
< AddVersionParent("eam.version.version6", "vim.version.version2")
< AddVersionParent("eam.version.version6", "vim.version.version3")
< AddVersionParent("eam.version.version6", "vmodl.version.version0")
< AddVersionParent("eam.version.version6", "vmodl.version.version1")
< AddVersionParent("eam.version.version6", "vmodl.version.version2")
< AddVersionParent("eam.version.version6", "eam.version.version2_5")
< AddVersionParent("eam.version.version6", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version6", "eam.version.version1")
< AddVersionParent("eam.version.version6", "eam.version.version2")
< AddVersionParent("eam.version.version6", "eam.version.version3")
< AddVersionParent("eam.version.version6", "eam.version.version6")
< AddVersionParent("eam.version.version7", "vmodl.query.version.version4")
< AddVersionParent("eam.version.version7", "vmodl.query.version.version3")
< AddVersionParent("eam.version.version7", "vmodl.query.version.version2")
< AddVersionParent("eam.version.version7", "vmodl.query.version.version1")
< AddVersionParent("eam.version.version7", "vim.version.version8")
< AddVersionParent("eam.version.version7", "vim.version.version9")
< AddVersionParent("eam.version.version7", "vim.version.version6")
< AddVersionParent("eam.version.version7", "vim.version.version7")
< AddVersionParent("eam.version.version7", "vim.version.version1")
< AddVersionParent("eam.version.version7", "vim.version.version4")
< AddVersionParent("eam.version.version7", "vim.version.version5")
< AddVersionParent("eam.version.version7", "vim.version.version2")
< AddVersionParent("eam.version.version7", "vim.version.version3")
< AddVersionParent("eam.version.version7", "vmodl.version.version0")
< AddVersionParent("eam.version.version7", "vmodl.version.version1")
< AddVersionParent("eam.version.version7", "vmodl.version.version2")
< AddVersionParent("eam.version.version7", "eam.version.version2_5")
< AddVersionParent("eam.version.version7", "eam.version.version6_5")
< AddVersionParent("eam.version.version7", "eam.version.version6_8")
< AddVersionParent("eam.version.version7", "eam.version.version6_9")
< AddVersionParent("eam.version.version7", "eam.version.version6_7")
< AddVersionParent("eam.version.version7", "vmodl.reflect.version.version1")
< AddVersionParent("eam.version.version7", "vmodl.reflect.version.version2")
< AddVersionParent("eam.version.version7", "vim.version.version13")
< AddVersionParent("eam.version.version7", "eam.version.version1")
< AddVersionParent("eam.version.version7", "eam.version.version2")
< AddVersionParent("eam.version.version7", "eam.version.version3")
< AddVersionParent("eam.version.version7", "eam.version.version6")
< AddVersionParent("eam.version.version7", "eam.version.version7")
< AddVersionParent("eam.version.version7", "vim.version.version10")
< AddVersionParent("eam.version.version7", "vim.version.version11")
< AddVersionParent("eam.version.version7", "vim.version.version12")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version10", "vim.version.version8")
< AddVersionParent("vim.version.version10", "vim.version.version9")
< AddVersionParent("vim.version.version10", "vim.version.version6")
< AddVersionParent("vim.version.version10", "vim.version.version7")
< AddVersionParent("vim.version.version10", "vim.version.version1")
< AddVersionParent("vim.version.version10", "vim.version.version4")
< AddVersionParent("vim.version.version10", "vim.version.version5")
< AddVersionParent("vim.version.version10", "vim.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version3")
< AddVersionParent("vim.version.version10", "vmodl.version.version0")
< AddVersionParent("vim.version.version10", "vmodl.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version10")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version11", "vim.version.version8")
< AddVersionParent("vim.version.version11", "vim.version.version9")
< AddVersionParent("vim.version.version11", "vim.version.version6")
< AddVersionParent("vim.version.version11", "vim.version.version7")
< AddVersionParent("vim.version.version11", "vim.version.version1")
< AddVersionParent("vim.version.version11", "vim.version.version4")
< AddVersionParent("vim.version.version11", "vim.version.version5")
< AddVersionParent("vim.version.version11", "vim.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.version.version0")
< AddVersionParent("vim.version.version11", "vmodl.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version10")
< AddVersionParent("vim.version.version11", "vim.version.version11")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version12", "vim.version.version8")
< AddVersionParent("vim.version.version12", "vim.version.version9")
< AddVersionParent("vim.version.version12", "vim.version.version6")
< AddVersionParent("vim.version.version12", "vim.version.version7")
< AddVersionParent("vim.version.version12", "vim.version.version1")
< AddVersionParent("vim.version.version12", "vim.version.version4")
< AddVersionParent("vim.version.version12", "vim.version.version5")
< AddVersionParent("vim.version.version12", "vim.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.version.version0")
< AddVersionParent("vim.version.version12", "vmodl.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version10")
< AddVersionParent("vim.version.version12", "vim.version.version11")
< AddVersionParent("vim.version.version12", "vim.version.version12")
< 
< newestVersions.Add("eam.version.version7_6")
< publicVersions.Add("eam.version.version7_6")
< dottedVersions.Add("eam.version.version7_6")
< oldestVersions.Add("eam.version.version1")
< 
< CreateManagedType("eam.EamObject", "EamObject", "vmodl.ManagedObject", "eam.version.version1", None, [("resolve", "Resolve", "eam.version.version1", (("issueKey", "int[]", "eam.version.version1", 0, None),), (F_OPTIONAL, "int[]", "int[]"), None, None), ("resolveAll", "ResolveAll", "eam.version.version1", (), (0, "void", "void"), None, None), ("queryIssue", "QueryIssue", "eam.version.version1", (("issueKey", "int[]", "eam.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "eam.issue.Issue[]", "eam.issue.Issue[]"), None, None)])
< CreateDataType("eam.EamObject.RuntimeInfo", "EamObjectRuntimeInfo", "vmodl.DynamicData", "eam.version.version1", [("status", "string", "eam.version.version1", 0), ("issue", "eam.issue.Issue[]", "eam.version.version1", F_OPTIONAL), ("goalState", "string", "eam.version.version1", 0), ("entity", "eam.EamObject", "eam.version.version1", 0)])
< CreateEnumType("eam.EamObject.RuntimeInfo.Status", "EamObjectRuntimeInfoStatus", "eam.version.version1", ["green", "yellow", "red"])
< CreateEnumType("eam.EamObject.RuntimeInfo.GoalState", "EamObjectRuntimeInfoGoalState", "eam.version.version1", ["enabled", "disabled", "uninstalled"])
< CreateManagedType("eam.Task", "EamTask", "vmodl.ManagedObject", "eam.version.version1", None, None)
< CreateDataType("eam.fault.EamFault", "EamFault", "vmodl.MethodFault", "eam.version.version1", None)
< CreateDataType("eam.fault.EamRuntimeFault", "EamRuntimeFault", "vmodl.RuntimeFault", "eam.version.version1", None)
< CreateDataType("eam.fault.EamServiceNotInitialized", "EamServiceNotInitialized", "eam.fault.EamRuntimeFault", "eam.version.version6_5", None)
< CreateDataType("eam.fault.EamSystemFault", "EamSystemFault", "eam.fault.EamRuntimeFault", "eam.version.version6_5", None)
< CreateDataType("eam.fault.InvalidAgencyScope", "InvalidAgencyScope", "eam.fault.EamFault", "eam.version.version1", [("unknownComputeResource", "vim.ComputeResource[]", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.fault.InvalidLogin", "EamInvalidLogin", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
< CreateDataType("eam.fault.InvalidUrl", "InvalidUrl", "eam.fault.EamFault", "eam.version.version1", [("url", "string", "eam.version.version1", 0), ("malformedUrl", "boolean", "eam.version.version1", 0), ("unknownHost", "boolean", "eam.version.version1", 0), ("connectionRefused", "boolean", "eam.version.version1", 0), ("responseCode", "int", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.fault.InvalidVibPackage", "EamInvalidVibPackage", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
< CreateDataType("eam.fault.NoConnectionToVCenter", "NoConnectionToVCenter", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
< CreateDataType("eam.fault.NotAuthorized", "NotAuthorized", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
< CreateDataType("eam.issue.Issue", "Issue", "vmodl.DynamicData", "eam.version.version1", [("key", "int", "eam.version.version1", 0), ("description", "string", "eam.version.version1", 0), ("time", "vmodl.DateTime", "eam.version.version1", 0)])
< CreateDataType("eam.vib.VibInfo", "VibVibInfo", "vmodl.DynamicData", "eam.version.version6", [("id", "string", "eam.version.version6", 0), ("name", "string", "eam.version.version6", 0), ("version", "string", "eam.version.version6", 0), ("vendor", "string", "eam.version.version6", 0), ("summary", "string", "eam.version.version6", 0), ("softwareTags", "eam.vib.VibInfo.SoftwareTags", "eam.version.version6_5", F_OPTIONAL), ("releaseDate", "vmodl.DateTime", "eam.version.version6", 0)])
< CreateDataType("eam.vib.VibInfo.SoftwareTags", "VibVibInfoSoftwareTags", "vmodl.DynamicData", "eam.version.version6_5", [("tags", "string[]", "eam.version.version6_5", F_OPTIONAL)])
< CreateManagedType("eam.Agent", "Agent", "eam.EamObject", "eam.version.version1", [("runtime", "eam.Agent.RuntimeInfo", "eam.version.version1", 0, None), ("config", "eam.Agent.ConfigInfo", "eam.version.version1", 0, None)], [("queryRuntime", "AgentQueryRuntime", "eam.version.version1", (), (0, "eam.Agent.RuntimeInfo", "eam.Agent.RuntimeInfo"), None, None), ("markAsAvailable", "MarkAsAvailable", "eam.version.version1", (), (0, "void", "void"), None, None), ("queryConfig", "AgentQueryConfig", "eam.version.version1", (), (0, "eam.Agent.ConfigInfo", "eam.Agent.ConfigInfo"), None, None)])
< CreateDataType("eam.Agent.RuntimeInfo", "AgentRuntimeInfo", "eam.EamObject.RuntimeInfo", "eam.version.version1", [("vmPowerState", "vim.VirtualMachine.PowerState", "eam.version.version1", 0), ("receivingHeartBeat", "boolean", "eam.version.version1", 0), ("host", "vim.HostSystem", "eam.version.version1", F_OPTIONAL), ("vm", "vim.VirtualMachine", "eam.version.version1", F_OPTIONAL), ("vmIp", "string", "eam.version.version1", F_OPTIONAL), ("vmName", "string", "eam.version.version1", 0), ("esxAgentResourcePool", "vim.ResourcePool", "eam.version.version1", F_OPTIONAL), ("esxAgentFolder", "vim.Folder", "eam.version.version1", F_OPTIONAL), ("installedBulletin", "string[]", "eam.version.version1", F_OPTIONAL), ("installedVibs", "eam.vib.VibInfo[]", "eam.version.version6", F_OPTIONAL), ("agency", "eam.Agency", "eam.version.version2", F_OPTIONAL), ("vmHook", "eam.Agent.VmHook", "eam.version.version6_7", F_OPTIONAL)])
< CreateDataType("eam.Agent.VmHook", "AgentVmHook", "vmodl.DynamicData", "eam.version.version6_7", [("vm", "vim.VirtualMachine", "eam.version.version6_7", 0), ("vmState", "string", "eam.version.version6_7", 0)])
< CreateEnumType("eam.Agent.VmHook.VmState", "AgentVmHookVmState", "eam.version.version1", ["provisioned", "poweredOn", "prePowerOn"])
< CreateDataType("eam.Agent.StoragePolicy", "AgentStoragePolicy", "vmodl.DynamicData", "eam.version.version7", None)
< CreateDataType("eam.Agent.VsanStoragePolicy", "AgentVsanStoragePolicy", "eam.Agent.StoragePolicy", "eam.version.version7", [("profileId", "string", "eam.version.version7", 0)])
< CreateDataType("eam.Agent.ConfigInfo", "AgentConfigInfo", "vmodl.DynamicData", "eam.version.version1", [("productLineId", "string", "eam.version.version1", F_OPTIONAL), ("hostVersion", "string", "eam.version.version1", F_OPTIONAL), ("ovfPackageUrl", "string", "eam.version.version1", F_OPTIONAL), ("ovfEnvironment", "eam.Agent.OvfEnvironmentInfo", "eam.version.version1", F_OPTIONAL), ("vibUrl", "string", "eam.version.version1", F_OPTIONAL), ("vibMatchingRules", "eam.Agent.VibMatchingRule[]", "eam.version.version2_5", F_OPTIONAL), ("vibName", "string", "eam.version.version2", F_OPTIONAL), ("dvFilterEnabled", "boolean", "eam.version.version1", F_OPTIONAL), ("rebootHostAfterVibUninstall", "boolean", "eam.version.version1", F_OPTIONAL), ("vmciService", "string[]", "eam.version.version1", F_OPTIONAL), ("ovfDiskProvisioning", "string", "eam.version.version6_9", F_OPTIONAL), ("vmStoragePolicies", "eam.Agent.StoragePolicy[]", "eam.version.version7", F_OPTIONAL)])
< CreateEnumType("eam.Agent.ConfigInfo.OvfDiskProvisioning", "AgentConfigInfoOvfDiskProvisioning", "eam.version.version6_9", ["none", "thin", "thick"])
< CreateDataType("eam.Agent.OvfEnvironmentInfo", "AgentOvfEnvironmentInfo", "vmodl.DynamicData", "eam.version.version1", [("ovfProperty", "eam.Agent.OvfEnvironmentInfo.OvfProperty[]", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.Agent.OvfEnvironmentInfo.OvfProperty", "AgentOvfEnvironmentInfoOvfProperty", "vmodl.DynamicData", "eam.version.version1", [("key", "string", "eam.version.version1", 0), ("value", "string", "eam.version.version1", 0)])
< CreateDataType("eam.Agent.VibMatchingRule", "AgentVibMatchingRule", "vmodl.DynamicData", "eam.version.version1", [("vibNameRegex", "string", "eam.version.version1", 0), ("vibVersionRegex", "string", "eam.version.version1", 0)])
< CreateDataType("eam.fault.EamAppFault", "EamAppFault", "eam.fault.EamRuntimeFault", "eam.version.version6", None)
< CreateDataType("eam.fault.EamIOFault", "EamIOFault", "eam.fault.EamRuntimeFault", "eam.version.version6", None)
< CreateDataType("eam.fault.InvalidAgentConfiguration", "InvalidAgentConfiguration", "eam.fault.EamFault", "eam.version.version1", [("invalidAgentConfiguration", "eam.Agent.ConfigInfo", "eam.version.version1", F_OPTIONAL), ("invalidField", "string", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.fault.InvalidState", "EamInvalidState", "eam.fault.EamAppFault", "eam.version.version7_1", None)
< CreateDataType("eam.issue.AgencyIssue", "AgencyIssue", "eam.issue.Issue", "eam.version.version1", [("agency", "eam.Agency", "eam.version.version1", 0), ("agencyName", "string", "eam.version.version1", 0), ("solutionId", "string", "eam.version.version1", 0), ("solutionName", "string", "eam.version.version1", 0)])
< CreateDataType("eam.issue.AgentIssue", "AgentIssue", "eam.issue.AgencyIssue", "eam.version.version1", [("agent", "eam.Agent", "eam.version.version1", 0), ("agentName", "string", "eam.version.version1", 0), ("host", "vim.HostSystem", "eam.version.version1", 0), ("hostName", "string", "eam.version.version1", 0)])
< CreateDataType("eam.issue.ExtensibleIssue", "ExtensibleIssue", "eam.issue.Issue", "eam.version.version2", [("typeId", "string", "eam.version.version2", 0), ("argument", "vmodl.KeyAnyValue[]", "eam.version.version2", F_OPTIONAL), ("target", "vim.ManagedEntity", "eam.version.version2", F_OPTIONAL), ("agent", "eam.Agent", "eam.version.version2", F_OPTIONAL), ("agency", "eam.Agency", "eam.version.version2", F_OPTIONAL)])
< CreateDataType("eam.issue.HostIssue", "HostIssue", "eam.issue.Issue", "eam.version.version1", [("host", "vim.HostSystem", "eam.version.version1", 0)])
< CreateDataType("eam.issue.HostNotReachable", "ManagedHostNotReachable", "eam.issue.AgentIssue", "eam.version.version6_8", None)
< CreateDataType("eam.issue.MissingDvFilterSwitch", "MissingDvFilterSwitch", "eam.issue.AgentIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.OrphanedAgency", "OrphanedAgency", "eam.issue.AgencyIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.OrphanedDvFilterSwitch", "OrphanedDvFilterSwitch", "eam.issue.HostIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.OvfInvalidProperty", "OvfInvalidProperty", "eam.issue.AgentIssue", "eam.version.version1", [("error", "vmodl.MethodFault[]", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.issue.UnknownAgentVm", "UnknownAgentVm", "eam.issue.HostIssue", "eam.version.version1", [("vm", "vim.VirtualMachine", "eam.version.version1", 0)])
< CreateDataType("eam.issue.VibIssue", "VibIssue", "eam.issue.AgentIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VibNotInstalled", "VibNotInstalled", "eam.issue.VibIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VibRequirementsNotMetByHost", "VibRequirementsNotMetByHost", "eam.issue.VibNotInstalled", "eam.version.version6_8", None)
< CreateDataType("eam.issue.VibRequiresHostInMaintenanceMode", "VibRequiresHostInMaintenanceMode", "eam.issue.VibIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VibRequiresHostReboot", "VibRequiresHostReboot", "eam.issue.VibIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VibRequiresManualInstallation", "VibRequiresManualInstallation", "eam.issue.VibIssue", "eam.version.version1", [("bulletin", "string[]", "eam.version.version1", 0)])
< CreateDataType("eam.issue.VibRequiresManualUninstallation", "VibRequiresManualUninstallation", "eam.issue.VibIssue", "eam.version.version1", [("bulletin", "string[]", "eam.version.version1", 0)])
< CreateDataType("eam.issue.VmIssue", "VmIssue", "eam.issue.AgentIssue", "eam.version.version1", [("vm", "vim.VirtualMachine", "eam.version.version1", 0)])
< CreateDataType("eam.issue.VmMarkedAsTemplate", "VmMarkedAsTemplate", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmNotDeployed", "VmNotDeployed", "eam.issue.AgentIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmOrphaned", "VmOrphaned", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmPoweredOff", "VmPoweredOff", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmPoweredOn", "VmPoweredOn", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmRequiresHostOutOfMaintenanceMode", "VmRequiresHostOutOfMaintenanceMode", "eam.issue.VmNotDeployed", "eam.version.version7_2", None)
< CreateDataType("eam.issue.VmSuspended", "VmSuspended", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VmWrongFolder", "VmWrongFolder", "eam.issue.VmIssue", "eam.version.version1", [("currentFolder", "vim.Folder", "eam.version.version1", 0), ("requiredFolder", "vim.Folder", "eam.version.version1", 0)])
< CreateDataType("eam.issue.VmWrongResourcePool", "VmWrongResourcePool", "eam.issue.VmIssue", "eam.version.version1", [("currentResourcePool", "vim.ResourcePool", "eam.version.version1", 0), ("requiredResourcePool", "vim.ResourcePool", "eam.version.version1", 0)])
< CreateDataType("eam.issue.cluster.agent.AgentIssue", "ClusterAgentAgentIssue", "eam.issue.AgencyIssue", "eam.version.version6_9", [("agent", "eam.Agent", "eam.version.version6_9", 0), ("cluster", "vim.ComputeResource", "eam.version.version6_9", F_OPTIONAL)])
< CreateDataType("eam.issue.cluster.agent.OvfInvalidProperty", "ClusterAgentOvfInvalidProperty", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", [("error", "vmodl.MethodFault[]", "eam.version.version6_9", F_OPTIONAL)])
< CreateDataType("eam.issue.cluster.agent.VmIssue", "ClusterAgentVmIssue", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", [("vm", "vim.VirtualMachine", "eam.version.version6_9", 0)])
< CreateDataType("eam.issue.cluster.agent.VmNotDeployed", "ClusterAgentVmNotDeployed", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.VmNotRemoved", "ClusterAgentVmNotRemoved", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.VmPoweredOff", "ClusterAgentVmPoweredOff", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.VmPoweredOn", "ClusterAgentVmPoweredOn", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.VmSuspended", "ClusterAgentVmSuspended", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
< CreateDataType("eam.issue.integrity.agency.VUMIssue", "IntegrityAgencyVUMIssue", "eam.issue.AgencyIssue", "eam.version.version6_7", None)
< CreateDataType("eam.issue.integrity.agency.VUMUnavailable", "IntegrityAgencyVUMUnavailable", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
< CreateDataType("eam.issue.personality.agency.PMIssue", "PersonalityAgencyPMIssue", "eam.issue.AgencyIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.personality.agency.PMUnavailable", "PersonalityAgencyPMUnavailable", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.personality.agent.PMIssue", "PersonalityAgentPMIssue", "eam.issue.AgentIssue", "eam.version.version7_1", None)
< CreateManagedType("eam.Agency", "Agency", "eam.EamObject", "eam.version.version1", [("solutionId", "string", "eam.version.version1", 0, None), ("owner", "string", "eam.version.version6", F_OPTIONAL, None), ("config", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None), ("runtime", "eam.EamObject.RuntimeInfo", "eam.version.version1", 0, None), ("agent", "eam.Agent[]", "eam.version.version1", F_OPTIONAL, None)], [("querySolutionId", "QuerySolutionId", "eam.version.version1", (), (0, "string", "string"), None, None), ("queryConfig", "QueryConfig", "eam.version.version1", (), (0, "eam.Agency.ConfigInfo", "eam.Agency.ConfigInfo"), None, None), ("update", "Update", "eam.version.version1", (("config", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None),), (0, "void", "void"), None, ["eam.fault.InvalidAgentConfiguration", "eam.fault.InvalidAgencyScope", "eam.fault.InvalidUrl", ]), ("queryRuntime", "AgencyQueryRuntime", "eam.version.version1", (), (0, "eam.EamObject.RuntimeInfo", "eam.EamObject.RuntimeInfo"), None, None), ("queryAgent", "QueryAgent", "eam.version.version1", (), (F_OPTIONAL, "eam.Agent[]", "eam.Agent[]"), None, None), ("registerAgentVm", "RegisterAgentVm", "eam.version.version2", (("agentVm", "vim.VirtualMachine", "eam.version.version2", 0, None),), (0, "eam.Agent", "eam.Agent"), None, ["vmodl.fault.ManagedObjectNotFound", ]), ("unregisterAgentVm", "UnregisterAgentVm", "eam.version.version2", (("agentVm", "vim.VirtualMachine", "eam.version.version2", 0, None),), (0, "void", "void"), None, None), ("enable", "Agency_Enable", "eam.version.version1", (), (0, "void", "void"), None, None), ("disable", "Agency_Disable", "eam.version.version1", (), (0, "void", "void"), None, None), ("uninstall", "Uninstall", "eam.version.version1", (), (0, "void", "void"), None, None), ("destroyAgency", "DestroyAgency", "eam.version.version1", (), (0, "void", "void"), None, None), ("addIssue", "AddIssue", "eam.version.version2", (("issue", "eam.issue.Issue", "eam.version.version2", 0, None),), (0, "eam.issue.Issue", "eam.issue.Issue"), None, ["vmodl.fault.InvalidArgument", ])])
< CreateDataType("eam.Agency.VMResourcePool", "AgencyVMResourcePool", "vmodl.DynamicData", "eam.version.version6_9", [("resourcePoolId", "vim.ResourcePool", "eam.version.version6_9", 0), ("computeResourceId", "vim.ComputeResource", "eam.version.version6_9", 0)])
< CreateDataType("eam.Agency.VMFolder", "AgencyVMFolder", "vmodl.DynamicData", "eam.version.version6_9", [("folderId", "vim.Folder", "eam.version.version6_9", 0), ("datacenterId", "vim.Datacenter", "eam.version.version6_9", 0)])
< CreateEnumType("eam.Agency.VMPlacementPolicy.VMDataAffinity", "AgencyVMPlacementPolicyVMDataAffinity", "eam.version.version1", ["none", "soft"])
< CreateEnumType("eam.Agency.VMPlacementPolicy.VMAntiAffinity", "AgencyVMPlacementPolicyVMAntiAffinity", "eam.version.version1", ["none", "soft"])
< CreateDataType("eam.Agency.ConfigInfo", "AgencyConfigInfo", "vmodl.DynamicData", "eam.version.version1", [("agentConfig", "eam.Agent.ConfigInfo[]", "eam.version.version1", F_OPTIONAL), ("scope", "eam.Agency.Scope", "eam.version.version1", F_OPTIONAL), ("manuallyMarkAgentVmAvailableAfterProvisioning", "boolean", "eam.version.version1", F_OPTIONAL), ("manuallyMarkAgentVmAvailableAfterPowerOn", "boolean", "eam.version.version1", F_OPTIONAL), ("optimizedDeploymentEnabled", "boolean", "eam.version.version1", F_OPTIONAL), ("agentName", "string", "eam.version.version1", F_OPTIONAL), ("agencyName", "string", "eam.version.version1", F_OPTIONAL), ("useUuidVmName", "boolean", "eam.version.version7_5", F_OPTIONAL), ("manuallyProvisioned", "boolean", "eam.version.version2", F_OPTIONAL), ("manuallyMonitored", "boolean", "eam.version.version2", F_OPTIONAL), ("bypassVumEnabled", "boolean", "eam.version.version2", F_OPTIONAL), ("agentVmNetwork", "vim.Network[]", "eam.version.version2", F_OPTIONAL), ("agentVmDatastore", "vim.Datastore[]", "eam.version.version2_5", F_OPTIONAL), ("preferHostConfiguration", "boolean", "eam.version.version2_5", F_OPTIONAL), ("ipPool", "vim.vApp.IpPool", "eam.version.version3", F_OPTIONAL), ("resourcePools", "eam.Agency.VMResourcePool[]", "eam.version.version6_9", F_OPTIONAL), ("folders", "eam.Agency.VMFolder[]", "eam.version.version6_9", F_OPTIONAL)])
< CreateDataType("eam.Agency.Scope", "AgencyScope", "vmodl.DynamicData", "eam.version.version1", None)
< CreateDataType("eam.Agency.ComputeResourceScope", "AgencyComputeResourceScope", "eam.Agency.Scope", "eam.version.version1", [("computeResource", "vim.ComputeResource[]", "eam.version.version1", F_OPTIONAL)])
< CreateManagedType("eam.EsxAgentManager", "EsxAgentManager", "eam.EamObject", "eam.version.version1", [("agency", "eam.Agency[]", "eam.version.version1", F_OPTIONAL, None), ("issue", "eam.issue.Issue[]", "eam.version.version1", F_OPTIONAL, None)], [("queryAgency", "QueryAgency", "eam.version.version1", (), (F_OPTIONAL, "eam.Agency[]", "eam.Agency[]"), None, None), ("createAgency", "CreateAgency", "eam.version.version1", (("agencyConfigInfo", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None),("initialGoalState", "string", "eam.version.version1", 0, None),), (0, "eam.Agency", "eam.Agency"), None, ["eam.fault.InvalidAgentConfiguration", "eam.fault.InvalidAgencyScope", "eam.fault.InvalidUrl", ]), ("scanForUnknownAgentVm", "ScanForUnknownAgentVm", "eam.version.version1", (), (0, "void", "void"), None, None), ("setMaintenanceModePolicy", "SetMaintenanceModePolicy", "eam.version.version7_4", (("policy", "string", "eam.version.version7_4", 0, None),), (0, "void", "void"), None, None), ("getMaintenanceModePolicy", "GetMaintenanceModePolicy", "eam.version.version7_4", (), (0, "string", "string"), None, None)])
< CreateEnumType("eam.EsxAgentManager.MaintenanceModePolicy", "EsxAgentManagerMaintenanceModePolicy", "eam.version.version7_4", ["singleHost", "multipleHosts"])
< CreateDataType("eam.fault.DisabledClusterFault", "DisabledClusterFault", "eam.fault.EamAppFault", "eam.version.version7_6", [("disabledComputeResource", "vim.ComputeResource[]", "eam.version.version7_6", F_OPTIONAL)])
< CreateDataType("eam.issue.AgencyDisabled", "AgencyDisabled", "eam.issue.AgencyIssue", "eam.version.version7_6", None)
< CreateDataType("eam.issue.CannotAccessAgentOVF", "CannotAccessAgentOVF", "eam.issue.VmNotDeployed", "eam.version.version1", [("downloadUrl", "string", "eam.version.version1", 0)])
< CreateDataType("eam.issue.CannotAccessAgentVib", "CannotAccessAgentVib", "eam.issue.VibNotInstalled", "eam.version.version1", [("downloadUrl", "string", "eam.version.version1", 0)])
< CreateDataType("eam.issue.ImmediateHostRebootRequired", "ImmediateHostRebootRequired", "eam.issue.VibIssue", "eam.version.version6_8", None)
< CreateDataType("eam.issue.IncompatibleHostVersion", "IncompatibleHostVersion", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.InsufficientIpAddresses", "InsufficientIpAddresses", "eam.issue.VmPoweredOff", "eam.version.version1", [("network", "vim.Network", "eam.version.version1", 0)])
< CreateDataType("eam.issue.InsufficientResources", "InsufficientResources", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.InsufficientSpace", "InsufficientSpace", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.InvalidConfig", "InvalidConfig", "eam.issue.VmIssue", "eam.version.version6_9", [("error", "anyType", "eam.version.version6_9", 0)])
< CreateDataType("eam.issue.MissingAgentIpPool", "MissingAgentIpPool", "eam.issue.VmPoweredOff", "eam.version.version1", [("network", "vim.Network", "eam.version.version1", 0)])
< CreateDataType("eam.issue.NoAgentVmDatastore", "NoAgentVmDatastore", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.NoAgentVmNetwork", "NoAgentVmNetwork", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.NoCustomAgentVmDatastore", "NoCustomAgentVmDatastore", "eam.issue.NoAgentVmDatastore", "eam.version.version1", [("customAgentVmDatastore", "vim.Datastore[]", "eam.version.version1", 0), ("customAgentVmDatastoreName", "string[]", "eam.version.version1", 0)])
< CreateDataType("eam.issue.NoCustomAgentVmNetwork", "NoCustomAgentVmNetwork", "eam.issue.NoAgentVmNetwork", "eam.version.version1", [("customAgentVmNetwork", "vim.Network[]", "eam.version.version1", 0), ("customAgentVmNetworkName", "string[]", "eam.version.version1", 0)])
< CreateDataType("eam.issue.NoDiscoverableAgentVmDatastore", "NoDiscoverableAgentVmDatastore", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.NoDiscoverableAgentVmNetwork", "NoDiscoverableAgentVmNetwork", "eam.issue.VmNotDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.OvfInvalidFormat", "OvfInvalidFormat", "eam.issue.VmNotDeployed", "eam.version.version1", [("error", "vmodl.MethodFault[]", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.issue.VibCannotPutHostInMaintenanceMode", "VibCannotPutHostInMaintenanceMode", "eam.issue.VibIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.VibCannotPutHostOutOfMaintenanceMode", "VibCannotPutHostOutOfMaintenanceMode", "eam.issue.VibIssue", "eam.version.version6_5", None)
< CreateDataType("eam.issue.VibDependenciesNotMetByHost", "VibDependenciesNotMetByHost", "eam.issue.VibNotInstalled", "eam.version.version6_8", None)
< CreateDataType("eam.issue.VibInvalidFormat", "VibInvalidFormat", "eam.issue.VibNotInstalled", "eam.version.version1", None)
< CreateDataType("eam.issue.VmCorrupted", "VmCorrupted", "eam.issue.VmIssue", "eam.version.version1", [("missingFile", "string", "eam.version.version1", F_OPTIONAL)])
< CreateDataType("eam.issue.VmDeployed", "VmDeployed", "eam.issue.VmIssue", "eam.version.version1", None)
< CreateDataType("eam.issue.cluster.agent.InsufficientClusterResources", "ClusterAgentInsufficientClusterResources", "eam.issue.cluster.agent.VmPoweredOff", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.InsufficientClusterSpace", "ClusterAgentInsufficientClusterSpace", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", None)
< CreateDataType("eam.issue.cluster.agent.InvalidConfig", "ClusterAgentInvalidConfig", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", [("error", "anyType", "eam.version.version6_9", 0)])
< CreateDataType("eam.issue.cluster.agent.MissingClusterVmDatastore", "ClusterAgentMissingClusterVmDatastore", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", [("missingDatastores", "vim.Datastore[]", "eam.version.version6_9", F_OPTIONAL)])
< CreateDataType("eam.issue.cluster.agent.MissingClusterVmNetwork", "ClusterAgentMissingClusterVmNetwork", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", [("missingNetworks", "vim.Network[]", "eam.version.version6_9", F_OPTIONAL), ("networkNames", "string[]", "eam.version.version6_9", F_OPTIONAL)])
< CreateDataType("eam.issue.integrity.agency.CannotDeleteSoftware", "IntegrityAgencyCannotDeleteSoftware", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
< CreateDataType("eam.issue.integrity.agency.CannotStageSoftware", "IntegrityAgencyCannotStageSoftware", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
< CreateDataType("eam.issue.personality.agency.CannotConfigureSolutions", "PersonalityAgencyCannotConfigureSolutions", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", [("cr", "vim.ComputeResource", "eam.version.version7_1", 0), ("solutionsToModify", "string[]", "eam.version.version7_1", F_OPTIONAL), ("solutionsToRemove", "string[]", "eam.version.version7_1", F_OPTIONAL)])
< CreateDataType("eam.issue.personality.agency.DepotIssue", "PersonalityAgencyDepotIssue", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", [("remoteDepotUrl", "string", "eam.version.version7_1", 0)])
< CreateDataType("eam.issue.personality.agency.InaccessibleDepot", "PersonalityAgencyInaccessibleDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.personality.agency.InvalidDepot", "PersonalityAgencyInvalidDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.personality.agent.AwaitingPMRemediation", "PersonalityAgentAwaitingPMRemediation", "eam.issue.personality.agent.PMIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.personality.agent.BlockedByAgencyOperation", "PersonalityAgentBlockedByAgencyOperation", "eam.issue.personality.agent.PMIssue", "eam.version.version7_1", None)
< CreateDataType("eam.issue.HostInMaintenanceMode", "HostInMaintenanceMode", "eam.issue.VmDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.HostInStandbyMode", "HostInStandbyMode", "eam.issue.VmDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.HostPoweredOff", "HostPoweredOff", "eam.issue.VmDeployed", "eam.version.version1", None)
< CreateDataType("eam.issue.personality.agency.CannotUploadDepot", "PersonalityAgencyCannotUploadDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", [("localDepotUrl", "string", "eam.version.version7_1", 0)])
---
> # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
> from .VmomiSupport import CreateDataType, CreateManagedType
> from .VmomiSupport import CreateEnumType
> from .VmomiSupport import AddVersion, AddVersionParent
> from .VmomiSupport import AddBreakingChangesInfo
> from .VmomiSupport import F_LINK, F_LINKABLE
> from .VmomiSupport import F_OPTIONAL, F_SECRET
> from .VmomiSupport import newestVersions
> from .VmomiSupport import publicVersions, dottedVersions
> from .VmomiSupport import oldestVersions
> 
> AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
> AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
> AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
> AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
> AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
> AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
> AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
> AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
> AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
> AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
> AddVersion("vmodl.version.version0", "", "", 0, "vim25")
> AddVersion("vmodl.version.version1", "", "", 0, "vim25")
> AddVersion("vmodl.version.version2", "", "", 0, "vim25")
> AddVersion("eam.version.version2_5", "eam", "2_5", 0, "eam")
> AddVersion("eam.version.version6_5", "eam", "6.5", 0, "eam")
> AddVersion("eam.version.version6_8", "eam", "6.8", 0, "eam")
> AddVersion("eam.version.version6_9", "eam", "6.9", 0, "eam")
> AddVersion("eam.version.version6_7", "eam", "6.7", 0, "eam")
> AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
> AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
> AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
> AddVersion("eam.version.version7_3", "eam", "7.3", 0, "eam")
> AddVersion("eam.version.version1", "eam", "1.0", 0, "eam")
> AddVersion("eam.version.version2", "eam", "2.0", 0, "eam")
> AddVersion("eam.version.version7_4", "eam", "7.4", 0, "eam")
> AddVersion("eam.version.version7_1", "eam", "7.1", 0, "eam")
> AddVersion("eam.version.version3", "eam", "3.0", 0, "eam")
> AddVersion("eam.version.version7_2", "eam", "7.2", 0, "eam")
> AddVersion("eam.version.version7_5", "eam", "7.5", 0, "eam")
> AddVersion("eam.version.version7_6", "eam", "7.6", 0, "eam")
> AddVersion("eam.version.version6", "eam", "6.0", 0, "eam")
> AddVersion("eam.version.version7", "eam", "7.0", 0, "eam")
> AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
> AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
> AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version8")
> AddVersionParent("vim.version.version8", "vim.version.version6")
> AddVersionParent("vim.version.version8", "vim.version.version7")
> AddVersionParent("vim.version.version8", "vim.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version4")
> AddVersionParent("vim.version.version8", "vim.version.version5")
> AddVersionParent("vim.version.version8", "vim.version.version2")
> AddVersionParent("vim.version.version8", "vim.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.version.version0")
> AddVersionParent("vim.version.version8", "vmodl.version.version1")
> AddVersionParent("vim.version.version8", "vmodl.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version8")
> AddVersionParent("vim.version.version9", "vim.version.version9")
> AddVersionParent("vim.version.version9", "vim.version.version6")
> AddVersionParent("vim.version.version9", "vim.version.version7")
> AddVersionParent("vim.version.version9", "vim.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version4")
> AddVersionParent("vim.version.version9", "vim.version.version5")
> AddVersionParent("vim.version.version9", "vim.version.version2")
> AddVersionParent("vim.version.version9", "vim.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.version.version0")
> AddVersionParent("vim.version.version9", "vmodl.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version6")
> AddVersionParent("vim.version.version6", "vim.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version4")
> AddVersionParent("vim.version.version6", "vim.version.version5")
> AddVersionParent("vim.version.version6", "vim.version.version2")
> AddVersionParent("vim.version.version6", "vim.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.version.version0")
> AddVersionParent("vim.version.version6", "vmodl.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version6")
> AddVersionParent("vim.version.version7", "vim.version.version7")
> AddVersionParent("vim.version.version7", "vim.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version4")
> AddVersionParent("vim.version.version7", "vim.version.version5")
> AddVersionParent("vim.version.version7", "vim.version.version2")
> AddVersionParent("vim.version.version7", "vim.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.version.version0")
> AddVersionParent("vim.version.version7", "vmodl.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version1", "vim.version.version1")
> AddVersionParent("vim.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version4", "vim.version.version1")
> AddVersionParent("vim.version.version4", "vim.version.version4")
> AddVersionParent("vim.version.version4", "vim.version.version2")
> AddVersionParent("vim.version.version4", "vim.version.version3")
> AddVersionParent("vim.version.version4", "vmodl.version.version0")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version4")
> AddVersionParent("vim.version.version5", "vim.version.version5")
> AddVersionParent("vim.version.version5", "vim.version.version2")
> AddVersionParent("vim.version.version5", "vim.version.version3")
> AddVersionParent("vim.version.version5", "vmodl.version.version0")
> AddVersionParent("vim.version.version5", "vmodl.version.version1")
> AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version2", "vim.version.version1")
> AddVersionParent("vim.version.version2", "vim.version.version2")
> AddVersionParent("vim.version.version2", "vmodl.version.version0")
> AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version3", "vim.version.version1")
> AddVersionParent("vim.version.version3", "vim.version.version2")
> AddVersionParent("vim.version.version3", "vim.version.version3")
> AddVersionParent("vim.version.version3", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
> AddVersionParent("eam.version.version2_5", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version2_5", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version2_5", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version2_5", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version2_5", "vim.version.version8")
> AddVersionParent("eam.version.version2_5", "vim.version.version6")
> AddVersionParent("eam.version.version2_5", "vim.version.version7")
> AddVersionParent("eam.version.version2_5", "vim.version.version1")
> AddVersionParent("eam.version.version2_5", "vim.version.version4")
> AddVersionParent("eam.version.version2_5", "vim.version.version5")
> AddVersionParent("eam.version.version2_5", "vim.version.version2")
> AddVersionParent("eam.version.version2_5", "vim.version.version3")
> AddVersionParent("eam.version.version2_5", "vmodl.version.version0")
> AddVersionParent("eam.version.version2_5", "vmodl.version.version1")
> AddVersionParent("eam.version.version2_5", "vmodl.version.version2")
> AddVersionParent("eam.version.version2_5", "eam.version.version2_5")
> AddVersionParent("eam.version.version2_5", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version2_5", "eam.version.version1")
> AddVersionParent("eam.version.version2_5", "eam.version.version2")
> AddVersionParent("eam.version.version6_5", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version6_5", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version6_5", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version6_5", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version6_5", "vim.version.version8")
> AddVersionParent("eam.version.version6_5", "vim.version.version6")
> AddVersionParent("eam.version.version6_5", "vim.version.version7")
> AddVersionParent("eam.version.version6_5", "vim.version.version1")
> AddVersionParent("eam.version.version6_5", "vim.version.version4")
> AddVersionParent("eam.version.version6_5", "vim.version.version5")
> AddVersionParent("eam.version.version6_5", "vim.version.version2")
> AddVersionParent("eam.version.version6_5", "vim.version.version3")
> AddVersionParent("eam.version.version6_5", "vmodl.version.version0")
> AddVersionParent("eam.version.version6_5", "vmodl.version.version1")
> AddVersionParent("eam.version.version6_5", "vmodl.version.version2")
> AddVersionParent("eam.version.version6_5", "eam.version.version2_5")
> AddVersionParent("eam.version.version6_5", "eam.version.version6_5")
> AddVersionParent("eam.version.version6_5", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version6_5", "eam.version.version1")
> AddVersionParent("eam.version.version6_5", "eam.version.version2")
> AddVersionParent("eam.version.version6_5", "eam.version.version3")
> AddVersionParent("eam.version.version6_5", "eam.version.version6")
> AddVersionParent("eam.version.version6_8", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version6_8", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version6_8", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version6_8", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version6_8", "vim.version.version8")
> AddVersionParent("eam.version.version6_8", "vim.version.version6")
> AddVersionParent("eam.version.version6_8", "vim.version.version7")
> AddVersionParent("eam.version.version6_8", "vim.version.version1")
> AddVersionParent("eam.version.version6_8", "vim.version.version4")
> AddVersionParent("eam.version.version6_8", "vim.version.version5")
> AddVersionParent("eam.version.version6_8", "vim.version.version2")
> AddVersionParent("eam.version.version6_8", "vim.version.version3")
> AddVersionParent("eam.version.version6_8", "vmodl.version.version0")
> AddVersionParent("eam.version.version6_8", "vmodl.version.version1")
> AddVersionParent("eam.version.version6_8", "vmodl.version.version2")
> AddVersionParent("eam.version.version6_8", "eam.version.version2_5")
> AddVersionParent("eam.version.version6_8", "eam.version.version6_5")
> AddVersionParent("eam.version.version6_8", "eam.version.version6_8")
> AddVersionParent("eam.version.version6_8", "eam.version.version6_7")
> AddVersionParent("eam.version.version6_8", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version6_8", "eam.version.version1")
> AddVersionParent("eam.version.version6_8", "eam.version.version2")
> AddVersionParent("eam.version.version6_8", "eam.version.version3")
> AddVersionParent("eam.version.version6_8", "eam.version.version6")
> AddVersionParent("eam.version.version6_9", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version6_9", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version6_9", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version6_9", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version6_9", "vim.version.version8")
> AddVersionParent("eam.version.version6_9", "vim.version.version6")
> AddVersionParent("eam.version.version6_9", "vim.version.version7")
> AddVersionParent("eam.version.version6_9", "vim.version.version1")
> AddVersionParent("eam.version.version6_9", "vim.version.version4")
> AddVersionParent("eam.version.version6_9", "vim.version.version5")
> AddVersionParent("eam.version.version6_9", "vim.version.version2")
> AddVersionParent("eam.version.version6_9", "vim.version.version3")
> AddVersionParent("eam.version.version6_9", "vmodl.version.version0")
> AddVersionParent("eam.version.version6_9", "vmodl.version.version1")
> AddVersionParent("eam.version.version6_9", "vmodl.version.version2")
> AddVersionParent("eam.version.version6_9", "eam.version.version2_5")
> AddVersionParent("eam.version.version6_9", "eam.version.version6_5")
> AddVersionParent("eam.version.version6_9", "eam.version.version6_8")
> AddVersionParent("eam.version.version6_9", "eam.version.version6_9")
> AddVersionParent("eam.version.version6_9", "eam.version.version6_7")
> AddVersionParent("eam.version.version6_9", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version6_9", "eam.version.version1")
> AddVersionParent("eam.version.version6_9", "eam.version.version2")
> AddVersionParent("eam.version.version6_9", "eam.version.version3")
> AddVersionParent("eam.version.version6_9", "eam.version.version6")
> AddVersionParent("eam.version.version6_7", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version6_7", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version6_7", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version6_7", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version6_7", "vim.version.version8")
> AddVersionParent("eam.version.version6_7", "vim.version.version6")
> AddVersionParent("eam.version.version6_7", "vim.version.version7")
> AddVersionParent("eam.version.version6_7", "vim.version.version1")
> AddVersionParent("eam.version.version6_7", "vim.version.version4")
> AddVersionParent("eam.version.version6_7", "vim.version.version5")
> AddVersionParent("eam.version.version6_7", "vim.version.version2")
> AddVersionParent("eam.version.version6_7", "vim.version.version3")
> AddVersionParent("eam.version.version6_7", "vmodl.version.version0")
> AddVersionParent("eam.version.version6_7", "vmodl.version.version1")
> AddVersionParent("eam.version.version6_7", "vmodl.version.version2")
> AddVersionParent("eam.version.version6_7", "eam.version.version2_5")
> AddVersionParent("eam.version.version6_7", "eam.version.version6_5")
> AddVersionParent("eam.version.version6_7", "eam.version.version6_7")
> AddVersionParent("eam.version.version6_7", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version6_7", "eam.version.version1")
> AddVersionParent("eam.version.version6_7", "eam.version.version2")
> AddVersionParent("eam.version.version6_7", "eam.version.version3")
> AddVersionParent("eam.version.version6_7", "eam.version.version6")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version13", "vim.version.version8")
> AddVersionParent("vim.version.version13", "vim.version.version9")
> AddVersionParent("vim.version.version13", "vim.version.version6")
> AddVersionParent("vim.version.version13", "vim.version.version7")
> AddVersionParent("vim.version.version13", "vim.version.version1")
> AddVersionParent("vim.version.version13", "vim.version.version4")
> AddVersionParent("vim.version.version13", "vim.version.version5")
> AddVersionParent("vim.version.version13", "vim.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.version.version0")
> AddVersionParent("vim.version.version13", "vmodl.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version13")
> AddVersionParent("vim.version.version13", "vim.version.version10")
> AddVersionParent("vim.version.version13", "vim.version.version11")
> AddVersionParent("vim.version.version13", "vim.version.version12")
> AddVersionParent("eam.version.version7_3", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_3", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_3", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_3", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_3", "vim.version.version8")
> AddVersionParent("eam.version.version7_3", "vim.version.version9")
> AddVersionParent("eam.version.version7_3", "vim.version.version6")
> AddVersionParent("eam.version.version7_3", "vim.version.version7")
> AddVersionParent("eam.version.version7_3", "vim.version.version1")
> AddVersionParent("eam.version.version7_3", "vim.version.version4")
> AddVersionParent("eam.version.version7_3", "vim.version.version5")
> AddVersionParent("eam.version.version7_3", "vim.version.version2")
> AddVersionParent("eam.version.version7_3", "vim.version.version3")
> AddVersionParent("eam.version.version7_3", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_3", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_3", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_3", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_3", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_3", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_3", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_3", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_3", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_3", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_3", "vim.version.version13")
> AddVersionParent("eam.version.version7_3", "eam.version.version7_3")
> AddVersionParent("eam.version.version7_3", "eam.version.version1")
> AddVersionParent("eam.version.version7_3", "eam.version.version2")
> AddVersionParent("eam.version.version7_3", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_3", "eam.version.version3")
> AddVersionParent("eam.version.version7_3", "eam.version.version7_2")
> AddVersionParent("eam.version.version7_3", "eam.version.version6")
> AddVersionParent("eam.version.version7_3", "eam.version.version7")
> AddVersionParent("eam.version.version7_3", "vim.version.version10")
> AddVersionParent("eam.version.version7_3", "vim.version.version11")
> AddVersionParent("eam.version.version7_3", "vim.version.version12")
> AddVersionParent("eam.version.version1", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version1", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version1", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version1", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version1", "vim.version.version8")
> AddVersionParent("eam.version.version1", "vim.version.version6")
> AddVersionParent("eam.version.version1", "vim.version.version7")
> AddVersionParent("eam.version.version1", "vim.version.version1")
> AddVersionParent("eam.version.version1", "vim.version.version4")
> AddVersionParent("eam.version.version1", "vim.version.version5")
> AddVersionParent("eam.version.version1", "vim.version.version2")
> AddVersionParent("eam.version.version1", "vim.version.version3")
> AddVersionParent("eam.version.version1", "vmodl.version.version0")
> AddVersionParent("eam.version.version1", "vmodl.version.version1")
> AddVersionParent("eam.version.version1", "vmodl.version.version2")
> AddVersionParent("eam.version.version1", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version1", "eam.version.version1")
> AddVersionParent("eam.version.version2", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version2", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version2", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version2", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version2", "vim.version.version8")
> AddVersionParent("eam.version.version2", "vim.version.version6")
> AddVersionParent("eam.version.version2", "vim.version.version7")
> AddVersionParent("eam.version.version2", "vim.version.version1")
> AddVersionParent("eam.version.version2", "vim.version.version4")
> AddVersionParent("eam.version.version2", "vim.version.version5")
> AddVersionParent("eam.version.version2", "vim.version.version2")
> AddVersionParent("eam.version.version2", "vim.version.version3")
> AddVersionParent("eam.version.version2", "vmodl.version.version0")
> AddVersionParent("eam.version.version2", "vmodl.version.version1")
> AddVersionParent("eam.version.version2", "vmodl.version.version2")
> AddVersionParent("eam.version.version2", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version2", "eam.version.version1")
> AddVersionParent("eam.version.version2", "eam.version.version2")
> AddVersionParent("eam.version.version7_4", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_4", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_4", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_4", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_4", "vim.version.version8")
> AddVersionParent("eam.version.version7_4", "vim.version.version9")
> AddVersionParent("eam.version.version7_4", "vim.version.version6")
> AddVersionParent("eam.version.version7_4", "vim.version.version7")
> AddVersionParent("eam.version.version7_4", "vim.version.version1")
> AddVersionParent("eam.version.version7_4", "vim.version.version4")
> AddVersionParent("eam.version.version7_4", "vim.version.version5")
> AddVersionParent("eam.version.version7_4", "vim.version.version2")
> AddVersionParent("eam.version.version7_4", "vim.version.version3")
> AddVersionParent("eam.version.version7_4", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_4", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_4", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_4", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_4", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_4", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_4", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_4", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_4", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_4", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_4", "vim.version.version13")
> AddVersionParent("eam.version.version7_4", "eam.version.version7_3")
> AddVersionParent("eam.version.version7_4", "eam.version.version1")
> AddVersionParent("eam.version.version7_4", "eam.version.version2")
> AddVersionParent("eam.version.version7_4", "eam.version.version7_4")
> AddVersionParent("eam.version.version7_4", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_4", "eam.version.version3")
> AddVersionParent("eam.version.version7_4", "eam.version.version7_2")
> AddVersionParent("eam.version.version7_4", "eam.version.version6")
> AddVersionParent("eam.version.version7_4", "eam.version.version7")
> AddVersionParent("eam.version.version7_4", "vim.version.version10")
> AddVersionParent("eam.version.version7_4", "vim.version.version11")
> AddVersionParent("eam.version.version7_4", "vim.version.version12")
> AddVersionParent("eam.version.version7_1", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_1", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_1", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_1", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_1", "vim.version.version8")
> AddVersionParent("eam.version.version7_1", "vim.version.version9")
> AddVersionParent("eam.version.version7_1", "vim.version.version6")
> AddVersionParent("eam.version.version7_1", "vim.version.version7")
> AddVersionParent("eam.version.version7_1", "vim.version.version1")
> AddVersionParent("eam.version.version7_1", "vim.version.version4")
> AddVersionParent("eam.version.version7_1", "vim.version.version5")
> AddVersionParent("eam.version.version7_1", "vim.version.version2")
> AddVersionParent("eam.version.version7_1", "vim.version.version3")
> AddVersionParent("eam.version.version7_1", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_1", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_1", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_1", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_1", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_1", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_1", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_1", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_1", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_1", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_1", "vim.version.version13")
> AddVersionParent("eam.version.version7_1", "eam.version.version1")
> AddVersionParent("eam.version.version7_1", "eam.version.version2")
> AddVersionParent("eam.version.version7_1", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_1", "eam.version.version3")
> AddVersionParent("eam.version.version7_1", "eam.version.version6")
> AddVersionParent("eam.version.version7_1", "eam.version.version7")
> AddVersionParent("eam.version.version7_1", "vim.version.version10")
> AddVersionParent("eam.version.version7_1", "vim.version.version11")
> AddVersionParent("eam.version.version7_1", "vim.version.version12")
> AddVersionParent("eam.version.version3", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version3", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version3", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version3", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version3", "vim.version.version8")
> AddVersionParent("eam.version.version3", "vim.version.version6")
> AddVersionParent("eam.version.version3", "vim.version.version7")
> AddVersionParent("eam.version.version3", "vim.version.version1")
> AddVersionParent("eam.version.version3", "vim.version.version4")
> AddVersionParent("eam.version.version3", "vim.version.version5")
> AddVersionParent("eam.version.version3", "vim.version.version2")
> AddVersionParent("eam.version.version3", "vim.version.version3")
> AddVersionParent("eam.version.version3", "vmodl.version.version0")
> AddVersionParent("eam.version.version3", "vmodl.version.version1")
> AddVersionParent("eam.version.version3", "vmodl.version.version2")
> AddVersionParent("eam.version.version3", "eam.version.version2_5")
> AddVersionParent("eam.version.version3", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version3", "eam.version.version1")
> AddVersionParent("eam.version.version3", "eam.version.version2")
> AddVersionParent("eam.version.version3", "eam.version.version3")
> AddVersionParent("eam.version.version7_2", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_2", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_2", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_2", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_2", "vim.version.version8")
> AddVersionParent("eam.version.version7_2", "vim.version.version9")
> AddVersionParent("eam.version.version7_2", "vim.version.version6")
> AddVersionParent("eam.version.version7_2", "vim.version.version7")
> AddVersionParent("eam.version.version7_2", "vim.version.version1")
> AddVersionParent("eam.version.version7_2", "vim.version.version4")
> AddVersionParent("eam.version.version7_2", "vim.version.version5")
> AddVersionParent("eam.version.version7_2", "vim.version.version2")
> AddVersionParent("eam.version.version7_2", "vim.version.version3")
> AddVersionParent("eam.version.version7_2", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_2", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_2", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_2", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_2", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_2", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_2", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_2", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_2", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_2", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_2", "vim.version.version13")
> AddVersionParent("eam.version.version7_2", "eam.version.version1")
> AddVersionParent("eam.version.version7_2", "eam.version.version2")
> AddVersionParent("eam.version.version7_2", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_2", "eam.version.version3")
> AddVersionParent("eam.version.version7_2", "eam.version.version7_2")
> AddVersionParent("eam.version.version7_2", "eam.version.version6")
> AddVersionParent("eam.version.version7_2", "eam.version.version7")
> AddVersionParent("eam.version.version7_2", "vim.version.version10")
> AddVersionParent("eam.version.version7_2", "vim.version.version11")
> AddVersionParent("eam.version.version7_2", "vim.version.version12")
> AddVersionParent("eam.version.version7_5", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_5", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_5", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_5", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_5", "vim.version.version8")
> AddVersionParent("eam.version.version7_5", "vim.version.version9")
> AddVersionParent("eam.version.version7_5", "vim.version.version6")
> AddVersionParent("eam.version.version7_5", "vim.version.version7")
> AddVersionParent("eam.version.version7_5", "vim.version.version1")
> AddVersionParent("eam.version.version7_5", "vim.version.version4")
> AddVersionParent("eam.version.version7_5", "vim.version.version5")
> AddVersionParent("eam.version.version7_5", "vim.version.version2")
> AddVersionParent("eam.version.version7_5", "vim.version.version3")
> AddVersionParent("eam.version.version7_5", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_5", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_5", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_5", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_5", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_5", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_5", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_5", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_5", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_5", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_5", "vim.version.version13")
> AddVersionParent("eam.version.version7_5", "eam.version.version7_3")
> AddVersionParent("eam.version.version7_5", "eam.version.version1")
> AddVersionParent("eam.version.version7_5", "eam.version.version2")
> AddVersionParent("eam.version.version7_5", "eam.version.version7_4")
> AddVersionParent("eam.version.version7_5", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_5", "eam.version.version3")
> AddVersionParent("eam.version.version7_5", "eam.version.version7_2")
> AddVersionParent("eam.version.version7_5", "eam.version.version7_5")
> AddVersionParent("eam.version.version7_5", "eam.version.version6")
> AddVersionParent("eam.version.version7_5", "eam.version.version7")
> AddVersionParent("eam.version.version7_5", "vim.version.version10")
> AddVersionParent("eam.version.version7_5", "vim.version.version11")
> AddVersionParent("eam.version.version7_5", "vim.version.version12")
> AddVersionParent("eam.version.version7_6", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7_6", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7_6", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7_6", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7_6", "vim.version.version8")
> AddVersionParent("eam.version.version7_6", "vim.version.version9")
> AddVersionParent("eam.version.version7_6", "vim.version.version6")
> AddVersionParent("eam.version.version7_6", "vim.version.version7")
> AddVersionParent("eam.version.version7_6", "vim.version.version1")
> AddVersionParent("eam.version.version7_6", "vim.version.version4")
> AddVersionParent("eam.version.version7_6", "vim.version.version5")
> AddVersionParent("eam.version.version7_6", "vim.version.version2")
> AddVersionParent("eam.version.version7_6", "vim.version.version3")
> AddVersionParent("eam.version.version7_6", "vmodl.version.version0")
> AddVersionParent("eam.version.version7_6", "vmodl.version.version1")
> AddVersionParent("eam.version.version7_6", "vmodl.version.version2")
> AddVersionParent("eam.version.version7_6", "eam.version.version2_5")
> AddVersionParent("eam.version.version7_6", "eam.version.version6_5")
> AddVersionParent("eam.version.version7_6", "eam.version.version6_8")
> AddVersionParent("eam.version.version7_6", "eam.version.version6_9")
> AddVersionParent("eam.version.version7_6", "eam.version.version6_7")
> AddVersionParent("eam.version.version7_6", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7_6", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7_6", "vim.version.version13")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_3")
> AddVersionParent("eam.version.version7_6", "eam.version.version1")
> AddVersionParent("eam.version.version7_6", "eam.version.version2")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_4")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_1")
> AddVersionParent("eam.version.version7_6", "eam.version.version3")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_2")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_5")
> AddVersionParent("eam.version.version7_6", "eam.version.version7_6")
> AddVersionParent("eam.version.version7_6", "eam.version.version6")
> AddVersionParent("eam.version.version7_6", "eam.version.version7")
> AddVersionParent("eam.version.version7_6", "vim.version.version10")
> AddVersionParent("eam.version.version7_6", "vim.version.version11")
> AddVersionParent("eam.version.version7_6", "vim.version.version12")
> AddVersionParent("eam.version.version6", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version6", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version6", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version6", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version6", "vim.version.version8")
> AddVersionParent("eam.version.version6", "vim.version.version6")
> AddVersionParent("eam.version.version6", "vim.version.version7")
> AddVersionParent("eam.version.version6", "vim.version.version1")
> AddVersionParent("eam.version.version6", "vim.version.version4")
> AddVersionParent("eam.version.version6", "vim.version.version5")
> AddVersionParent("eam.version.version6", "vim.version.version2")
> AddVersionParent("eam.version.version6", "vim.version.version3")
> AddVersionParent("eam.version.version6", "vmodl.version.version0")
> AddVersionParent("eam.version.version6", "vmodl.version.version1")
> AddVersionParent("eam.version.version6", "vmodl.version.version2")
> AddVersionParent("eam.version.version6", "eam.version.version2_5")
> AddVersionParent("eam.version.version6", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version6", "eam.version.version1")
> AddVersionParent("eam.version.version6", "eam.version.version2")
> AddVersionParent("eam.version.version6", "eam.version.version3")
> AddVersionParent("eam.version.version6", "eam.version.version6")
> AddVersionParent("eam.version.version7", "vmodl.query.version.version4")
> AddVersionParent("eam.version.version7", "vmodl.query.version.version3")
> AddVersionParent("eam.version.version7", "vmodl.query.version.version2")
> AddVersionParent("eam.version.version7", "vmodl.query.version.version1")
> AddVersionParent("eam.version.version7", "vim.version.version8")
> AddVersionParent("eam.version.version7", "vim.version.version9")
> AddVersionParent("eam.version.version7", "vim.version.version6")
> AddVersionParent("eam.version.version7", "vim.version.version7")
> AddVersionParent("eam.version.version7", "vim.version.version1")
> AddVersionParent("eam.version.version7", "vim.version.version4")
> AddVersionParent("eam.version.version7", "vim.version.version5")
> AddVersionParent("eam.version.version7", "vim.version.version2")
> AddVersionParent("eam.version.version7", "vim.version.version3")
> AddVersionParent("eam.version.version7", "vmodl.version.version0")
> AddVersionParent("eam.version.version7", "vmodl.version.version1")
> AddVersionParent("eam.version.version7", "vmodl.version.version2")
> AddVersionParent("eam.version.version7", "eam.version.version2_5")
> AddVersionParent("eam.version.version7", "eam.version.version6_5")
> AddVersionParent("eam.version.version7", "eam.version.version6_8")
> AddVersionParent("eam.version.version7", "eam.version.version6_9")
> AddVersionParent("eam.version.version7", "eam.version.version6_7")
> AddVersionParent("eam.version.version7", "vmodl.reflect.version.version1")
> AddVersionParent("eam.version.version7", "vmodl.reflect.version.version2")
> AddVersionParent("eam.version.version7", "vim.version.version13")
> AddVersionParent("eam.version.version7", "eam.version.version1")
> AddVersionParent("eam.version.version7", "eam.version.version2")
> AddVersionParent("eam.version.version7", "eam.version.version3")
> AddVersionParent("eam.version.version7", "eam.version.version6")
> AddVersionParent("eam.version.version7", "eam.version.version7")
> AddVersionParent("eam.version.version7", "vim.version.version10")
> AddVersionParent("eam.version.version7", "vim.version.version11")
> AddVersionParent("eam.version.version7", "vim.version.version12")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version10", "vim.version.version8")
> AddVersionParent("vim.version.version10", "vim.version.version9")
> AddVersionParent("vim.version.version10", "vim.version.version6")
> AddVersionParent("vim.version.version10", "vim.version.version7")
> AddVersionParent("vim.version.version10", "vim.version.version1")
> AddVersionParent("vim.version.version10", "vim.version.version4")
> AddVersionParent("vim.version.version10", "vim.version.version5")
> AddVersionParent("vim.version.version10", "vim.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version3")
> AddVersionParent("vim.version.version10", "vmodl.version.version0")
> AddVersionParent("vim.version.version10", "vmodl.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version10")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version11", "vim.version.version8")
> AddVersionParent("vim.version.version11", "vim.version.version9")
> AddVersionParent("vim.version.version11", "vim.version.version6")
> AddVersionParent("vim.version.version11", "vim.version.version7")
> AddVersionParent("vim.version.version11", "vim.version.version1")
> AddVersionParent("vim.version.version11", "vim.version.version4")
> AddVersionParent("vim.version.version11", "vim.version.version5")
> AddVersionParent("vim.version.version11", "vim.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.version.version0")
> AddVersionParent("vim.version.version11", "vmodl.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version10")
> AddVersionParent("vim.version.version11", "vim.version.version11")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version12", "vim.version.version8")
> AddVersionParent("vim.version.version12", "vim.version.version9")
> AddVersionParent("vim.version.version12", "vim.version.version6")
> AddVersionParent("vim.version.version12", "vim.version.version7")
> AddVersionParent("vim.version.version12", "vim.version.version1")
> AddVersionParent("vim.version.version12", "vim.version.version4")
> AddVersionParent("vim.version.version12", "vim.version.version5")
> AddVersionParent("vim.version.version12", "vim.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.version.version0")
> AddVersionParent("vim.version.version12", "vmodl.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version10")
> AddVersionParent("vim.version.version12", "vim.version.version11")
> AddVersionParent("vim.version.version12", "vim.version.version12")
> 
> newestVersions.Add("eam.version.version7_6")
> publicVersions.Add("eam.version.version7_6")
> dottedVersions.Add("eam.version.version7_6")
> oldestVersions.Add("eam.version.version1")
> 
> CreateManagedType("eam.EamObject", "EamObject", "vmodl.ManagedObject", "eam.version.version1", None, [("resolve", "Resolve", "eam.version.version1", (("issueKey", "int[]", "eam.version.version1", 0, None),), (F_OPTIONAL, "int[]", "int[]"), None, None), ("resolveAll", "ResolveAll", "eam.version.version1", (), (0, "void", "void"), None, None), ("queryIssue", "QueryIssue", "eam.version.version1", (("issueKey", "int[]", "eam.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "eam.issue.Issue[]", "eam.issue.Issue[]"), None, None)])
> CreateDataType("eam.EamObject.RuntimeInfo", "EamObjectRuntimeInfo", "vmodl.DynamicData", "eam.version.version1", [("status", "string", "eam.version.version1", 0), ("issue", "eam.issue.Issue[]", "eam.version.version1", F_OPTIONAL), ("goalState", "string", "eam.version.version1", 0), ("entity", "eam.EamObject", "eam.version.version1", 0)])
> CreateEnumType("eam.EamObject.RuntimeInfo.Status", "EamObjectRuntimeInfoStatus", "eam.version.version1", ["green", "yellow", "red"])
> CreateEnumType("eam.EamObject.RuntimeInfo.GoalState", "EamObjectRuntimeInfoGoalState", "eam.version.version1", ["enabled", "disabled", "uninstalled"])
> CreateManagedType("eam.Task", "EamTask", "vmodl.ManagedObject", "eam.version.version1", None, None)
> CreateDataType("eam.fault.EamFault", "EamFault", "vmodl.MethodFault", "eam.version.version1", None)
> CreateDataType("eam.fault.EamRuntimeFault", "EamRuntimeFault", "vmodl.RuntimeFault", "eam.version.version1", None)
> CreateDataType("eam.fault.EamServiceNotInitialized", "EamServiceNotInitialized", "eam.fault.EamRuntimeFault", "eam.version.version6_5", None)
> CreateDataType("eam.fault.EamSystemFault", "EamSystemFault", "eam.fault.EamRuntimeFault", "eam.version.version6_5", None)
> CreateDataType("eam.fault.InvalidAgencyScope", "InvalidAgencyScope", "eam.fault.EamFault", "eam.version.version1", [("unknownComputeResource", "vim.ComputeResource[]", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.fault.InvalidLogin", "EamInvalidLogin", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
> CreateDataType("eam.fault.InvalidUrl", "InvalidUrl", "eam.fault.EamFault", "eam.version.version1", [("url", "string", "eam.version.version1", 0), ("malformedUrl", "boolean", "eam.version.version1", 0), ("unknownHost", "boolean", "eam.version.version1", 0), ("connectionRefused", "boolean", "eam.version.version1", 0), ("responseCode", "int", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.fault.InvalidVibPackage", "EamInvalidVibPackage", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
> CreateDataType("eam.fault.NoConnectionToVCenter", "NoConnectionToVCenter", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
> CreateDataType("eam.fault.NotAuthorized", "NotAuthorized", "eam.fault.EamRuntimeFault", "eam.version.version1", None)
> CreateDataType("eam.issue.Issue", "Issue", "vmodl.DynamicData", "eam.version.version1", [("key", "int", "eam.version.version1", 0), ("description", "string", "eam.version.version1", 0), ("time", "vmodl.DateTime", "eam.version.version1", 0)])
> CreateDataType("eam.vib.VibInfo", "VibVibInfo", "vmodl.DynamicData", "eam.version.version6", [("id", "string", "eam.version.version6", 0), ("name", "string", "eam.version.version6", 0), ("version", "string", "eam.version.version6", 0), ("vendor", "string", "eam.version.version6", 0), ("summary", "string", "eam.version.version6", 0), ("softwareTags", "eam.vib.VibInfo.SoftwareTags", "eam.version.version6_5", F_OPTIONAL), ("releaseDate", "vmodl.DateTime", "eam.version.version6", 0)])
> CreateDataType("eam.vib.VibInfo.SoftwareTags", "VibVibInfoSoftwareTags", "vmodl.DynamicData", "eam.version.version6_5", [("tags", "string[]", "eam.version.version6_5", F_OPTIONAL)])
> CreateManagedType("eam.Agent", "Agent", "eam.EamObject", "eam.version.version1", [("runtime", "eam.Agent.RuntimeInfo", "eam.version.version1", 0, None), ("config", "eam.Agent.ConfigInfo", "eam.version.version1", 0, None)], [("queryRuntime", "AgentQueryRuntime", "eam.version.version1", (), (0, "eam.Agent.RuntimeInfo", "eam.Agent.RuntimeInfo"), None, None), ("markAsAvailable", "MarkAsAvailable", "eam.version.version1", (), (0, "void", "void"), None, None), ("queryConfig", "AgentQueryConfig", "eam.version.version1", (), (0, "eam.Agent.ConfigInfo", "eam.Agent.ConfigInfo"), None, None)])
> CreateDataType("eam.Agent.RuntimeInfo", "AgentRuntimeInfo", "eam.EamObject.RuntimeInfo", "eam.version.version1", [("vmPowerState", "vim.VirtualMachine.PowerState", "eam.version.version1", 0), ("receivingHeartBeat", "boolean", "eam.version.version1", 0), ("host", "vim.HostSystem", "eam.version.version1", F_OPTIONAL), ("vm", "vim.VirtualMachine", "eam.version.version1", F_OPTIONAL), ("vmIp", "string", "eam.version.version1", F_OPTIONAL), ("vmName", "string", "eam.version.version1", 0), ("esxAgentResourcePool", "vim.ResourcePool", "eam.version.version1", F_OPTIONAL), ("esxAgentFolder", "vim.Folder", "eam.version.version1", F_OPTIONAL), ("installedBulletin", "string[]", "eam.version.version1", F_OPTIONAL), ("installedVibs", "eam.vib.VibInfo[]", "eam.version.version6", F_OPTIONAL), ("agency", "eam.Agency", "eam.version.version2", F_OPTIONAL), ("vmHook", "eam.Agent.VmHook", "eam.version.version6_7", F_OPTIONAL)])
> CreateDataType("eam.Agent.VmHook", "AgentVmHook", "vmodl.DynamicData", "eam.version.version6_7", [("vm", "vim.VirtualMachine", "eam.version.version6_7", 0), ("vmState", "string", "eam.version.version6_7", 0)])
> CreateEnumType("eam.Agent.VmHook.VmState", "AgentVmHookVmState", "eam.version.version1", ["provisioned", "poweredOn", "prePowerOn"])
> CreateDataType("eam.Agent.StoragePolicy", "AgentStoragePolicy", "vmodl.DynamicData", "eam.version.version7", None)
> CreateDataType("eam.Agent.VsanStoragePolicy", "AgentVsanStoragePolicy", "eam.Agent.StoragePolicy", "eam.version.version7", [("profileId", "string", "eam.version.version7", 0)])
> CreateDataType("eam.Agent.ConfigInfo", "AgentConfigInfo", "vmodl.DynamicData", "eam.version.version1", [("productLineId", "string", "eam.version.version1", F_OPTIONAL), ("hostVersion", "string", "eam.version.version1", F_OPTIONAL), ("ovfPackageUrl", "string", "eam.version.version1", F_OPTIONAL), ("ovfEnvironment", "eam.Agent.OvfEnvironmentInfo", "eam.version.version1", F_OPTIONAL), ("vibUrl", "string", "eam.version.version1", F_OPTIONAL), ("vibMatchingRules", "eam.Agent.VibMatchingRule[]", "eam.version.version2_5", F_OPTIONAL), ("vibName", "string", "eam.version.version2", F_OPTIONAL), ("dvFilterEnabled", "boolean", "eam.version.version1", F_OPTIONAL), ("rebootHostAfterVibUninstall", "boolean", "eam.version.version1", F_OPTIONAL), ("vmciService", "string[]", "eam.version.version1", F_OPTIONAL), ("ovfDiskProvisioning", "string", "eam.version.version6_9", F_OPTIONAL), ("vmStoragePolicies", "eam.Agent.StoragePolicy[]", "eam.version.version7", F_OPTIONAL)])
> CreateEnumType("eam.Agent.ConfigInfo.OvfDiskProvisioning", "AgentConfigInfoOvfDiskProvisioning", "eam.version.version6_9", ["none", "thin", "thick"])
> CreateDataType("eam.Agent.OvfEnvironmentInfo", "AgentOvfEnvironmentInfo", "vmodl.DynamicData", "eam.version.version1", [("ovfProperty", "eam.Agent.OvfEnvironmentInfo.OvfProperty[]", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.Agent.OvfEnvironmentInfo.OvfProperty", "AgentOvfEnvironmentInfoOvfProperty", "vmodl.DynamicData", "eam.version.version1", [("key", "string", "eam.version.version1", 0), ("value", "string", "eam.version.version1", 0)])
> CreateDataType("eam.Agent.VibMatchingRule", "AgentVibMatchingRule", "vmodl.DynamicData", "eam.version.version1", [("vibNameRegex", "string", "eam.version.version1", 0), ("vibVersionRegex", "string", "eam.version.version1", 0)])
> CreateDataType("eam.fault.EamAppFault", "EamAppFault", "eam.fault.EamRuntimeFault", "eam.version.version6", None)
> CreateDataType("eam.fault.EamIOFault", "EamIOFault", "eam.fault.EamRuntimeFault", "eam.version.version6", None)
> CreateDataType("eam.fault.InvalidAgentConfiguration", "InvalidAgentConfiguration", "eam.fault.EamFault", "eam.version.version1", [("invalidAgentConfiguration", "eam.Agent.ConfigInfo", "eam.version.version1", F_OPTIONAL), ("invalidField", "string", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.fault.InvalidState", "EamInvalidState", "eam.fault.EamAppFault", "eam.version.version7_1", None)
> CreateDataType("eam.issue.AgencyIssue", "AgencyIssue", "eam.issue.Issue", "eam.version.version1", [("agency", "eam.Agency", "eam.version.version1", 0), ("agencyName", "string", "eam.version.version1", 0), ("solutionId", "string", "eam.version.version1", 0), ("solutionName", "string", "eam.version.version1", 0)])
> CreateDataType("eam.issue.AgentIssue", "AgentIssue", "eam.issue.AgencyIssue", "eam.version.version1", [("agent", "eam.Agent", "eam.version.version1", 0), ("agentName", "string", "eam.version.version1", 0), ("host", "vim.HostSystem", "eam.version.version1", 0), ("hostName", "string", "eam.version.version1", 0)])
> CreateDataType("eam.issue.ExtensibleIssue", "ExtensibleIssue", "eam.issue.Issue", "eam.version.version2", [("typeId", "string", "eam.version.version2", 0), ("argument", "vmodl.KeyAnyValue[]", "eam.version.version2", F_OPTIONAL), ("target", "vim.ManagedEntity", "eam.version.version2", F_OPTIONAL), ("agent", "eam.Agent", "eam.version.version2", F_OPTIONAL), ("agency", "eam.Agency", "eam.version.version2", F_OPTIONAL)])
> CreateDataType("eam.issue.HostIssue", "HostIssue", "eam.issue.Issue", "eam.version.version1", [("host", "vim.HostSystem", "eam.version.version1", 0)])
> CreateDataType("eam.issue.HostNotReachable", "ManagedHostNotReachable", "eam.issue.AgentIssue", "eam.version.version6_8", None)
> CreateDataType("eam.issue.MissingDvFilterSwitch", "MissingDvFilterSwitch", "eam.issue.AgentIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.OrphanedAgency", "OrphanedAgency", "eam.issue.AgencyIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.OrphanedDvFilterSwitch", "OrphanedDvFilterSwitch", "eam.issue.HostIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.OvfInvalidProperty", "OvfInvalidProperty", "eam.issue.AgentIssue", "eam.version.version1", [("error", "vmodl.MethodFault[]", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.issue.UnknownAgentVm", "UnknownAgentVm", "eam.issue.HostIssue", "eam.version.version1", [("vm", "vim.VirtualMachine", "eam.version.version1", 0)])
> CreateDataType("eam.issue.VibIssue", "VibIssue", "eam.issue.AgentIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VibNotInstalled", "VibNotInstalled", "eam.issue.VibIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VibRequirementsNotMetByHost", "VibRequirementsNotMetByHost", "eam.issue.VibNotInstalled", "eam.version.version6_8", None)
> CreateDataType("eam.issue.VibRequiresHostInMaintenanceMode", "VibRequiresHostInMaintenanceMode", "eam.issue.VibIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VibRequiresHostReboot", "VibRequiresHostReboot", "eam.issue.VibIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VibRequiresManualInstallation", "VibRequiresManualInstallation", "eam.issue.VibIssue", "eam.version.version1", [("bulletin", "string[]", "eam.version.version1", 0)])
> CreateDataType("eam.issue.VibRequiresManualUninstallation", "VibRequiresManualUninstallation", "eam.issue.VibIssue", "eam.version.version1", [("bulletin", "string[]", "eam.version.version1", 0)])
> CreateDataType("eam.issue.VmIssue", "VmIssue", "eam.issue.AgentIssue", "eam.version.version1", [("vm", "vim.VirtualMachine", "eam.version.version1", 0)])
> CreateDataType("eam.issue.VmMarkedAsTemplate", "VmMarkedAsTemplate", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmNotDeployed", "VmNotDeployed", "eam.issue.AgentIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmOrphaned", "VmOrphaned", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmPoweredOff", "VmPoweredOff", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmPoweredOn", "VmPoweredOn", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmRequiresHostOutOfMaintenanceMode", "VmRequiresHostOutOfMaintenanceMode", "eam.issue.VmNotDeployed", "eam.version.version7_2", None)
> CreateDataType("eam.issue.VmSuspended", "VmSuspended", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VmWrongFolder", "VmWrongFolder", "eam.issue.VmIssue", "eam.version.version1", [("currentFolder", "vim.Folder", "eam.version.version1", 0), ("requiredFolder", "vim.Folder", "eam.version.version1", 0)])
> CreateDataType("eam.issue.VmWrongResourcePool", "VmWrongResourcePool", "eam.issue.VmIssue", "eam.version.version1", [("currentResourcePool", "vim.ResourcePool", "eam.version.version1", 0), ("requiredResourcePool", "vim.ResourcePool", "eam.version.version1", 0)])
> CreateDataType("eam.issue.cluster.agent.AgentIssue", "ClusterAgentAgentIssue", "eam.issue.AgencyIssue", "eam.version.version6_9", [("agent", "eam.Agent", "eam.version.version6_9", 0), ("cluster", "vim.ComputeResource", "eam.version.version6_9", F_OPTIONAL)])
> CreateDataType("eam.issue.cluster.agent.OvfInvalidProperty", "ClusterAgentOvfInvalidProperty", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", [("error", "vmodl.MethodFault[]", "eam.version.version6_9", F_OPTIONAL)])
> CreateDataType("eam.issue.cluster.agent.VmIssue", "ClusterAgentVmIssue", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", [("vm", "vim.VirtualMachine", "eam.version.version6_9", 0)])
> CreateDataType("eam.issue.cluster.agent.VmNotDeployed", "ClusterAgentVmNotDeployed", "eam.issue.cluster.agent.AgentIssue", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.VmNotRemoved", "ClusterAgentVmNotRemoved", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.VmPoweredOff", "ClusterAgentVmPoweredOff", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.VmPoweredOn", "ClusterAgentVmPoweredOn", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.VmSuspended", "ClusterAgentVmSuspended", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", None)
> CreateDataType("eam.issue.integrity.agency.VUMIssue", "IntegrityAgencyVUMIssue", "eam.issue.AgencyIssue", "eam.version.version6_7", None)
> CreateDataType("eam.issue.integrity.agency.VUMUnavailable", "IntegrityAgencyVUMUnavailable", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
> CreateDataType("eam.issue.personality.agency.PMIssue", "PersonalityAgencyPMIssue", "eam.issue.AgencyIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.personality.agency.PMUnavailable", "PersonalityAgencyPMUnavailable", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.personality.agent.PMIssue", "PersonalityAgentPMIssue", "eam.issue.AgentIssue", "eam.version.version7_1", None)
> CreateManagedType("eam.Agency", "Agency", "eam.EamObject", "eam.version.version1", [("solutionId", "string", "eam.version.version1", 0, None), ("owner", "string", "eam.version.version6", F_OPTIONAL, None), ("config", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None), ("runtime", "eam.EamObject.RuntimeInfo", "eam.version.version1", 0, None), ("agent", "eam.Agent[]", "eam.version.version1", F_OPTIONAL, None)], [("querySolutionId", "QuerySolutionId", "eam.version.version1", (), (0, "string", "string"), None, None), ("queryConfig", "QueryConfig", "eam.version.version1", (), (0, "eam.Agency.ConfigInfo", "eam.Agency.ConfigInfo"), None, None), ("update", "Update", "eam.version.version1", (("config", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None),), (0, "void", "void"), None, ["eam.fault.InvalidAgentConfiguration", "eam.fault.InvalidAgencyScope", "eam.fault.InvalidUrl", ]), ("queryRuntime", "AgencyQueryRuntime", "eam.version.version1", (), (0, "eam.EamObject.RuntimeInfo", "eam.EamObject.RuntimeInfo"), None, None), ("queryAgent", "QueryAgent", "eam.version.version1", (), (F_OPTIONAL, "eam.Agent[]", "eam.Agent[]"), None, None), ("registerAgentVm", "RegisterAgentVm", "eam.version.version2", (("agentVm", "vim.VirtualMachine", "eam.version.version2", 0, None),), (0, "eam.Agent", "eam.Agent"), None, ["vmodl.fault.ManagedObjectNotFound", ]), ("unregisterAgentVm", "UnregisterAgentVm", "eam.version.version2", (("agentVm", "vim.VirtualMachine", "eam.version.version2", 0, None),), (0, "void", "void"), None, None), ("enable", "Agency_Enable", "eam.version.version1", (), (0, "void", "void"), None, None), ("disable", "Agency_Disable", "eam.version.version1", (), (0, "void", "void"), None, None), ("uninstall", "Uninstall", "eam.version.version1", (), (0, "void", "void"), None, None), ("destroyAgency", "DestroyAgency", "eam.version.version1", (), (0, "void", "void"), None, None), ("addIssue", "AddIssue", "eam.version.version2", (("issue", "eam.issue.Issue", "eam.version.version2", 0, None),), (0, "eam.issue.Issue", "eam.issue.Issue"), None, ["vmodl.fault.InvalidArgument", ])])
> CreateDataType("eam.Agency.VMResourcePool", "AgencyVMResourcePool", "vmodl.DynamicData", "eam.version.version6_9", [("resourcePoolId", "vim.ResourcePool", "eam.version.version6_9", 0), ("computeResourceId", "vim.ComputeResource", "eam.version.version6_9", 0)])
> CreateDataType("eam.Agency.VMFolder", "AgencyVMFolder", "vmodl.DynamicData", "eam.version.version6_9", [("folderId", "vim.Folder", "eam.version.version6_9", 0), ("datacenterId", "vim.Datacenter", "eam.version.version6_9", 0)])
> CreateEnumType("eam.Agency.VMPlacementPolicy.VMDataAffinity", "AgencyVMPlacementPolicyVMDataAffinity", "eam.version.version1", ["none", "soft"])
> CreateEnumType("eam.Agency.VMPlacementPolicy.VMAntiAffinity", "AgencyVMPlacementPolicyVMAntiAffinity", "eam.version.version1", ["none", "soft"])
> CreateDataType("eam.Agency.ConfigInfo", "AgencyConfigInfo", "vmodl.DynamicData", "eam.version.version1", [("agentConfig", "eam.Agent.ConfigInfo[]", "eam.version.version1", F_OPTIONAL), ("scope", "eam.Agency.Scope", "eam.version.version1", F_OPTIONAL), ("manuallyMarkAgentVmAvailableAfterProvisioning", "boolean", "eam.version.version1", F_OPTIONAL), ("manuallyMarkAgentVmAvailableAfterPowerOn", "boolean", "eam.version.version1", F_OPTIONAL), ("optimizedDeploymentEnabled", "boolean", "eam.version.version1", F_OPTIONAL), ("agentName", "string", "eam.version.version1", F_OPTIONAL), ("agencyName", "string", "eam.version.version1", F_OPTIONAL), ("useUuidVmName", "boolean", "eam.version.version7_5", F_OPTIONAL), ("manuallyProvisioned", "boolean", "eam.version.version2", F_OPTIONAL), ("manuallyMonitored", "boolean", "eam.version.version2", F_OPTIONAL), ("bypassVumEnabled", "boolean", "eam.version.version2", F_OPTIONAL), ("agentVmNetwork", "vim.Network[]", "eam.version.version2", F_OPTIONAL), ("agentVmDatastore", "vim.Datastore[]", "eam.version.version2_5", F_OPTIONAL), ("preferHostConfiguration", "boolean", "eam.version.version2_5", F_OPTIONAL), ("ipPool", "vim.vApp.IpPool", "eam.version.version3", F_OPTIONAL), ("resourcePools", "eam.Agency.VMResourcePool[]", "eam.version.version6_9", F_OPTIONAL), ("folders", "eam.Agency.VMFolder[]", "eam.version.version6_9", F_OPTIONAL)])
> CreateDataType("eam.Agency.Scope", "AgencyScope", "vmodl.DynamicData", "eam.version.version1", None)
> CreateDataType("eam.Agency.ComputeResourceScope", "AgencyComputeResourceScope", "eam.Agency.Scope", "eam.version.version1", [("computeResource", "vim.ComputeResource[]", "eam.version.version1", F_OPTIONAL)])
> CreateManagedType("eam.EsxAgentManager", "EsxAgentManager", "eam.EamObject", "eam.version.version1", [("agency", "eam.Agency[]", "eam.version.version1", F_OPTIONAL, None), ("issue", "eam.issue.Issue[]", "eam.version.version1", F_OPTIONAL, None)], [("queryAgency", "QueryAgency", "eam.version.version1", (), (F_OPTIONAL, "eam.Agency[]", "eam.Agency[]"), None, None), ("createAgency", "CreateAgency", "eam.version.version1", (("agencyConfigInfo", "eam.Agency.ConfigInfo", "eam.version.version1", 0, None),("initialGoalState", "string", "eam.version.version1", 0, None),), (0, "eam.Agency", "eam.Agency"), None, ["eam.fault.InvalidAgentConfiguration", "eam.fault.InvalidAgencyScope", "eam.fault.InvalidUrl", ]), ("scanForUnknownAgentVm", "ScanForUnknownAgentVm", "eam.version.version1", (), (0, "void", "void"), None, None), ("setMaintenanceModePolicy", "SetMaintenanceModePolicy", "eam.version.version7_4", (("policy", "string", "eam.version.version7_4", 0, None),), (0, "void", "void"), None, None), ("getMaintenanceModePolicy", "GetMaintenanceModePolicy", "eam.version.version7_4", (), (0, "string", "string"), None, None)])
> CreateEnumType("eam.EsxAgentManager.MaintenanceModePolicy", "EsxAgentManagerMaintenanceModePolicy", "eam.version.version7_4", ["singleHost", "multipleHosts"])
> CreateDataType("eam.fault.DisabledClusterFault", "DisabledClusterFault", "eam.fault.EamAppFault", "eam.version.version7_6", [("disabledComputeResource", "vim.ComputeResource[]", "eam.version.version7_6", F_OPTIONAL)])
> CreateDataType("eam.issue.AgencyDisabled", "AgencyDisabled", "eam.issue.AgencyIssue", "eam.version.version7_6", None)
> CreateDataType("eam.issue.CannotAccessAgentOVF", "CannotAccessAgentOVF", "eam.issue.VmNotDeployed", "eam.version.version1", [("downloadUrl", "string", "eam.version.version1", 0)])
> CreateDataType("eam.issue.CannotAccessAgentVib", "CannotAccessAgentVib", "eam.issue.VibNotInstalled", "eam.version.version1", [("downloadUrl", "string", "eam.version.version1", 0)])
> CreateDataType("eam.issue.ImmediateHostRebootRequired", "ImmediateHostRebootRequired", "eam.issue.VibIssue", "eam.version.version6_8", None)
> CreateDataType("eam.issue.IncompatibleHostVersion", "IncompatibleHostVersion", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.InsufficientIpAddresses", "InsufficientIpAddresses", "eam.issue.VmPoweredOff", "eam.version.version1", [("network", "vim.Network", "eam.version.version1", 0)])
> CreateDataType("eam.issue.InsufficientResources", "InsufficientResources", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.InsufficientSpace", "InsufficientSpace", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.InvalidConfig", "InvalidConfig", "eam.issue.VmIssue", "eam.version.version6_9", [("error", "anyType", "eam.version.version6_9", 0)])
> CreateDataType("eam.issue.MissingAgentIpPool", "MissingAgentIpPool", "eam.issue.VmPoweredOff", "eam.version.version1", [("network", "vim.Network", "eam.version.version1", 0)])
> CreateDataType("eam.issue.NoAgentVmDatastore", "NoAgentVmDatastore", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.NoAgentVmNetwork", "NoAgentVmNetwork", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.NoCustomAgentVmDatastore", "NoCustomAgentVmDatastore", "eam.issue.NoAgentVmDatastore", "eam.version.version1", [("customAgentVmDatastore", "vim.Datastore[]", "eam.version.version1", 0), ("customAgentVmDatastoreName", "string[]", "eam.version.version1", 0)])
> CreateDataType("eam.issue.NoCustomAgentVmNetwork", "NoCustomAgentVmNetwork", "eam.issue.NoAgentVmNetwork", "eam.version.version1", [("customAgentVmNetwork", "vim.Network[]", "eam.version.version1", 0), ("customAgentVmNetworkName", "string[]", "eam.version.version1", 0)])
> CreateDataType("eam.issue.NoDiscoverableAgentVmDatastore", "NoDiscoverableAgentVmDatastore", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.NoDiscoverableAgentVmNetwork", "NoDiscoverableAgentVmNetwork", "eam.issue.VmNotDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.OvfInvalidFormat", "OvfInvalidFormat", "eam.issue.VmNotDeployed", "eam.version.version1", [("error", "vmodl.MethodFault[]", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.issue.VibCannotPutHostInMaintenanceMode", "VibCannotPutHostInMaintenanceMode", "eam.issue.VibIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.VibCannotPutHostOutOfMaintenanceMode", "VibCannotPutHostOutOfMaintenanceMode", "eam.issue.VibIssue", "eam.version.version6_5", None)
> CreateDataType("eam.issue.VibDependenciesNotMetByHost", "VibDependenciesNotMetByHost", "eam.issue.VibNotInstalled", "eam.version.version6_8", None)
> CreateDataType("eam.issue.VibInvalidFormat", "VibInvalidFormat", "eam.issue.VibNotInstalled", "eam.version.version1", None)
> CreateDataType("eam.issue.VmCorrupted", "VmCorrupted", "eam.issue.VmIssue", "eam.version.version1", [("missingFile", "string", "eam.version.version1", F_OPTIONAL)])
> CreateDataType("eam.issue.VmDeployed", "VmDeployed", "eam.issue.VmIssue", "eam.version.version1", None)
> CreateDataType("eam.issue.cluster.agent.InsufficientClusterResources", "ClusterAgentInsufficientClusterResources", "eam.issue.cluster.agent.VmPoweredOff", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.InsufficientClusterSpace", "ClusterAgentInsufficientClusterSpace", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", None)
> CreateDataType("eam.issue.cluster.agent.InvalidConfig", "ClusterAgentInvalidConfig", "eam.issue.cluster.agent.VmIssue", "eam.version.version6_9", [("error", "anyType", "eam.version.version6_9", 0)])
> CreateDataType("eam.issue.cluster.agent.MissingClusterVmDatastore", "ClusterAgentMissingClusterVmDatastore", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", [("missingDatastores", "vim.Datastore[]", "eam.version.version6_9", F_OPTIONAL)])
> CreateDataType("eam.issue.cluster.agent.MissingClusterVmNetwork", "ClusterAgentMissingClusterVmNetwork", "eam.issue.cluster.agent.VmNotDeployed", "eam.version.version6_9", [("missingNetworks", "vim.Network[]", "eam.version.version6_9", F_OPTIONAL), ("networkNames", "string[]", "eam.version.version6_9", F_OPTIONAL)])
> CreateDataType("eam.issue.integrity.agency.CannotDeleteSoftware", "IntegrityAgencyCannotDeleteSoftware", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
> CreateDataType("eam.issue.integrity.agency.CannotStageSoftware", "IntegrityAgencyCannotStageSoftware", "eam.issue.integrity.agency.VUMIssue", "eam.version.version6_7", None)
> CreateDataType("eam.issue.personality.agency.CannotConfigureSolutions", "PersonalityAgencyCannotConfigureSolutions", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", [("cr", "vim.ComputeResource", "eam.version.version7_1", 0), ("solutionsToModify", "string[]", "eam.version.version7_1", F_OPTIONAL), ("solutionsToRemove", "string[]", "eam.version.version7_1", F_OPTIONAL)])
> CreateDataType("eam.issue.personality.agency.DepotIssue", "PersonalityAgencyDepotIssue", "eam.issue.personality.agency.PMIssue", "eam.version.version7_1", [("remoteDepotUrl", "string", "eam.version.version7_1", 0)])
> CreateDataType("eam.issue.personality.agency.InaccessibleDepot", "PersonalityAgencyInaccessibleDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.personality.agency.InvalidDepot", "PersonalityAgencyInvalidDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.personality.agent.AwaitingPMRemediation", "PersonalityAgentAwaitingPMRemediation", "eam.issue.personality.agent.PMIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.personality.agent.BlockedByAgencyOperation", "PersonalityAgentBlockedByAgencyOperation", "eam.issue.personality.agent.PMIssue", "eam.version.version7_1", None)
> CreateDataType("eam.issue.HostInMaintenanceMode", "HostInMaintenanceMode", "eam.issue.VmDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.HostInStandbyMode", "HostInStandbyMode", "eam.issue.VmDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.HostPoweredOff", "HostPoweredOff", "eam.issue.VmDeployed", "eam.version.version1", None)
> CreateDataType("eam.issue.personality.agency.CannotUploadDepot", "PersonalityAgencyCannotUploadDepot", "eam.issue.personality.agency.DepotIssue", "eam.version.version7_1", [("localDepotUrl", "string", "eam.version.version7_1", 0)])
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_pbm.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_pbm.py
1,969c1,969
< # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
< from .VmomiSupport import CreateDataType, CreateManagedType
< from .VmomiSupport import CreateEnumType
< from .VmomiSupport import AddVersion, AddVersionParent
< from .VmomiSupport import AddBreakingChangesInfo
< from .VmomiSupport import F_LINK, F_LINKABLE
< from .VmomiSupport import F_OPTIONAL, F_SECRET
< from .VmomiSupport import newestVersions
< from .VmomiSupport import publicVersions, dottedVersions
< from .VmomiSupport import oldestVersions
< 
< AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
< AddVersion("vim.version.v7_0_1_1", "vim25", "7.0.1.1", 0, "vim25")
< AddVersion("pbm.version.version1", "pbm", "1.0", 0, "pbm")
< AddVersion("pbm.version.version2", "pbm", "2.0", 0, "pbm")
< AddVersion("vmodl.version.version0", "", "", 0, "vim25")
< AddVersion("vmodl.version.version1", "", "", 0, "vim25")
< AddVersion("vmodl.version.version2", "", "", 0, "vim25")
< AddVersion("vim.version.v6_9_1", "vim25", "6.9.1", 0, "vim25")
< AddVersion("vim.version.v7_0_0_2", "vim25", "7.0.0.2", 0, "vim25")
< AddVersion("pbm.version.v7_0", "pbm", "7.0.0.0", 0, "pbm")
< AddVersion("vim.version.v6_8_7", "vim25", "6.8.7", 0, "vim25")
< AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
< AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
< AddVersion("pbm.version.v7_0_2_0", "pbm", "7.0.2.0", 0, "pbm")
< AddVersion("vim.version.v7_0_3_0", "vim25", "7.0.3.0", 0, "vim25")
< AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
< AddVersion("vim.version.version14", "vim25", "6.7.2", 0, "vim25")
< AddVersion("vim.version.version15", "vim25", "6.7.3", 0, "vim25")
< AddVersion("pbm.version.v7_0_3_0", "pbm", "7.0.3.0", 0, "pbm")
< AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
< AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
< AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
< AddVersion("pbm.version.v7_0_1_0", "pbm", "7.0.1.0", 0, "pbm")
< AddVersion("vim.version.v7_0_2_0", "vim25", "7.0.2.0", 0, "vim25")
< AddVersion("vim.version.v7_0_2_1", "vim25", "7.0.2.1", 0, "vim25")
< AddVersion("vim.version.v7_0_1_0", "vim25", "7.0.1.0", 0, "vim25")
< AddVersion("vim.version.v7_0", "vim25", "7.0.0.0", 0, "vim25")
< AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
< AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
< AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
< AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
< AddVersion("pbm.version.v7_0_0_1", "pbm", "7.0.0.1", 0, "pbm")
< AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
< AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
< AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
< AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
< AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
< AddVersion("pbm.version.version11", "pbm", "6.5", 0, "pbm")
< AddVersion("pbm.version.version14", "pbm", "6.7.2", 0, "pbm")
< AddVersion("pbm.version.version12", "pbm", "6.7", 0, "pbm")
< AddVersion("pbm.version.version13", "pbm", "6.7.1", 0, "pbm")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version3")
< AddVersionParent("pbm.version.version1", "pbm.version.version1")
< AddVersionParent("pbm.version.version1", "vmodl.version.version0")
< AddVersionParent("pbm.version.version1", "vmodl.version.version1")
< AddVersionParent("pbm.version.version1", "vmodl.version.version2")
< AddVersionParent("pbm.version.version2", "pbm.version.version1")
< AddVersionParent("pbm.version.version2", "pbm.version.version2")
< AddVersionParent("pbm.version.version2", "vmodl.version.version0")
< AddVersionParent("pbm.version.version2", "vmodl.version.version1")
< AddVersionParent("pbm.version.version2", "vmodl.version.version2")
< AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v6_9_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version13")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version14")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version15")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version10")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version11")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version12")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version8")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version9")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version6")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version7")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version4")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version5")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version1")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version2")
< AddVersionParent("pbm.version.v7_0", "vmodl.version.version0")
< AddVersionParent("pbm.version.v7_0", "vmodl.version.version1")
< AddVersionParent("pbm.version.v7_0", "vmodl.version.version2")
< AddVersionParent("pbm.version.v7_0", "vim.version.v6_9_1")
< AddVersionParent("pbm.version.v7_0", "pbm.version.v7_0")
< AddVersionParent("pbm.version.v7_0", "vim.version.v6_8_7")
< AddVersionParent("pbm.version.v7_0", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.v7_0", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0", "vim.version.version13")
< AddVersionParent("pbm.version.v7_0", "vim.version.version14")
< AddVersionParent("pbm.version.v7_0", "vim.version.version15")
< AddVersionParent("pbm.version.v7_0", "vim.version.version10")
< AddVersionParent("pbm.version.v7_0", "vim.version.version11")
< AddVersionParent("pbm.version.v7_0", "vim.version.version12")
< AddVersionParent("pbm.version.v7_0", "vim.version.v7_0")
< AddVersionParent("pbm.version.v7_0", "vim.version.version8")
< AddVersionParent("pbm.version.v7_0", "vim.version.version9")
< AddVersionParent("pbm.version.v7_0", "vim.version.version6")
< AddVersionParent("pbm.version.v7_0", "vim.version.version7")
< AddVersionParent("pbm.version.v7_0", "vim.version.version1")
< AddVersionParent("pbm.version.v7_0", "vim.version.version4")
< AddVersionParent("pbm.version.v7_0", "vim.version.version5")
< AddVersionParent("pbm.version.v7_0", "vim.version.version2")
< AddVersionParent("pbm.version.v7_0", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version11")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version14")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version12")
< AddVersionParent("pbm.version.v7_0", "pbm.version.version13")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version0")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version13")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version14")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version15")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version10")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version11")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version12")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version8")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version9")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version6")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version7")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version4")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version5")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version3")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_1_1")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version1")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version0")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version1")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v6_9_1")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_0_2")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v6_8_7")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.v7_0_2_0", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_2_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version13")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version14")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version15")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version10")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version11")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version12")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_2_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version8")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version9")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version6")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version7")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_0_1")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version1")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version4")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version5")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version2")
< AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version11")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version14")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version12")
< AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version13")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_3_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.version.version0")
< AddVersionParent("vim.version.version13", "vmodl.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version13")
< AddVersionParent("vim.version.version13", "vim.version.version10")
< AddVersionParent("vim.version.version13", "vim.version.version11")
< AddVersionParent("vim.version.version13", "vim.version.version12")
< AddVersionParent("vim.version.version13", "vim.version.version8")
< AddVersionParent("vim.version.version13", "vim.version.version9")
< AddVersionParent("vim.version.version13", "vim.version.version6")
< AddVersionParent("vim.version.version13", "vim.version.version7")
< AddVersionParent("vim.version.version13", "vim.version.version1")
< AddVersionParent("vim.version.version13", "vim.version.version4")
< AddVersionParent("vim.version.version13", "vim.version.version5")
< AddVersionParent("vim.version.version13", "vim.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version3")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.version.version0")
< AddVersionParent("vim.version.version14", "vmodl.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.version.version2")
< AddVersionParent("vim.version.version14", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version14", "vim.version.version13")
< AddVersionParent("vim.version.version14", "vim.version.version14")
< AddVersionParent("vim.version.version14", "vim.version.version10")
< AddVersionParent("vim.version.version14", "vim.version.version11")
< AddVersionParent("vim.version.version14", "vim.version.version12")
< AddVersionParent("vim.version.version14", "vim.version.version8")
< AddVersionParent("vim.version.version14", "vim.version.version9")
< AddVersionParent("vim.version.version14", "vim.version.version6")
< AddVersionParent("vim.version.version14", "vim.version.version7")
< AddVersionParent("vim.version.version14", "vim.version.version1")
< AddVersionParent("vim.version.version14", "vim.version.version4")
< AddVersionParent("vim.version.version14", "vim.version.version5")
< AddVersionParent("vim.version.version14", "vim.version.version2")
< AddVersionParent("vim.version.version14", "vim.version.version3")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.version.version0")
< AddVersionParent("vim.version.version15", "vmodl.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.version.version2")
< AddVersionParent("vim.version.version15", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version15", "vim.version.version13")
< AddVersionParent("vim.version.version15", "vim.version.version14")
< AddVersionParent("vim.version.version15", "vim.version.version15")
< AddVersionParent("vim.version.version15", "vim.version.version10")
< AddVersionParent("vim.version.version15", "vim.version.version11")
< AddVersionParent("vim.version.version15", "vim.version.version12")
< AddVersionParent("vim.version.version15", "vim.version.version8")
< AddVersionParent("vim.version.version15", "vim.version.version9")
< AddVersionParent("vim.version.version15", "vim.version.version6")
< AddVersionParent("vim.version.version15", "vim.version.version7")
< AddVersionParent("vim.version.version15", "vim.version.version1")
< AddVersionParent("vim.version.version15", "vim.version.version4")
< AddVersionParent("vim.version.version15", "vim.version.version5")
< AddVersionParent("vim.version.version15", "vim.version.version2")
< AddVersionParent("vim.version.version15", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_1_1")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version1")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version2")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version0")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version1")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version2")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v6_9_1")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_0_2")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v6_8_7")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.v7_0_3_0", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_2_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_3_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version13")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version14")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version15")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_3_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version10")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version11")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version12")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_2_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_2_1")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version8")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version9")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version6")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version7")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_0_1")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version1")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version4")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version5")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version2")
< AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version11")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version14")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version12")
< AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version13")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.version.version0")
< AddVersionParent("vim.version.version10", "vmodl.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version10")
< AddVersionParent("vim.version.version10", "vim.version.version8")
< AddVersionParent("vim.version.version10", "vim.version.version9")
< AddVersionParent("vim.version.version10", "vim.version.version6")
< AddVersionParent("vim.version.version10", "vim.version.version7")
< AddVersionParent("vim.version.version10", "vim.version.version1")
< AddVersionParent("vim.version.version10", "vim.version.version4")
< AddVersionParent("vim.version.version10", "vim.version.version5")
< AddVersionParent("vim.version.version10", "vim.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.version.version0")
< AddVersionParent("vim.version.version11", "vmodl.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version10")
< AddVersionParent("vim.version.version11", "vim.version.version11")
< AddVersionParent("vim.version.version11", "vim.version.version8")
< AddVersionParent("vim.version.version11", "vim.version.version9")
< AddVersionParent("vim.version.version11", "vim.version.version6")
< AddVersionParent("vim.version.version11", "vim.version.version7")
< AddVersionParent("vim.version.version11", "vim.version.version1")
< AddVersionParent("vim.version.version11", "vim.version.version4")
< AddVersionParent("vim.version.version11", "vim.version.version5")
< AddVersionParent("vim.version.version11", "vim.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.version.version0")
< AddVersionParent("vim.version.version12", "vmodl.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version10")
< AddVersionParent("vim.version.version12", "vim.version.version11")
< AddVersionParent("vim.version.version12", "vim.version.version12")
< AddVersionParent("vim.version.version12", "vim.version.version8")
< AddVersionParent("vim.version.version12", "vim.version.version9")
< AddVersionParent("vim.version.version12", "vim.version.version6")
< AddVersionParent("vim.version.version12", "vim.version.version7")
< AddVersionParent("vim.version.version12", "vim.version.version1")
< AddVersionParent("vim.version.version12", "vim.version.version4")
< AddVersionParent("vim.version.version12", "vim.version.version5")
< AddVersionParent("vim.version.version12", "vim.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version1")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version2")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version0")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version1")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version2")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v6_9_1")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0_0_2")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v6_8_7")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.v7_0_1_0", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version13")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version14")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version15")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version10")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version11")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version12")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0_1_0")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version8")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version9")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version6")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version7")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0_0_1")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version1")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version4")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version5")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version2")
< AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version11")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version14")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version12")
< AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version13")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version3")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version8", "vmodl.version.version0")
< AddVersionParent("vim.version.version8", "vmodl.version.version1")
< AddVersionParent("vim.version.version8", "vmodl.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version8")
< AddVersionParent("vim.version.version8", "vim.version.version6")
< AddVersionParent("vim.version.version8", "vim.version.version7")
< AddVersionParent("vim.version.version8", "vim.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version4")
< AddVersionParent("vim.version.version8", "vim.version.version5")
< AddVersionParent("vim.version.version8", "vim.version.version2")
< AddVersionParent("vim.version.version8", "vim.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.version.version0")
< AddVersionParent("vim.version.version9", "vmodl.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version8")
< AddVersionParent("vim.version.version9", "vim.version.version9")
< AddVersionParent("vim.version.version9", "vim.version.version6")
< AddVersionParent("vim.version.version9", "vim.version.version7")
< AddVersionParent("vim.version.version9", "vim.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version4")
< AddVersionParent("vim.version.version9", "vim.version.version5")
< AddVersionParent("vim.version.version9", "vim.version.version2")
< AddVersionParent("vim.version.version9", "vim.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version6", "vmodl.version.version0")
< AddVersionParent("vim.version.version6", "vmodl.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version6")
< AddVersionParent("vim.version.version6", "vim.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version4")
< AddVersionParent("vim.version.version6", "vim.version.version5")
< AddVersionParent("vim.version.version6", "vim.version.version2")
< AddVersionParent("vim.version.version6", "vim.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.version.version0")
< AddVersionParent("vim.version.version7", "vmodl.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version6")
< AddVersionParent("vim.version.version7", "vim.version.version7")
< AddVersionParent("vim.version.version7", "vim.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version4")
< AddVersionParent("vim.version.version7", "vim.version.version5")
< AddVersionParent("vim.version.version7", "vim.version.version2")
< AddVersionParent("vim.version.version7", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version1")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version2")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version0")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version1")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version2")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v6_9_1")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.v7_0")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v6_8_7")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.v7_0_0_1", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version13")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version14")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version15")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version10")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version11")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version12")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v7_0")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version8")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version9")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version6")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version7")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.v7_0_0_1")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version1")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version4")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version5")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version2")
< AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version3")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version11")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version14")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version12")
< AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version13")
< AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.version1", "vim.version.version1")
< AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version4", "vmodl.version.version0")
< AddVersionParent("vim.version.version4", "vim.version.version1")
< AddVersionParent("vim.version.version4", "vim.version.version4")
< AddVersionParent("vim.version.version4", "vim.version.version2")
< AddVersionParent("vim.version.version4", "vim.version.version3")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version5", "vmodl.version.version0")
< AddVersionParent("vim.version.version5", "vmodl.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version4")
< AddVersionParent("vim.version.version5", "vim.version.version5")
< AddVersionParent("vim.version.version5", "vim.version.version2")
< AddVersionParent("vim.version.version5", "vim.version.version3")
< AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version2", "vmodl.version.version0")
< AddVersionParent("vim.version.version2", "vim.version.version1")
< AddVersionParent("vim.version.version2", "vim.version.version2")
< AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version3", "vmodl.version.version0")
< AddVersionParent("vim.version.version3", "vim.version.version1")
< AddVersionParent("vim.version.version3", "vim.version.version2")
< AddVersionParent("vim.version.version3", "vim.version.version3")
< AddVersionParent("pbm.version.version11", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.version11", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.version11", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.version11", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.version11", "pbm.version.version1")
< AddVersionParent("pbm.version.version11", "pbm.version.version2")
< AddVersionParent("pbm.version.version11", "vmodl.version.version0")
< AddVersionParent("pbm.version.version11", "vmodl.version.version1")
< AddVersionParent("pbm.version.version11", "vmodl.version.version2")
< AddVersionParent("pbm.version.version11", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.version11", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.version11", "vim.version.version10")
< AddVersionParent("pbm.version.version11", "vim.version.version11")
< AddVersionParent("pbm.version.version11", "vim.version.version8")
< AddVersionParent("pbm.version.version11", "vim.version.version9")
< AddVersionParent("pbm.version.version11", "vim.version.version6")
< AddVersionParent("pbm.version.version11", "vim.version.version7")
< AddVersionParent("pbm.version.version11", "vim.version.version1")
< AddVersionParent("pbm.version.version11", "vim.version.version4")
< AddVersionParent("pbm.version.version11", "vim.version.version5")
< AddVersionParent("pbm.version.version11", "vim.version.version2")
< AddVersionParent("pbm.version.version11", "vim.version.version3")
< AddVersionParent("pbm.version.version11", "pbm.version.version11")
< AddVersionParent("pbm.version.version14", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.version14", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.version14", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.version14", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.version14", "pbm.version.version1")
< AddVersionParent("pbm.version.version14", "pbm.version.version2")
< AddVersionParent("pbm.version.version14", "vmodl.version.version0")
< AddVersionParent("pbm.version.version14", "vmodl.version.version1")
< AddVersionParent("pbm.version.version14", "vmodl.version.version2")
< AddVersionParent("pbm.version.version14", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.version14", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.version14", "vim.version.version13")
< AddVersionParent("pbm.version.version14", "vim.version.version14")
< AddVersionParent("pbm.version.version14", "vim.version.version10")
< AddVersionParent("pbm.version.version14", "vim.version.version11")
< AddVersionParent("pbm.version.version14", "vim.version.version12")
< AddVersionParent("pbm.version.version14", "vim.version.version8")
< AddVersionParent("pbm.version.version14", "vim.version.version9")
< AddVersionParent("pbm.version.version14", "vim.version.version6")
< AddVersionParent("pbm.version.version14", "vim.version.version7")
< AddVersionParent("pbm.version.version14", "vim.version.version1")
< AddVersionParent("pbm.version.version14", "vim.version.version4")
< AddVersionParent("pbm.version.version14", "vim.version.version5")
< AddVersionParent("pbm.version.version14", "vim.version.version2")
< AddVersionParent("pbm.version.version14", "vim.version.version3")
< AddVersionParent("pbm.version.version14", "pbm.version.version11")
< AddVersionParent("pbm.version.version14", "pbm.version.version14")
< AddVersionParent("pbm.version.version14", "pbm.version.version12")
< AddVersionParent("pbm.version.version14", "pbm.version.version13")
< AddVersionParent("pbm.version.version12", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.version12", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.version12", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.version12", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.version12", "pbm.version.version1")
< AddVersionParent("pbm.version.version12", "pbm.version.version2")
< AddVersionParent("pbm.version.version12", "vmodl.version.version0")
< AddVersionParent("pbm.version.version12", "vmodl.version.version1")
< AddVersionParent("pbm.version.version12", "vmodl.version.version2")
< AddVersionParent("pbm.version.version12", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.version12", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.version12", "vim.version.version10")
< AddVersionParent("pbm.version.version12", "vim.version.version11")
< AddVersionParent("pbm.version.version12", "vim.version.version12")
< AddVersionParent("pbm.version.version12", "vim.version.version8")
< AddVersionParent("pbm.version.version12", "vim.version.version9")
< AddVersionParent("pbm.version.version12", "vim.version.version6")
< AddVersionParent("pbm.version.version12", "vim.version.version7")
< AddVersionParent("pbm.version.version12", "vim.version.version1")
< AddVersionParent("pbm.version.version12", "vim.version.version4")
< AddVersionParent("pbm.version.version12", "vim.version.version5")
< AddVersionParent("pbm.version.version12", "vim.version.version2")
< AddVersionParent("pbm.version.version12", "vim.version.version3")
< AddVersionParent("pbm.version.version12", "pbm.version.version11")
< AddVersionParent("pbm.version.version12", "pbm.version.version12")
< AddVersionParent("pbm.version.version13", "vmodl.query.version.version4")
< AddVersionParent("pbm.version.version13", "vmodl.query.version.version3")
< AddVersionParent("pbm.version.version13", "vmodl.query.version.version2")
< AddVersionParent("pbm.version.version13", "vmodl.query.version.version1")
< AddVersionParent("pbm.version.version13", "pbm.version.version1")
< AddVersionParent("pbm.version.version13", "pbm.version.version2")
< AddVersionParent("pbm.version.version13", "vmodl.version.version0")
< AddVersionParent("pbm.version.version13", "vmodl.version.version1")
< AddVersionParent("pbm.version.version13", "vmodl.version.version2")
< AddVersionParent("pbm.version.version13", "vmodl.reflect.version.version1")
< AddVersionParent("pbm.version.version13", "vmodl.reflect.version.version2")
< AddVersionParent("pbm.version.version13", "vim.version.version13")
< AddVersionParent("pbm.version.version13", "vim.version.version10")
< AddVersionParent("pbm.version.version13", "vim.version.version11")
< AddVersionParent("pbm.version.version13", "vim.version.version12")
< AddVersionParent("pbm.version.version13", "vim.version.version8")
< AddVersionParent("pbm.version.version13", "vim.version.version9")
< AddVersionParent("pbm.version.version13", "vim.version.version6")
< AddVersionParent("pbm.version.version13", "vim.version.version7")
< AddVersionParent("pbm.version.version13", "vim.version.version1")
< AddVersionParent("pbm.version.version13", "vim.version.version4")
< AddVersionParent("pbm.version.version13", "vim.version.version5")
< AddVersionParent("pbm.version.version13", "vim.version.version2")
< AddVersionParent("pbm.version.version13", "vim.version.version3")
< AddVersionParent("pbm.version.version13", "pbm.version.version11")
< AddVersionParent("pbm.version.version13", "pbm.version.version12")
< AddVersionParent("pbm.version.version13", "pbm.version.version13")
< 
< newestVersions.Add("pbm.version.v7_0_3_0")
< publicVersions.Add("pbm.version.v7_0_3_0")
< dottedVersions.Add("pbm.version.v7_0_3_0")
< oldestVersions.Add("pbm.version.version1")
< 
< CreateDataType("pbm.AboutInfo", "PbmAboutInfo", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("version", "string", "pbm.version.version1", 0), ("instanceUuid", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.ExtendedElementDescription", "PbmExtendedElementDescription", "vmodl.DynamicData", "pbm.version.version1", [("label", "string", "pbm.version.version1", 0), ("summary", "string", "pbm.version.version1", 0), ("key", "string", "pbm.version.version1", 0), ("messageCatalogKeyPrefix", "string", "pbm.version.version1", 0), ("messageArg", "vmodl.KeyAnyValue[]", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.ServerObjectRef", "PbmServerObjectRef", "vmodl.DynamicData", "pbm.version.version1", [("objectType", "string", "pbm.version.version1", 0), ("key", "string", "pbm.version.version1", 0), ("serverUuid", "string", "pbm.version.version1", F_OPTIONAL)])
< CreateEnumType("pbm.ServerObjectRef.VvolType", "PbmVvolType", "pbm.version.version1", ["Config", "Data", "Swap"])
< CreateEnumType("pbm.ServerObjectRef.ObjectType", "PbmObjectType", "pbm.version.version1", ["virtualMachine", "virtualMachineAndDisks", "virtualDiskId", "virtualDiskUUID", "datastore", "vsanObjectId", "fileShareId", "host", "cluster", "unknown"])
< CreateManagedType("pbm.ServiceInstance", "PbmServiceInstance", "vmodl.ManagedObject", "pbm.version.version1", [("content", "pbm.ServiceInstanceContent", "pbm.version.version1", 0, "System.Anonymous")], [("retrieveContent", "PbmRetrieveServiceContent", "pbm.version.version1", (), (0, "pbm.ServiceInstanceContent", "pbm.ServiceInstanceContent"), "System.Anonymous", None)])
< CreateDataType("pbm.ServiceInstanceContent", "PbmServiceInstanceContent", "vmodl.DynamicData", "pbm.version.version1", [("aboutInfo", "pbm.AboutInfo", "pbm.version.version1", 0), ("sessionManager", "pbm.auth.SessionManager", "pbm.version.version1", 0), ("capabilityMetadataManager", "pbm.capability.CapabilityMetadataManager", "pbm.version.version1", 0), ("profileManager", "pbm.profile.ProfileManager", "pbm.version.version1", 0), ("complianceManager", "pbm.compliance.ComplianceManager", "pbm.version.version1", 0), ("placementSolver", "pbm.placement.PlacementSolver", "pbm.version.version1", 0), ("replicationManager", "pbm.replication.ReplicationManager", "pbm.version.version11", F_OPTIONAL)])
< CreateManagedType("pbm.auth.SessionManager", "PbmSessionManager", "vmodl.ManagedObject", "pbm.version.version1", None, None)
< CreateDataType("pbm.capability.CapabilityMetadata", "PbmCapabilityMetadata", "vmodl.DynamicData", "pbm.version.version1", [("id", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("summary", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("mandatory", "boolean", "pbm.version.version1", F_OPTIONAL), ("hint", "boolean", "pbm.version.version1", F_OPTIONAL), ("keyId", "string", "pbm.version.version1", F_OPTIONAL), ("allowMultipleConstraints", "boolean", "pbm.version.version1", F_OPTIONAL), ("propertyMetadata", "pbm.capability.PropertyMetadata[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.CapabilityMetadata.UniqueId", "PbmCapabilityMetadataUniqueId", "vmodl.DynamicData", "pbm.version.version1", [("namespace", "string", "pbm.version.version1", 0), ("id", "string", "pbm.version.version1", 0)])
< CreateManagedType("pbm.capability.CapabilityMetadataManager", "PbmCapabilityMetadataManager", "vmodl.ManagedObject", "pbm.version.version1", None, None)
< CreateDataType("pbm.capability.ConstraintInstance", "PbmCapabilityConstraintInstance", "vmodl.DynamicData", "pbm.version.version1", [("propertyInstance", "pbm.capability.PropertyInstance[]", "pbm.version.version1", 0)])
< CreateEnumType("pbm.capability.Operator", "PbmCapabilityOperator", "pbm.version.version11", ["NOT"])
< CreateDataType("pbm.capability.PropertyInstance", "PbmCapabilityPropertyInstance", "vmodl.DynamicData", "pbm.version.version1", [("id", "string", "pbm.version.version1", 0), ("operator", "string", "pbm.version.version11", F_OPTIONAL), ("value", "anyType", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.PropertyMetadata", "PbmCapabilityPropertyMetadata", "vmodl.DynamicData", "pbm.version.version1", [("id", "string", "pbm.version.version1", 0), ("summary", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("mandatory", "boolean", "pbm.version.version1", 0), ("type", "pbm.capability.TypeInfo", "pbm.version.version1", F_OPTIONAL), ("defaultValue", "anyType", "pbm.version.version1", F_OPTIONAL), ("allowedValue", "anyType", "pbm.version.version1", F_OPTIONAL), ("requirementsTypeHint", "string", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.capability.TypeInfo", "PbmCapabilityTypeInfo", "vmodl.DynamicData", "pbm.version.version1", [("typeName", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.CapabilityObjectMetadataPerCategory", "PbmCapabilityMetadataPerCategory", "vmodl.DynamicData", "pbm.version.version1", [("subCategory", "string", "pbm.version.version1", 0), ("capabilityMetadata", "pbm.capability.CapabilityMetadata[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.CapabilityObjectSchema", "PbmCapabilitySchema", "vmodl.DynamicData", "pbm.version.version1", [("vendorInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "pbm.version.version1", 0), ("namespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "pbm.version.version1", 0), ("lineOfService", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", F_OPTIONAL), ("capabilityMetadataPerCategory", "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "PbmCapabilitySchemaVendorInfo", "vmodl.DynamicData", "pbm.version.version1", [("vendorUuid", "string", "pbm.version.version1", 0), ("info", "pbm.ExtendedElementDescription", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "PbmCapabilityNamespaceInfo", "vmodl.DynamicData", "pbm.version.version1", [("version", "string", "pbm.version.version1", 0), ("namespace", "string", "pbm.version.version1", 0), ("info", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
< CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo", "PbmCapabilityVendorResourceTypeInfo", "vmodl.DynamicData", "pbm.version.version1", [("resourceType", "string", "pbm.version.version1", 0), ("vendorNamespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorNamespaceInfo[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorNamespaceInfo", "PbmCapabilityVendorNamespaceInfo", "vmodl.DynamicData", "pbm.version.version1", [("vendorInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "pbm.version.version1", 0), ("namespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.provider.LineOfServiceInfo", "PbmLineOfServiceInfo", "vmodl.DynamicData", "pbm.version.version11", [("lineOfService", "string", "pbm.version.version11", 0), ("name", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("description", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
< CreateEnumType("pbm.capability.provider.LineOfServiceInfo.LineOfServiceEnum", "PbmLineOfServiceInfoLineOfServiceEnum", "pbm.version.version11", ["INSPECTION", "COMPRESSION", "ENCRYPTION", "REPLICATION", "CACHING", "PERSISTENCE", "DATA_PROVIDER", "DATASTORE_IO_CONTROL", "DATA_PROTECTION"])
< CreateDataType("pbm.capability.provider.PersistenceBasedDataServiceInfo", "PbmPersistenceBasedDataServiceInfo", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", [("compatiblePersistenceSchemaNamespace", "string[]", "pbm.version.version11", F_OPTIONAL)])
< CreateDataType("pbm.capability.provider.VaioDataServiceInfo", "PbmVaioDataServiceInfo", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", None)
< CreateEnumType("pbm.capability.types.BuiltinGenericTypesEnum", "PbmBuiltinGenericType", "pbm.version.version1", ["VMW_RANGE", "VMW_SET"])
< CreateEnumType("pbm.capability.types.BuiltinTypesEnum", "PbmBuiltinType", "pbm.version.version1", ["XSD_LONG", "XSD_SHORT", "XSD_INTEGER", "XSD_INT", "XSD_STRING", "XSD_BOOLEAN", "XSD_DOUBLE", "XSD_DATETIME", "VMW_TIMESPAN", "VMW_POLICY"])
< CreateDataType("pbm.capability.types.DescriptiveValue", "PbmCapabilityDescription", "vmodl.DynamicData", "pbm.version.version1", [("description", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("value", "anyType", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.types.DiscreteSet", "PbmCapabilityDiscreteSet", "vmodl.DynamicData", "pbm.version.version1", [("values", "anyType[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.types.Range", "PbmCapabilityRange", "vmodl.DynamicData", "pbm.version.version1", [("min", "anyType", "pbm.version.version1", 0), ("max", "anyType", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.types.TimeSpan", "PbmCapabilityTimeSpan", "vmodl.DynamicData", "pbm.version.version1", [("value", "int", "pbm.version.version1", 0), ("unit", "string", "pbm.version.version1", 0)])
< CreateEnumType("pbm.capability.types.TimeUnitEnum", "PbmCapabilityTimeUnitType", "pbm.version.version1", ["SECONDS", "MINUTES", "HOURS", "DAYS", "WEEKS", "MONTHS", "YEARS"])
< CreateManagedType("pbm.compliance.ComplianceManager", "PbmComplianceManager", "vmodl.ManagedObject", "pbm.version.version1", None, [("checkCompliance", "PbmCheckCompliance", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.compliance.ComplianceResult[]", "pbm.compliance.ComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("fetchComplianceResult", "PbmFetchComplianceResult", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.compliance.ComplianceResult[]", "pbm.compliance.ComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("checkRollupCompliance", "PbmCheckRollupCompliance", "pbm.version.version1", (("entity", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.compliance.RollupComplianceResult[]", "pbm.compliance.RollupComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("fetchRollupComplianceResult", "PbmFetchRollupComplianceResult", "pbm.version.version1", (("entity", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.compliance.RollupComplianceResult[]", "pbm.compliance.RollupComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryByRollupComplianceStatus", "PbmQueryByRollupComplianceStatus", "pbm.version.version11", (("status", "string", "pbm.version.version11", 0, None),), (F_OPTIONAL, "pbm.ServerObjectRef[]", "pbm.ServerObjectRef[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.PBMFault", ])])
< CreateDataType("pbm.compliance.ComplianceResult", "PbmComplianceResult", "vmodl.DynamicData", "pbm.version.version1", [("checkTime", "vmodl.DateTime", "pbm.version.version1", 0), ("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL), ("complianceTaskStatus", "string", "pbm.version.version11", F_OPTIONAL), ("complianceStatus", "string", "pbm.version.version1", 0), ("mismatch", "boolean", "pbm.version.version1", 0), ("violatedPolicies", "pbm.compliance.PolicyStatus[]", "pbm.version.version1", F_OPTIONAL), ("errorCause", "vmodl.MethodFault[]", "pbm.version.version11", F_OPTIONAL), ("operationalStatus", "pbm.compliance.OperationalStatus", "pbm.version.version1", F_OPTIONAL), ("info", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
< CreateEnumType("pbm.compliance.ComplianceResult.ComplianceStatus", "PbmComplianceStatus", "pbm.version.version1", ["compliant", "nonCompliant", "unknown", "notApplicable", "outOfDate"])
< CreateEnumType("pbm.compliance.ComplianceResult.ComplianceTaskStatus", "PbmComplianceResultComplianceTaskStatus", "pbm.version.version11", ["inProgress", "success", "failed"])
< CreateEnumType("pbm.compliance.EntityHealthStatus.HealthStatus", "PbmHealthStatusForEntity", "pbm.version.v7_0", ["red", "yellow", "green", "unknown"])
< CreateDataType("pbm.compliance.FetchEntityHealthStatusSpec", "PbmFetchEntityHealthStatusSpec", "vmodl.DynamicData", "pbm.version.v7_0_3_0", [("objectRef", "pbm.ServerObjectRef", "pbm.version.v7_0_3_0", 0), ("backingId", "string", "pbm.version.v7_0_3_0", F_OPTIONAL)])
< CreateDataType("pbm.compliance.OperationalStatus", "PbmComplianceOperationalStatus", "vmodl.DynamicData", "pbm.version.version1", [("healthy", "boolean", "pbm.version.version1", F_OPTIONAL), ("operationETA", "vmodl.DateTime", "pbm.version.version1", F_OPTIONAL), ("operationProgress", "long", "pbm.version.version1", F_OPTIONAL), ("transitional", "boolean", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.compliance.PolicyStatus", "PbmCompliancePolicyStatus", "vmodl.DynamicData", "pbm.version.version1", [("expectedValue", "pbm.capability.CapabilityInstance", "pbm.version.version1", 0), ("currentValue", "pbm.capability.CapabilityInstance", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.compliance.RollupComplianceResult", "PbmRollupComplianceResult", "vmodl.DynamicData", "pbm.version.version1", [("oldestCheckTime", "vmodl.DateTime", "pbm.version.version1", 0), ("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("overallComplianceStatus", "string", "pbm.version.version1", 0), ("overallComplianceTaskStatus", "string", "pbm.version.version11", F_OPTIONAL), ("result", "pbm.compliance.ComplianceResult[]", "pbm.version.version1", F_OPTIONAL), ("errorCause", "vmodl.MethodFault[]", "pbm.version.version11", F_OPTIONAL), ("profileMismatch", "boolean", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.PBMFault", "PbmFault", "vmodl.MethodFault", "pbm.version.version1", None)
< CreateDataType("pbm.fault.ProfileStorageFault", "PbmFaultProfileStorageFault", "pbm.fault.PBMFault", "pbm.version.version1", None)
< CreateDataType("pbm.fault.ResourceInUse", "PbmResourceInUse", "pbm.fault.PBMFault", "pbm.version.version1", [("type", "vmodl.TypeName", "pbm.version.version1", F_OPTIONAL), ("name", "string", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.placement.CompatibilityResult", "PbmPlacementCompatibilityResult", "vmodl.DynamicData", "pbm.version.version1", [("hub", "pbm.placement.PlacementHub", "pbm.version.version1", 0), ("matchingResources", "pbm.placement.MatchingResources[]", "pbm.version.version11", F_OPTIONAL), ("howMany", "long", "pbm.version.version11", F_OPTIONAL), ("utilization", "pbm.placement.ResourceUtilization[]", "pbm.version.version11", F_OPTIONAL), ("warning", "vmodl.MethodFault[]", "pbm.version.version1", F_OPTIONAL), ("error", "vmodl.MethodFault[]", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.placement.MatchingResources", "PbmPlacementMatchingResources", "vmodl.DynamicData", "pbm.version.version11", None)
< CreateDataType("pbm.placement.PlacementHub", "PbmPlacementHub", "vmodl.DynamicData", "pbm.version.version1", [("hubType", "string", "pbm.version.version1", 0), ("hubId", "string", "pbm.version.version1", 0)])
< CreateManagedType("pbm.placement.PlacementSolver", "PbmPlacementSolver", "vmodl.ManagedObject", "pbm.version.version1", None, [("queryMatchingHub", "PbmQueryMatchingHub", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.PlacementHub[]", "pbm.placement.PlacementHub[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryMatchingHubWithSpec", "PbmQueryMatchingHubWithSpec", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("createSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.PlacementHub[]", "pbm.placement.PlacementHub[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("checkCompatibility", "PbmCheckCompatibility", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", None), ("checkCompatibilityWithSpec", "PbmCheckCompatibilityWithSpec", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profileSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", None), ("checkRequirements", "PbmCheckRequirements", "pbm.version.version11", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version11", F_OPTIONAL, None),("placementSubjectRef", "pbm.ServerObjectRef", "pbm.version.version11", F_OPTIONAL, None),("placementSubjectRequirement", "pbm.placement.Requirement[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
< CreateDataType("pbm.placement.Requirement", "PbmPlacementRequirement", "vmodl.DynamicData", "pbm.version.version11", None)
< CreateDataType("pbm.placement.ResourceUtilization", "PbmPlacementResourceUtilization", "vmodl.DynamicData", "pbm.version.version11", [("name", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("description", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("availableBefore", "long", "pbm.version.version11", F_OPTIONAL), ("availableAfter", "long", "pbm.version.version11", F_OPTIONAL), ("total", "long", "pbm.version.version11", F_OPTIONAL)])
< CreateEnumType("pbm.profile.AssociateAndApplyPolicyStatus.PolicyStatus", "PbmAssociateAndApplyPolicyStatusPolicyStatus", "pbm.version.version1", ["success", "failed", "invalid"])
< CreateDataType("pbm.profile.CapabilityBasedProfileCreateSpec", "PbmCapabilityProfileCreateSpec", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("category", "string", "pbm.version.version11", F_OPTIONAL), ("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", 0)])
< CreateDataType("pbm.profile.CapabilityBasedProfileUpdateSpec", "PbmCapabilityProfileUpdateSpec", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", F_OPTIONAL), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.profile.CapabilityConstraints", "PbmCapabilityConstraints", "vmodl.DynamicData", "pbm.version.version1", None)
< CreateDataType("pbm.profile.DataServiceToPoliciesMap", "PbmDataServiceToPoliciesMap", "vmodl.DynamicData", "pbm.version.version11", [("dataServicePolicy", "pbm.profile.ProfileId", "pbm.version.version11", 0), ("parentStoragePolicies", "pbm.profile.ProfileId[]", "pbm.version.version11", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version11", F_OPTIONAL)])
< CreateDataType("pbm.profile.DefaultProfileInfo", "PbmDefaultProfileInfo", "vmodl.DynamicData", "pbm.version.version2", [("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0), ("defaultProfile", "pbm.profile.Profile", "pbm.version.version2", F_OPTIONAL)])
< CreateEnumType("pbm.profile.EntityAssociations.Operation", "PbmOperation", "pbm.version.version11", ["CREATE", "REGISTER", "RECONFIGURE", "MIGRATE", "CLONE"])
< CreateEnumType("pbm.profile.IofilterInfo.FilterType", "PbmIofilterInfoFilterType", "pbm.version.version1", ["INSPECTION", "COMPRESSION", "ENCRYPTION", "REPLICATION", "CACHE", "DATAPROVIDER", "DATASTOREIOCONTROL"])
< CreateDataType("pbm.profile.Profile", "PbmProfile", "vmodl.DynamicData", "pbm.version.version1", [("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0), ("name", "string", "pbm.version.version1", 0), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("creationTime", "vmodl.DateTime", "pbm.version.version1", 0), ("createdBy", "string", "pbm.version.version1", 0), ("lastUpdatedTime", "vmodl.DateTime", "pbm.version.version1", 0), ("lastUpdatedBy", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.profile.ProfileId", "PbmProfileId", "vmodl.DynamicData", "pbm.version.version1", [("uniqueId", "string", "pbm.version.version1", 0)])
< CreateManagedType("pbm.profile.ProfileManager", "PbmProfileProfileManager", "vmodl.ManagedObject", "pbm.version.version1", None, [("fetchResourceType", "PbmFetchResourceType", "pbm.version.version1", (), (F_OPTIONAL, "pbm.profile.ResourceType[]", "pbm.profile.ResourceType[]"), "StorageProfile.View", None), ("fetchVendorInfo", "PbmFetchVendorInfo", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo[]", "pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo[]"), "StorageProfile.View", None), ("fetchCapabilityMetadata", "PbmFetchCapabilityMetadata", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", F_OPTIONAL, None),("vendorUuid", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]", "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]"), "StorageProfile.View", None), ("fetchCapabilitySchema", "PbmFetchCapabilitySchema", "pbm.version.version11", (("vendorUuid", "string", "pbm.version.version11", F_OPTIONAL, None),("lineOfService", "string[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectSchema[]", "pbm.capability.provider.CapabilityObjectSchema[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("create", "PbmCreate", "pbm.version.version1", (("createSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (0, "pbm.profile.ProfileId", "pbm.profile.ProfileId"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.ProfileStorageFault", "pbm.fault.DuplicateName", ]), ("update", "PbmUpdate", "pbm.version.version1", (("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),("updateSpec", "pbm.profile.CapabilityBasedProfileUpdateSpec", "pbm.version.version1", 0, None),), (0, "void", "void"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.ProfileStorageFault", ]), ("delete", "PbmDelete", "pbm.version.version1", (("profileId", "pbm.profile.ProfileId[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileOperationOutcome[]", "pbm.profile.ProfileOperationOutcome[]"), "StorageProfile.Update", None), ("queryProfile", "PbmQueryProfile", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0, None),("profileCategory", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.ProfileId[]", "pbm.profile.ProfileId[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", ]), ("retrieveContent", "PbmRetrieveContent", "pbm.version.version1", (("profileIds", "pbm.profile.ProfileId[]", "pbm.version.version1", 0, None),), (0, "pbm.profile.Profile[]", "pbm.profile.Profile[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", ]), ("queryAssociatedProfiles", "PbmQueryAssociatedProfiles", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.QueryProfileResult[]", "pbm.profile.QueryProfileResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryAssociatedProfile", "PbmQueryAssociatedProfile", "pbm.version.version1", (("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileId[]", "pbm.profile.ProfileId[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryAssociatedEntity", "PbmQueryAssociatedEntity", "pbm.version.version1", (("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),("entityType", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.ServerObjectRef[]", "pbm.ServerObjectRef[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryDefaultRequirementProfile", "PbmQueryDefaultRequirementProfile", "pbm.version.version2", (("hub", "pbm.placement.PlacementHub", "pbm.version.version2", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileId", "pbm.profile.ProfileId"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("resetDefaultRequirementProfile", "PbmResetDefaultRequirementProfile", "pbm.version.version1", (("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (0, "void", "void"), "StorageProfile.Update", None), ("assignDefaultRequirementProfile", "PbmAssignDefaultRequirementProfile", "pbm.version.version2", (("profile", "pbm.profile.ProfileId", "pbm.version.version2", 0, None),("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (0, "void", "void"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.LegacyHubsNotSupported", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("findApplicableDefaultProfile", "PbmFindApplicableDefaultProfile", "pbm.version.version2", (("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (F_OPTIONAL, "pbm.profile.Profile[]", "pbm.profile.Profile[]"), "StorageProfile.View", ["pbm.fault.LegacyHubsNotSupported", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", "vmodl.fault.InvalidArgument", ]), ("queryDefaultRequirementProfiles", "PbmQueryDefaultRequirementProfiles", "pbm.version.version2", (("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (0, "pbm.profile.DefaultProfileInfo[]", "pbm.profile.DefaultProfileInfo[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("resetVSanDefaultProfile", "PbmResetVSanDefaultProfile", "pbm.version.version2", (), (0, "void", "void"), "StorageProfile.Update", None), ("querySpaceStatsForStorageContainer", "PbmQuerySpaceStatsForStorageContainer", "pbm.version.version2", (("datastore", "pbm.ServerObjectRef", "pbm.version.version2", 0, None),("capabilityProfileId", "pbm.profile.ProfileId[]", "pbm.version.version2", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.provider.DatastoreSpaceStatistics[]", "pbm.profile.provider.DatastoreSpaceStatistics[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.PBMFault", ]), ("queryAssociatedEntities", "PbmQueryAssociatedEntities", "pbm.version.version11", (("profiles", "pbm.profile.ProfileId[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.QueryProfileResult[]", "pbm.profile.QueryProfileResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
< CreateDataType("pbm.profile.ProfileOperationOutcome", "PbmProfileOperationOutcome", "vmodl.DynamicData", "pbm.version.version1", [("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0), ("fault", "vmodl.MethodFault", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.profile.ProfileType", "PbmProfileType", "vmodl.DynamicData", "pbm.version.version1", [("uniqueId", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.profile.QueryProfileResult", "PbmQueryProfileResult", "vmodl.DynamicData", "pbm.version.version1", [("object", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("profileId", "pbm.profile.ProfileId[]", "pbm.version.version1", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.profile.ResourceType", "PbmProfileResourceType", "vmodl.DynamicData", "pbm.version.version1", [("resourceType", "string", "pbm.version.version1", 0)])
< CreateEnumType("pbm.profile.ResourceTypeEnum", "PbmProfileResourceTypeEnum", "pbm.version.version1", ["STORAGE"])
< CreateDataType("pbm.profile.SubProfileCapabilityConstraints", "PbmCapabilitySubProfileConstraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", [("subProfiles", "pbm.profile.SubProfileCapabilityConstraints.SubProfile[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.profile.SubProfileCapabilityConstraints.SubProfile", "PbmCapabilitySubProfile", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("capability", "pbm.capability.CapabilityInstance[]", "pbm.version.version1", 0), ("forceProvision", "boolean", "pbm.version.version1", F_OPTIONAL)])
< CreateEnumType("pbm.profile.VmAssociations.Operation", "PbmVmOperation", "pbm.version.version11", ["CREATE", "RECONFIGURE", "MIGRATE", "CLONE"])
< CreateDataType("pbm.profile.provider.DatastoreSpaceStatistics", "PbmDatastoreSpaceStatistics", "vmodl.DynamicData", "pbm.version.version2", [("profileId", "string", "pbm.version.version2", F_OPTIONAL), ("physicalTotalInMB", "long", "pbm.version.version2", 0), ("physicalFreeInMB", "long", "pbm.version.version2", 0), ("physicalUsedInMB", "long", "pbm.version.version2", 0), ("logicalLimitInMB", "long", "pbm.version.version2", F_OPTIONAL), ("logicalFreeInMB", "long", "pbm.version.version2", 0), ("logicalUsedInMB", "long", "pbm.version.version2", 0)])
< CreateManagedType("pbm.provider.Provider", "PbmProvider", "vmodl.ManagedObject", "pbm.version.version1", None, None)
< CreateDataType("pbm.replication.QueryReplicationGroupResult", "PbmQueryReplicationGroupResult", "vmodl.DynamicData", "pbm.version.version11", [("object", "pbm.ServerObjectRef", "pbm.version.version11", 0), ("replicationGroupId", "vim.vm.replication.ReplicationGroupId", "pbm.version.version11", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version11", F_OPTIONAL)])
< CreateManagedType("pbm.replication.ReplicationManager", "PbmReplicationManager", "vmodl.ManagedObject", "pbm.version.version11", None, [("queryReplicationGroups", "PbmQueryReplicationGroups", "pbm.version.version11", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.replication.QueryReplicationGroupResult[]", "pbm.replication.QueryReplicationGroupResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
< CreateDataType("pbm.capability.CapabilityInstance", "PbmCapabilityInstance", "vmodl.DynamicData", "pbm.version.version1", [("id", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("constraint", "pbm.capability.ConstraintInstance[]", "pbm.version.version1", 0)])
< CreateDataType("pbm.capability.GenericTypeInfo", "PbmCapabilityGenericTypeInfo", "pbm.capability.TypeInfo", "pbm.version.version1", [("genericTypeName", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.AlreadyExists", "PbmAlreadyExists", "pbm.fault.PBMFault", "pbm.version.version1", [("name", "string", "pbm.version.version1", F_OPTIONAL)])
< CreateDataType("pbm.fault.CompatibilityCheckFault", "PbmCompatibilityCheckFault", "pbm.fault.PBMFault", "pbm.version.version1", [("hub", "pbm.placement.PlacementHub", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.DefaultProfileAppliesFault", "PbmDefaultProfileAppliesFault", "pbm.fault.CompatibilityCheckFault", "pbm.version.version1", None)
< CreateDataType("pbm.fault.DuplicateName", "PbmDuplicateName", "pbm.fault.PBMFault", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.InvalidLogin", "PbmFaultInvalidLogin", "pbm.fault.PBMFault", "pbm.version.version2", None)
< CreateDataType("pbm.fault.LegacyHubsNotSupported", "PbmLegacyHubsNotSupported", "pbm.fault.PBMFault", "pbm.version.version2", [("hubs", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0)])
< CreateDataType("pbm.fault.NonExistentHubs", "PbmNonExistentHubs", "pbm.fault.PBMFault", "pbm.version.version2", [("hubs", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0)])
< CreateDataType("pbm.fault.NotFound", "PbmFaultNotFound", "pbm.fault.PBMFault", "pbm.version.version1", None)
< CreateDataType("pbm.fault.PropertyMismatchFault", "PbmPropertyMismatchFault", "pbm.fault.CompatibilityCheckFault", "pbm.version.version1", [("capabilityInstanceId", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("requirementPropertyInstance", "pbm.capability.PropertyInstance", "pbm.version.version1", 0)])
< CreateDataType("pbm.placement.CapabilityConstraintsRequirement", "PbmPlacementCapabilityConstraintsRequirement", "pbm.placement.Requirement", "pbm.version.version11", [("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version11", 0)])
< CreateDataType("pbm.placement.CapabilityProfileRequirement", "PbmPlacementCapabilityProfileRequirement", "pbm.placement.Requirement", "pbm.version.version11", [("profileId", "pbm.profile.ProfileId", "pbm.version.version11", 0)])
< CreateDataType("pbm.placement.MatchingReplicationResources", "PbmPlacementMatchingReplicationResources", "pbm.placement.MatchingResources", "pbm.version.version11", [("replicationGroup", "vim.vm.replication.ReplicationGroupId[]", "pbm.version.version11", F_OPTIONAL)])
< CreateDataType("pbm.profile.CapabilityBasedProfile", "PbmCapabilityProfile", "pbm.profile.Profile", "pbm.version.version1", [("profileCategory", "string", "pbm.version.version1", 0), ("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", 0), ("generationId", "long", "pbm.version.version1", F_OPTIONAL), ("isDefault", "boolean", "pbm.version.version1", 0), ("systemCreatedProfileType", "string", "pbm.version.version2", F_OPTIONAL), ("lineOfService", "string", "pbm.version.version11", F_OPTIONAL)])
< CreateEnumType("pbm.profile.CapabilityBasedProfile.ProfileCategoryEnum", "PbmProfileCategoryEnum", "pbm.version.version1", ["REQUIREMENT", "RESOURCE", "DATA_SERVICE_POLICY"])
< CreateEnumType("pbm.profile.CapabilityBasedProfile.SystemCreatedProfileType", "PbmSystemCreatedProfileType", "pbm.version.version2", ["VsanDefaultProfile", "VVolDefaultProfile", "PmemDefaultProfile", "VmcManagementProfile", "VsanPMemDefaultProfile"])
< CreateDataType("pbm.profile.DefaultCapabilityBasedProfile", "PbmDefaultCapabilityProfile", "pbm.profile.CapabilityBasedProfile", "pbm.version.version1", [("vvolType", "string[]", "pbm.version.version1", 0), ("containerId", "string", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.CapabilityProfilePropertyMismatchFault", "PbmCapabilityProfilePropertyMismatchFault", "pbm.fault.PropertyMismatchFault", "pbm.version.version1", [("resourcePropertyInstance", "pbm.capability.PropertyInstance", "pbm.version.version1", 0)])
< CreateDataType("pbm.fault.IncompatibleVendorSpecificRuleSet", "PbmIncompatibleVendorSpecificRuleSet", "pbm.fault.CapabilityProfilePropertyMismatchFault", "pbm.version.version1", None)
---
> # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
> from .VmomiSupport import CreateDataType, CreateManagedType
> from .VmomiSupport import CreateEnumType
> from .VmomiSupport import AddVersion, AddVersionParent
> from .VmomiSupport import AddBreakingChangesInfo
> from .VmomiSupport import F_LINK, F_LINKABLE
> from .VmomiSupport import F_OPTIONAL, F_SECRET
> from .VmomiSupport import newestVersions
> from .VmomiSupport import publicVersions, dottedVersions
> from .VmomiSupport import oldestVersions
> 
> AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
> AddVersion("vim.version.v7_0_1_1", "vim25", "7.0.1.1", 0, "vim25")
> AddVersion("pbm.version.version1", "pbm", "1.0", 0, "pbm")
> AddVersion("pbm.version.version2", "pbm", "2.0", 0, "pbm")
> AddVersion("vmodl.version.version0", "", "", 0, "vim25")
> AddVersion("vmodl.version.version1", "", "", 0, "vim25")
> AddVersion("vmodl.version.version2", "", "", 0, "vim25")
> AddVersion("vim.version.v6_9_1", "vim25", "6.9.1", 0, "vim25")
> AddVersion("vim.version.v7_0_0_2", "vim25", "7.0.0.2", 0, "vim25")
> AddVersion("pbm.version.v7_0", "pbm", "7.0.0.0", 0, "pbm")
> AddVersion("vim.version.v6_8_7", "vim25", "6.8.7", 0, "vim25")
> AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
> AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
> AddVersion("pbm.version.v7_0_2_0", "pbm", "7.0.2.0", 0, "pbm")
> AddVersion("vim.version.v7_0_3_0", "vim25", "7.0.3.0", 0, "vim25")
> AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
> AddVersion("vim.version.version14", "vim25", "6.7.2", 0, "vim25")
> AddVersion("vim.version.version15", "vim25", "6.7.3", 0, "vim25")
> AddVersion("pbm.version.v7_0_3_0", "pbm", "7.0.3.0", 0, "pbm")
> AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
> AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
> AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
> AddVersion("pbm.version.v7_0_1_0", "pbm", "7.0.1.0", 0, "pbm")
> AddVersion("vim.version.v7_0_2_0", "vim25", "7.0.2.0", 0, "vim25")
> AddVersion("vim.version.v7_0_2_1", "vim25", "7.0.2.1", 0, "vim25")
> AddVersion("vim.version.v7_0_1_0", "vim25", "7.0.1.0", 0, "vim25")
> AddVersion("vim.version.v7_0", "vim25", "7.0.0.0", 0, "vim25")
> AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
> AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
> AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
> AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
> AddVersion("pbm.version.v7_0_0_1", "pbm", "7.0.0.1", 0, "pbm")
> AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
> AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
> AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
> AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
> AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
> AddVersion("pbm.version.version11", "pbm", "6.5", 0, "pbm")
> AddVersion("pbm.version.version14", "pbm", "6.7.2", 0, "pbm")
> AddVersion("pbm.version.version12", "pbm", "6.7", 0, "pbm")
> AddVersion("pbm.version.version13", "pbm", "6.7.1", 0, "pbm")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version3")
> AddVersionParent("pbm.version.version1", "pbm.version.version1")
> AddVersionParent("pbm.version.version1", "vmodl.version.version0")
> AddVersionParent("pbm.version.version1", "vmodl.version.version1")
> AddVersionParent("pbm.version.version1", "vmodl.version.version2")
> AddVersionParent("pbm.version.version2", "pbm.version.version1")
> AddVersionParent("pbm.version.version2", "pbm.version.version2")
> AddVersionParent("pbm.version.version2", "vmodl.version.version0")
> AddVersionParent("pbm.version.version2", "vmodl.version.version1")
> AddVersionParent("pbm.version.version2", "vmodl.version.version2")
> AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v6_9_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version13")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version14")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version15")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version10")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version11")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version12")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version8")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version9")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version6")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version7")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version4")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version5")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.v7_0", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version1")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version2")
> AddVersionParent("pbm.version.v7_0", "vmodl.version.version0")
> AddVersionParent("pbm.version.v7_0", "vmodl.version.version1")
> AddVersionParent("pbm.version.v7_0", "vmodl.version.version2")
> AddVersionParent("pbm.version.v7_0", "vim.version.v6_9_1")
> AddVersionParent("pbm.version.v7_0", "pbm.version.v7_0")
> AddVersionParent("pbm.version.v7_0", "vim.version.v6_8_7")
> AddVersionParent("pbm.version.v7_0", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.v7_0", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0", "vim.version.version13")
> AddVersionParent("pbm.version.v7_0", "vim.version.version14")
> AddVersionParent("pbm.version.v7_0", "vim.version.version15")
> AddVersionParent("pbm.version.v7_0", "vim.version.version10")
> AddVersionParent("pbm.version.v7_0", "vim.version.version11")
> AddVersionParent("pbm.version.v7_0", "vim.version.version12")
> AddVersionParent("pbm.version.v7_0", "vim.version.v7_0")
> AddVersionParent("pbm.version.v7_0", "vim.version.version8")
> AddVersionParent("pbm.version.v7_0", "vim.version.version9")
> AddVersionParent("pbm.version.v7_0", "vim.version.version6")
> AddVersionParent("pbm.version.v7_0", "vim.version.version7")
> AddVersionParent("pbm.version.v7_0", "vim.version.version1")
> AddVersionParent("pbm.version.v7_0", "vim.version.version4")
> AddVersionParent("pbm.version.v7_0", "vim.version.version5")
> AddVersionParent("pbm.version.v7_0", "vim.version.version2")
> AddVersionParent("pbm.version.v7_0", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version11")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version14")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version12")
> AddVersionParent("pbm.version.v7_0", "pbm.version.version13")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version0")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version13")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version14")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version15")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version10")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version11")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version12")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version8")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version9")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version6")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version7")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version4")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version5")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version3")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_1_1")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version1")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version0")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version1")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v6_9_1")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_0_2")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v6_8_7")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.v7_0_2_0", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_2_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version13")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version14")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version15")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version10")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version11")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version12")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_2_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.v7_0")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version8")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version9")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version6")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version7")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.v7_0_0_1")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version1")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version4")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version5")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version2")
> AddVersionParent("pbm.version.v7_0_2_0", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version11")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version14")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version12")
> AddVersionParent("pbm.version.v7_0_2_0", "pbm.version.version13")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_3_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.version.version0")
> AddVersionParent("vim.version.version13", "vmodl.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version13")
> AddVersionParent("vim.version.version13", "vim.version.version10")
> AddVersionParent("vim.version.version13", "vim.version.version11")
> AddVersionParent("vim.version.version13", "vim.version.version12")
> AddVersionParent("vim.version.version13", "vim.version.version8")
> AddVersionParent("vim.version.version13", "vim.version.version9")
> AddVersionParent("vim.version.version13", "vim.version.version6")
> AddVersionParent("vim.version.version13", "vim.version.version7")
> AddVersionParent("vim.version.version13", "vim.version.version1")
> AddVersionParent("vim.version.version13", "vim.version.version4")
> AddVersionParent("vim.version.version13", "vim.version.version5")
> AddVersionParent("vim.version.version13", "vim.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version3")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.version.version0")
> AddVersionParent("vim.version.version14", "vmodl.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.version.version2")
> AddVersionParent("vim.version.version14", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version14", "vim.version.version13")
> AddVersionParent("vim.version.version14", "vim.version.version14")
> AddVersionParent("vim.version.version14", "vim.version.version10")
> AddVersionParent("vim.version.version14", "vim.version.version11")
> AddVersionParent("vim.version.version14", "vim.version.version12")
> AddVersionParent("vim.version.version14", "vim.version.version8")
> AddVersionParent("vim.version.version14", "vim.version.version9")
> AddVersionParent("vim.version.version14", "vim.version.version6")
> AddVersionParent("vim.version.version14", "vim.version.version7")
> AddVersionParent("vim.version.version14", "vim.version.version1")
> AddVersionParent("vim.version.version14", "vim.version.version4")
> AddVersionParent("vim.version.version14", "vim.version.version5")
> AddVersionParent("vim.version.version14", "vim.version.version2")
> AddVersionParent("vim.version.version14", "vim.version.version3")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.version.version0")
> AddVersionParent("vim.version.version15", "vmodl.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.version.version2")
> AddVersionParent("vim.version.version15", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version15", "vim.version.version13")
> AddVersionParent("vim.version.version15", "vim.version.version14")
> AddVersionParent("vim.version.version15", "vim.version.version15")
> AddVersionParent("vim.version.version15", "vim.version.version10")
> AddVersionParent("vim.version.version15", "vim.version.version11")
> AddVersionParent("vim.version.version15", "vim.version.version12")
> AddVersionParent("vim.version.version15", "vim.version.version8")
> AddVersionParent("vim.version.version15", "vim.version.version9")
> AddVersionParent("vim.version.version15", "vim.version.version6")
> AddVersionParent("vim.version.version15", "vim.version.version7")
> AddVersionParent("vim.version.version15", "vim.version.version1")
> AddVersionParent("vim.version.version15", "vim.version.version4")
> AddVersionParent("vim.version.version15", "vim.version.version5")
> AddVersionParent("vim.version.version15", "vim.version.version2")
> AddVersionParent("vim.version.version15", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_1_1")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version1")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version2")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version0")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version1")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.version.version2")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v6_9_1")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_0_2")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v6_8_7")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.v7_0_3_0", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_2_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_3_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version13")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version14")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version15")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_3_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version10")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version11")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version12")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_2_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_2_1")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.v7_0")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version8")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version9")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version6")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version7")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.v7_0_0_1")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version1")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version4")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version5")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version2")
> AddVersionParent("pbm.version.v7_0_3_0", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version11")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version14")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version12")
> AddVersionParent("pbm.version.v7_0_3_0", "pbm.version.version13")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.version.version0")
> AddVersionParent("vim.version.version10", "vmodl.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version10")
> AddVersionParent("vim.version.version10", "vim.version.version8")
> AddVersionParent("vim.version.version10", "vim.version.version9")
> AddVersionParent("vim.version.version10", "vim.version.version6")
> AddVersionParent("vim.version.version10", "vim.version.version7")
> AddVersionParent("vim.version.version10", "vim.version.version1")
> AddVersionParent("vim.version.version10", "vim.version.version4")
> AddVersionParent("vim.version.version10", "vim.version.version5")
> AddVersionParent("vim.version.version10", "vim.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.version.version0")
> AddVersionParent("vim.version.version11", "vmodl.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version10")
> AddVersionParent("vim.version.version11", "vim.version.version11")
> AddVersionParent("vim.version.version11", "vim.version.version8")
> AddVersionParent("vim.version.version11", "vim.version.version9")
> AddVersionParent("vim.version.version11", "vim.version.version6")
> AddVersionParent("vim.version.version11", "vim.version.version7")
> AddVersionParent("vim.version.version11", "vim.version.version1")
> AddVersionParent("vim.version.version11", "vim.version.version4")
> AddVersionParent("vim.version.version11", "vim.version.version5")
> AddVersionParent("vim.version.version11", "vim.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.version.version0")
> AddVersionParent("vim.version.version12", "vmodl.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version10")
> AddVersionParent("vim.version.version12", "vim.version.version11")
> AddVersionParent("vim.version.version12", "vim.version.version12")
> AddVersionParent("vim.version.version12", "vim.version.version8")
> AddVersionParent("vim.version.version12", "vim.version.version9")
> AddVersionParent("vim.version.version12", "vim.version.version6")
> AddVersionParent("vim.version.version12", "vim.version.version7")
> AddVersionParent("vim.version.version12", "vim.version.version1")
> AddVersionParent("vim.version.version12", "vim.version.version4")
> AddVersionParent("vim.version.version12", "vim.version.version5")
> AddVersionParent("vim.version.version12", "vim.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version1")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version2")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version0")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version1")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.version.version2")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v6_9_1")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0_0_2")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v6_8_7")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.v7_0_1_0", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version13")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version14")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version15")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version10")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version11")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version12")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0_1_0")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.v7_0")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version8")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version9")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version6")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version7")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.v7_0_0_1")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version1")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version4")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version5")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version2")
> AddVersionParent("pbm.version.v7_0_1_0", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version11")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version14")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version12")
> AddVersionParent("pbm.version.v7_0_1_0", "pbm.version.version13")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version3")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version8", "vmodl.version.version0")
> AddVersionParent("vim.version.version8", "vmodl.version.version1")
> AddVersionParent("vim.version.version8", "vmodl.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version8")
> AddVersionParent("vim.version.version8", "vim.version.version6")
> AddVersionParent("vim.version.version8", "vim.version.version7")
> AddVersionParent("vim.version.version8", "vim.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version4")
> AddVersionParent("vim.version.version8", "vim.version.version5")
> AddVersionParent("vim.version.version8", "vim.version.version2")
> AddVersionParent("vim.version.version8", "vim.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.version.version0")
> AddVersionParent("vim.version.version9", "vmodl.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version8")
> AddVersionParent("vim.version.version9", "vim.version.version9")
> AddVersionParent("vim.version.version9", "vim.version.version6")
> AddVersionParent("vim.version.version9", "vim.version.version7")
> AddVersionParent("vim.version.version9", "vim.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version4")
> AddVersionParent("vim.version.version9", "vim.version.version5")
> AddVersionParent("vim.version.version9", "vim.version.version2")
> AddVersionParent("vim.version.version9", "vim.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version6", "vmodl.version.version0")
> AddVersionParent("vim.version.version6", "vmodl.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version6")
> AddVersionParent("vim.version.version6", "vim.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version4")
> AddVersionParent("vim.version.version6", "vim.version.version5")
> AddVersionParent("vim.version.version6", "vim.version.version2")
> AddVersionParent("vim.version.version6", "vim.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.version.version0")
> AddVersionParent("vim.version.version7", "vmodl.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version6")
> AddVersionParent("vim.version.version7", "vim.version.version7")
> AddVersionParent("vim.version.version7", "vim.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version4")
> AddVersionParent("vim.version.version7", "vim.version.version5")
> AddVersionParent("vim.version.version7", "vim.version.version2")
> AddVersionParent("vim.version.version7", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version1")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version2")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version0")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version1")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.version.version2")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v6_9_1")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.v7_0")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v6_8_7")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.v7_0_0_1", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version13")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version14")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version15")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version10")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version11")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version12")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.v7_0")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version8")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version9")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version6")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version7")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.v7_0_0_1")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version1")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version4")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version5")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version2")
> AddVersionParent("pbm.version.v7_0_0_1", "vim.version.version3")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version11")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version14")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version12")
> AddVersionParent("pbm.version.v7_0_0_1", "pbm.version.version13")
> AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.version1", "vim.version.version1")
> AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version4", "vmodl.version.version0")
> AddVersionParent("vim.version.version4", "vim.version.version1")
> AddVersionParent("vim.version.version4", "vim.version.version4")
> AddVersionParent("vim.version.version4", "vim.version.version2")
> AddVersionParent("vim.version.version4", "vim.version.version3")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version5", "vmodl.version.version0")
> AddVersionParent("vim.version.version5", "vmodl.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version4")
> AddVersionParent("vim.version.version5", "vim.version.version5")
> AddVersionParent("vim.version.version5", "vim.version.version2")
> AddVersionParent("vim.version.version5", "vim.version.version3")
> AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version2", "vmodl.version.version0")
> AddVersionParent("vim.version.version2", "vim.version.version1")
> AddVersionParent("vim.version.version2", "vim.version.version2")
> AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version3", "vmodl.version.version0")
> AddVersionParent("vim.version.version3", "vim.version.version1")
> AddVersionParent("vim.version.version3", "vim.version.version2")
> AddVersionParent("vim.version.version3", "vim.version.version3")
> AddVersionParent("pbm.version.version11", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.version11", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.version11", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.version11", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.version11", "pbm.version.version1")
> AddVersionParent("pbm.version.version11", "pbm.version.version2")
> AddVersionParent("pbm.version.version11", "vmodl.version.version0")
> AddVersionParent("pbm.version.version11", "vmodl.version.version1")
> AddVersionParent("pbm.version.version11", "vmodl.version.version2")
> AddVersionParent("pbm.version.version11", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.version11", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.version11", "vim.version.version10")
> AddVersionParent("pbm.version.version11", "vim.version.version11")
> AddVersionParent("pbm.version.version11", "vim.version.version8")
> AddVersionParent("pbm.version.version11", "vim.version.version9")
> AddVersionParent("pbm.version.version11", "vim.version.version6")
> AddVersionParent("pbm.version.version11", "vim.version.version7")
> AddVersionParent("pbm.version.version11", "vim.version.version1")
> AddVersionParent("pbm.version.version11", "vim.version.version4")
> AddVersionParent("pbm.version.version11", "vim.version.version5")
> AddVersionParent("pbm.version.version11", "vim.version.version2")
> AddVersionParent("pbm.version.version11", "vim.version.version3")
> AddVersionParent("pbm.version.version11", "pbm.version.version11")
> AddVersionParent("pbm.version.version14", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.version14", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.version14", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.version14", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.version14", "pbm.version.version1")
> AddVersionParent("pbm.version.version14", "pbm.version.version2")
> AddVersionParent("pbm.version.version14", "vmodl.version.version0")
> AddVersionParent("pbm.version.version14", "vmodl.version.version1")
> AddVersionParent("pbm.version.version14", "vmodl.version.version2")
> AddVersionParent("pbm.version.version14", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.version14", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.version14", "vim.version.version13")
> AddVersionParent("pbm.version.version14", "vim.version.version14")
> AddVersionParent("pbm.version.version14", "vim.version.version10")
> AddVersionParent("pbm.version.version14", "vim.version.version11")
> AddVersionParent("pbm.version.version14", "vim.version.version12")
> AddVersionParent("pbm.version.version14", "vim.version.version8")
> AddVersionParent("pbm.version.version14", "vim.version.version9")
> AddVersionParent("pbm.version.version14", "vim.version.version6")
> AddVersionParent("pbm.version.version14", "vim.version.version7")
> AddVersionParent("pbm.version.version14", "vim.version.version1")
> AddVersionParent("pbm.version.version14", "vim.version.version4")
> AddVersionParent("pbm.version.version14", "vim.version.version5")
> AddVersionParent("pbm.version.version14", "vim.version.version2")
> AddVersionParent("pbm.version.version14", "vim.version.version3")
> AddVersionParent("pbm.version.version14", "pbm.version.version11")
> AddVersionParent("pbm.version.version14", "pbm.version.version14")
> AddVersionParent("pbm.version.version14", "pbm.version.version12")
> AddVersionParent("pbm.version.version14", "pbm.version.version13")
> AddVersionParent("pbm.version.version12", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.version12", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.version12", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.version12", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.version12", "pbm.version.version1")
> AddVersionParent("pbm.version.version12", "pbm.version.version2")
> AddVersionParent("pbm.version.version12", "vmodl.version.version0")
> AddVersionParent("pbm.version.version12", "vmodl.version.version1")
> AddVersionParent("pbm.version.version12", "vmodl.version.version2")
> AddVersionParent("pbm.version.version12", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.version12", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.version12", "vim.version.version10")
> AddVersionParent("pbm.version.version12", "vim.version.version11")
> AddVersionParent("pbm.version.version12", "vim.version.version12")
> AddVersionParent("pbm.version.version12", "vim.version.version8")
> AddVersionParent("pbm.version.version12", "vim.version.version9")
> AddVersionParent("pbm.version.version12", "vim.version.version6")
> AddVersionParent("pbm.version.version12", "vim.version.version7")
> AddVersionParent("pbm.version.version12", "vim.version.version1")
> AddVersionParent("pbm.version.version12", "vim.version.version4")
> AddVersionParent("pbm.version.version12", "vim.version.version5")
> AddVersionParent("pbm.version.version12", "vim.version.version2")
> AddVersionParent("pbm.version.version12", "vim.version.version3")
> AddVersionParent("pbm.version.version12", "pbm.version.version11")
> AddVersionParent("pbm.version.version12", "pbm.version.version12")
> AddVersionParent("pbm.version.version13", "vmodl.query.version.version4")
> AddVersionParent("pbm.version.version13", "vmodl.query.version.version3")
> AddVersionParent("pbm.version.version13", "vmodl.query.version.version2")
> AddVersionParent("pbm.version.version13", "vmodl.query.version.version1")
> AddVersionParent("pbm.version.version13", "pbm.version.version1")
> AddVersionParent("pbm.version.version13", "pbm.version.version2")
> AddVersionParent("pbm.version.version13", "vmodl.version.version0")
> AddVersionParent("pbm.version.version13", "vmodl.version.version1")
> AddVersionParent("pbm.version.version13", "vmodl.version.version2")
> AddVersionParent("pbm.version.version13", "vmodl.reflect.version.version1")
> AddVersionParent("pbm.version.version13", "vmodl.reflect.version.version2")
> AddVersionParent("pbm.version.version13", "vim.version.version13")
> AddVersionParent("pbm.version.version13", "vim.version.version10")
> AddVersionParent("pbm.version.version13", "vim.version.version11")
> AddVersionParent("pbm.version.version13", "vim.version.version12")
> AddVersionParent("pbm.version.version13", "vim.version.version8")
> AddVersionParent("pbm.version.version13", "vim.version.version9")
> AddVersionParent("pbm.version.version13", "vim.version.version6")
> AddVersionParent("pbm.version.version13", "vim.version.version7")
> AddVersionParent("pbm.version.version13", "vim.version.version1")
> AddVersionParent("pbm.version.version13", "vim.version.version4")
> AddVersionParent("pbm.version.version13", "vim.version.version5")
> AddVersionParent("pbm.version.version13", "vim.version.version2")
> AddVersionParent("pbm.version.version13", "vim.version.version3")
> AddVersionParent("pbm.version.version13", "pbm.version.version11")
> AddVersionParent("pbm.version.version13", "pbm.version.version12")
> AddVersionParent("pbm.version.version13", "pbm.version.version13")
> 
> newestVersions.Add("pbm.version.v7_0_3_0")
> publicVersions.Add("pbm.version.v7_0_3_0")
> dottedVersions.Add("pbm.version.v7_0_3_0")
> oldestVersions.Add("pbm.version.version1")
> 
> CreateDataType("pbm.AboutInfo", "PbmAboutInfo", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("version", "string", "pbm.version.version1", 0), ("instanceUuid", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.ExtendedElementDescription", "PbmExtendedElementDescription", "vmodl.DynamicData", "pbm.version.version1", [("label", "string", "pbm.version.version1", 0), ("summary", "string", "pbm.version.version1", 0), ("key", "string", "pbm.version.version1", 0), ("messageCatalogKeyPrefix", "string", "pbm.version.version1", 0), ("messageArg", "vmodl.KeyAnyValue[]", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.ServerObjectRef", "PbmServerObjectRef", "vmodl.DynamicData", "pbm.version.version1", [("objectType", "string", "pbm.version.version1", 0), ("key", "string", "pbm.version.version1", 0), ("serverUuid", "string", "pbm.version.version1", F_OPTIONAL)])
> CreateEnumType("pbm.ServerObjectRef.VvolType", "PbmVvolType", "pbm.version.version1", ["Config", "Data", "Swap"])
> CreateEnumType("pbm.ServerObjectRef.ObjectType", "PbmObjectType", "pbm.version.version1", ["virtualMachine", "virtualMachineAndDisks", "virtualDiskId", "virtualDiskUUID", "datastore", "vsanObjectId", "fileShareId", "host", "cluster", "unknown"])
> CreateManagedType("pbm.ServiceInstance", "PbmServiceInstance", "vmodl.ManagedObject", "pbm.version.version1", [("content", "pbm.ServiceInstanceContent", "pbm.version.version1", 0, "System.Anonymous")], [("retrieveContent", "PbmRetrieveServiceContent", "pbm.version.version1", (), (0, "pbm.ServiceInstanceContent", "pbm.ServiceInstanceContent"), "System.Anonymous", None)])
> CreateDataType("pbm.ServiceInstanceContent", "PbmServiceInstanceContent", "vmodl.DynamicData", "pbm.version.version1", [("aboutInfo", "pbm.AboutInfo", "pbm.version.version1", 0), ("sessionManager", "pbm.auth.SessionManager", "pbm.version.version1", 0), ("capabilityMetadataManager", "pbm.capability.CapabilityMetadataManager", "pbm.version.version1", 0), ("profileManager", "pbm.profile.ProfileManager", "pbm.version.version1", 0), ("complianceManager", "pbm.compliance.ComplianceManager", "pbm.version.version1", 0), ("placementSolver", "pbm.placement.PlacementSolver", "pbm.version.version1", 0), ("replicationManager", "pbm.replication.ReplicationManager", "pbm.version.version11", F_OPTIONAL)])
> CreateManagedType("pbm.auth.SessionManager", "PbmSessionManager", "vmodl.ManagedObject", "pbm.version.version1", None, None)
> CreateDataType("pbm.capability.CapabilityMetadata", "PbmCapabilityMetadata", "vmodl.DynamicData", "pbm.version.version1", [("id", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("summary", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("mandatory", "boolean", "pbm.version.version1", F_OPTIONAL), ("hint", "boolean", "pbm.version.version1", F_OPTIONAL), ("keyId", "string", "pbm.version.version1", F_OPTIONAL), ("allowMultipleConstraints", "boolean", "pbm.version.version1", F_OPTIONAL), ("propertyMetadata", "pbm.capability.PropertyMetadata[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.CapabilityMetadata.UniqueId", "PbmCapabilityMetadataUniqueId", "vmodl.DynamicData", "pbm.version.version1", [("namespace", "string", "pbm.version.version1", 0), ("id", "string", "pbm.version.version1", 0)])
> CreateManagedType("pbm.capability.CapabilityMetadataManager", "PbmCapabilityMetadataManager", "vmodl.ManagedObject", "pbm.version.version1", None, None)
> CreateDataType("pbm.capability.ConstraintInstance", "PbmCapabilityConstraintInstance", "vmodl.DynamicData", "pbm.version.version1", [("propertyInstance", "pbm.capability.PropertyInstance[]", "pbm.version.version1", 0)])
> CreateEnumType("pbm.capability.Operator", "PbmCapabilityOperator", "pbm.version.version11", ["NOT"])
> CreateDataType("pbm.capability.PropertyInstance", "PbmCapabilityPropertyInstance", "vmodl.DynamicData", "pbm.version.version1", [("id", "string", "pbm.version.version1", 0), ("operator", "string", "pbm.version.version11", F_OPTIONAL), ("value", "anyType", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.PropertyMetadata", "PbmCapabilityPropertyMetadata", "vmodl.DynamicData", "pbm.version.version1", [("id", "string", "pbm.version.version1", 0), ("summary", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("mandatory", "boolean", "pbm.version.version1", 0), ("type", "pbm.capability.TypeInfo", "pbm.version.version1", F_OPTIONAL), ("defaultValue", "anyType", "pbm.version.version1", F_OPTIONAL), ("allowedValue", "anyType", "pbm.version.version1", F_OPTIONAL), ("requirementsTypeHint", "string", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.capability.TypeInfo", "PbmCapabilityTypeInfo", "vmodl.DynamicData", "pbm.version.version1", [("typeName", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.CapabilityObjectMetadataPerCategory", "PbmCapabilityMetadataPerCategory", "vmodl.DynamicData", "pbm.version.version1", [("subCategory", "string", "pbm.version.version1", 0), ("capabilityMetadata", "pbm.capability.CapabilityMetadata[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.CapabilityObjectSchema", "PbmCapabilitySchema", "vmodl.DynamicData", "pbm.version.version1", [("vendorInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "pbm.version.version1", 0), ("namespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "pbm.version.version1", 0), ("lineOfService", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", F_OPTIONAL), ("capabilityMetadataPerCategory", "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "PbmCapabilitySchemaVendorInfo", "vmodl.DynamicData", "pbm.version.version1", [("vendorUuid", "string", "pbm.version.version1", 0), ("info", "pbm.ExtendedElementDescription", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "PbmCapabilityNamespaceInfo", "vmodl.DynamicData", "pbm.version.version1", [("version", "string", "pbm.version.version1", 0), ("namespace", "string", "pbm.version.version1", 0), ("info", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
> CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo", "PbmCapabilityVendorResourceTypeInfo", "vmodl.DynamicData", "pbm.version.version1", [("resourceType", "string", "pbm.version.version1", 0), ("vendorNamespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorNamespaceInfo[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.CapabilityObjectSchema.VendorNamespaceInfo", "PbmCapabilityVendorNamespaceInfo", "vmodl.DynamicData", "pbm.version.version1", [("vendorInfo", "pbm.capability.provider.CapabilityObjectSchema.VendorInfo", "pbm.version.version1", 0), ("namespaceInfo", "pbm.capability.provider.CapabilityObjectSchema.NamespaceInfo", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.provider.LineOfServiceInfo", "PbmLineOfServiceInfo", "vmodl.DynamicData", "pbm.version.version11", [("lineOfService", "string", "pbm.version.version11", 0), ("name", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("description", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
> CreateEnumType("pbm.capability.provider.LineOfServiceInfo.LineOfServiceEnum", "PbmLineOfServiceInfoLineOfServiceEnum", "pbm.version.version11", ["INSPECTION", "COMPRESSION", "ENCRYPTION", "REPLICATION", "CACHING", "PERSISTENCE", "DATA_PROVIDER", "DATASTORE_IO_CONTROL", "DATA_PROTECTION"])
> CreateDataType("pbm.capability.provider.PersistenceBasedDataServiceInfo", "PbmPersistenceBasedDataServiceInfo", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", [("compatiblePersistenceSchemaNamespace", "string[]", "pbm.version.version11", F_OPTIONAL)])
> CreateDataType("pbm.capability.provider.VaioDataServiceInfo", "PbmVaioDataServiceInfo", "pbm.capability.provider.LineOfServiceInfo", "pbm.version.version11", None)
> CreateEnumType("pbm.capability.types.BuiltinGenericTypesEnum", "PbmBuiltinGenericType", "pbm.version.version1", ["VMW_RANGE", "VMW_SET"])
> CreateEnumType("pbm.capability.types.BuiltinTypesEnum", "PbmBuiltinType", "pbm.version.version1", ["XSD_LONG", "XSD_SHORT", "XSD_INTEGER", "XSD_INT", "XSD_STRING", "XSD_BOOLEAN", "XSD_DOUBLE", "XSD_DATETIME", "VMW_TIMESPAN", "VMW_POLICY"])
> CreateDataType("pbm.capability.types.DescriptiveValue", "PbmCapabilityDescription", "vmodl.DynamicData", "pbm.version.version1", [("description", "pbm.ExtendedElementDescription", "pbm.version.version1", 0), ("value", "anyType", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.types.DiscreteSet", "PbmCapabilityDiscreteSet", "vmodl.DynamicData", "pbm.version.version1", [("values", "anyType[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.types.Range", "PbmCapabilityRange", "vmodl.DynamicData", "pbm.version.version1", [("min", "anyType", "pbm.version.version1", 0), ("max", "anyType", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.types.TimeSpan", "PbmCapabilityTimeSpan", "vmodl.DynamicData", "pbm.version.version1", [("value", "int", "pbm.version.version1", 0), ("unit", "string", "pbm.version.version1", 0)])
> CreateEnumType("pbm.capability.types.TimeUnitEnum", "PbmCapabilityTimeUnitType", "pbm.version.version1", ["SECONDS", "MINUTES", "HOURS", "DAYS", "WEEKS", "MONTHS", "YEARS"])
> CreateManagedType("pbm.compliance.ComplianceManager", "PbmComplianceManager", "vmodl.ManagedObject", "pbm.version.version1", None, [("checkCompliance", "PbmCheckCompliance", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.compliance.ComplianceResult[]", "pbm.compliance.ComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("fetchComplianceResult", "PbmFetchComplianceResult", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.compliance.ComplianceResult[]", "pbm.compliance.ComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("checkRollupCompliance", "PbmCheckRollupCompliance", "pbm.version.version1", (("entity", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.compliance.RollupComplianceResult[]", "pbm.compliance.RollupComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("fetchRollupComplianceResult", "PbmFetchRollupComplianceResult", "pbm.version.version1", (("entity", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.compliance.RollupComplianceResult[]", "pbm.compliance.RollupComplianceResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryByRollupComplianceStatus", "PbmQueryByRollupComplianceStatus", "pbm.version.version11", (("status", "string", "pbm.version.version11", 0, None),), (F_OPTIONAL, "pbm.ServerObjectRef[]", "pbm.ServerObjectRef[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.PBMFault", ])])
> CreateDataType("pbm.compliance.ComplianceResult", "PbmComplianceResult", "vmodl.DynamicData", "pbm.version.version1", [("checkTime", "vmodl.DateTime", "pbm.version.version1", 0), ("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL), ("complianceTaskStatus", "string", "pbm.version.version11", F_OPTIONAL), ("complianceStatus", "string", "pbm.version.version1", 0), ("mismatch", "boolean", "pbm.version.version1", 0), ("violatedPolicies", "pbm.compliance.PolicyStatus[]", "pbm.version.version1", F_OPTIONAL), ("errorCause", "vmodl.MethodFault[]", "pbm.version.version11", F_OPTIONAL), ("operationalStatus", "pbm.compliance.OperationalStatus", "pbm.version.version1", F_OPTIONAL), ("info", "pbm.ExtendedElementDescription", "pbm.version.version11", F_OPTIONAL)])
> CreateEnumType("pbm.compliance.ComplianceResult.ComplianceStatus", "PbmComplianceStatus", "pbm.version.version1", ["compliant", "nonCompliant", "unknown", "notApplicable", "outOfDate"])
> CreateEnumType("pbm.compliance.ComplianceResult.ComplianceTaskStatus", "PbmComplianceResultComplianceTaskStatus", "pbm.version.version11", ["inProgress", "success", "failed"])
> CreateEnumType("pbm.compliance.EntityHealthStatus.HealthStatus", "PbmHealthStatusForEntity", "pbm.version.v7_0", ["red", "yellow", "green", "unknown"])
> CreateDataType("pbm.compliance.FetchEntityHealthStatusSpec", "PbmFetchEntityHealthStatusSpec", "vmodl.DynamicData", "pbm.version.v7_0_3_0", [("objectRef", "pbm.ServerObjectRef", "pbm.version.v7_0_3_0", 0), ("backingId", "string", "pbm.version.v7_0_3_0", F_OPTIONAL)])
> CreateDataType("pbm.compliance.OperationalStatus", "PbmComplianceOperationalStatus", "vmodl.DynamicData", "pbm.version.version1", [("healthy", "boolean", "pbm.version.version1", F_OPTIONAL), ("operationETA", "vmodl.DateTime", "pbm.version.version1", F_OPTIONAL), ("operationProgress", "long", "pbm.version.version1", F_OPTIONAL), ("transitional", "boolean", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.compliance.PolicyStatus", "PbmCompliancePolicyStatus", "vmodl.DynamicData", "pbm.version.version1", [("expectedValue", "pbm.capability.CapabilityInstance", "pbm.version.version1", 0), ("currentValue", "pbm.capability.CapabilityInstance", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.compliance.RollupComplianceResult", "PbmRollupComplianceResult", "vmodl.DynamicData", "pbm.version.version1", [("oldestCheckTime", "vmodl.DateTime", "pbm.version.version1", 0), ("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("overallComplianceStatus", "string", "pbm.version.version1", 0), ("overallComplianceTaskStatus", "string", "pbm.version.version11", F_OPTIONAL), ("result", "pbm.compliance.ComplianceResult[]", "pbm.version.version1", F_OPTIONAL), ("errorCause", "vmodl.MethodFault[]", "pbm.version.version11", F_OPTIONAL), ("profileMismatch", "boolean", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.PBMFault", "PbmFault", "vmodl.MethodFault", "pbm.version.version1", None)
> CreateDataType("pbm.fault.ProfileStorageFault", "PbmFaultProfileStorageFault", "pbm.fault.PBMFault", "pbm.version.version1", None)
> CreateDataType("pbm.fault.ResourceInUse", "PbmResourceInUse", "pbm.fault.PBMFault", "pbm.version.version1", [("type", "vmodl.TypeName", "pbm.version.version1", F_OPTIONAL), ("name", "string", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.placement.CompatibilityResult", "PbmPlacementCompatibilityResult", "vmodl.DynamicData", "pbm.version.version1", [("hub", "pbm.placement.PlacementHub", "pbm.version.version1", 0), ("matchingResources", "pbm.placement.MatchingResources[]", "pbm.version.version11", F_OPTIONAL), ("howMany", "long", "pbm.version.version11", F_OPTIONAL), ("utilization", "pbm.placement.ResourceUtilization[]", "pbm.version.version11", F_OPTIONAL), ("warning", "vmodl.MethodFault[]", "pbm.version.version1", F_OPTIONAL), ("error", "vmodl.MethodFault[]", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.placement.MatchingResources", "PbmPlacementMatchingResources", "vmodl.DynamicData", "pbm.version.version11", None)
> CreateDataType("pbm.placement.PlacementHub", "PbmPlacementHub", "vmodl.DynamicData", "pbm.version.version1", [("hubType", "string", "pbm.version.version1", 0), ("hubId", "string", "pbm.version.version1", 0)])
> CreateManagedType("pbm.placement.PlacementSolver", "PbmPlacementSolver", "vmodl.ManagedObject", "pbm.version.version1", None, [("queryMatchingHub", "PbmQueryMatchingHub", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.PlacementHub[]", "pbm.placement.PlacementHub[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryMatchingHubWithSpec", "PbmQueryMatchingHubWithSpec", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("createSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.PlacementHub[]", "pbm.placement.PlacementHub[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("checkCompatibility", "PbmCheckCompatibility", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", None), ("checkCompatibilityWithSpec", "PbmCheckCompatibilityWithSpec", "pbm.version.version1", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version1", F_OPTIONAL, None),("profileSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", None), ("checkRequirements", "PbmCheckRequirements", "pbm.version.version11", (("hubsToSearch", "pbm.placement.PlacementHub[]", "pbm.version.version11", F_OPTIONAL, None),("placementSubjectRef", "pbm.ServerObjectRef", "pbm.version.version11", F_OPTIONAL, None),("placementSubjectRequirement", "pbm.placement.Requirement[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.placement.CompatibilityResult[]", "pbm.placement.CompatibilityResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
> CreateDataType("pbm.placement.Requirement", "PbmPlacementRequirement", "vmodl.DynamicData", "pbm.version.version11", None)
> CreateDataType("pbm.placement.ResourceUtilization", "PbmPlacementResourceUtilization", "vmodl.DynamicData", "pbm.version.version11", [("name", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("description", "pbm.ExtendedElementDescription", "pbm.version.version11", 0), ("availableBefore", "long", "pbm.version.version11", F_OPTIONAL), ("availableAfter", "long", "pbm.version.version11", F_OPTIONAL), ("total", "long", "pbm.version.version11", F_OPTIONAL)])
> CreateEnumType("pbm.profile.AssociateAndApplyPolicyStatus.PolicyStatus", "PbmAssociateAndApplyPolicyStatusPolicyStatus", "pbm.version.version1", ["success", "failed", "invalid"])
> CreateDataType("pbm.profile.CapabilityBasedProfileCreateSpec", "PbmCapabilityProfileCreateSpec", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("category", "string", "pbm.version.version11", F_OPTIONAL), ("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", 0)])
> CreateDataType("pbm.profile.CapabilityBasedProfileUpdateSpec", "PbmCapabilityProfileUpdateSpec", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", F_OPTIONAL), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.profile.CapabilityConstraints", "PbmCapabilityConstraints", "vmodl.DynamicData", "pbm.version.version1", None)
> CreateDataType("pbm.profile.DataServiceToPoliciesMap", "PbmDataServiceToPoliciesMap", "vmodl.DynamicData", "pbm.version.version11", [("dataServicePolicy", "pbm.profile.ProfileId", "pbm.version.version11", 0), ("parentStoragePolicies", "pbm.profile.ProfileId[]", "pbm.version.version11", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version11", F_OPTIONAL)])
> CreateDataType("pbm.profile.DefaultProfileInfo", "PbmDefaultProfileInfo", "vmodl.DynamicData", "pbm.version.version2", [("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0), ("defaultProfile", "pbm.profile.Profile", "pbm.version.version2", F_OPTIONAL)])
> CreateEnumType("pbm.profile.EntityAssociations.Operation", "PbmOperation", "pbm.version.version11", ["CREATE", "REGISTER", "RECONFIGURE", "MIGRATE", "CLONE"])
> CreateEnumType("pbm.profile.IofilterInfo.FilterType", "PbmIofilterInfoFilterType", "pbm.version.version1", ["INSPECTION", "COMPRESSION", "ENCRYPTION", "REPLICATION", "CACHE", "DATAPROVIDER", "DATASTOREIOCONTROL"])
> CreateDataType("pbm.profile.Profile", "PbmProfile", "vmodl.DynamicData", "pbm.version.version1", [("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0), ("name", "string", "pbm.version.version1", 0), ("description", "string", "pbm.version.version1", F_OPTIONAL), ("creationTime", "vmodl.DateTime", "pbm.version.version1", 0), ("createdBy", "string", "pbm.version.version1", 0), ("lastUpdatedTime", "vmodl.DateTime", "pbm.version.version1", 0), ("lastUpdatedBy", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.profile.ProfileId", "PbmProfileId", "vmodl.DynamicData", "pbm.version.version1", [("uniqueId", "string", "pbm.version.version1", 0)])
> CreateManagedType("pbm.profile.ProfileManager", "PbmProfileProfileManager", "vmodl.ManagedObject", "pbm.version.version1", None, [("fetchResourceType", "PbmFetchResourceType", "pbm.version.version1", (), (F_OPTIONAL, "pbm.profile.ResourceType[]", "pbm.profile.ResourceType[]"), "StorageProfile.View", None), ("fetchVendorInfo", "PbmFetchVendorInfo", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo[]", "pbm.capability.provider.CapabilityObjectSchema.VendorResourceTypeInfo[]"), "StorageProfile.View", None), ("fetchCapabilityMetadata", "PbmFetchCapabilityMetadata", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", F_OPTIONAL, None),("vendorUuid", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]", "pbm.capability.provider.CapabilityObjectMetadataPerCategory[]"), "StorageProfile.View", None), ("fetchCapabilitySchema", "PbmFetchCapabilitySchema", "pbm.version.version11", (("vendorUuid", "string", "pbm.version.version11", F_OPTIONAL, None),("lineOfService", "string[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.capability.provider.CapabilityObjectSchema[]", "pbm.capability.provider.CapabilityObjectSchema[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("create", "PbmCreate", "pbm.version.version1", (("createSpec", "pbm.profile.CapabilityBasedProfileCreateSpec", "pbm.version.version1", 0, None),), (0, "pbm.profile.ProfileId", "pbm.profile.ProfileId"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.ProfileStorageFault", "pbm.fault.DuplicateName", ]), ("update", "PbmUpdate", "pbm.version.version1", (("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),("updateSpec", "pbm.profile.CapabilityBasedProfileUpdateSpec", "pbm.version.version1", 0, None),), (0, "void", "void"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.ProfileStorageFault", ]), ("delete", "PbmDelete", "pbm.version.version1", (("profileId", "pbm.profile.ProfileId[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileOperationOutcome[]", "pbm.profile.ProfileOperationOutcome[]"), "StorageProfile.Update", None), ("queryProfile", "PbmQueryProfile", "pbm.version.version1", (("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0, None),("profileCategory", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.ProfileId[]", "pbm.profile.ProfileId[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", ]), ("retrieveContent", "PbmRetrieveContent", "pbm.version.version1", (("profileIds", "pbm.profile.ProfileId[]", "pbm.version.version1", 0, None),), (0, "pbm.profile.Profile[]", "pbm.profile.Profile[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", ]), ("queryAssociatedProfiles", "PbmQueryAssociatedProfiles", "pbm.version.version1", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.QueryProfileResult[]", "pbm.profile.QueryProfileResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryAssociatedProfile", "PbmQueryAssociatedProfile", "pbm.version.version1", (("entity", "pbm.ServerObjectRef", "pbm.version.version1", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileId[]", "pbm.profile.ProfileId[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryAssociatedEntity", "PbmQueryAssociatedEntity", "pbm.version.version1", (("profile", "pbm.profile.ProfileId", "pbm.version.version1", 0, None),("entityType", "string", "pbm.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.ServerObjectRef[]", "pbm.ServerObjectRef[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ]), ("queryDefaultRequirementProfile", "PbmQueryDefaultRequirementProfile", "pbm.version.version2", (("hub", "pbm.placement.PlacementHub", "pbm.version.version2", 0, None),), (F_OPTIONAL, "pbm.profile.ProfileId", "pbm.profile.ProfileId"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("resetDefaultRequirementProfile", "PbmResetDefaultRequirementProfile", "pbm.version.version1", (("profile", "pbm.profile.ProfileId", "pbm.version.version1", F_OPTIONAL, None),), (0, "void", "void"), "StorageProfile.Update", None), ("assignDefaultRequirementProfile", "PbmAssignDefaultRequirementProfile", "pbm.version.version2", (("profile", "pbm.profile.ProfileId", "pbm.version.version2", 0, None),("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (0, "void", "void"), "StorageProfile.Update", ["vmodl.fault.InvalidArgument", "pbm.fault.LegacyHubsNotSupported", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("findApplicableDefaultProfile", "PbmFindApplicableDefaultProfile", "pbm.version.version2", (("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (F_OPTIONAL, "pbm.profile.Profile[]", "pbm.profile.Profile[]"), "StorageProfile.View", ["pbm.fault.LegacyHubsNotSupported", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", "vmodl.fault.InvalidArgument", ]), ("queryDefaultRequirementProfiles", "PbmQueryDefaultRequirementProfiles", "pbm.version.version2", (("datastores", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0, None),), (0, "pbm.profile.DefaultProfileInfo[]", "pbm.profile.DefaultProfileInfo[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.NonExistentHubs", "pbm.fault.PBMFault", ]), ("resetVSanDefaultProfile", "PbmResetVSanDefaultProfile", "pbm.version.version2", (), (0, "void", "void"), "StorageProfile.Update", None), ("querySpaceStatsForStorageContainer", "PbmQuerySpaceStatsForStorageContainer", "pbm.version.version2", (("datastore", "pbm.ServerObjectRef", "pbm.version.version2", 0, None),("capabilityProfileId", "pbm.profile.ProfileId[]", "pbm.version.version2", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.provider.DatastoreSpaceStatistics[]", "pbm.profile.provider.DatastoreSpaceStatistics[]"), "StorageProfile.View", ["vmodl.fault.InvalidArgument", "pbm.fault.PBMFault", ]), ("queryAssociatedEntities", "PbmQueryAssociatedEntities", "pbm.version.version11", (("profiles", "pbm.profile.ProfileId[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.profile.QueryProfileResult[]", "pbm.profile.QueryProfileResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
> CreateDataType("pbm.profile.ProfileOperationOutcome", "PbmProfileOperationOutcome", "vmodl.DynamicData", "pbm.version.version1", [("profileId", "pbm.profile.ProfileId", "pbm.version.version1", 0), ("fault", "vmodl.MethodFault", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.profile.ProfileType", "PbmProfileType", "vmodl.DynamicData", "pbm.version.version1", [("uniqueId", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.profile.QueryProfileResult", "PbmQueryProfileResult", "vmodl.DynamicData", "pbm.version.version1", [("object", "pbm.ServerObjectRef", "pbm.version.version1", 0), ("profileId", "pbm.profile.ProfileId[]", "pbm.version.version1", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.profile.ResourceType", "PbmProfileResourceType", "vmodl.DynamicData", "pbm.version.version1", [("resourceType", "string", "pbm.version.version1", 0)])
> CreateEnumType("pbm.profile.ResourceTypeEnum", "PbmProfileResourceTypeEnum", "pbm.version.version1", ["STORAGE"])
> CreateDataType("pbm.profile.SubProfileCapabilityConstraints", "PbmCapabilitySubProfileConstraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", [("subProfiles", "pbm.profile.SubProfileCapabilityConstraints.SubProfile[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.profile.SubProfileCapabilityConstraints.SubProfile", "PbmCapabilitySubProfile", "vmodl.DynamicData", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0), ("capability", "pbm.capability.CapabilityInstance[]", "pbm.version.version1", 0), ("forceProvision", "boolean", "pbm.version.version1", F_OPTIONAL)])
> CreateEnumType("pbm.profile.VmAssociations.Operation", "PbmVmOperation", "pbm.version.version11", ["CREATE", "RECONFIGURE", "MIGRATE", "CLONE"])
> CreateDataType("pbm.profile.provider.DatastoreSpaceStatistics", "PbmDatastoreSpaceStatistics", "vmodl.DynamicData", "pbm.version.version2", [("profileId", "string", "pbm.version.version2", F_OPTIONAL), ("physicalTotalInMB", "long", "pbm.version.version2", 0), ("physicalFreeInMB", "long", "pbm.version.version2", 0), ("physicalUsedInMB", "long", "pbm.version.version2", 0), ("logicalLimitInMB", "long", "pbm.version.version2", F_OPTIONAL), ("logicalFreeInMB", "long", "pbm.version.version2", 0), ("logicalUsedInMB", "long", "pbm.version.version2", 0)])
> CreateManagedType("pbm.provider.Provider", "PbmProvider", "vmodl.ManagedObject", "pbm.version.version1", None, None)
> CreateDataType("pbm.replication.QueryReplicationGroupResult", "PbmQueryReplicationGroupResult", "vmodl.DynamicData", "pbm.version.version11", [("object", "pbm.ServerObjectRef", "pbm.version.version11", 0), ("replicationGroupId", "vim.vm.replication.ReplicationGroupId", "pbm.version.version11", F_OPTIONAL), ("fault", "vmodl.MethodFault", "pbm.version.version11", F_OPTIONAL)])
> CreateManagedType("pbm.replication.ReplicationManager", "PbmReplicationManager", "vmodl.ManagedObject", "pbm.version.version11", None, [("queryReplicationGroups", "PbmQueryReplicationGroups", "pbm.version.version11", (("entities", "pbm.ServerObjectRef[]", "pbm.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "pbm.replication.QueryReplicationGroupResult[]", "pbm.replication.QueryReplicationGroupResult[]"), "StorageProfile.View", ["pbm.fault.PBMFault", ])])
> CreateDataType("pbm.capability.CapabilityInstance", "PbmCapabilityInstance", "vmodl.DynamicData", "pbm.version.version1", [("id", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("constraint", "pbm.capability.ConstraintInstance[]", "pbm.version.version1", 0)])
> CreateDataType("pbm.capability.GenericTypeInfo", "PbmCapabilityGenericTypeInfo", "pbm.capability.TypeInfo", "pbm.version.version1", [("genericTypeName", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.AlreadyExists", "PbmAlreadyExists", "pbm.fault.PBMFault", "pbm.version.version1", [("name", "string", "pbm.version.version1", F_OPTIONAL)])
> CreateDataType("pbm.fault.CompatibilityCheckFault", "PbmCompatibilityCheckFault", "pbm.fault.PBMFault", "pbm.version.version1", [("hub", "pbm.placement.PlacementHub", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.DefaultProfileAppliesFault", "PbmDefaultProfileAppliesFault", "pbm.fault.CompatibilityCheckFault", "pbm.version.version1", None)
> CreateDataType("pbm.fault.DuplicateName", "PbmDuplicateName", "pbm.fault.PBMFault", "pbm.version.version1", [("name", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.InvalidLogin", "PbmFaultInvalidLogin", "pbm.fault.PBMFault", "pbm.version.version2", None)
> CreateDataType("pbm.fault.LegacyHubsNotSupported", "PbmLegacyHubsNotSupported", "pbm.fault.PBMFault", "pbm.version.version2", [("hubs", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0)])
> CreateDataType("pbm.fault.NonExistentHubs", "PbmNonExistentHubs", "pbm.fault.PBMFault", "pbm.version.version2", [("hubs", "pbm.placement.PlacementHub[]", "pbm.version.version2", 0)])
> CreateDataType("pbm.fault.NotFound", "PbmFaultNotFound", "pbm.fault.PBMFault", "pbm.version.version1", None)
> CreateDataType("pbm.fault.PropertyMismatchFault", "PbmPropertyMismatchFault", "pbm.fault.CompatibilityCheckFault", "pbm.version.version1", [("capabilityInstanceId", "pbm.capability.CapabilityMetadata.UniqueId", "pbm.version.version1", 0), ("requirementPropertyInstance", "pbm.capability.PropertyInstance", "pbm.version.version1", 0)])
> CreateDataType("pbm.placement.CapabilityConstraintsRequirement", "PbmPlacementCapabilityConstraintsRequirement", "pbm.placement.Requirement", "pbm.version.version11", [("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version11", 0)])
> CreateDataType("pbm.placement.CapabilityProfileRequirement", "PbmPlacementCapabilityProfileRequirement", "pbm.placement.Requirement", "pbm.version.version11", [("profileId", "pbm.profile.ProfileId", "pbm.version.version11", 0)])
> CreateDataType("pbm.placement.MatchingReplicationResources", "PbmPlacementMatchingReplicationResources", "pbm.placement.MatchingResources", "pbm.version.version11", [("replicationGroup", "vim.vm.replication.ReplicationGroupId[]", "pbm.version.version11", F_OPTIONAL)])
> CreateDataType("pbm.profile.CapabilityBasedProfile", "PbmCapabilityProfile", "pbm.profile.Profile", "pbm.version.version1", [("profileCategory", "string", "pbm.version.version1", 0), ("resourceType", "pbm.profile.ResourceType", "pbm.version.version1", 0), ("constraints", "pbm.profile.CapabilityConstraints", "pbm.version.version1", 0), ("generationId", "long", "pbm.version.version1", F_OPTIONAL), ("isDefault", "boolean", "pbm.version.version1", 0), ("systemCreatedProfileType", "string", "pbm.version.version2", F_OPTIONAL), ("lineOfService", "string", "pbm.version.version11", F_OPTIONAL)])
> CreateEnumType("pbm.profile.CapabilityBasedProfile.ProfileCategoryEnum", "PbmProfileCategoryEnum", "pbm.version.version1", ["REQUIREMENT", "RESOURCE", "DATA_SERVICE_POLICY"])
> CreateEnumType("pbm.profile.CapabilityBasedProfile.SystemCreatedProfileType", "PbmSystemCreatedProfileType", "pbm.version.version2", ["VsanDefaultProfile", "VVolDefaultProfile", "PmemDefaultProfile", "VmcManagementProfile", "VsanPMemDefaultProfile"])
> CreateDataType("pbm.profile.DefaultCapabilityBasedProfile", "PbmDefaultCapabilityProfile", "pbm.profile.CapabilityBasedProfile", "pbm.version.version1", [("vvolType", "string[]", "pbm.version.version1", 0), ("containerId", "string", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.CapabilityProfilePropertyMismatchFault", "PbmCapabilityProfilePropertyMismatchFault", "pbm.fault.PropertyMismatchFault", "pbm.version.version1", [("resourcePropertyInstance", "pbm.capability.PropertyInstance", "pbm.version.version1", 0)])
> CreateDataType("pbm.fault.IncompatibleVendorSpecificRuleSet", "PbmIncompatibleVendorSpecificRuleSet", "pbm.fault.CapabilityProfilePropertyMismatchFault", "pbm.version.version1", None)
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_query.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_query.py
1,63c1,63
< # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
< from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType
< from pyVmomi.VmomiSupport import AddVersion, AddVersionParent
< from pyVmomi.VmomiSupport import F_OPTIONAL
< from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions
< 
< AddVersion("vmodl.version.version0", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
< AddVersion("vmodl.version.version1", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
< AddVersion("vmodl.version.version2", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
< AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
< 
< newestVersions.Add("vmodl.query.version.version4")
< publicVersions.Add("vmodl.query.version.version4")
< oldestVersions.Add("vmodl.query.version.version1")
< 
< CreateDataType("vmodl.query.InvalidCollectorVersion", "InvalidCollectorVersion", "vmodl.MethodFault", "vmodl.query.version.version1", None)
< CreateDataType("vmodl.query.InvalidProperty", "InvalidProperty", "vmodl.MethodFault", "vmodl.query.version.version1", [("name", "vmodl.PropertyPath", "vmodl.query.version.version1", 0)])
< CreateManagedType("vmodl.query.PropertyCollector", "PropertyCollector", "vmodl.ManagedObject", "vmodl.query.version.version1", [("filter", "vmodl.query.PropertyCollector.Filter[]", "vmodl.query.version.version1", F_OPTIONAL, "System.View")], [("createFilter", "CreateFilter", "vmodl.query.version.version1", (("spec", "vmodl.query.PropertyCollector.FilterSpec", "vmodl.query.version.version1", 0, None),("partialUpdates", "boolean", "vmodl.query.version.version1", 0, None),), (0, "vmodl.query.PropertyCollector.Filter", "vmodl.query.PropertyCollector.Filter"), "System.View", ["vmodl.query.InvalidProperty", ]), ("retrieveContents", "RetrieveProperties", "vmodl.query.version.version1", (("specSet", "vmodl.query.PropertyCollector.FilterSpec[]", "vmodl.query.version.version1", 0, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.ObjectContent[]", "vmodl.query.PropertyCollector.ObjectContent[]"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("checkForUpdates", "CheckForUpdates", "vmodl.query.version.version1", (("version", "string", "vmodl.query.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("waitForUpdates", "WaitForUpdates", "vmodl.query.version.version1", (("version", "string", "vmodl.query.version.version1", F_OPTIONAL, None),), (0, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("cancelWaitForUpdates", "CancelWaitForUpdates", "vmodl.query.version.version1", (), (0, "void", "void"), "System.View", None), ("waitForUpdatesEx", "WaitForUpdatesEx", "vmodl.query.version.version3", (("version", "string", "vmodl.query.version.version3", F_OPTIONAL, None),("options", "vmodl.query.PropertyCollector.WaitOptions", "vmodl.query.version.version3", F_OPTIONAL, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("retrievePropertiesEx", "RetrievePropertiesEx", "vmodl.query.version.version3", (("specSet", "vmodl.query.PropertyCollector.FilterSpec[]", "vmodl.query.version.version3", 0, None),("options", "vmodl.query.PropertyCollector.RetrieveOptions", "vmodl.query.version.version3", 0, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.RetrieveResult", "vmodl.query.PropertyCollector.RetrieveResult"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("continueRetrievePropertiesEx", "ContinueRetrievePropertiesEx", "vmodl.query.version.version3", (("token", "string", "vmodl.query.version.version3", 0, None),), (0, "vmodl.query.PropertyCollector.RetrieveResult", "vmodl.query.PropertyCollector.RetrieveResult"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("cancelRetrievePropertiesEx", "CancelRetrievePropertiesEx", "vmodl.query.version.version3", (("token", "string", "vmodl.query.version.version3", 0, None),), (0, "void", "void"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("createPropertyCollector", "CreatePropertyCollector", "vmodl.query.version.version3", (), (0, "vmodl.query.PropertyCollector", "vmodl.query.PropertyCollector"), "System.View", None), ("destroy", "DestroyPropertyCollector", "vmodl.query.version.version3", (), (0, "void", "void"), "System.View", None)])
< CreateDataType("vmodl.query.PropertyCollector.FilterSpec", "PropertyFilterSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("propSet", "vmodl.query.PropertyCollector.PropertySpec[]", "vmodl.query.version.version1", 0), ("objectSet", "vmodl.query.PropertyCollector.ObjectSpec[]", "vmodl.query.version.version1", 0), ("reportMissingObjectsInResults", "boolean", "vmodl.query.version.version3", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.PropertySpec", "PropertySpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("type", "vmodl.TypeName", "vmodl.query.version.version1", 0), ("all", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("pathSet", "vmodl.PropertyPath[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.ObjectSpec", "ObjectSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("skip", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("selectSet", "vmodl.query.PropertyCollector.SelectionSpec[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.SelectionSpec", "SelectionSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("name", "string", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.TraversalSpec", "TraversalSpec", "vmodl.query.PropertyCollector.SelectionSpec", "vmodl.query.version.version1", [("type", "vmodl.TypeName", "vmodl.query.version.version1", 0), ("path", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("skip", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("selectSet", "vmodl.query.PropertyCollector.SelectionSpec[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateManagedType("vmodl.query.PropertyCollector.Filter", "PropertyFilter", "vmodl.ManagedObject", "vmodl.query.version.version1", [("spec", "vmodl.query.PropertyCollector.FilterSpec", "vmodl.query.version.version1", 0, None), ("partialUpdates", "boolean", "vmodl.query.version.version1", 0, None)], [("destroy", "DestroyPropertyFilter", "vmodl.query.version.version1", (), (0, "void", "void"), None, None)])
< CreateDataType("vmodl.query.PropertyCollector.ObjectContent", "ObjectContent", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("propSet", "vmodl.DynamicProperty[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingProperty[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.UpdateSet", "UpdateSet", "vmodl.DynamicData", "vmodl.query.version.version1", [("version", "string", "vmodl.query.version.version1", 0), ("filterSet", "vmodl.query.PropertyCollector.FilterUpdate[]", "vmodl.query.version.version1", F_OPTIONAL), ("truncated", "boolean", "vmodl.query.version.version3", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.FilterUpdate", "PropertyFilterUpdate", "vmodl.DynamicData", "vmodl.query.version.version1", [("filter", "vmodl.query.PropertyCollector.Filter", "vmodl.query.version.version1", 0), ("objectSet", "vmodl.query.PropertyCollector.ObjectUpdate[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingObject[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.ObjectUpdate", "ObjectUpdate", "vmodl.DynamicData", "vmodl.query.version.version1", [("kind", "vmodl.query.PropertyCollector.ObjectUpdate.Kind", "vmodl.query.version.version1", 0), ("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("changeSet", "vmodl.query.PropertyCollector.Change[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingProperty[]", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateEnumType("vmodl.query.PropertyCollector.ObjectUpdate.Kind", "ObjectUpdateKind", "vmodl.query.version.version1", ["modify", "enter", "leave"])
< CreateDataType("vmodl.query.PropertyCollector.Change", "PropertyChange", "vmodl.DynamicData", "vmodl.query.version.version1", [("name", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("op", "vmodl.query.PropertyCollector.Change.Op", "vmodl.query.version.version1", 0), ("val", "anyType", "vmodl.query.version.version1", F_OPTIONAL)])
< CreateEnumType("vmodl.query.PropertyCollector.Change.Op", "PropertyChangeOp", "vmodl.query.version.version1", ["add", "remove", "assign", "indirectRemove"])
< CreateDataType("vmodl.query.PropertyCollector.MissingProperty", "MissingProperty", "vmodl.DynamicData", "vmodl.query.version.version1", [("path", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("fault", "vmodl.MethodFault", "vmodl.query.version.version1", 0)])
< CreateDataType("vmodl.query.PropertyCollector.MissingObject", "MissingObject", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("fault", "vmodl.MethodFault", "vmodl.query.version.version1", 0)])
< CreateDataType("vmodl.query.PropertyCollector.WaitOptions", "WaitOptions", "vmodl.DynamicData", "vmodl.query.version.version3", [("maxWaitSeconds", "int", "vmodl.query.version.version3", F_OPTIONAL), ("maxObjectUpdates", "int", "vmodl.query.version.version3", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.RetrieveOptions", "RetrieveOptions", "vmodl.DynamicData", "vmodl.query.version.version3", [("maxObjects", "int", "vmodl.query.version.version3", F_OPTIONAL)])
< CreateDataType("vmodl.query.PropertyCollector.RetrieveResult", "RetrieveResult", "vmodl.DynamicData", "vmodl.query.version.version3", [("token", "string", "vmodl.query.version.version3", F_OPTIONAL), ("objects", "vmodl.query.PropertyCollector.ObjectContent[]", "vmodl.query.version.version3", 0)])
---
> # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
> from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType
> from pyVmomi.VmomiSupport import AddVersion, AddVersionParent
> from pyVmomi.VmomiSupport import F_OPTIONAL
> from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions
> 
> AddVersion("vmodl.version.version0", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
> AddVersion("vmodl.version.version1", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
> AddVersion("vmodl.version.version2", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
> AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
> 
> newestVersions.Add("vmodl.query.version.version4")
> publicVersions.Add("vmodl.query.version.version4")
> oldestVersions.Add("vmodl.query.version.version1")
> 
> CreateDataType("vmodl.query.InvalidCollectorVersion", "InvalidCollectorVersion", "vmodl.MethodFault", "vmodl.query.version.version1", None)
> CreateDataType("vmodl.query.InvalidProperty", "InvalidProperty", "vmodl.MethodFault", "vmodl.query.version.version1", [("name", "vmodl.PropertyPath", "vmodl.query.version.version1", 0)])
> CreateManagedType("vmodl.query.PropertyCollector", "PropertyCollector", "vmodl.ManagedObject", "vmodl.query.version.version1", [("filter", "vmodl.query.PropertyCollector.Filter[]", "vmodl.query.version.version1", F_OPTIONAL, "System.View")], [("createFilter", "CreateFilter", "vmodl.query.version.version1", (("spec", "vmodl.query.PropertyCollector.FilterSpec", "vmodl.query.version.version1", 0, None),("partialUpdates", "boolean", "vmodl.query.version.version1", 0, None),), (0, "vmodl.query.PropertyCollector.Filter", "vmodl.query.PropertyCollector.Filter"), "System.View", ["vmodl.query.InvalidProperty", ]), ("retrieveContents", "RetrieveProperties", "vmodl.query.version.version1", (("specSet", "vmodl.query.PropertyCollector.FilterSpec[]", "vmodl.query.version.version1", 0, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.ObjectContent[]", "vmodl.query.PropertyCollector.ObjectContent[]"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("checkForUpdates", "CheckForUpdates", "vmodl.query.version.version1", (("version", "string", "vmodl.query.version.version1", F_OPTIONAL, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("waitForUpdates", "WaitForUpdates", "vmodl.query.version.version1", (("version", "string", "vmodl.query.version.version1", F_OPTIONAL, None),), (0, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("cancelWaitForUpdates", "CancelWaitForUpdates", "vmodl.query.version.version1", (), (0, "void", "void"), "System.View", None), ("waitForUpdatesEx", "WaitForUpdatesEx", "vmodl.query.version.version3", (("version", "string", "vmodl.query.version.version3", F_OPTIONAL, None),("options", "vmodl.query.PropertyCollector.WaitOptions", "vmodl.query.version.version3", F_OPTIONAL, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.UpdateSet", "vmodl.query.PropertyCollector.UpdateSet"), "System.View", ["vmodl.query.InvalidCollectorVersion", ]), ("retrievePropertiesEx", "RetrievePropertiesEx", "vmodl.query.version.version3", (("specSet", "vmodl.query.PropertyCollector.FilterSpec[]", "vmodl.query.version.version3", 0, None),("options", "vmodl.query.PropertyCollector.RetrieveOptions", "vmodl.query.version.version3", 0, None),), (F_OPTIONAL, "vmodl.query.PropertyCollector.RetrieveResult", "vmodl.query.PropertyCollector.RetrieveResult"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("continueRetrievePropertiesEx", "ContinueRetrievePropertiesEx", "vmodl.query.version.version3", (("token", "string", "vmodl.query.version.version3", 0, None),), (0, "vmodl.query.PropertyCollector.RetrieveResult", "vmodl.query.PropertyCollector.RetrieveResult"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("cancelRetrievePropertiesEx", "CancelRetrievePropertiesEx", "vmodl.query.version.version3", (("token", "string", "vmodl.query.version.version3", 0, None),), (0, "void", "void"), "System.Anonymous", ["vmodl.query.InvalidProperty", ]), ("createPropertyCollector", "CreatePropertyCollector", "vmodl.query.version.version3", (), (0, "vmodl.query.PropertyCollector", "vmodl.query.PropertyCollector"), "System.View", None), ("destroy", "DestroyPropertyCollector", "vmodl.query.version.version3", (), (0, "void", "void"), "System.View", None)])
> CreateDataType("vmodl.query.PropertyCollector.FilterSpec", "PropertyFilterSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("propSet", "vmodl.query.PropertyCollector.PropertySpec[]", "vmodl.query.version.version1", 0), ("objectSet", "vmodl.query.PropertyCollector.ObjectSpec[]", "vmodl.query.version.version1", 0), ("reportMissingObjectsInResults", "boolean", "vmodl.query.version.version3", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.PropertySpec", "PropertySpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("type", "vmodl.TypeName", "vmodl.query.version.version1", 0), ("all", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("pathSet", "vmodl.PropertyPath[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.ObjectSpec", "ObjectSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("skip", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("selectSet", "vmodl.query.PropertyCollector.SelectionSpec[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.SelectionSpec", "SelectionSpec", "vmodl.DynamicData", "vmodl.query.version.version1", [("name", "string", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.TraversalSpec", "TraversalSpec", "vmodl.query.PropertyCollector.SelectionSpec", "vmodl.query.version.version1", [("type", "vmodl.TypeName", "vmodl.query.version.version1", 0), ("path", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("skip", "boolean", "vmodl.query.version.version1", F_OPTIONAL), ("selectSet", "vmodl.query.PropertyCollector.SelectionSpec[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateManagedType("vmodl.query.PropertyCollector.Filter", "PropertyFilter", "vmodl.ManagedObject", "vmodl.query.version.version1", [("spec", "vmodl.query.PropertyCollector.FilterSpec", "vmodl.query.version.version1", 0, None), ("partialUpdates", "boolean", "vmodl.query.version.version1", 0, None)], [("destroy", "DestroyPropertyFilter", "vmodl.query.version.version1", (), (0, "void", "void"), None, None)])
> CreateDataType("vmodl.query.PropertyCollector.ObjectContent", "ObjectContent", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("propSet", "vmodl.DynamicProperty[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingProperty[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.UpdateSet", "UpdateSet", "vmodl.DynamicData", "vmodl.query.version.version1", [("version", "string", "vmodl.query.version.version1", 0), ("filterSet", "vmodl.query.PropertyCollector.FilterUpdate[]", "vmodl.query.version.version1", F_OPTIONAL), ("truncated", "boolean", "vmodl.query.version.version3", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.FilterUpdate", "PropertyFilterUpdate", "vmodl.DynamicData", "vmodl.query.version.version1", [("filter", "vmodl.query.PropertyCollector.Filter", "vmodl.query.version.version1", 0), ("objectSet", "vmodl.query.PropertyCollector.ObjectUpdate[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingObject[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.ObjectUpdate", "ObjectUpdate", "vmodl.DynamicData", "vmodl.query.version.version1", [("kind", "vmodl.query.PropertyCollector.ObjectUpdate.Kind", "vmodl.query.version.version1", 0), ("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("changeSet", "vmodl.query.PropertyCollector.Change[]", "vmodl.query.version.version1", F_OPTIONAL), ("missingSet", "vmodl.query.PropertyCollector.MissingProperty[]", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateEnumType("vmodl.query.PropertyCollector.ObjectUpdate.Kind", "ObjectUpdateKind", "vmodl.query.version.version1", ["modify", "enter", "leave"])
> CreateDataType("vmodl.query.PropertyCollector.Change", "PropertyChange", "vmodl.DynamicData", "vmodl.query.version.version1", [("name", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("op", "vmodl.query.PropertyCollector.Change.Op", "vmodl.query.version.version1", 0), ("val", "anyType", "vmodl.query.version.version1", F_OPTIONAL)])
> CreateEnumType("vmodl.query.PropertyCollector.Change.Op", "PropertyChangeOp", "vmodl.query.version.version1", ["add", "remove", "assign", "indirectRemove"])
> CreateDataType("vmodl.query.PropertyCollector.MissingProperty", "MissingProperty", "vmodl.DynamicData", "vmodl.query.version.version1", [("path", "vmodl.PropertyPath", "vmodl.query.version.version1", 0), ("fault", "vmodl.MethodFault", "vmodl.query.version.version1", 0)])
> CreateDataType("vmodl.query.PropertyCollector.MissingObject", "MissingObject", "vmodl.DynamicData", "vmodl.query.version.version1", [("obj", "vmodl.ManagedObject", "vmodl.query.version.version1", 0), ("fault", "vmodl.MethodFault", "vmodl.query.version.version1", 0)])
> CreateDataType("vmodl.query.PropertyCollector.WaitOptions", "WaitOptions", "vmodl.DynamicData", "vmodl.query.version.version3", [("maxWaitSeconds", "int", "vmodl.query.version.version3", F_OPTIONAL), ("maxObjectUpdates", "int", "vmodl.query.version.version3", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.RetrieveOptions", "RetrieveOptions", "vmodl.DynamicData", "vmodl.query.version.version3", [("maxObjects", "int", "vmodl.query.version.version3", F_OPTIONAL)])
> CreateDataType("vmodl.query.PropertyCollector.RetrieveResult", "RetrieveResult", "vmodl.DynamicData", "vmodl.query.version.version3", [("token", "string", "vmodl.query.version.version3", F_OPTIONAL), ("objects", "vmodl.query.PropertyCollector.ObjectContent[]", "vmodl.query.version.version3", 0)])
diff -r source-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_sms.py lookaside-pyvmomi-7.0.3.tar.gz-extracted/pyvmomi-7.0.3/pyVmomi/_typeinfo_sms.py
1,997c1,997
< # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
< 
< from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType
< from pyVmomi.VmomiSupport import AddVersion, AddVersionParent
< from pyVmomi.VmomiSupport import F_OPTIONAL, F_SECRET
< from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions, dottedVersions
< 
< AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
< AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
< AddVersion("vim.version.v7_0_1_1", "vim25", "7.0.1.1", 0, "vim25")
< AddVersion("vmodl.version.version0", "", "", 0, "vim25")
< AddVersion("vmodl.version.version1", "", "", 0, "vim25")
< AddVersion("vmodl.version.version2", "", "", 0, "vim25")
< AddVersion("vim.version.v6_9_1", "vim25", "6.9.1", 0, "vim25")
< AddVersion("vim.version.v7_0_0_2", "vim25", "7.0.0.2", 0, "vim25")
< AddVersion("vim.version.v6_8_7", "vim25", "6.8.7", 0, "vim25")
< AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
< AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
< AddVersion("vim.version.v7_0_3_0", "vim25", "7.0.3.0", 0, "vim25")
< AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
< AddVersion("vim.version.version14", "vim25", "6.7.2", 0, "vim25")
< AddVersion("vim.version.version15", "vim25", "6.7.3", 0, "vim25")
< AddVersion("sms.version.v7_0_0_1", "sms", "7.0.0.1", 0, "sms")
< AddVersion("sms.version.v6_8_7", "sms", "6.8.7", 0, "sms")
< AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
< AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
< AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
< AddVersion("vim.version.v7_0_2_0", "vim25", "7.0.2.0", 0, "vim25")
< AddVersion("vim.version.v7_0_2_1", "vim25", "7.0.2.1", 0, "vim25")
< AddVersion("sms.version.version5", "sms", "5.0", 0, "sms")
< AddVersion("sms.version.version13", "sms", "6.7.1", 0, "sms")
< AddVersion("vim.version.v7_0_1_0", "vim25", "7.0.1.0", 0, "vim25")
< AddVersion("sms.version.version12", "sms", "6.7", 0, "sms")
< AddVersion("sms.version.version11", "sms", "6.5", 0, "sms")
< AddVersion("sms.version.version2", "sms", "2.0", 0, "sms")
< AddVersion("sms.version.version1", "sms", "1.0", 0, "sms")
< AddVersion("sms.version.version4", "sms", "4.0", 0, "sms")
< AddVersion("sms.version.version3", "sms", "3.0", 0, "sms")
< AddVersion("vim.version.v7_0", "vim25", "7.0.0.0", 0, "vim25")
< AddVersion("sms.version.version14", "sms", "6.7.2", 0, "sms")
< AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
< AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
< AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
< AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
< AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
< AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
< AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
< AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
< AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
< AddVersion("sms.version.v7_0", "sms", "7.0.0.0", 0, "sms")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
< AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_1_1", "vim.version.version3")
< AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v6_9_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version13")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version14")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version15")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version10")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version11")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version12")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version8")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version9")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version6")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version7")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version1")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version4")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version5")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version2")
< AddVersionParent("vim.version.v6_9_1", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_0_2", "vim.version.version3")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version0")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version13")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version14")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version15")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version10")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version11")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version12")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version8")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version9")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version6")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version7")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version1")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version4")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version5")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version2")
< AddVersionParent("vim.version.v6_8_7", "vim.version.version3")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
< AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_3_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_3_0", "vim.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.version.version0")
< AddVersionParent("vim.version.version13", "vmodl.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.version.version2")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version13")
< AddVersionParent("vim.version.version13", "vim.version.version10")
< AddVersionParent("vim.version.version13", "vim.version.version11")
< AddVersionParent("vim.version.version13", "vim.version.version12")
< AddVersionParent("vim.version.version13", "vim.version.version8")
< AddVersionParent("vim.version.version13", "vim.version.version9")
< AddVersionParent("vim.version.version13", "vim.version.version6")
< AddVersionParent("vim.version.version13", "vim.version.version7")
< AddVersionParent("vim.version.version13", "vim.version.version1")
< AddVersionParent("vim.version.version13", "vim.version.version4")
< AddVersionParent("vim.version.version13", "vim.version.version5")
< AddVersionParent("vim.version.version13", "vim.version.version2")
< AddVersionParent("vim.version.version13", "vim.version.version3")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version14", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.version.version0")
< AddVersionParent("vim.version.version14", "vmodl.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.version.version2")
< AddVersionParent("vim.version.version14", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version14", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version14", "vim.version.version13")
< AddVersionParent("vim.version.version14", "vim.version.version14")
< AddVersionParent("vim.version.version14", "vim.version.version10")
< AddVersionParent("vim.version.version14", "vim.version.version11")
< AddVersionParent("vim.version.version14", "vim.version.version12")
< AddVersionParent("vim.version.version14", "vim.version.version8")
< AddVersionParent("vim.version.version14", "vim.version.version9")
< AddVersionParent("vim.version.version14", "vim.version.version6")
< AddVersionParent("vim.version.version14", "vim.version.version7")
< AddVersionParent("vim.version.version14", "vim.version.version1")
< AddVersionParent("vim.version.version14", "vim.version.version4")
< AddVersionParent("vim.version.version14", "vim.version.version5")
< AddVersionParent("vim.version.version14", "vim.version.version2")
< AddVersionParent("vim.version.version14", "vim.version.version3")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version15", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.version.version0")
< AddVersionParent("vim.version.version15", "vmodl.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.version.version2")
< AddVersionParent("vim.version.version15", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version15", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version15", "vim.version.version13")
< AddVersionParent("vim.version.version15", "vim.version.version14")
< AddVersionParent("vim.version.version15", "vim.version.version15")
< AddVersionParent("vim.version.version15", "vim.version.version10")
< AddVersionParent("vim.version.version15", "vim.version.version11")
< AddVersionParent("vim.version.version15", "vim.version.version12")
< AddVersionParent("vim.version.version15", "vim.version.version8")
< AddVersionParent("vim.version.version15", "vim.version.version9")
< AddVersionParent("vim.version.version15", "vim.version.version6")
< AddVersionParent("vim.version.version15", "vim.version.version7")
< AddVersionParent("vim.version.version15", "vim.version.version1")
< AddVersionParent("vim.version.version15", "vim.version.version4")
< AddVersionParent("vim.version.version15", "vim.version.version5")
< AddVersionParent("vim.version.version15", "vim.version.version2")
< AddVersionParent("vim.version.version15", "vim.version.version3")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version4")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version3")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version2")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version1")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version0")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version1")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version2")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.v6_9_1")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.v6_8_7")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.v7_0_0_1", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version13")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version14")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version15")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.v7_0_0_1")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.v6_8_7")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version10")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version11")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version12")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version5")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version13")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version12")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version11")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version2")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version1")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version4")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version3")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.v7_0")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.version14")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version8")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version9")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version6")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version7")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version1")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version4")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version5")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version2")
< AddVersionParent("sms.version.v7_0_0_1", "vim.version.version3")
< AddVersionParent("sms.version.v7_0_0_1", "sms.version.v7_0")
< AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version4")
< AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version3")
< AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version2")
< AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version1")
< AddVersionParent("sms.version.v6_8_7", "vmodl.version.version0")
< AddVersionParent("sms.version.v6_8_7", "vmodl.version.version1")
< AddVersionParent("sms.version.v6_8_7", "vmodl.version.version2")
< AddVersionParent("sms.version.v6_8_7", "vim.version.v6_8_7")
< AddVersionParent("sms.version.v6_8_7", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.v6_8_7", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version13")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version14")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version15")
< AddVersionParent("sms.version.v6_8_7", "sms.version.v6_8_7")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version10")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version11")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version12")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version5")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version13")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version12")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version11")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version2")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version1")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version4")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version3")
< AddVersionParent("sms.version.v6_8_7", "sms.version.version14")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version8")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version9")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version6")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version7")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version1")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version4")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version5")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version2")
< AddVersionParent("sms.version.v6_8_7", "vim.version.version3")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.version.version0")
< AddVersionParent("vim.version.version10", "vmodl.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.version.version2")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version10")
< AddVersionParent("vim.version.version10", "vim.version.version8")
< AddVersionParent("vim.version.version10", "vim.version.version9")
< AddVersionParent("vim.version.version10", "vim.version.version6")
< AddVersionParent("vim.version.version10", "vim.version.version7")
< AddVersionParent("vim.version.version10", "vim.version.version1")
< AddVersionParent("vim.version.version10", "vim.version.version4")
< AddVersionParent("vim.version.version10", "vim.version.version5")
< AddVersionParent("vim.version.version10", "vim.version.version2")
< AddVersionParent("vim.version.version10", "vim.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.version.version0")
< AddVersionParent("vim.version.version11", "vmodl.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.version.version2")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version10")
< AddVersionParent("vim.version.version11", "vim.version.version11")
< AddVersionParent("vim.version.version11", "vim.version.version8")
< AddVersionParent("vim.version.version11", "vim.version.version9")
< AddVersionParent("vim.version.version11", "vim.version.version6")
< AddVersionParent("vim.version.version11", "vim.version.version7")
< AddVersionParent("vim.version.version11", "vim.version.version1")
< AddVersionParent("vim.version.version11", "vim.version.version4")
< AddVersionParent("vim.version.version11", "vim.version.version5")
< AddVersionParent("vim.version.version11", "vim.version.version2")
< AddVersionParent("vim.version.version11", "vim.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.version.version0")
< AddVersionParent("vim.version.version12", "vmodl.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.version.version2")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version10")
< AddVersionParent("vim.version.version12", "vim.version.version11")
< AddVersionParent("vim.version.version12", "vim.version.version12")
< AddVersionParent("vim.version.version12", "vim.version.version8")
< AddVersionParent("vim.version.version12", "vim.version.version9")
< AddVersionParent("vim.version.version12", "vim.version.version6")
< AddVersionParent("vim.version.version12", "vim.version.version7")
< AddVersionParent("vim.version.version12", "vim.version.version1")
< AddVersionParent("vim.version.version12", "vim.version.version4")
< AddVersionParent("vim.version.version12", "vim.version.version5")
< AddVersionParent("vim.version.version12", "vim.version.version2")
< AddVersionParent("vim.version.version12", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_2_0", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_2_1", "vim.version.version3")
< AddVersionParent("sms.version.version5", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version5", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version5", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version5", "vmodl.version.version0")
< AddVersionParent("sms.version.version5", "vmodl.version.version1")
< AddVersionParent("sms.version.version5", "sms.version.version5")
< AddVersionParent("sms.version.version5", "sms.version.version2")
< AddVersionParent("sms.version.version5", "sms.version.version1")
< AddVersionParent("sms.version.version5", "sms.version.version4")
< AddVersionParent("sms.version.version5", "sms.version.version3")
< AddVersionParent("sms.version.version5", "vim.version.version6")
< AddVersionParent("sms.version.version5", "vim.version.version1")
< AddVersionParent("sms.version.version5", "vim.version.version4")
< AddVersionParent("sms.version.version5", "vim.version.version5")
< AddVersionParent("sms.version.version5", "vim.version.version2")
< AddVersionParent("sms.version.version5", "vim.version.version3")
< AddVersionParent("sms.version.version13", "vmodl.query.version.version4")
< AddVersionParent("sms.version.version13", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version13", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version13", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version13", "vmodl.version.version0")
< AddVersionParent("sms.version.version13", "vmodl.version.version1")
< AddVersionParent("sms.version.version13", "vmodl.version.version2")
< AddVersionParent("sms.version.version13", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.version13", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.version13", "vim.version.version13")
< AddVersionParent("sms.version.version13", "vim.version.version10")
< AddVersionParent("sms.version.version13", "vim.version.version11")
< AddVersionParent("sms.version.version13", "vim.version.version12")
< AddVersionParent("sms.version.version13", "sms.version.version5")
< AddVersionParent("sms.version.version13", "sms.version.version13")
< AddVersionParent("sms.version.version13", "sms.version.version12")
< AddVersionParent("sms.version.version13", "sms.version.version11")
< AddVersionParent("sms.version.version13", "sms.version.version2")
< AddVersionParent("sms.version.version13", "sms.version.version1")
< AddVersionParent("sms.version.version13", "sms.version.version4")
< AddVersionParent("sms.version.version13", "sms.version.version3")
< AddVersionParent("sms.version.version13", "vim.version.version8")
< AddVersionParent("sms.version.version13", "vim.version.version9")
< AddVersionParent("sms.version.version13", "vim.version.version6")
< AddVersionParent("sms.version.version13", "vim.version.version7")
< AddVersionParent("sms.version.version13", "vim.version.version1")
< AddVersionParent("sms.version.version13", "vim.version.version4")
< AddVersionParent("sms.version.version13", "vim.version.version5")
< AddVersionParent("sms.version.version13", "vim.version.version2")
< AddVersionParent("sms.version.version13", "vim.version.version3")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_0_2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_1_0")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0_1_0", "vim.version.version3")
< AddVersionParent("sms.version.version12", "vmodl.query.version.version4")
< AddVersionParent("sms.version.version12", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version12", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version12", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version12", "vmodl.version.version0")
< AddVersionParent("sms.version.version12", "vmodl.version.version1")
< AddVersionParent("sms.version.version12", "vmodl.version.version2")
< AddVersionParent("sms.version.version12", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.version12", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.version12", "vim.version.version10")
< AddVersionParent("sms.version.version12", "vim.version.version11")
< AddVersionParent("sms.version.version12", "vim.version.version12")
< AddVersionParent("sms.version.version12", "sms.version.version5")
< AddVersionParent("sms.version.version12", "sms.version.version12")
< AddVersionParent("sms.version.version12", "sms.version.version11")
< AddVersionParent("sms.version.version12", "sms.version.version2")
< AddVersionParent("sms.version.version12", "sms.version.version1")
< AddVersionParent("sms.version.version12", "sms.version.version4")
< AddVersionParent("sms.version.version12", "sms.version.version3")
< AddVersionParent("sms.version.version12", "vim.version.version8")
< AddVersionParent("sms.version.version12", "vim.version.version9")
< AddVersionParent("sms.version.version12", "vim.version.version6")
< AddVersionParent("sms.version.version12", "vim.version.version7")
< AddVersionParent("sms.version.version12", "vim.version.version1")
< AddVersionParent("sms.version.version12", "vim.version.version4")
< AddVersionParent("sms.version.version12", "vim.version.version5")
< AddVersionParent("sms.version.version12", "vim.version.version2")
< AddVersionParent("sms.version.version12", "vim.version.version3")
< AddVersionParent("sms.version.version11", "vmodl.query.version.version4")
< AddVersionParent("sms.version.version11", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version11", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version11", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version11", "vmodl.version.version0")
< AddVersionParent("sms.version.version11", "vmodl.version.version1")
< AddVersionParent("sms.version.version11", "vmodl.version.version2")
< AddVersionParent("sms.version.version11", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.version11", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.version11", "vim.version.version10")
< AddVersionParent("sms.version.version11", "vim.version.version11")
< AddVersionParent("sms.version.version11", "sms.version.version5")
< AddVersionParent("sms.version.version11", "sms.version.version11")
< AddVersionParent("sms.version.version11", "sms.version.version2")
< AddVersionParent("sms.version.version11", "sms.version.version1")
< AddVersionParent("sms.version.version11", "sms.version.version4")
< AddVersionParent("sms.version.version11", "sms.version.version3")
< AddVersionParent("sms.version.version11", "vim.version.version8")
< AddVersionParent("sms.version.version11", "vim.version.version9")
< AddVersionParent("sms.version.version11", "vim.version.version6")
< AddVersionParent("sms.version.version11", "vim.version.version7")
< AddVersionParent("sms.version.version11", "vim.version.version1")
< AddVersionParent("sms.version.version11", "vim.version.version4")
< AddVersionParent("sms.version.version11", "vim.version.version5")
< AddVersionParent("sms.version.version11", "vim.version.version2")
< AddVersionParent("sms.version.version11", "vim.version.version3")
< AddVersionParent("sms.version.version2", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version2", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version2", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version2", "vmodl.version.version0")
< AddVersionParent("sms.version.version2", "vmodl.version.version1")
< AddVersionParent("sms.version.version2", "sms.version.version2")
< AddVersionParent("sms.version.version2", "sms.version.version1")
< AddVersionParent("sms.version.version2", "vim.version.version6")
< AddVersionParent("sms.version.version2", "vim.version.version1")
< AddVersionParent("sms.version.version2", "vim.version.version4")
< AddVersionParent("sms.version.version2", "vim.version.version5")
< AddVersionParent("sms.version.version2", "vim.version.version2")
< AddVersionParent("sms.version.version2", "vim.version.version3")
< AddVersionParent("sms.version.version1", "vmodl.version.version0")
< AddVersionParent("sms.version.version1", "vmodl.version.version1")
< AddVersionParent("sms.version.version1", "sms.version.version1")
< AddVersionParent("sms.version.version4", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version4", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version4", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version4", "vmodl.version.version0")
< AddVersionParent("sms.version.version4", "vmodl.version.version1")
< AddVersionParent("sms.version.version4", "sms.version.version2")
< AddVersionParent("sms.version.version4", "sms.version.version1")
< AddVersionParent("sms.version.version4", "sms.version.version4")
< AddVersionParent("sms.version.version4", "sms.version.version3")
< AddVersionParent("sms.version.version4", "vim.version.version6")
< AddVersionParent("sms.version.version4", "vim.version.version1")
< AddVersionParent("sms.version.version4", "vim.version.version4")
< AddVersionParent("sms.version.version4", "vim.version.version5")
< AddVersionParent("sms.version.version4", "vim.version.version2")
< AddVersionParent("sms.version.version4", "vim.version.version3")
< AddVersionParent("sms.version.version3", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version3", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version3", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version3", "vmodl.version.version0")
< AddVersionParent("sms.version.version3", "vmodl.version.version1")
< AddVersionParent("sms.version.version3", "sms.version.version2")
< AddVersionParent("sms.version.version3", "sms.version.version1")
< AddVersionParent("sms.version.version3", "sms.version.version3")
< AddVersionParent("sms.version.version3", "vim.version.version6")
< AddVersionParent("sms.version.version3", "vim.version.version1")
< AddVersionParent("sms.version.version3", "vim.version.version4")
< AddVersionParent("sms.version.version3", "vim.version.version5")
< AddVersionParent("sms.version.version3", "vim.version.version2")
< AddVersionParent("sms.version.version3", "vim.version.version3")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version4")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version3")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version2")
< AddVersionParent("vim.version.v7_0", "vmodl.query.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version0")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.v6_9_1")
< AddVersionParent("vim.version.v7_0", "vim.version.v6_8_7")
< AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.version13")
< AddVersionParent("vim.version.v7_0", "vim.version.version14")
< AddVersionParent("vim.version.v7_0", "vim.version.version15")
< AddVersionParent("vim.version.v7_0", "vim.version.version10")
< AddVersionParent("vim.version.v7_0", "vim.version.version11")
< AddVersionParent("vim.version.v7_0", "vim.version.version12")
< AddVersionParent("vim.version.v7_0", "vim.version.v7_0")
< AddVersionParent("vim.version.v7_0", "vim.version.version8")
< AddVersionParent("vim.version.v7_0", "vim.version.version9")
< AddVersionParent("vim.version.v7_0", "vim.version.version6")
< AddVersionParent("vim.version.v7_0", "vim.version.version7")
< AddVersionParent("vim.version.v7_0", "vim.version.version1")
< AddVersionParent("vim.version.v7_0", "vim.version.version4")
< AddVersionParent("vim.version.v7_0", "vim.version.version5")
< AddVersionParent("vim.version.v7_0", "vim.version.version2")
< AddVersionParent("vim.version.v7_0", "vim.version.version3")
< AddVersionParent("sms.version.version14", "vmodl.query.version.version4")
< AddVersionParent("sms.version.version14", "vmodl.query.version.version3")
< AddVersionParent("sms.version.version14", "vmodl.query.version.version2")
< AddVersionParent("sms.version.version14", "vmodl.query.version.version1")
< AddVersionParent("sms.version.version14", "vmodl.version.version0")
< AddVersionParent("sms.version.version14", "vmodl.version.version1")
< AddVersionParent("sms.version.version14", "vmodl.version.version2")
< AddVersionParent("sms.version.version14", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.version14", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.version14", "vim.version.version13")
< AddVersionParent("sms.version.version14", "vim.version.version14")
< AddVersionParent("sms.version.version14", "vim.version.version10")
< AddVersionParent("sms.version.version14", "vim.version.version11")
< AddVersionParent("sms.version.version14", "vim.version.version12")
< AddVersionParent("sms.version.version14", "sms.version.version5")
< AddVersionParent("sms.version.version14", "sms.version.version13")
< AddVersionParent("sms.version.version14", "sms.version.version12")
< AddVersionParent("sms.version.version14", "sms.version.version11")
< AddVersionParent("sms.version.version14", "sms.version.version2")
< AddVersionParent("sms.version.version14", "sms.version.version1")
< AddVersionParent("sms.version.version14", "sms.version.version4")
< AddVersionParent("sms.version.version14", "sms.version.version3")
< AddVersionParent("sms.version.version14", "sms.version.version14")
< AddVersionParent("sms.version.version14", "vim.version.version8")
< AddVersionParent("sms.version.version14", "vim.version.version9")
< AddVersionParent("sms.version.version14", "vim.version.version6")
< AddVersionParent("sms.version.version14", "vim.version.version7")
< AddVersionParent("sms.version.version14", "vim.version.version1")
< AddVersionParent("sms.version.version14", "vim.version.version4")
< AddVersionParent("sms.version.version14", "vim.version.version5")
< AddVersionParent("sms.version.version14", "vim.version.version2")
< AddVersionParent("sms.version.version14", "vim.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version8", "vmodl.version.version0")
< AddVersionParent("vim.version.version8", "vmodl.version.version1")
< AddVersionParent("vim.version.version8", "vmodl.version.version2")
< AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version8")
< AddVersionParent("vim.version.version8", "vim.version.version6")
< AddVersionParent("vim.version.version8", "vim.version.version7")
< AddVersionParent("vim.version.version8", "vim.version.version1")
< AddVersionParent("vim.version.version8", "vim.version.version4")
< AddVersionParent("vim.version.version8", "vim.version.version5")
< AddVersionParent("vim.version.version8", "vim.version.version2")
< AddVersionParent("vim.version.version8", "vim.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.version.version0")
< AddVersionParent("vim.version.version9", "vmodl.version.version1")
< AddVersionParent("vim.version.version9", "vmodl.version.version2")
< AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version8")
< AddVersionParent("vim.version.version9", "vim.version.version9")
< AddVersionParent("vim.version.version9", "vim.version.version6")
< AddVersionParent("vim.version.version9", "vim.version.version7")
< AddVersionParent("vim.version.version9", "vim.version.version1")
< AddVersionParent("vim.version.version9", "vim.version.version4")
< AddVersionParent("vim.version.version9", "vim.version.version5")
< AddVersionParent("vim.version.version9", "vim.version.version2")
< AddVersionParent("vim.version.version9", "vim.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version6", "vmodl.version.version0")
< AddVersionParent("vim.version.version6", "vmodl.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version6")
< AddVersionParent("vim.version.version6", "vim.version.version1")
< AddVersionParent("vim.version.version6", "vim.version.version4")
< AddVersionParent("vim.version.version6", "vim.version.version5")
< AddVersionParent("vim.version.version6", "vim.version.version2")
< AddVersionParent("vim.version.version6", "vim.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.version.version0")
< AddVersionParent("vim.version.version7", "vmodl.version.version1")
< AddVersionParent("vim.version.version7", "vmodl.version.version2")
< AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version6")
< AddVersionParent("vim.version.version7", "vim.version.version7")
< AddVersionParent("vim.version.version7", "vim.version.version1")
< AddVersionParent("vim.version.version7", "vim.version.version4")
< AddVersionParent("vim.version.version7", "vim.version.version5")
< AddVersionParent("vim.version.version7", "vim.version.version2")
< AddVersionParent("vim.version.version7", "vim.version.version3")
< AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version1", "vmodl.version.version0")
< AddVersionParent("vim.version.version1", "vim.version.version1")
< AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version4", "vmodl.version.version0")
< AddVersionParent("vim.version.version4", "vim.version.version1")
< AddVersionParent("vim.version.version4", "vim.version.version4")
< AddVersionParent("vim.version.version4", "vim.version.version2")
< AddVersionParent("vim.version.version4", "vim.version.version3")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
< AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version5", "vmodl.version.version0")
< AddVersionParent("vim.version.version5", "vmodl.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version1")
< AddVersionParent("vim.version.version5", "vim.version.version4")
< AddVersionParent("vim.version.version5", "vim.version.version5")
< AddVersionParent("vim.version.version5", "vim.version.version2")
< AddVersionParent("vim.version.version5", "vim.version.version3")
< AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version2", "vmodl.version.version0")
< AddVersionParent("vim.version.version2", "vim.version.version1")
< AddVersionParent("vim.version.version2", "vim.version.version2")
< AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
< AddVersionParent("vim.version.version3", "vmodl.version.version0")
< AddVersionParent("vim.version.version3", "vim.version.version1")
< AddVersionParent("vim.version.version3", "vim.version.version2")
< AddVersionParent("vim.version.version3", "vim.version.version3")
< AddVersionParent("sms.version.v7_0", "vmodl.query.version.version4")
< AddVersionParent("sms.version.v7_0", "vmodl.query.version.version3")
< AddVersionParent("sms.version.v7_0", "vmodl.query.version.version2")
< AddVersionParent("sms.version.v7_0", "vmodl.query.version.version1")
< AddVersionParent("sms.version.v7_0", "vmodl.version.version0")
< AddVersionParent("sms.version.v7_0", "vmodl.version.version1")
< AddVersionParent("sms.version.v7_0", "vmodl.version.version2")
< AddVersionParent("sms.version.v7_0", "vim.version.v6_9_1")
< AddVersionParent("sms.version.v7_0", "vim.version.v6_8_7")
< AddVersionParent("sms.version.v7_0", "vmodl.reflect.version.version1")
< AddVersionParent("sms.version.v7_0", "vmodl.reflect.version.version2")
< AddVersionParent("sms.version.v7_0", "vim.version.version13")
< AddVersionParent("sms.version.v7_0", "vim.version.version14")
< AddVersionParent("sms.version.v7_0", "vim.version.version15")
< AddVersionParent("sms.version.v7_0", "sms.version.v6_8_7")
< AddVersionParent("sms.version.v7_0", "vim.version.version10")
< AddVersionParent("sms.version.v7_0", "vim.version.version11")
< AddVersionParent("sms.version.v7_0", "vim.version.version12")
< AddVersionParent("sms.version.v7_0", "sms.version.version5")
< AddVersionParent("sms.version.v7_0", "sms.version.version13")
< AddVersionParent("sms.version.v7_0", "sms.version.version12")
< AddVersionParent("sms.version.v7_0", "sms.version.version11")
< AddVersionParent("sms.version.v7_0", "sms.version.version2")
< AddVersionParent("sms.version.v7_0", "sms.version.version1")
< AddVersionParent("sms.version.v7_0", "sms.version.version4")
< AddVersionParent("sms.version.v7_0", "sms.version.version3")
< AddVersionParent("sms.version.v7_0", "vim.version.v7_0")
< AddVersionParent("sms.version.v7_0", "sms.version.version14")
< AddVersionParent("sms.version.v7_0", "vim.version.version8")
< AddVersionParent("sms.version.v7_0", "vim.version.version9")
< AddVersionParent("sms.version.v7_0", "vim.version.version6")
< AddVersionParent("sms.version.v7_0", "vim.version.version7")
< AddVersionParent("sms.version.v7_0", "vim.version.version1")
< AddVersionParent("sms.version.v7_0", "vim.version.version4")
< AddVersionParent("sms.version.v7_0", "vim.version.version5")
< AddVersionParent("sms.version.v7_0", "vim.version.version2")
< AddVersionParent("sms.version.v7_0", "vim.version.version3")
< AddVersionParent("sms.version.v7_0", "sms.version.v7_0")
< 
< newestVersions.Add("sms.version.v7_0_0_1")
< publicVersions.Add("sms.version.v7_0_0_1")
< dottedVersions.Add("sms.version.v7_0_0_1")
< oldestVersions.Add("sms.version.version1")
< 
< CreateDataType("sms.AboutInfo", "SmsAboutInfo", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("fullName", "string", "sms.version.version2", 0), ("vendor", "string", "sms.version.version2", 0), ("apiVersion", "string", "sms.version.version2", 0), ("instanceUuid", "string", "sms.version.version2", 0), ("vasaApiVersion", "string", "sms.version.version4", F_OPTIONAL)])
< CreateDataType("sms.EntityReference", "EntityReference", "vmodl.DynamicData", "sms.version.version1", [("id", "string", "sms.version.version1", 0), ("type", "sms.EntityReference.EntityType", "sms.version.version1", F_OPTIONAL)])
< CreateEnumType("sms.EntityReference.EntityType", "EntityReferenceEntityType", "sms.version.version1", ["datacenter", "resourcePool", "storagePod", "cluster", "vm", "datastore", "host", "vmFile", "scsiPath", "scsiTarget", "scsiVolume", "scsiAdapter", "nasMount"])
< CreateDataType("sms.FaultDomainFilter", "FaultDomainFilter", "vmodl.DynamicData", "sms.version.version11", [("providerId", "string", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.ReplicationGroupFilter", "ReplicationGroupFilter", "vmodl.DynamicData", "sms.version.version11", [("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL)])
< CreateManagedType("sms.ServiceInstance", "SmsServiceInstance", "vmodl.ManagedObject", "sms.version.version1", None, [("queryStorageManager", "QueryStorageManager", "sms.version.version2", (), (0, "sms.StorageManager", "sms.StorageManager"), "StorageViews.View", None), ("querySessionManager", "QuerySessionManager", "sms.version.version5", (), (0, "sms.auth.SessionManager", "sms.auth.SessionManager"), "System.Anonymous", None), ("queryAboutInfo", "QueryAboutInfo", "sms.version.version2", (), (0, "sms.AboutInfo", "sms.AboutInfo"), "StorageViews.View", None)])
< CreateManagedType("sms.StorageManager", "SmsStorageManager", "vmodl.ManagedObject", "sms.version.version2", None, [("registerProvider", "RegisterProvider_Task", "sms.version.version2", (("providerSpec", "sms.provider.ProviderSpec", "sms.version.version2", 0, None),), (0, "sms.Task", "sms.provider.Provider"), "StorageViews.ConfigureService", ["vim.fault.AlreadyExists", "sms.fault.ProviderRegistrationFault", ]), ("unregisterProvider", "UnregisterProvider_Task", "sms.version.version2", (("providerId", "string", "sms.version.version2", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["vim.fault.NotFound", "sms.fault.ProviderUnregistrationFault", ]), ("queryProvider", "QueryProvider", "sms.version.version2", (), (F_OPTIONAL, "sms.provider.Provider[]", "sms.provider.Provider[]"), "StorageViews.View", ["sms.fault.QueryExecutionFault", ]), ("queryArray", "QueryArray", "sms.version.version2", (("providerId", "string[]", "sms.version.version2", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.StorageArray[]", "sms.storage.StorageArray[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryProcessorAssociatedWithArray", "QueryProcessorAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageProcessor[]", "sms.storage.StorageProcessor[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithArray", "QueryPortAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort[]", "sms.storage.StoragePort[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithLun", "QueryPortAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort", "sms.storage.StoragePort"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryLunAssociatedWithPort", "QueryLunAssociatedWithPort", "sms.version.version2", (("portId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageLun[]", "sms.storage.StorageLun[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryArrayAssociatedWithLun", "QueryArrayAssociatedWithLun", "sms.version.version2", (("canonicalName", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageArray", "sms.storage.StorageArray"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithProcessor", "QueryPortAssociatedWithProcessor", "sms.version.version2", (("processorId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort[]", "sms.storage.StoragePort[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryLunAssociatedWithArray", "QueryLunAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageLun[]", "sms.storage.StorageLun[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryFileSystemAssociatedWithArray", "QueryFileSystemAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageFileSystem[]", "sms.storage.StorageFileSystem[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDatastoreCapability", "QueryDatastoreCapability", "sms.version.version2", (("datastore", "vim.Datastore", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageCapability", "sms.storage.StorageCapability"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryHostAssociatedWithLun", "QueryHostAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.HostSystem[]", "vim.HostSystem[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryVmfsDatastoreAssociatedWithLun", "QueryVmfsDatastoreAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.Datastore", "vim.Datastore"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryNfsDatastoreAssociatedWithFileSystem", "QueryNfsDatastoreAssociatedWithFileSystem", "sms.version.version2", (("fileSystemId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.Datastore", "vim.Datastore"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDrsMigrationCapabilityForPerformance", "QueryDrsMigrationCapabilityForPerformance", "sms.version.version2", (("srcDatastore", "vim.Datastore", "sms.version.version2", 0, None),("dstDatastore", "vim.Datastore", "sms.version.version2", 0, None),), (0, "boolean", "boolean"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDrsMigrationCapabilityForPerformanceEx", "QueryDrsMigrationCapabilityForPerformanceEx", "sms.version.version3", (("datastore", "vim.Datastore[]", "sms.version.version3", 0, None),), (0, "sms.storage.DrsMigrationCapabilityResult", "sms.storage.DrsMigrationCapabilityResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryStorageContainer", "QueryStorageContainer", "sms.version.version5", (("containerSpec", "sms.storage.StorageContainerSpec", "sms.version.version5", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.StorageContainerResult", "sms.storage.StorageContainerResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryAssociatedBackingStoragePool", "QueryAssociatedBackingStoragePool", "sms.version.version5", (("entityId", "string", "sms.version.version5", F_OPTIONAL, None),("entityType", "string", "sms.version.version5", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.BackingStoragePool[]", "sms.storage.BackingStoragePool[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDatastoreBackingPoolMapping", "QueryDatastoreBackingPoolMapping", "sms.version.version5", (("datastore", "vim.Datastore[]", "sms.version.version5", 0, None),), (0, "sms.storage.DatastoreBackingPoolMapping[]", "sms.storage.DatastoreBackingPoolMapping[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("refreshCACertificatesAndCRLs", "SmsRefreshCACertificatesAndCRLs_Task", "sms.version.version5", (("providerId", "string[]", "sms.version.version5", F_OPTIONAL, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["vim.fault.NotFound", "sms.fault.CertificateRefreshFailed", ]), ("queryFaultDomain", "QueryFaultDomain", "sms.version.version11", (("filter", "sms.FaultDomainFilter", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "vim.vm.replication.FaultDomainId[]", "vim.vm.replication.FaultDomainId[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryReplicationGroupInfo", "QueryReplicationGroupInfo", "sms.version.version11", (("rgFilter", "sms.ReplicationGroupFilter", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.QueryExecutionFault", ])])
< CreateManagedType("sms.Task", "SmsTask", "vmodl.ManagedObject", "sms.version.version2", None, [("queryResult", "QuerySmsTaskResult", "sms.version.version2", (), (F_OPTIONAL, "anyType", "anyType"), "StorageViews.View", None), ("queryInfo", "QuerySmsTaskInfo", "sms.version.version2", (), (0, "sms.TaskInfo", "sms.TaskInfo"), "StorageViews.View", None)])
< CreateDataType("sms.TaskInfo", "SmsTaskInfo", "vmodl.DynamicData", "sms.version.version2", [("key", "string", "sms.version.version2", 0), ("task", "sms.Task", "sms.version.version2", 0), ("object", "vmodl.ManagedObject", "sms.version.version2", F_OPTIONAL), ("error", "vmodl.MethodFault", "sms.version.version2", F_OPTIONAL), ("result", "anyType", "sms.version.version2", F_OPTIONAL), ("startTime", "vmodl.DateTime", "sms.version.version2", F_OPTIONAL), ("completionTime", "vmodl.DateTime", "sms.version.version2", F_OPTIONAL), ("state", "string", "sms.version.version2", 0), ("progress", "int", "sms.version.version2", F_OPTIONAL)])
< CreateEnumType("sms.TaskInfo.State", "SmsTaskState", "sms.version.version1", ["queued", "running", "success", "error"])
< CreateDataType("sms.fault.AuthConnectionFailed", "AuthConnectionFailed", "vim.fault.NoPermission", "sms.version.version2", None)
< CreateDataType("sms.fault.CertificateRefreshFailed", "CertificateRefreshFailed", "vmodl.MethodFault", "sms.version.version5", [("providerId", "string[]", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.fault.CertificateRevocationFailed", "CertificateRevocationFailed", "vmodl.MethodFault", "sms.version.version5", None)
< CreateDataType("sms.fault.DuplicateEntry", "DuplicateEntry", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.InactiveProvider", "InactiveProvider", "vmodl.MethodFault", "sms.version.version11", [("mapping", "sms.storage.FaultDomainProviderMapping[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.fault.InvalidLogin", "SmsInvalidLogin", "vmodl.MethodFault", "sms.version.version5", None)
< CreateDataType("sms.fault.InvalidProfile", "InvalidProfile", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.InvalidSession", "InvalidSession", "vim.fault.NoPermission", "sms.version.version2", [("sessionCookie", "string", "sms.version.version2", 0)])
< CreateDataType("sms.fault.MultipleSortSpecsNotSupported", "MultipleSortSpecsNotSupported", "vmodl.fault.InvalidArgument", "sms.version.version1", None)
< CreateDataType("sms.fault.NotSupportedByProvider", "NotSupportedByProvider", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.ProviderBusy", "ProviderBusy", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.ProviderConnectionFailed", "ProviderConnectionFailed", "vmodl.RuntimeFault", "sms.version.version2", None)
< CreateDataType("sms.fault.ProviderOutOfProvisioningResource", "ProviderOutOfProvisioningResource", "vmodl.MethodFault", "sms.version.version11", [("provisioningResourceId", "string", "sms.version.version11", 0), ("availableBefore", "long", "sms.version.version11", F_OPTIONAL), ("availableAfter", "long", "sms.version.version11", F_OPTIONAL), ("total", "long", "sms.version.version11", F_OPTIONAL), ("isTransient", "boolean", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.fault.ProviderOutOfResource", "ProviderOutOfResource", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.ProviderRegistrationFault", "ProviderRegistrationFault", "vmodl.MethodFault", "sms.version.version2", None)
< CreateDataType("sms.fault.ProviderSyncFailed", "ProviderSyncFailed", "vmodl.MethodFault", "sms.version.version1", None)
< CreateDataType("sms.fault.ProviderUnavailable", "ProviderUnavailable", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.ProviderUnregistrationFault", "ProviderUnregistrationFault", "vmodl.MethodFault", "sms.version.version2", None)
< CreateDataType("sms.fault.ProxyRegistrationFailed", "ProxyRegistrationFailed", "vmodl.RuntimeFault", "sms.version.version1", None)
< CreateDataType("sms.fault.QueryExecutionFault", "QueryExecutionFault", "vmodl.MethodFault", "sms.version.version1", None)
< CreateDataType("sms.fault.QueryNotSupported", "QueryNotSupported", "vmodl.fault.InvalidArgument", "sms.version.version1", [("entityType", "sms.EntityReference.EntityType", "sms.version.version1", F_OPTIONAL), ("relatedEntityType", "sms.EntityReference.EntityType", "sms.version.version1", 0)])
< CreateDataType("sms.fault.ResourceInUse", "SmsResourceInUse", "vim.fault.ResourceInUse", "sms.version.version11", [("deviceIds", "sms.storage.replication.DeviceId[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.fault.ServiceNotInitialized", "ServiceNotInitialized", "vmodl.RuntimeFault", "sms.version.version1", None)
< CreateDataType("sms.fault.SyncInProgress", "SyncInProgress", "sms.fault.ProviderSyncFailed", "sms.version.version1", None)
< CreateDataType("sms.fault.TooMany", "TooMany", "vmodl.MethodFault", "sms.version.version11", [("maxBatchSize", "long", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.fault.replication.ReplicationFault", "SmsReplicationFault", "vmodl.MethodFault", "sms.version.version11", None)
< CreateDataType("sms.fault.replication.SyncOngoing", "SyncOngoing", "sms.fault.replication.ReplicationFault", "sms.version.version11", [("task", "sms.Task", "sms.version.version11", 0)])
< CreateDataType("sms.provider.AlarmFilter", "AlarmFilter", "vmodl.DynamicData", "sms.version.version11", [("alarmStatus", "string", "sms.version.version11", F_OPTIONAL), ("alarmType", "string", "sms.version.version11", F_OPTIONAL), ("entityType", "string", "sms.version.version11", F_OPTIONAL), ("entityId", "anyType[]", "sms.version.version11", F_OPTIONAL), ("pageMarker", "string", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.provider.AlarmResult", "AlarmResult", "vmodl.DynamicData", "sms.version.version11", [("storageAlarm", "sms.storage.StorageAlarm[]", "sms.version.version11", F_OPTIONAL), ("pageMarker", "string", "sms.version.version11", F_OPTIONAL)])
< CreateManagedType("sms.provider.Provider", "SmsProvider", "vmodl.ManagedObject", "sms.version.version2", None, [("queryProviderInfo", "QueryProviderInfo", "sms.version.version2", (), (0, "sms.provider.ProviderInfo", "sms.provider.ProviderInfo"), "StorageViews.View", None)])
< CreateDataType("sms.provider.ProviderInfo", "SmsProviderInfo", "vmodl.DynamicData", "sms.version.version2", [("uid", "string", "sms.version.version2", 0), ("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", F_OPTIONAL), ("version", "string", "sms.version.version2", F_OPTIONAL)])
< CreateDataType("sms.provider.ProviderSpec", "SmsProviderSpec", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", F_OPTIONAL)])
< CreateManagedType("sms.provider.VasaProvider", "VasaProvider", "sms.provider.Provider", "sms.version.version2", None, [("sync", "VasaProviderSync_Task", "sms.version.version2", (("arrayId", "string", "sms.version.version2", F_OPTIONAL, None),), (0, "sms.Task", "void"), "StorageViews.View", ["sms.fault.ProviderSyncFailed", ]), ("refreshCertificate", "VasaProviderRefreshCertificate_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.CertificateRefreshFailed", ]), ("revokeCertificate", "VasaProviderRevokeCertificate_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.CertificateRevocationFailed", ]), ("reconnect", "VasaProviderReconnect_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.InvalidCertificate", "sms.fault.ProviderConnectionFailed", ]), ("queryReplicationPeer", "QueryReplicationPeer", "sms.version.version11", (("faultDomainId", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.QueryReplicationPeerResult[]", "sms.storage.replication.QueryReplicationPeerResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("queryReplicationGroup", "QueryReplicationGroup", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("queryPointInTimeReplica", "QueryPointInTimeReplica", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("queryParam", "sms.storage.replication.QueryPointInTimeReplicaParam", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("testFailoverReplicationGroupStart", "TestFailoverReplicationGroupStart_Task", "sms.version.version11", (("testFailoverParam", "sms.storage.replication.TestFailoverParam", "sms.version.version11", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("testFailoverReplicationGroupStop", "TestFailoverReplicationGroupStop_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("force", "boolean", "sms.version.version11", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", "sms.fault.NotSupportedByProvider", ]), ("promoteReplicationGroup", "PromoteReplicationGroup_Task", "sms.version.version11", (("promoteParam", "sms.storage.replication.PromoteParam", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("syncReplicationGroup", "SyncReplicationGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("pitName", "string", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", "sms.fault.TooMany", ]), ("prepareFailoverReplicationGroup", "PrepareFailoverReplicationGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("failoverReplicationGroup", "FailoverReplicationGroup_Task", "sms.version.version11", (("failoverParam", "sms.storage.replication.FailoverParam", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("reverseReplicateGroup", "ReverseReplicateGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("queryActiveAlarm", "QueryActiveAlarm", "sms.version.version11", (("alarmFilter", "sms.provider.AlarmFilter", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.provider.AlarmResult", "sms.provider.AlarmResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.ProviderBusy", "sms.fault.InactiveProvider", "sms.fault.ProviderUnavailable", "sms.fault.QueryExecutionFault", ])])
< CreateDataType("sms.provider.VasaProviderInfo", "VasaProviderInfo", "sms.provider.ProviderInfo", "sms.version.version2", [("url", "string", "sms.version.version2", 0), ("certificate", "string", "sms.version.version2", F_OPTIONAL), ("status", "string", "sms.version.version2", F_OPTIONAL), ("statusFault", "vmodl.MethodFault", "sms.version.version11", F_OPTIONAL), ("vasaVersion", "string", "sms.version.version2", F_OPTIONAL), ("namespace", "string", "sms.version.version2", F_OPTIONAL), ("lastSyncTime", "string", "sms.version.version2", F_OPTIONAL), ("supportedVendorModelMapping", "sms.provider.VasaProviderInfo.SupportedVendorModelMapping[]", "sms.version.version2", F_OPTIONAL), ("supportedProfile", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedProviderProfile", "string[]", "sms.version.version4", F_OPTIONAL), ("relatedStorageArray", "sms.provider.VasaProviderInfo.RelatedStorageArray[]", "sms.version.version4", F_OPTIONAL), ("providerId", "string", "sms.version.version4", F_OPTIONAL), ("certificateExpiryDate", "string", "sms.version.version5", F_OPTIONAL), ("certificateStatus", "string", "sms.version.version5", F_OPTIONAL), ("serviceLocation", "string", "sms.version.version5", F_OPTIONAL), ("needsExplicitActivation", "boolean", "sms.version.version5", F_OPTIONAL), ("maxBatchSize", "long", "sms.version.version11", F_OPTIONAL), ("retainVasaProviderCertificate", "boolean", "sms.version.version5", F_OPTIONAL), ("arrayIndependentProvider", "boolean", "sms.version.version11", F_OPTIONAL), ("type", "string", "sms.version.version11", F_OPTIONAL), ("category", "string", "sms.version.version12", F_OPTIONAL), ("priority", "int", "sms.version.version11", F_OPTIONAL), ("failoverGroupId", "string", "sms.version.version11", F_OPTIONAL)])
< CreateEnumType("sms.provider.VasaProviderInfo.CertificateStatus", "VasaProviderCertificateStatus", "sms.version.version5", ["valid", "expirySoftLimitReached", "expiryHardLimitReached", "expired", "invalid"])
< CreateDataType("sms.provider.VasaProviderInfo.RelatedStorageArray", "RelatedStorageArray", "vmodl.DynamicData", "sms.version.version4", [("arrayId", "string", "sms.version.version4", 0), ("active", "boolean", "sms.version.version4", 0), ("manageable", "boolean", "sms.version.version4", 0), ("priority", "int", "sms.version.version4", 0)])
< CreateDataType("sms.provider.VasaProviderInfo.SupportedVendorModelMapping", "SupportedVendorModelMapping", "vmodl.DynamicData", "sms.version.version1", [("vendorId", "string", "sms.version.version1", F_OPTIONAL), ("modelId", "string", "sms.version.version1", F_OPTIONAL)])
< CreateEnumType("sms.provider.VasaProviderInfo.VasaProviderStatus", "VasaProviderStatus", "sms.version.version1", ["online", "offline", "syncError", "unknown", "connected", "disconnected"])
< CreateEnumType("sms.provider.VasaProviderInfo.VasaProviderProfile", "VasaProviderProfile", "sms.version.version1", ["blockDevice", "fileSystem", "capability"])
< CreateEnumType("sms.provider.VasaProviderInfo.ProviderProfile", "ProviderProfile", "sms.version.version11", ["ProfileBasedManagement", "Replication"])
< CreateEnumType("sms.provider.VasaProviderInfo.Type", "VpType", "sms.version.version11", ["PERSISTENCE", "DATASERVICE", "UNKNOWN"])
< CreateEnumType("sms.provider.VasaProviderInfo.Category", "VpCategory", "sms.version.version12", ["internal", "external"])
< CreateDataType("sms.provider.VasaProviderSpec", "VasaProviderSpec", "sms.provider.ProviderSpec", "sms.version.version2", [("username", "string", "sms.version.version2", 0), ("password", "string", "sms.version.version2", F_SECRET), ("url", "string", "sms.version.version2", 0), ("certificate", "string", "sms.version.version2", F_OPTIONAL)])
< CreateEnumType("sms.provider.VmodlVasaProviderSpec.AuthenticationType", "VasaAuthenticationType", "sms.version.version12", ["LoginByToken", "UseSessionId"])
< CreateEnumType("sms.storage.AlarmStatus", "SmsAlarmStatus", "sms.version.version11", ["Red", "Green", "Yellow"])
< CreateEnumType("sms.storage.AlarmType", "AlarmType", "sms.version.version11", ["SpaceCapacityAlarm", "CapabilityAlarm", "StorageObjectAlarm", "ObjectAlarm", "ComplianceAlarm", "ManageabilityAlarm", "ReplicationAlarm"])
< CreateDataType("sms.storage.BackingConfig", "BackingConfig", "vmodl.DynamicData", "sms.version.version5", [("thinProvisionBackingIdentifier", "string", "sms.version.version5", F_OPTIONAL), ("deduplicationBackingIdentifier", "string", "sms.version.version5", F_OPTIONAL), ("autoTieringEnabled", "boolean", "sms.version.version5", F_OPTIONAL), ("deduplicationEfficiency", "long", "sms.version.version5", F_OPTIONAL), ("performanceOptimizationInterval", "long", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.storage.BackingStoragePool", "BackingStoragePool", "vmodl.DynamicData", "sms.version.version5", [("uuid", "string", "sms.version.version5", 0), ("type", "string", "sms.version.version5", 0), ("capacityInMB", "long", "sms.version.version5", 0), ("usedSpaceInMB", "long", "sms.version.version5", 0)])
< CreateEnumType("sms.storage.BackingStoragePool.BackingStoragePoolType", "BackingStoragePoolType", "sms.version.version1", ["thinProvisioningPool", "deduplicationPool", "thinAndDeduplicationCombinedPool"])
< CreateDataType("sms.storage.DatastoreBackingPoolMapping", "DatastoreBackingPoolMapping", "vmodl.DynamicData", "sms.version.version5", [("datastore", "vim.Datastore[]", "sms.version.version5", 0), ("backingStoragePool", "sms.storage.BackingStoragePool[]", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.storage.DatastorePair", "DatastorePair", "vmodl.DynamicData", "sms.version.version3", [("datastore1", "vim.Datastore", "sms.version.version3", 0), ("datastore2", "vim.Datastore", "sms.version.version3", 0)])
< CreateDataType("sms.storage.DrsMigrationCapabilityResult", "DrsMigrationCapabilityResult", "vmodl.DynamicData", "sms.version.version3", [("recommendedDatastorePair", "sms.storage.DatastorePair[]", "sms.version.version3", F_OPTIONAL), ("nonRecommendedDatastorePair", "sms.storage.DatastorePair[]", "sms.version.version3", F_OPTIONAL)])
< CreateEnumType("sms.storage.EntityType", "SmsEntityType", "sms.version.version11", ["StorageArrayEntity", "StorageProcessorEntity", "StoragePortEntity", "StorageLunEntity", "StorageFileSystemEntity", "StorageCapabilityEntity", "CapabilitySchemaEntity", "CapabilityProfileEntity", "DefaultProfileEntity", "ResourceAssociationEntity", "StorageContainerEntity", "StorageObjectEntity", "MessageCatalogEntity", "ProtocolEndpointEntity", "VirtualVolumeInfoEntity", "BackingStoragePoolEntity", "FaultDomainEntity", "ReplicationGroupEntity"])
< CreateDataType("sms.storage.FaultDomainProviderMapping", "FaultDomainProviderMapping", "vmodl.DynamicData", "sms.version.version11", [("activeProvider", "sms.provider.Provider", "sms.version.version11", 0), ("faultDomainId", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.FileSystemInfo", "StorageFileSystemInfo", "vmodl.DynamicData", "sms.version.version2", [("fileServerName", "string", "sms.version.version2", 0), ("fileSystemPath", "string", "sms.version.version2", 0), ("ipAddress", "string", "sms.version.version2", F_OPTIONAL)])
< CreateDataType("sms.storage.LunHbaAssociation", "LunHbaAssociation", "vmodl.DynamicData", "sms.version.version2", [("canonicalName", "string", "sms.version.version2", 0), ("hba", "vim.host.HostBusAdapter[]", "sms.version.version2", 0)])
< CreateDataType("sms.storage.NameValuePair", "NameValuePair", "vmodl.DynamicData", "sms.version.version11", [("parameterName", "string", "sms.version.version11", 0), ("parameterValue", "string", "sms.version.version11", 0)])
< CreateDataType("sms.storage.StorageAlarm", "StorageAlarm", "vmodl.DynamicData", "sms.version.version11", [("alarmId", "long", "sms.version.version11", 0), ("alarmType", "string", "sms.version.version11", 0), ("containerId", "string", "sms.version.version11", F_OPTIONAL), ("objectId", "string", "sms.version.version11", F_OPTIONAL), ("objectType", "string", "sms.version.version11", 0), ("status", "string", "sms.version.version11", 0), ("alarmTimeStamp", "vmodl.DateTime", "sms.version.version11", 0), ("messageId", "string", "sms.version.version11", 0), ("parameterList", "sms.storage.NameValuePair[]", "sms.version.version11", F_OPTIONAL), ("alarmObject", "anyType", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.StorageArray", "StorageArray", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("uuid", "string", "sms.version.version2", 0), ("vendorId", "string", "sms.version.version2", 0), ("modelId", "string", "sms.version.version2", 0), ("firmware", "string", "sms.version.version2", F_OPTIONAL), ("alternateName", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedBlockInterface", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedFileSystemInterface", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedProfile", "string[]", "sms.version.version3", F_OPTIONAL), ("priority", "int", "sms.version.version4", F_OPTIONAL)])
< CreateEnumType("sms.storage.StorageArray.BlockDeviceInterface", "BlockDeviceInterface", "sms.version.version1", ["fc", "iscsi", "fcoe", "otherBlock"])
< CreateEnumType("sms.storage.StorageArray.FileSystemInterface", "FileSystemInterface", "sms.version.version1", ["nfs", "otherFileSystem"])
< CreateEnumType("sms.storage.StorageArray.VasaProfile", "VasaProfile", "sms.version.version3", ["blockDevice", "fileSystem", "capability", "policy", "object", "statistics", "storageDrsBlockDevice", "storageDrsFileSystem"])
< CreateDataType("sms.storage.StorageCapability", "StorageCapability", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", 0)])
< CreateDataType("sms.storage.StorageContainer", "StorageContainer", "vmodl.DynamicData", "sms.version.version5", [("uuid", "string", "sms.version.version5", 0), ("name", "string", "sms.version.version5", 0), ("maxVvolSizeInMB", "long", "sms.version.version5", 0), ("providerId", "string[]", "sms.version.version5", 0), ("arrayId", "string[]", "sms.version.version5", 0)])
< CreateDataType("sms.storage.StorageContainerResult", "StorageContainerResult", "vmodl.DynamicData", "sms.version.version5", [("storageContainer", "sms.storage.StorageContainer[]", "sms.version.version5", F_OPTIONAL), ("providerInfo", "sms.provider.ProviderInfo[]", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.storage.StorageContainerSpec", "StorageContainerSpec", "vmodl.DynamicData", "sms.version.version5", [("containerId", "string[]", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.storage.StorageFileSystem", "StorageFileSystem", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("info", "sms.storage.FileSystemInfo[]", "sms.version.version2", 0), ("nativeSnapshotSupported", "boolean", "sms.version.version2", 0), ("thinProvisioningStatus", "string", "sms.version.version2", 0), ("type", "string", "sms.version.version2", 0), ("version", "string", "sms.version.version2", 0), ("backingConfig", "sms.storage.BackingConfig", "sms.version.version5", F_OPTIONAL)])
< CreateEnumType("sms.storage.StorageFileSystem.FileSystemInterfaceVersion", "FileSystemInterfaceVersion", "sms.version.version1", ["NFSV3_0"])
< CreateDataType("sms.storage.StorageLun", "StorageLun", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("vSphereLunIdentifier", "string", "sms.version.version2", 0), ("vendorDisplayName", "string", "sms.version.version2", 0), ("capacityInMB", "long", "sms.version.version2", 0), ("usedSpaceInMB", "long", "sms.version.version2", 0), ("lunThinProvisioned", "boolean", "sms.version.version2", 0), ("alternateIdentifier", "string[]", "sms.version.version2", F_OPTIONAL), ("drsManagementPermitted", "boolean", "sms.version.version2", 0), ("thinProvisioningStatus", "string", "sms.version.version2", 0), ("backingConfig", "sms.storage.BackingConfig", "sms.version.version5", F_OPTIONAL)])
< CreateDataType("sms.storage.StoragePort", "StoragePort", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("type", "string", "sms.version.version2", 0), ("alternateName", "string[]", "sms.version.version2", F_OPTIONAL)])
< CreateDataType("sms.storage.StorageProcessor", "StorageProcessor", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("alternateIdentifer", "string[]", "sms.version.version2", F_OPTIONAL)])
< CreateEnumType("sms.storage.ThinProvisioningStatus", "ThinProvisioningStatus", "sms.version.version2", ["RED", "YELLOW", "GREEN"])
< CreateDataType("sms.storage.replication.DeviceId", "DeviceId", "vmodl.DynamicData", "sms.version.version11", None)
< CreateDataType("sms.storage.replication.FailoverParam", "FailoverParam", "vmodl.DynamicData", "sms.version.version11", [("isPlanned", "boolean", "sms.version.version11", 0), ("checkOnly", "boolean", "sms.version.version11", 0), ("replicationGroupsToFailover", "sms.storage.replication.FailoverParam.ReplicationGroupData[]", "sms.version.version11", F_OPTIONAL), ("policyAssociations", "sms.storage.replication.FailoverParam.PolicyAssociation[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.FailoverParam.ReplicationGroupData", "ReplicationGroupData", "vmodl.DynamicData", "sms.version.version11", [("groupId", "vim.vm.replication.ReplicationGroupId", "sms.version.version11", 0), ("pitId", "sms.storage.replication.PointInTimeReplicaId", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.FailoverParam.PolicyAssociation", "PolicyAssociation", "vmodl.DynamicData", "sms.version.version11", [("id", "sms.storage.replication.DeviceId", "sms.version.version11", 0), ("policyId", "string", "sms.version.version11", 0), ("datastore", "vim.Datastore", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.FaultDomainInfo", "FaultDomainInfo", "vim.vm.replication.FaultDomainId", "sms.version.version11", [("name", "string", "sms.version.version11", F_OPTIONAL), ("description", "string", "sms.version.version11", F_OPTIONAL), ("storageArrayId", "string", "sms.version.version11", F_OPTIONAL), ("children", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL), ("provider", "sms.provider.Provider", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.GroupInfo", "GroupInfo", "vmodl.DynamicData", "sms.version.version11", [("groupId", "vim.vm.replication.ReplicationGroupId", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.GroupOperationResult", "GroupOperationResult", "vmodl.DynamicData", "sms.version.version11", [("groupId", "vim.vm.replication.ReplicationGroupId", "sms.version.version11", 0), ("warning", "vmodl.MethodFault[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.PointInTimeReplicaId", "PointInTimeReplicaId", "vmodl.DynamicData", "sms.version.version11", [("id", "string", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.PromoteParam", "PromoteParam", "vmodl.DynamicData", "sms.version.version11", [("isPlanned", "boolean", "sms.version.version11", 0), ("replicationGroupsToPromote", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaParam", "QueryPointInTimeReplicaParam", "vmodl.DynamicData", "sms.version.version11", [("replicaTimeQueryParam", "sms.storage.replication.QueryPointInTimeReplicaParam.ReplicaQueryIntervalParam", "sms.version.version11", F_OPTIONAL), ("pitName", "string", "sms.version.version11", F_OPTIONAL), ("tags", "string[]", "sms.version.version11", F_OPTIONAL), ("preferDetails", "boolean", "sms.version.v7_0_0_1", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaParam.ReplicaQueryIntervalParam", "ReplicaQueryIntervalParam", "vmodl.DynamicData", "sms.version.version11", [("fromDate", "vmodl.DateTime", "sms.version.version11", F_OPTIONAL), ("toDate", "vmodl.DateTime", "sms.version.version11", F_OPTIONAL), ("number", "int", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaSuccessResult", "QueryPointInTimeReplicaSuccessResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("replicaInfo", "sms.storage.replication.QueryPointInTimeReplicaSuccessResult.PointInTimeReplicaInfo[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaSuccessResult.PointInTimeReplicaInfo", "PointInTimeReplicaInfo", "vmodl.DynamicData", "sms.version.version11", [("id", "sms.storage.replication.PointInTimeReplicaId", "sms.version.version11", 0), ("pitName", "string", "sms.version.version11", 0), ("timeStamp", "vmodl.DateTime", "sms.version.version11", 0), ("tags", "string[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaSummaryResult", "QueryPointInTimeReplicaSummaryResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("intervalResults", "sms.storage.replication.QueryPointInTimeReplicaSummaryResult.ReplicaIntervalQueryResult[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.QueryPointInTimeReplicaSummaryResult.ReplicaIntervalQueryResult", "ReplicaIntervalQueryResult", "vmodl.DynamicData", "sms.version.version11", [("fromDate", "vmodl.DateTime", "sms.version.version11", 0), ("toDate", "vmodl.DateTime", "sms.version.version11", 0), ("number", "int", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.QueryReplicationGroupSuccessResult", "QueryReplicationGroupSuccessResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("rgInfo", "sms.storage.replication.GroupInfo", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.QueryReplicationPeerResult", "QueryReplicationPeerResult", "vmodl.DynamicData", "sms.version.version11", [("sourceDomain", "vim.vm.replication.FaultDomainId", "sms.version.version11", 0), ("targetDomain", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL), ("error", "vmodl.MethodFault[]", "sms.version.version11", F_OPTIONAL), ("warning", "vmodl.MethodFault[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.ReplicaId", "ReplicaId", "vmodl.DynamicData", "sms.version.version11", [("id", "string", "sms.version.version11", 0)])
< CreateEnumType("sms.storage.replication.ReplicationState", "ReplicationReplicationState", "sms.version.version11", ["SOURCE", "TARGET", "FAILEDOVER", "INTEST", "REMOTE_FAILEDOVER"])
< CreateDataType("sms.storage.replication.ReverseReplicationSuccessResult", "ReverseReplicationSuccessResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("newGroupId", "vim.vm.replication.DeviceGroupId", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.SourceGroupInfo", "SourceGroupInfo", "sms.storage.replication.GroupInfo", "sms.version.version11", [("name", "string", "sms.version.version11", F_OPTIONAL), ("description", "string", "sms.version.version11", F_OPTIONAL), ("state", "string", "sms.version.version11", 0), ("replica", "sms.storage.replication.SourceGroupInfo.ReplicationTargetInfo[]", "sms.version.version11", F_OPTIONAL), ("memberInfo", "sms.storage.replication.SourceGroupMemberInfo[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.SourceGroupInfo.ReplicationTargetInfo", "ReplicationTargetInfo", "vmodl.DynamicData", "sms.version.version11", [("targetGroupId", "vim.vm.replication.ReplicationGroupId", "sms.version.version11", 0), ("replicationAgreementDescription", "string", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.SourceGroupMemberInfo", "SourceGroupMemberInfo", "vmodl.DynamicData", "sms.version.version11", [("deviceId", "sms.storage.replication.DeviceId", "sms.version.version11", 0), ("targetId", "sms.storage.replication.SourceGroupMemberInfo.TargetDeviceId[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.SourceGroupMemberInfo.TargetDeviceId", "TargetDeviceId", "vmodl.DynamicData", "sms.version.version11", [("domainId", "vim.vm.replication.FaultDomainId", "sms.version.version11", 0), ("deviceId", "sms.storage.replication.ReplicaId", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.SyncReplicationGroupSuccessResult", "SyncReplicationGroupSuccessResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("timeStamp", "vmodl.DateTime", "sms.version.version11", 0), ("pitId", "sms.storage.replication.PointInTimeReplicaId", "sms.version.version11", F_OPTIONAL), ("pitName", "string", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.TargetGroupInfo", "TargetGroupInfo", "sms.storage.replication.GroupInfo", "sms.version.version11", [("sourceInfo", "sms.storage.replication.TargetGroupInfo.TargetToSourceInfo", "sms.version.version11", 0), ("state", "string", "sms.version.version11", 0), ("devices", "sms.storage.replication.TargetGroupMemberInfo[]", "sms.version.version11", F_OPTIONAL), ("isPromoteCapable", "boolean", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.TargetGroupInfo.TargetToSourceInfo", "TargetToSourceInfo", "vmodl.DynamicData", "sms.version.version11", [("sourceGroupId", "vim.vm.replication.ReplicationGroupId", "sms.version.version11", 0), ("replicationAgreementDescription", "string", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.TargetGroupMemberInfo", "TargetGroupMemberInfo", "vmodl.DynamicData", "sms.version.version11", [("replicaId", "sms.storage.replication.ReplicaId", "sms.version.version11", 0), ("sourceId", "sms.storage.replication.DeviceId", "sms.version.version11", 0), ("targetDatastore", "vim.Datastore", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.TestFailoverParam", "TestFailoverParam", "sms.storage.replication.FailoverParam", "sms.version.version11", None)
< CreateDataType("sms.storage.replication.VVolId", "VVolId", "sms.storage.replication.DeviceId", "sms.version.version11", [("id", "string", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.VirtualDiskId", "VasaVirtualDiskId", "sms.storage.replication.DeviceId", "sms.version.version11", [("diskId", "string", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.VirtualDiskKey", "VirtualDiskKey", "sms.storage.replication.DeviceId", "sms.version.version11", [("vmInstanceUUID", "string", "sms.version.version11", 0), ("deviceKey", "int", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.VirtualDiskMoId", "VirtualDiskMoId", "sms.storage.replication.DeviceId", "sms.version.version12", [("vcUuid", "string", "sms.version.version12", F_OPTIONAL), ("vmMoid", "string", "sms.version.version12", 0), ("diskKey", "string", "sms.version.version12", 0)])
< CreateDataType("sms.storage.replication.VirtualMachineId", "VirtualMachineId", "sms.storage.replication.DeviceId", "sms.version.version11", None)
< CreateDataType("sms.storage.replication.VirtualMachineMoId", "VirtualMachineMoId", "sms.storage.replication.VirtualMachineId", "sms.version.version12", [("vcUuid", "string", "sms.version.version12", F_OPTIONAL), ("vmMoid", "string", "sms.version.version12", 0)])
< CreateDataType("sms.storage.replication.VirtualMachineUUID", "VirtualMachineUUID", "sms.storage.replication.VirtualMachineId", "sms.version.version11", [("vmInstanceUUID", "string", "sms.version.version11", 0)])
< CreateDataType("sms.fault.CertificateAuthorityFault", "CertificateAuthorityFault", "sms.fault.ProviderRegistrationFault", "sms.version.version5", [("faultCode", "int", "sms.version.version5", 0)])
< CreateDataType("sms.fault.CertificateNotImported", "CertificateNotImported", "sms.fault.ProviderRegistrationFault", "sms.version.version5", None)
< CreateDataType("sms.fault.CertificateNotTrusted", "CertificateNotTrusted", "sms.fault.ProviderRegistrationFault", "sms.version.version2", [("certificate", "string", "sms.version.version2", 0)])
< CreateDataType("sms.fault.IncorrectUsernamePassword", "IncorrectUsernamePassword", "sms.fault.ProviderRegistrationFault", "sms.version.version2", None)
< CreateDataType("sms.fault.InvalidCertificate", "InvalidCertificate", "sms.fault.ProviderRegistrationFault", "sms.version.version4", [("certificate", "string", "sms.version.version4", 0)])
< CreateDataType("sms.fault.InvalidUrl", "InvalidUrl", "sms.fault.ProviderRegistrationFault", "sms.version.version4", [("url", "string", "sms.version.version4", 0)])
< CreateDataType("sms.fault.NoCommonProviderForAllBackings", "NoCommonProviderForAllBackings", "sms.fault.QueryExecutionFault", "sms.version.version2", None)
< CreateDataType("sms.fault.ProviderNotFound", "ProviderNotFound", "sms.fault.QueryExecutionFault", "sms.version.version2", None)
< CreateDataType("sms.fault.replication.AlreadyDone", "AlreadyDone", "sms.fault.replication.ReplicationFault", "sms.version.version11", None)
< CreateDataType("sms.fault.replication.InvalidFunctionTarget", "InvalidFunctionTarget", "sms.fault.replication.ReplicationFault", "sms.version.version11", None)
< CreateDataType("sms.fault.replication.InvalidReplicationState", "InvalidReplicationState", "sms.fault.replication.ReplicationFault", "sms.version.version11", [("desiredState", "string[]", "sms.version.version11", F_OPTIONAL), ("currentState", "string", "sms.version.version11", 0)])
< CreateDataType("sms.fault.replication.NoReplicationTarget", "NoReplicationTarget", "sms.fault.replication.ReplicationFault", "sms.version.version11", None)
< CreateDataType("sms.fault.replication.NoValidReplica", "NoValidReplica", "sms.fault.replication.ReplicationFault", "sms.version.version11", [("deviceId", "sms.storage.replication.DeviceId", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.fault.replication.PeerNotReachable", "PeerNotReachable", "sms.fault.replication.ReplicationFault", "sms.version.version11", None)
< CreateDataType("sms.storage.FcStoragePort", "FcStoragePort", "sms.storage.StoragePort", "sms.version.version2", [("portWwn", "string", "sms.version.version2", 0), ("nodeWwn", "string", "sms.version.version2", 0)])
< CreateDataType("sms.storage.FcoeStoragePort", "FcoeStoragePort", "sms.storage.StoragePort", "sms.version.version2", [("portWwn", "string", "sms.version.version2", 0), ("nodeWwn", "string", "sms.version.version2", 0)])
< CreateDataType("sms.storage.IscsiStoragePort", "IscsiStoragePort", "sms.storage.StoragePort", "sms.version.version2", [("identifier", "string", "sms.version.version2", 0)])
< CreateDataType("sms.storage.replication.FailoverSuccessResult", "FailoverSuccessResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("newState", "string", "sms.version.version11", 0), ("pitId", "sms.storage.replication.PointInTimeReplicaId", "sms.version.version11", F_OPTIONAL), ("pitIdBeforeFailover", "sms.storage.replication.PointInTimeReplicaId", "sms.version.version11", F_OPTIONAL), ("recoveredDeviceInfo", "sms.storage.replication.FailoverSuccessResult.RecoveredDevice[]", "sms.version.version11", F_OPTIONAL), ("timeStamp", "vmodl.DateTime", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.FailoverSuccessResult.RecoveredDiskInfo", "RecoveredDiskInfo", "vmodl.DynamicData", "sms.version.version11", [("deviceKey", "int", "sms.version.version11", 0), ("dsUrl", "string", "sms.version.version11", 0), ("diskPath", "string", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.FailoverSuccessResult.RecoveredDevice", "RecoveredDevice", "vmodl.DynamicData", "sms.version.version11", [("targetDeviceId", "sms.storage.replication.ReplicaId", "sms.version.version11", F_OPTIONAL), ("recoveredDeviceId", "sms.storage.replication.DeviceId", "sms.version.version11", F_OPTIONAL), ("sourceDeviceId", "sms.storage.replication.DeviceId", "sms.version.version11", 0), ("info", "string[]", "sms.version.version11", F_OPTIONAL), ("datastore", "vim.Datastore", "sms.version.version11", 0), ("recoveredDiskInfo", "sms.storage.replication.FailoverSuccessResult.RecoveredDiskInfo[]", "sms.version.version11", F_OPTIONAL), ("error", "vmodl.MethodFault", "sms.version.version11", F_OPTIONAL), ("warnings", "vmodl.MethodFault[]", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.GroupErrorResult", "GroupErrorResult", "sms.storage.replication.GroupOperationResult", "sms.version.version11", [("error", "vmodl.MethodFault[]", "sms.version.version11", 0)])
< CreateDataType("sms.storage.replication.RecoveredTargetGroupMemberInfo", "RecoveredTargetGroupMemberInfo", "sms.storage.replication.TargetGroupMemberInfo", "sms.version.version11", [("recoveredDeviceId", "sms.storage.replication.DeviceId", "sms.version.version11", F_OPTIONAL)])
< CreateDataType("sms.storage.replication.VirtualMachineFilePath", "VirtualMachineFilePath", "sms.storage.replication.VirtualMachineId", "sms.version.version11", [("vcUuid", "string", "sms.version.version11", F_OPTIONAL), ("dsUrl", "string", "sms.version.version11", 0), ("vmxPath", "string", "sms.version.version11", 0)])
---
> # ******* WARNING - AUTO GENERATED CODE - DO NOT EDIT *******
> 
> from pyVmomi.VmomiSupport import CreateDataType, CreateManagedType, CreateEnumType
> from pyVmomi.VmomiSupport import AddVersion, AddVersionParent
> from pyVmomi.VmomiSupport import F_OPTIONAL, F_SECRET
> from pyVmomi.VmomiSupport import newestVersions, publicVersions, oldestVersions, dottedVersions
> 
> AddVersion("vmodl.query.version.version4", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version3", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version2", "", "", 0, "vim25")
> AddVersion("vmodl.query.version.version1", "", "", 0, "vim25")
> AddVersion("vim.version.v7_0_1_1", "vim25", "7.0.1.1", 0, "vim25")
> AddVersion("vmodl.version.version0", "", "", 0, "vim25")
> AddVersion("vmodl.version.version1", "", "", 0, "vim25")
> AddVersion("vmodl.version.version2", "", "", 0, "vim25")
> AddVersion("vim.version.v6_9_1", "vim25", "6.9.1", 0, "vim25")
> AddVersion("vim.version.v7_0_0_2", "vim25", "7.0.0.2", 0, "vim25")
> AddVersion("vim.version.v6_8_7", "vim25", "6.8.7", 0, "vim25")
> AddVersion("vmodl.reflect.version.version1", "reflect", "1.0", 0, "reflect")
> AddVersion("vmodl.reflect.version.version2", "reflect", "2.0", 0, "reflect")
> AddVersion("vim.version.v7_0_3_0", "vim25", "7.0.3.0", 0, "vim25")
> AddVersion("vim.version.version13", "vim25", "6.7.1", 0, "vim25")
> AddVersion("vim.version.version14", "vim25", "6.7.2", 0, "vim25")
> AddVersion("vim.version.version15", "vim25", "6.7.3", 0, "vim25")
> AddVersion("sms.version.v7_0_0_1", "sms", "7.0.0.1", 0, "sms")
> AddVersion("sms.version.v6_8_7", "sms", "6.8.7", 0, "sms")
> AddVersion("vim.version.version10", "vim25", "6.0", 0, "vim25")
> AddVersion("vim.version.version11", "vim25", "6.5", 0, "vim25")
> AddVersion("vim.version.version12", "vim25", "6.7", 0, "vim25")
> AddVersion("vim.version.v7_0_2_0", "vim25", "7.0.2.0", 0, "vim25")
> AddVersion("vim.version.v7_0_2_1", "vim25", "7.0.2.1", 0, "vim25")
> AddVersion("sms.version.version5", "sms", "5.0", 0, "sms")
> AddVersion("sms.version.version13", "sms", "6.7.1", 0, "sms")
> AddVersion("vim.version.v7_0_1_0", "vim25", "7.0.1.0", 0, "vim25")
> AddVersion("sms.version.version12", "sms", "6.7", 0, "sms")
> AddVersion("sms.version.version11", "sms", "6.5", 0, "sms")
> AddVersion("sms.version.version2", "sms", "2.0", 0, "sms")
> AddVersion("sms.version.version1", "sms", "1.0", 0, "sms")
> AddVersion("sms.version.version4", "sms", "4.0", 0, "sms")
> AddVersion("sms.version.version3", "sms", "3.0", 0, "sms")
> AddVersion("vim.version.v7_0", "vim25", "7.0.0.0", 0, "vim25")
> AddVersion("sms.version.version14", "sms", "6.7.2", 0, "sms")
> AddVersion("vim.version.version8", "vim25", "5.1", 0, "vim25")
> AddVersion("vim.version.version9", "vim25", "5.5", 0, "vim25")
> AddVersion("vim.version.version6", "vim25", "4.1", 0, "vim25")
> AddVersion("vim.version.version7", "vim25", "5.0", 0, "vim25")
> AddVersion("vim.version.version1", "vim2", "2.0", 0, "vim25")
> AddVersion("vim.version.version4", "vim25", "2.5u2server", 0, "vim25")
> AddVersion("vim.version.version5", "vim25", "4.0", 0, "vim25")
> AddVersion("vim.version.version2", "vim25", "2.5", 0, "vim25")
> AddVersion("vim.version.version3", "vim25", "2.5u2", 0, "vim25")
> AddVersion("sms.version.v7_0", "sms", "7.0.0.0", 0, "sms")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version4")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version4", "vmodl.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version3")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version3", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version2")
> AddVersionParent("vmodl.query.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.query.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vmodl.query.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_1_1", "vim.version.version3")
> AddVersionParent("vmodl.version.version0", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.version.version2", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v6_9_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version13")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version14")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version15")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version10")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version11")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version12")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version8")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version9")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version6")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version7")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version1")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version4")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version5")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version2")
> AddVersionParent("vim.version.v6_9_1", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_0_2", "vim.version.version3")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version0")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version13")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version14")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version15")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version10")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version11")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version12")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version8")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version9")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version6")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version7")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version1")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version4")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version5")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version2")
> AddVersionParent("vim.version.v6_8_7", "vim.version.version3")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version1", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version0")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.version.version2")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version1")
> AddVersionParent("vmodl.reflect.version.version2", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_3_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_2_1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_3_0", "vim.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.version.version0")
> AddVersionParent("vim.version.version13", "vmodl.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.version.version2")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version13", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version13")
> AddVersionParent("vim.version.version13", "vim.version.version10")
> AddVersionParent("vim.version.version13", "vim.version.version11")
> AddVersionParent("vim.version.version13", "vim.version.version12")
> AddVersionParent("vim.version.version13", "vim.version.version8")
> AddVersionParent("vim.version.version13", "vim.version.version9")
> AddVersionParent("vim.version.version13", "vim.version.version6")
> AddVersionParent("vim.version.version13", "vim.version.version7")
> AddVersionParent("vim.version.version13", "vim.version.version1")
> AddVersionParent("vim.version.version13", "vim.version.version4")
> AddVersionParent("vim.version.version13", "vim.version.version5")
> AddVersionParent("vim.version.version13", "vim.version.version2")
> AddVersionParent("vim.version.version13", "vim.version.version3")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version14", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.version.version0")
> AddVersionParent("vim.version.version14", "vmodl.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.version.version2")
> AddVersionParent("vim.version.version14", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version14", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version14", "vim.version.version13")
> AddVersionParent("vim.version.version14", "vim.version.version14")
> AddVersionParent("vim.version.version14", "vim.version.version10")
> AddVersionParent("vim.version.version14", "vim.version.version11")
> AddVersionParent("vim.version.version14", "vim.version.version12")
> AddVersionParent("vim.version.version14", "vim.version.version8")
> AddVersionParent("vim.version.version14", "vim.version.version9")
> AddVersionParent("vim.version.version14", "vim.version.version6")
> AddVersionParent("vim.version.version14", "vim.version.version7")
> AddVersionParent("vim.version.version14", "vim.version.version1")
> AddVersionParent("vim.version.version14", "vim.version.version4")
> AddVersionParent("vim.version.version14", "vim.version.version5")
> AddVersionParent("vim.version.version14", "vim.version.version2")
> AddVersionParent("vim.version.version14", "vim.version.version3")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version15", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.version.version0")
> AddVersionParent("vim.version.version15", "vmodl.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.version.version2")
> AddVersionParent("vim.version.version15", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version15", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version15", "vim.version.version13")
> AddVersionParent("vim.version.version15", "vim.version.version14")
> AddVersionParent("vim.version.version15", "vim.version.version15")
> AddVersionParent("vim.version.version15", "vim.version.version10")
> AddVersionParent("vim.version.version15", "vim.version.version11")
> AddVersionParent("vim.version.version15", "vim.version.version12")
> AddVersionParent("vim.version.version15", "vim.version.version8")
> AddVersionParent("vim.version.version15", "vim.version.version9")
> AddVersionParent("vim.version.version15", "vim.version.version6")
> AddVersionParent("vim.version.version15", "vim.version.version7")
> AddVersionParent("vim.version.version15", "vim.version.version1")
> AddVersionParent("vim.version.version15", "vim.version.version4")
> AddVersionParent("vim.version.version15", "vim.version.version5")
> AddVersionParent("vim.version.version15", "vim.version.version2")
> AddVersionParent("vim.version.version15", "vim.version.version3")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version4")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version3")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version2")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.query.version.version1")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version0")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version1")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.version.version2")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.v6_9_1")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.v6_8_7")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.v7_0_0_1", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version13")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version14")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version15")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.v7_0_0_1")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.v6_8_7")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version10")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version11")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version12")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version5")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version13")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version12")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version11")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version2")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version1")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version4")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version3")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.v7_0")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.version14")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version8")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version9")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version6")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version7")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version1")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version4")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version5")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version2")
> AddVersionParent("sms.version.v7_0_0_1", "vim.version.version3")
> AddVersionParent("sms.version.v7_0_0_1", "sms.version.v7_0")
> AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version4")
> AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version3")
> AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version2")
> AddVersionParent("sms.version.v6_8_7", "vmodl.query.version.version1")
> AddVersionParent("sms.version.v6_8_7", "vmodl.version.version0")
> AddVersionParent("sms.version.v6_8_7", "vmodl.version.version1")
> AddVersionParent("sms.version.v6_8_7", "vmodl.version.version2")
> AddVersionParent("sms.version.v6_8_7", "vim.version.v6_8_7")
> AddVersionParent("sms.version.v6_8_7", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.v6_8_7", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version13")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version14")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version15")
> AddVersionParent("sms.version.v6_8_7", "sms.version.v6_8_7")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version10")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version11")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version12")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version5")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version13")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version12")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version11")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version2")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version1")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version4")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version3")
> AddVersionParent("sms.version.v6_8_7", "sms.version.version14")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version8")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version9")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version6")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version7")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version1")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version4")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version5")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version2")
> AddVersionParent("sms.version.v6_8_7", "vim.version.version3")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.version.version0")
> AddVersionParent("vim.version.version10", "vmodl.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.version.version2")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version10", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version10")
> AddVersionParent("vim.version.version10", "vim.version.version8")
> AddVersionParent("vim.version.version10", "vim.version.version9")
> AddVersionParent("vim.version.version10", "vim.version.version6")
> AddVersionParent("vim.version.version10", "vim.version.version7")
> AddVersionParent("vim.version.version10", "vim.version.version1")
> AddVersionParent("vim.version.version10", "vim.version.version4")
> AddVersionParent("vim.version.version10", "vim.version.version5")
> AddVersionParent("vim.version.version10", "vim.version.version2")
> AddVersionParent("vim.version.version10", "vim.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.version.version0")
> AddVersionParent("vim.version.version11", "vmodl.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.version.version2")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version11", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version10")
> AddVersionParent("vim.version.version11", "vim.version.version11")
> AddVersionParent("vim.version.version11", "vim.version.version8")
> AddVersionParent("vim.version.version11", "vim.version.version9")
> AddVersionParent("vim.version.version11", "vim.version.version6")
> AddVersionParent("vim.version.version11", "vim.version.version7")
> AddVersionParent("vim.version.version11", "vim.version.version1")
> AddVersionParent("vim.version.version11", "vim.version.version4")
> AddVersionParent("vim.version.version11", "vim.version.version5")
> AddVersionParent("vim.version.version11", "vim.version.version2")
> AddVersionParent("vim.version.version11", "vim.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.version.version0")
> AddVersionParent("vim.version.version12", "vmodl.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.version.version2")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version12", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version10")
> AddVersionParent("vim.version.version12", "vim.version.version11")
> AddVersionParent("vim.version.version12", "vim.version.version12")
> AddVersionParent("vim.version.version12", "vim.version.version8")
> AddVersionParent("vim.version.version12", "vim.version.version9")
> AddVersionParent("vim.version.version12", "vim.version.version6")
> AddVersionParent("vim.version.version12", "vim.version.version7")
> AddVersionParent("vim.version.version12", "vim.version.version1")
> AddVersionParent("vim.version.version12", "vim.version.version4")
> AddVersionParent("vim.version.version12", "vim.version.version5")
> AddVersionParent("vim.version.version12", "vim.version.version2")
> AddVersionParent("vim.version.version12", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_2_0", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_2_1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_2_1", "vim.version.version3")
> AddVersionParent("sms.version.version5", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version5", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version5", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version5", "vmodl.version.version0")
> AddVersionParent("sms.version.version5", "vmodl.version.version1")
> AddVersionParent("sms.version.version5", "sms.version.version5")
> AddVersionParent("sms.version.version5", "sms.version.version2")
> AddVersionParent("sms.version.version5", "sms.version.version1")
> AddVersionParent("sms.version.version5", "sms.version.version4")
> AddVersionParent("sms.version.version5", "sms.version.version3")
> AddVersionParent("sms.version.version5", "vim.version.version6")
> AddVersionParent("sms.version.version5", "vim.version.version1")
> AddVersionParent("sms.version.version5", "vim.version.version4")
> AddVersionParent("sms.version.version5", "vim.version.version5")
> AddVersionParent("sms.version.version5", "vim.version.version2")
> AddVersionParent("sms.version.version5", "vim.version.version3")
> AddVersionParent("sms.version.version13", "vmodl.query.version.version4")
> AddVersionParent("sms.version.version13", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version13", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version13", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version13", "vmodl.version.version0")
> AddVersionParent("sms.version.version13", "vmodl.version.version1")
> AddVersionParent("sms.version.version13", "vmodl.version.version2")
> AddVersionParent("sms.version.version13", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.version13", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.version13", "vim.version.version13")
> AddVersionParent("sms.version.version13", "vim.version.version10")
> AddVersionParent("sms.version.version13", "vim.version.version11")
> AddVersionParent("sms.version.version13", "vim.version.version12")
> AddVersionParent("sms.version.version13", "sms.version.version5")
> AddVersionParent("sms.version.version13", "sms.version.version13")
> AddVersionParent("sms.version.version13", "sms.version.version12")
> AddVersionParent("sms.version.version13", "sms.version.version11")
> AddVersionParent("sms.version.version13", "sms.version.version2")
> AddVersionParent("sms.version.version13", "sms.version.version1")
> AddVersionParent("sms.version.version13", "sms.version.version4")
> AddVersionParent("sms.version.version13", "sms.version.version3")
> AddVersionParent("sms.version.version13", "vim.version.version8")
> AddVersionParent("sms.version.version13", "vim.version.version9")
> AddVersionParent("sms.version.version13", "vim.version.version6")
> AddVersionParent("sms.version.version13", "vim.version.version7")
> AddVersionParent("sms.version.version13", "vim.version.version1")
> AddVersionParent("sms.version.version13", "vim.version.version4")
> AddVersionParent("sms.version.version13", "vim.version.version5")
> AddVersionParent("sms.version.version13", "vim.version.version2")
> AddVersionParent("sms.version.version13", "vim.version.version3")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_0_2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0_1_0")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0_1_0", "vim.version.version3")
> AddVersionParent("sms.version.version12", "vmodl.query.version.version4")
> AddVersionParent("sms.version.version12", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version12", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version12", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version12", "vmodl.version.version0")
> AddVersionParent("sms.version.version12", "vmodl.version.version1")
> AddVersionParent("sms.version.version12", "vmodl.version.version2")
> AddVersionParent("sms.version.version12", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.version12", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.version12", "vim.version.version10")
> AddVersionParent("sms.version.version12", "vim.version.version11")
> AddVersionParent("sms.version.version12", "vim.version.version12")
> AddVersionParent("sms.version.version12", "sms.version.version5")
> AddVersionParent("sms.version.version12", "sms.version.version12")
> AddVersionParent("sms.version.version12", "sms.version.version11")
> AddVersionParent("sms.version.version12", "sms.version.version2")
> AddVersionParent("sms.version.version12", "sms.version.version1")
> AddVersionParent("sms.version.version12", "sms.version.version4")
> AddVersionParent("sms.version.version12", "sms.version.version3")
> AddVersionParent("sms.version.version12", "vim.version.version8")
> AddVersionParent("sms.version.version12", "vim.version.version9")
> AddVersionParent("sms.version.version12", "vim.version.version6")
> AddVersionParent("sms.version.version12", "vim.version.version7")
> AddVersionParent("sms.version.version12", "vim.version.version1")
> AddVersionParent("sms.version.version12", "vim.version.version4")
> AddVersionParent("sms.version.version12", "vim.version.version5")
> AddVersionParent("sms.version.version12", "vim.version.version2")
> AddVersionParent("sms.version.version12", "vim.version.version3")
> AddVersionParent("sms.version.version11", "vmodl.query.version.version4")
> AddVersionParent("sms.version.version11", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version11", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version11", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version11", "vmodl.version.version0")
> AddVersionParent("sms.version.version11", "vmodl.version.version1")
> AddVersionParent("sms.version.version11", "vmodl.version.version2")
> AddVersionParent("sms.version.version11", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.version11", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.version11", "vim.version.version10")
> AddVersionParent("sms.version.version11", "vim.version.version11")
> AddVersionParent("sms.version.version11", "sms.version.version5")
> AddVersionParent("sms.version.version11", "sms.version.version11")
> AddVersionParent("sms.version.version11", "sms.version.version2")
> AddVersionParent("sms.version.version11", "sms.version.version1")
> AddVersionParent("sms.version.version11", "sms.version.version4")
> AddVersionParent("sms.version.version11", "sms.version.version3")
> AddVersionParent("sms.version.version11", "vim.version.version8")
> AddVersionParent("sms.version.version11", "vim.version.version9")
> AddVersionParent("sms.version.version11", "vim.version.version6")
> AddVersionParent("sms.version.version11", "vim.version.version7")
> AddVersionParent("sms.version.version11", "vim.version.version1")
> AddVersionParent("sms.version.version11", "vim.version.version4")
> AddVersionParent("sms.version.version11", "vim.version.version5")
> AddVersionParent("sms.version.version11", "vim.version.version2")
> AddVersionParent("sms.version.version11", "vim.version.version3")
> AddVersionParent("sms.version.version2", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version2", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version2", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version2", "vmodl.version.version0")
> AddVersionParent("sms.version.version2", "vmodl.version.version1")
> AddVersionParent("sms.version.version2", "sms.version.version2")
> AddVersionParent("sms.version.version2", "sms.version.version1")
> AddVersionParent("sms.version.version2", "vim.version.version6")
> AddVersionParent("sms.version.version2", "vim.version.version1")
> AddVersionParent("sms.version.version2", "vim.version.version4")
> AddVersionParent("sms.version.version2", "vim.version.version5")
> AddVersionParent("sms.version.version2", "vim.version.version2")
> AddVersionParent("sms.version.version2", "vim.version.version3")
> AddVersionParent("sms.version.version1", "vmodl.version.version0")
> AddVersionParent("sms.version.version1", "vmodl.version.version1")
> AddVersionParent("sms.version.version1", "sms.version.version1")
> AddVersionParent("sms.version.version4", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version4", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version4", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version4", "vmodl.version.version0")
> AddVersionParent("sms.version.version4", "vmodl.version.version1")
> AddVersionParent("sms.version.version4", "sms.version.version2")
> AddVersionParent("sms.version.version4", "sms.version.version1")
> AddVersionParent("sms.version.version4", "sms.version.version4")
> AddVersionParent("sms.version.version4", "sms.version.version3")
> AddVersionParent("sms.version.version4", "vim.version.version6")
> AddVersionParent("sms.version.version4", "vim.version.version1")
> AddVersionParent("sms.version.version4", "vim.version.version4")
> AddVersionParent("sms.version.version4", "vim.version.version5")
> AddVersionParent("sms.version.version4", "vim.version.version2")
> AddVersionParent("sms.version.version4", "vim.version.version3")
> AddVersionParent("sms.version.version3", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version3", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version3", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version3", "vmodl.version.version0")
> AddVersionParent("sms.version.version3", "vmodl.version.version1")
> AddVersionParent("sms.version.version3", "sms.version.version2")
> AddVersionParent("sms.version.version3", "sms.version.version1")
> AddVersionParent("sms.version.version3", "sms.version.version3")
> AddVersionParent("sms.version.version3", "vim.version.version6")
> AddVersionParent("sms.version.version3", "vim.version.version1")
> AddVersionParent("sms.version.version3", "vim.version.version4")
> AddVersionParent("sms.version.version3", "vim.version.version5")
> AddVersionParent("sms.version.version3", "vim.version.version2")
> AddVersionParent("sms.version.version3", "vim.version.version3")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version4")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version3")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version2")
> AddVersionParent("vim.version.v7_0", "vmodl.query.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version0")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.v6_9_1")
> AddVersionParent("vim.version.v7_0", "vim.version.v6_8_7")
> AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.v7_0", "vmodl.reflect.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.version13")
> AddVersionParent("vim.version.v7_0", "vim.version.version14")
> AddVersionParent("vim.version.v7_0", "vim.version.version15")
> AddVersionParent("vim.version.v7_0", "vim.version.version10")
> AddVersionParent("vim.version.v7_0", "vim.version.version11")
> AddVersionParent("vim.version.v7_0", "vim.version.version12")
> AddVersionParent("vim.version.v7_0", "vim.version.v7_0")
> AddVersionParent("vim.version.v7_0", "vim.version.version8")
> AddVersionParent("vim.version.v7_0", "vim.version.version9")
> AddVersionParent("vim.version.v7_0", "vim.version.version6")
> AddVersionParent("vim.version.v7_0", "vim.version.version7")
> AddVersionParent("vim.version.v7_0", "vim.version.version1")
> AddVersionParent("vim.version.v7_0", "vim.version.version4")
> AddVersionParent("vim.version.v7_0", "vim.version.version5")
> AddVersionParent("vim.version.v7_0", "vim.version.version2")
> AddVersionParent("vim.version.v7_0", "vim.version.version3")
> AddVersionParent("sms.version.version14", "vmodl.query.version.version4")
> AddVersionParent("sms.version.version14", "vmodl.query.version.version3")
> AddVersionParent("sms.version.version14", "vmodl.query.version.version2")
> AddVersionParent("sms.version.version14", "vmodl.query.version.version1")
> AddVersionParent("sms.version.version14", "vmodl.version.version0")
> AddVersionParent("sms.version.version14", "vmodl.version.version1")
> AddVersionParent("sms.version.version14", "vmodl.version.version2")
> AddVersionParent("sms.version.version14", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.version14", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.version14", "vim.version.version13")
> AddVersionParent("sms.version.version14", "vim.version.version14")
> AddVersionParent("sms.version.version14", "vim.version.version10")
> AddVersionParent("sms.version.version14", "vim.version.version11")
> AddVersionParent("sms.version.version14", "vim.version.version12")
> AddVersionParent("sms.version.version14", "sms.version.version5")
> AddVersionParent("sms.version.version14", "sms.version.version13")
> AddVersionParent("sms.version.version14", "sms.version.version12")
> AddVersionParent("sms.version.version14", "sms.version.version11")
> AddVersionParent("sms.version.version14", "sms.version.version2")
> AddVersionParent("sms.version.version14", "sms.version.version1")
> AddVersionParent("sms.version.version14", "sms.version.version4")
> AddVersionParent("sms.version.version14", "sms.version.version3")
> AddVersionParent("sms.version.version14", "sms.version.version14")
> AddVersionParent("sms.version.version14", "vim.version.version8")
> AddVersionParent("sms.version.version14", "vim.version.version9")
> AddVersionParent("sms.version.version14", "vim.version.version6")
> AddVersionParent("sms.version.version14", "vim.version.version7")
> AddVersionParent("sms.version.version14", "vim.version.version1")
> AddVersionParent("sms.version.version14", "vim.version.version4")
> AddVersionParent("sms.version.version14", "vim.version.version5")
> AddVersionParent("sms.version.version14", "vim.version.version2")
> AddVersionParent("sms.version.version14", "vim.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version8", "vmodl.version.version0")
> AddVersionParent("vim.version.version8", "vmodl.version.version1")
> AddVersionParent("vim.version.version8", "vmodl.version.version2")
> AddVersionParent("vim.version.version8", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version8")
> AddVersionParent("vim.version.version8", "vim.version.version6")
> AddVersionParent("vim.version.version8", "vim.version.version7")
> AddVersionParent("vim.version.version8", "vim.version.version1")
> AddVersionParent("vim.version.version8", "vim.version.version4")
> AddVersionParent("vim.version.version8", "vim.version.version5")
> AddVersionParent("vim.version.version8", "vim.version.version2")
> AddVersionParent("vim.version.version8", "vim.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.version.version0")
> AddVersionParent("vim.version.version9", "vmodl.version.version1")
> AddVersionParent("vim.version.version9", "vmodl.version.version2")
> AddVersionParent("vim.version.version9", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version8")
> AddVersionParent("vim.version.version9", "vim.version.version9")
> AddVersionParent("vim.version.version9", "vim.version.version6")
> AddVersionParent("vim.version.version9", "vim.version.version7")
> AddVersionParent("vim.version.version9", "vim.version.version1")
> AddVersionParent("vim.version.version9", "vim.version.version4")
> AddVersionParent("vim.version.version9", "vim.version.version5")
> AddVersionParent("vim.version.version9", "vim.version.version2")
> AddVersionParent("vim.version.version9", "vim.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version6", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version6", "vmodl.version.version0")
> AddVersionParent("vim.version.version6", "vmodl.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version6")
> AddVersionParent("vim.version.version6", "vim.version.version1")
> AddVersionParent("vim.version.version6", "vim.version.version4")
> AddVersionParent("vim.version.version6", "vim.version.version5")
> AddVersionParent("vim.version.version6", "vim.version.version2")
> AddVersionParent("vim.version.version6", "vim.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version4")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version3")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.version.version0")
> AddVersionParent("vim.version.version7", "vmodl.version.version1")
> AddVersionParent("vim.version.version7", "vmodl.version.version2")
> AddVersionParent("vim.version.version7", "vmodl.reflect.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version6")
> AddVersionParent("vim.version.version7", "vim.version.version7")
> AddVersionParent("vim.version.version7", "vim.version.version1")
> AddVersionParent("vim.version.version7", "vim.version.version4")
> AddVersionParent("vim.version.version7", "vim.version.version5")
> AddVersionParent("vim.version.version7", "vim.version.version2")
> AddVersionParent("vim.version.version7", "vim.version.version3")
> AddVersionParent("vim.version.version1", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version1", "vmodl.version.version0")
> AddVersionParent("vim.version.version1", "vim.version.version1")
> AddVersionParent("vim.version.version4", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version4", "vmodl.version.version0")
> AddVersionParent("vim.version.version4", "vim.version.version1")
> AddVersionParent("vim.version.version4", "vim.version.version4")
> AddVersionParent("vim.version.version4", "vim.version.version2")
> AddVersionParent("vim.version.version4", "vim.version.version3")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version2")
> AddVersionParent("vim.version.version5", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version5", "vmodl.version.version0")
> AddVersionParent("vim.version.version5", "vmodl.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version1")
> AddVersionParent("vim.version.version5", "vim.version.version4")
> AddVersionParent("vim.version.version5", "vim.version.version5")
> AddVersionParent("vim.version.version5", "vim.version.version2")
> AddVersionParent("vim.version.version5", "vim.version.version3")
> AddVersionParent("vim.version.version2", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version2", "vmodl.version.version0")
> AddVersionParent("vim.version.version2", "vim.version.version1")
> AddVersionParent("vim.version.version2", "vim.version.version2")
> AddVersionParent("vim.version.version3", "vmodl.query.version.version1")
> AddVersionParent("vim.version.version3", "vmodl.version.version0")
> AddVersionParent("vim.version.version3", "vim.version.version1")
> AddVersionParent("vim.version.version3", "vim.version.version2")
> AddVersionParent("vim.version.version3", "vim.version.version3")
> AddVersionParent("sms.version.v7_0", "vmodl.query.version.version4")
> AddVersionParent("sms.version.v7_0", "vmodl.query.version.version3")
> AddVersionParent("sms.version.v7_0", "vmodl.query.version.version2")
> AddVersionParent("sms.version.v7_0", "vmodl.query.version.version1")
> AddVersionParent("sms.version.v7_0", "vmodl.version.version0")
> AddVersionParent("sms.version.v7_0", "vmodl.version.version1")
> AddVersionParent("sms.version.v7_0", "vmodl.version.version2")
> AddVersionParent("sms.version.v7_0", "vim.version.v6_9_1")
> AddVersionParent("sms.version.v7_0", "vim.version.v6_8_7")
> AddVersionParent("sms.version.v7_0", "vmodl.reflect.version.version1")
> AddVersionParent("sms.version.v7_0", "vmodl.reflect.version.version2")
> AddVersionParent("sms.version.v7_0", "vim.version.version13")
> AddVersionParent("sms.version.v7_0", "vim.version.version14")
> AddVersionParent("sms.version.v7_0", "vim.version.version15")
> AddVersionParent("sms.version.v7_0", "sms.version.v6_8_7")
> AddVersionParent("sms.version.v7_0", "vim.version.version10")
> AddVersionParent("sms.version.v7_0", "vim.version.version11")
> AddVersionParent("sms.version.v7_0", "vim.version.version12")
> AddVersionParent("sms.version.v7_0", "sms.version.version5")
> AddVersionParent("sms.version.v7_0", "sms.version.version13")
> AddVersionParent("sms.version.v7_0", "sms.version.version12")
> AddVersionParent("sms.version.v7_0", "sms.version.version11")
> AddVersionParent("sms.version.v7_0", "sms.version.version2")
> AddVersionParent("sms.version.v7_0", "sms.version.version1")
> AddVersionParent("sms.version.v7_0", "sms.version.version4")
> AddVersionParent("sms.version.v7_0", "sms.version.version3")
> AddVersionParent("sms.version.v7_0", "vim.version.v7_0")
> AddVersionParent("sms.version.v7_0", "sms.version.version14")
> AddVersionParent("sms.version.v7_0", "vim.version.version8")
> AddVersionParent("sms.version.v7_0", "vim.version.version9")
> AddVersionParent("sms.version.v7_0", "vim.version.version6")
> AddVersionParent("sms.version.v7_0", "vim.version.version7")
> AddVersionParent("sms.version.v7_0", "vim.version.version1")
> AddVersionParent("sms.version.v7_0", "vim.version.version4")
> AddVersionParent("sms.version.v7_0", "vim.version.version5")
> AddVersionParent("sms.version.v7_0", "vim.version.version2")
> AddVersionParent("sms.version.v7_0", "vim.version.version3")
> AddVersionParent("sms.version.v7_0", "sms.version.v7_0")
> 
> newestVersions.Add("sms.version.v7_0_0_1")
> publicVersions.Add("sms.version.v7_0_0_1")
> dottedVersions.Add("sms.version.v7_0_0_1")
> oldestVersions.Add("sms.version.version1")
> 
> CreateDataType("sms.AboutInfo", "SmsAboutInfo", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("fullName", "string", "sms.version.version2", 0), ("vendor", "string", "sms.version.version2", 0), ("apiVersion", "string", "sms.version.version2", 0), ("instanceUuid", "string", "sms.version.version2", 0), ("vasaApiVersion", "string", "sms.version.version4", F_OPTIONAL)])
> CreateDataType("sms.EntityReference", "EntityReference", "vmodl.DynamicData", "sms.version.version1", [("id", "string", "sms.version.version1", 0), ("type", "sms.EntityReference.EntityType", "sms.version.version1", F_OPTIONAL)])
> CreateEnumType("sms.EntityReference.EntityType", "EntityReferenceEntityType", "sms.version.version1", ["datacenter", "resourcePool", "storagePod", "cluster", "vm", "datastore", "host", "vmFile", "scsiPath", "scsiTarget", "scsiVolume", "scsiAdapter", "nasMount"])
> CreateDataType("sms.FaultDomainFilter", "FaultDomainFilter", "vmodl.DynamicData", "sms.version.version11", [("providerId", "string", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.ReplicationGroupFilter", "ReplicationGroupFilter", "vmodl.DynamicData", "sms.version.version11", [("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL)])
> CreateManagedType("sms.ServiceInstance", "SmsServiceInstance", "vmodl.ManagedObject", "sms.version.version1", None, [("queryStorageManager", "QueryStorageManager", "sms.version.version2", (), (0, "sms.StorageManager", "sms.StorageManager"), "StorageViews.View", None), ("querySessionManager", "QuerySessionManager", "sms.version.version5", (), (0, "sms.auth.SessionManager", "sms.auth.SessionManager"), "System.Anonymous", None), ("queryAboutInfo", "QueryAboutInfo", "sms.version.version2", (), (0, "sms.AboutInfo", "sms.AboutInfo"), "StorageViews.View", None)])
> CreateManagedType("sms.StorageManager", "SmsStorageManager", "vmodl.ManagedObject", "sms.version.version2", None, [("registerProvider", "RegisterProvider_Task", "sms.version.version2", (("providerSpec", "sms.provider.ProviderSpec", "sms.version.version2", 0, None),), (0, "sms.Task", "sms.provider.Provider"), "StorageViews.ConfigureService", ["vim.fault.AlreadyExists", "sms.fault.ProviderRegistrationFault", ]), ("unregisterProvider", "UnregisterProvider_Task", "sms.version.version2", (("providerId", "string", "sms.version.version2", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["vim.fault.NotFound", "sms.fault.ProviderUnregistrationFault", ]), ("queryProvider", "QueryProvider", "sms.version.version2", (), (F_OPTIONAL, "sms.provider.Provider[]", "sms.provider.Provider[]"), "StorageViews.View", ["sms.fault.QueryExecutionFault", ]), ("queryArray", "QueryArray", "sms.version.version2", (("providerId", "string[]", "sms.version.version2", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.StorageArray[]", "sms.storage.StorageArray[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryProcessorAssociatedWithArray", "QueryProcessorAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageProcessor[]", "sms.storage.StorageProcessor[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithArray", "QueryPortAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort[]", "sms.storage.StoragePort[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithLun", "QueryPortAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort", "sms.storage.StoragePort"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryLunAssociatedWithPort", "QueryLunAssociatedWithPort", "sms.version.version2", (("portId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageLun[]", "sms.storage.StorageLun[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryArrayAssociatedWithLun", "QueryArrayAssociatedWithLun", "sms.version.version2", (("canonicalName", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageArray", "sms.storage.StorageArray"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryPortAssociatedWithProcessor", "QueryPortAssociatedWithProcessor", "sms.version.version2", (("processorId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StoragePort[]", "sms.storage.StoragePort[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryLunAssociatedWithArray", "QueryLunAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageLun[]", "sms.storage.StorageLun[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryFileSystemAssociatedWithArray", "QueryFileSystemAssociatedWithArray", "sms.version.version2", (("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageFileSystem[]", "sms.storage.StorageFileSystem[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDatastoreCapability", "QueryDatastoreCapability", "sms.version.version2", (("datastore", "vim.Datastore", "sms.version.version2", 0, None),), (F_OPTIONAL, "sms.storage.StorageCapability", "sms.storage.StorageCapability"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryHostAssociatedWithLun", "QueryHostAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.HostSystem[]", "vim.HostSystem[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryVmfsDatastoreAssociatedWithLun", "QueryVmfsDatastoreAssociatedWithLun", "sms.version.version2", (("scsi3Id", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.Datastore", "vim.Datastore"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryNfsDatastoreAssociatedWithFileSystem", "QueryNfsDatastoreAssociatedWithFileSystem", "sms.version.version2", (("fileSystemId", "string", "sms.version.version2", 0, None),("arrayId", "string", "sms.version.version2", 0, None),), (F_OPTIONAL, "vim.Datastore", "vim.Datastore"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDrsMigrationCapabilityForPerformance", "QueryDrsMigrationCapabilityForPerformance", "sms.version.version2", (("srcDatastore", "vim.Datastore", "sms.version.version2", 0, None),("dstDatastore", "vim.Datastore", "sms.version.version2", 0, None),), (0, "boolean", "boolean"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDrsMigrationCapabilityForPerformanceEx", "QueryDrsMigrationCapabilityForPerformanceEx", "sms.version.version3", (("datastore", "vim.Datastore[]", "sms.version.version3", 0, None),), (0, "sms.storage.DrsMigrationCapabilityResult", "sms.storage.DrsMigrationCapabilityResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryStorageContainer", "QueryStorageContainer", "sms.version.version5", (("containerSpec", "sms.storage.StorageContainerSpec", "sms.version.version5", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.StorageContainerResult", "sms.storage.StorageContainerResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryAssociatedBackingStoragePool", "QueryAssociatedBackingStoragePool", "sms.version.version5", (("entityId", "string", "sms.version.version5", F_OPTIONAL, None),("entityType", "string", "sms.version.version5", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.BackingStoragePool[]", "sms.storage.BackingStoragePool[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryDatastoreBackingPoolMapping", "QueryDatastoreBackingPoolMapping", "sms.version.version5", (("datastore", "vim.Datastore[]", "sms.version.version5", 0, None),), (0, "sms.storage.DatastoreBackingPoolMapping[]", "sms.storage.DatastoreBackingPoolMapping[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("refreshCACertificatesAndCRLs", "SmsRefreshCACertificatesAndCRLs_Task", "sms.version.version5", (("providerId", "string[]", "sms.version.version5", F_OPTIONAL, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["vim.fault.NotFound", "sms.fault.CertificateRefreshFailed", ]), ("queryFaultDomain", "QueryFaultDomain", "sms.version.version11", (("filter", "sms.FaultDomainFilter", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "vim.vm.replication.FaultDomainId[]", "vim.vm.replication.FaultDomainId[]"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.QueryExecutionFault", ]), ("queryReplicationGroupInfo", "QueryReplicationGroupInfo", "sms.version.version11", (("rgFilter", "sms.ReplicationGroupFilter", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.QueryExecutionFault", ])])
> CreateManagedType("sms.Task", "SmsTask", "vmodl.ManagedObject", "sms.version.version2", None, [("queryResult", "QuerySmsTaskResult", "sms.version.version2", (), (F_OPTIONAL, "anyType", "anyType"), "StorageViews.View", None), ("queryInfo", "QuerySmsTaskInfo", "sms.version.version2", (), (0, "sms.TaskInfo", "sms.TaskInfo"), "StorageViews.View", None)])
> CreateDataType("sms.TaskInfo", "SmsTaskInfo", "vmodl.DynamicData", "sms.version.version2", [("key", "string", "sms.version.version2", 0), ("task", "sms.Task", "sms.version.version2", 0), ("object", "vmodl.ManagedObject", "sms.version.version2", F_OPTIONAL), ("error", "vmodl.MethodFault", "sms.version.version2", F_OPTIONAL), ("result", "anyType", "sms.version.version2", F_OPTIONAL), ("startTime", "vmodl.DateTime", "sms.version.version2", F_OPTIONAL), ("completionTime", "vmodl.DateTime", "sms.version.version2", F_OPTIONAL), ("state", "string", "sms.version.version2", 0), ("progress", "int", "sms.version.version2", F_OPTIONAL)])
> CreateEnumType("sms.TaskInfo.State", "SmsTaskState", "sms.version.version1", ["queued", "running", "success", "error"])
> CreateDataType("sms.fault.AuthConnectionFailed", "AuthConnectionFailed", "vim.fault.NoPermission", "sms.version.version2", None)
> CreateDataType("sms.fault.CertificateRefreshFailed", "CertificateRefreshFailed", "vmodl.MethodFault", "sms.version.version5", [("providerId", "string[]", "sms.version.version5", F_OPTIONAL)])
> CreateDataType("sms.fault.CertificateRevocationFailed", "CertificateRevocationFailed", "vmodl.MethodFault", "sms.version.version5", None)
> CreateDataType("sms.fault.DuplicateEntry", "DuplicateEntry", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.InactiveProvider", "InactiveProvider", "vmodl.MethodFault", "sms.version.version11", [("mapping", "sms.storage.FaultDomainProviderMapping[]", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.fault.InvalidLogin", "SmsInvalidLogin", "vmodl.MethodFault", "sms.version.version5", None)
> CreateDataType("sms.fault.InvalidProfile", "InvalidProfile", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.InvalidSession", "InvalidSession", "vim.fault.NoPermission", "sms.version.version2", [("sessionCookie", "string", "sms.version.version2", 0)])
> CreateDataType("sms.fault.MultipleSortSpecsNotSupported", "MultipleSortSpecsNotSupported", "vmodl.fault.InvalidArgument", "sms.version.version1", None)
> CreateDataType("sms.fault.NotSupportedByProvider", "NotSupportedByProvider", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.ProviderBusy", "ProviderBusy", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.ProviderConnectionFailed", "ProviderConnectionFailed", "vmodl.RuntimeFault", "sms.version.version2", None)
> CreateDataType("sms.fault.ProviderOutOfProvisioningResource", "ProviderOutOfProvisioningResource", "vmodl.MethodFault", "sms.version.version11", [("provisioningResourceId", "string", "sms.version.version11", 0), ("availableBefore", "long", "sms.version.version11", F_OPTIONAL), ("availableAfter", "long", "sms.version.version11", F_OPTIONAL), ("total", "long", "sms.version.version11", F_OPTIONAL), ("isTransient", "boolean", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.fault.ProviderOutOfResource", "ProviderOutOfResource", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.ProviderRegistrationFault", "ProviderRegistrationFault", "vmodl.MethodFault", "sms.version.version2", None)
> CreateDataType("sms.fault.ProviderSyncFailed", "ProviderSyncFailed", "vmodl.MethodFault", "sms.version.version1", None)
> CreateDataType("sms.fault.ProviderUnavailable", "ProviderUnavailable", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.ProviderUnregistrationFault", "ProviderUnregistrationFault", "vmodl.MethodFault", "sms.version.version2", None)
> CreateDataType("sms.fault.ProxyRegistrationFailed", "ProxyRegistrationFailed", "vmodl.RuntimeFault", "sms.version.version1", None)
> CreateDataType("sms.fault.QueryExecutionFault", "QueryExecutionFault", "vmodl.MethodFault", "sms.version.version1", None)
> CreateDataType("sms.fault.QueryNotSupported", "QueryNotSupported", "vmodl.fault.InvalidArgument", "sms.version.version1", [("entityType", "sms.EntityReference.EntityType", "sms.version.version1", F_OPTIONAL), ("relatedEntityType", "sms.EntityReference.EntityType", "sms.version.version1", 0)])
> CreateDataType("sms.fault.ResourceInUse", "SmsResourceInUse", "vim.fault.ResourceInUse", "sms.version.version11", [("deviceIds", "sms.storage.replication.DeviceId[]", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.fault.ServiceNotInitialized", "ServiceNotInitialized", "vmodl.RuntimeFault", "sms.version.version1", None)
> CreateDataType("sms.fault.SyncInProgress", "SyncInProgress", "sms.fault.ProviderSyncFailed", "sms.version.version1", None)
> CreateDataType("sms.fault.TooMany", "TooMany", "vmodl.MethodFault", "sms.version.version11", [("maxBatchSize", "long", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.fault.replication.ReplicationFault", "SmsReplicationFault", "vmodl.MethodFault", "sms.version.version11", None)
> CreateDataType("sms.fault.replication.SyncOngoing", "SyncOngoing", "sms.fault.replication.ReplicationFault", "sms.version.version11", [("task", "sms.Task", "sms.version.version11", 0)])
> CreateDataType("sms.provider.AlarmFilter", "AlarmFilter", "vmodl.DynamicData", "sms.version.version11", [("alarmStatus", "string", "sms.version.version11", F_OPTIONAL), ("alarmType", "string", "sms.version.version11", F_OPTIONAL), ("entityType", "string", "sms.version.version11", F_OPTIONAL), ("entityId", "anyType[]", "sms.version.version11", F_OPTIONAL), ("pageMarker", "string", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.provider.AlarmResult", "AlarmResult", "vmodl.DynamicData", "sms.version.version11", [("storageAlarm", "sms.storage.StorageAlarm[]", "sms.version.version11", F_OPTIONAL), ("pageMarker", "string", "sms.version.version11", F_OPTIONAL)])
> CreateManagedType("sms.provider.Provider", "SmsProvider", "vmodl.ManagedObject", "sms.version.version2", None, [("queryProviderInfo", "QueryProviderInfo", "sms.version.version2", (), (0, "sms.provider.ProviderInfo", "sms.provider.ProviderInfo"), "StorageViews.View", None)])
> CreateDataType("sms.provider.ProviderInfo", "SmsProviderInfo", "vmodl.DynamicData", "sms.version.version2", [("uid", "string", "sms.version.version2", 0), ("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", F_OPTIONAL), ("version", "string", "sms.version.version2", F_OPTIONAL)])
> CreateDataType("sms.provider.ProviderSpec", "SmsProviderSpec", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", F_OPTIONAL)])
> CreateManagedType("sms.provider.VasaProvider", "VasaProvider", "sms.provider.Provider", "sms.version.version2", None, [("sync", "VasaProviderSync_Task", "sms.version.version2", (("arrayId", "string", "sms.version.version2", F_OPTIONAL, None),), (0, "sms.Task", "void"), "StorageViews.View", ["sms.fault.ProviderSyncFailed", ]), ("refreshCertificate", "VasaProviderRefreshCertificate_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.CertificateRefreshFailed", ]), ("revokeCertificate", "VasaProviderRevokeCertificate_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.CertificateRevocationFailed", ]), ("reconnect", "VasaProviderReconnect_Task", "sms.version.version5", (), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.InvalidCertificate", "sms.fault.ProviderConnectionFailed", ]), ("queryReplicationPeer", "QueryReplicationPeer", "sms.version.version11", (("faultDomainId", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.QueryReplicationPeerResult[]", "sms.storage.replication.QueryReplicationPeerResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("queryReplicationGroup", "QueryReplicationGroup", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("queryPointInTimeReplica", "QueryPointInTimeReplica", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("queryParam", "sms.storage.replication.QueryPointInTimeReplicaParam", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.storage.replication.GroupOperationResult[]", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.View", ["sms.fault.ProviderUnavailable", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.QueryExecutionFault", ]), ("testFailoverReplicationGroupStart", "TestFailoverReplicationGroupStart_Task", "sms.version.version11", (("testFailoverParam", "sms.storage.replication.TestFailoverParam", "sms.version.version11", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("testFailoverReplicationGroupStop", "TestFailoverReplicationGroupStop_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("force", "boolean", "sms.version.version11", 0, None),), (0, "sms.Task", "void"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", "sms.fault.NotSupportedByProvider", ]), ("promoteReplicationGroup", "PromoteReplicationGroup_Task", "sms.version.version11", (("promoteParam", "sms.storage.replication.PromoteParam", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("syncReplicationGroup", "SyncReplicationGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),("pitName", "string", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", "sms.fault.TooMany", ]), ("prepareFailoverReplicationGroup", "PrepareFailoverReplicationGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("failoverReplicationGroup", "FailoverReplicationGroup_Task", "sms.version.version11", (("failoverParam", "sms.storage.replication.FailoverParam", "sms.version.version11", 0, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("reverseReplicateGroup", "ReverseReplicateGroup_Task", "sms.version.version11", (("groupId", "vim.vm.replication.ReplicationGroupId[]", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.Task", "sms.storage.replication.GroupOperationResult[]"), "StorageViews.ConfigureService", ["sms.fault.ProviderUnavailable", "sms.fault.ProviderOutOfResource", "sms.fault.InactiveProvider", "sms.fault.TooMany", "sms.fault.ProviderBusy", "sms.fault.replication.ReplicationFault", ]), ("queryActiveAlarm", "QueryActiveAlarm", "sms.version.version11", (("alarmFilter", "sms.provider.AlarmFilter", "sms.version.version11", F_OPTIONAL, None),), (F_OPTIONAL, "sms.provider.AlarmResult", "sms.provider.AlarmResult"), "StorageViews.View", ["vim.fault.NotFound", "sms.fault.ProviderBusy", "sms.fault.InactiveProvider", "sms.fault.ProviderUnavailable", "sms.fault.QueryExecutionFault", ])])
> CreateDataType("sms.provider.VasaProviderInfo", "VasaProviderInfo", "sms.provider.ProviderInfo", "sms.version.version2", [("url", "string", "sms.version.version2", 0), ("certificate", "string", "sms.version.version2", F_OPTIONAL), ("status", "string", "sms.version.version2", F_OPTIONAL), ("statusFault", "vmodl.MethodFault", "sms.version.version11", F_OPTIONAL), ("vasaVersion", "string", "sms.version.version2", F_OPTIONAL), ("namespace", "string", "sms.version.version2", F_OPTIONAL), ("lastSyncTime", "string", "sms.version.version2", F_OPTIONAL), ("supportedVendorModelMapping", "sms.provider.VasaProviderInfo.SupportedVendorModelMapping[]", "sms.version.version2", F_OPTIONAL), ("supportedProfile", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedProviderProfile", "string[]", "sms.version.version4", F_OPTIONAL), ("relatedStorageArray", "sms.provider.VasaProviderInfo.RelatedStorageArray[]", "sms.version.version4", F_OPTIONAL), ("providerId", "string", "sms.version.version4", F_OPTIONAL), ("certificateExpiryDate", "string", "sms.version.version5", F_OPTIONAL), ("certificateStatus", "string", "sms.version.version5", F_OPTIONAL), ("serviceLocation", "string", "sms.version.version5", F_OPTIONAL), ("needsExplicitActivation", "boolean", "sms.version.version5", F_OPTIONAL), ("maxBatchSize", "long", "sms.version.version11", F_OPTIONAL), ("retainVasaProviderCertificate", "boolean", "sms.version.version5", F_OPTIONAL), ("arrayIndependentProvider", "boolean", "sms.version.version11", F_OPTIONAL), ("type", "string", "sms.version.version11", F_OPTIONAL), ("category", "string", "sms.version.version12", F_OPTIONAL), ("priority", "int", "sms.version.version11", F_OPTIONAL), ("failoverGroupId", "string", "sms.version.version11", F_OPTIONAL)])
> CreateEnumType("sms.provider.VasaProviderInfo.CertificateStatus", "VasaProviderCertificateStatus", "sms.version.version5", ["valid", "expirySoftLimitReached", "expiryHardLimitReached", "expired", "invalid"])
> CreateDataType("sms.provider.VasaProviderInfo.RelatedStorageArray", "RelatedStorageArray", "vmodl.DynamicData", "sms.version.version4", [("arrayId", "string", "sms.version.version4", 0), ("active", "boolean", "sms.version.version4", 0), ("manageable", "boolean", "sms.version.version4", 0), ("priority", "int", "sms.version.version4", 0)])
> CreateDataType("sms.provider.VasaProviderInfo.SupportedVendorModelMapping", "SupportedVendorModelMapping", "vmodl.DynamicData", "sms.version.version1", [("vendorId", "string", "sms.version.version1", F_OPTIONAL), ("modelId", "string", "sms.version.version1", F_OPTIONAL)])
> CreateEnumType("sms.provider.VasaProviderInfo.VasaProviderStatus", "VasaProviderStatus", "sms.version.version1", ["online", "offline", "syncError", "unknown", "connected", "disconnected"])
> CreateEnumType("sms.provider.VasaProviderInfo.VasaProviderProfile", "VasaProviderProfile", "sms.version.version1", ["blockDevice", "fileSystem", "capability"])
> CreateEnumType("sms.provider.VasaProviderInfo.ProviderProfile", "ProviderProfile", "sms.version.version11", ["ProfileBasedManagement", "Replication"])
> CreateEnumType("sms.provider.VasaProviderInfo.Type", "VpType", "sms.version.version11", ["PERSISTENCE", "DATASERVICE", "UNKNOWN"])
> CreateEnumType("sms.provider.VasaProviderInfo.Category", "VpCategory", "sms.version.version12", ["internal", "external"])
> CreateDataType("sms.provider.VasaProviderSpec", "VasaProviderSpec", "sms.provider.ProviderSpec", "sms.version.version2", [("username", "string", "sms.version.version2", 0), ("password", "string", "sms.version.version2", F_SECRET), ("url", "string", "sms.version.version2", 0), ("certificate", "string", "sms.version.version2", F_OPTIONAL)])
> CreateEnumType("sms.provider.VmodlVasaProviderSpec.AuthenticationType", "VasaAuthenticationType", "sms.version.version12", ["LoginByToken", "UseSessionId"])
> CreateEnumType("sms.storage.AlarmStatus", "SmsAlarmStatus", "sms.version.version11", ["Red", "Green", "Yellow"])
> CreateEnumType("sms.storage.AlarmType", "AlarmType", "sms.version.version11", ["SpaceCapacityAlarm", "CapabilityAlarm", "StorageObjectAlarm", "ObjectAlarm", "ComplianceAlarm", "ManageabilityAlarm", "ReplicationAlarm"])
> CreateDataType("sms.storage.BackingConfig", "BackingConfig", "vmodl.DynamicData", "sms.version.version5", [("thinProvisionBackingIdentifier", "string", "sms.version.version5", F_OPTIONAL), ("deduplicationBackingIdentifier", "string", "sms.version.version5", F_OPTIONAL), ("autoTieringEnabled", "boolean", "sms.version.version5", F_OPTIONAL), ("deduplicationEfficiency", "long", "sms.version.version5", F_OPTIONAL), ("performanceOptimizationInterval", "long", "sms.version.version5", F_OPTIONAL)])
> CreateDataType("sms.storage.BackingStoragePool", "BackingStoragePool", "vmodl.DynamicData", "sms.version.version5", [("uuid", "string", "sms.version.version5", 0), ("type", "string", "sms.version.version5", 0), ("capacityInMB", "long", "sms.version.version5", 0), ("usedSpaceInMB", "long", "sms.version.version5", 0)])
> CreateEnumType("sms.storage.BackingStoragePool.BackingStoragePoolType", "BackingStoragePoolType", "sms.version.version1", ["thinProvisioningPool", "deduplicationPool", "thinAndDeduplicationCombinedPool"])
> CreateDataType("sms.storage.DatastoreBackingPoolMapping", "DatastoreBackingPoolMapping", "vmodl.DynamicData", "sms.version.version5", [("datastore", "vim.Datastore[]", "sms.version.version5", 0), ("backingStoragePool", "sms.storage.BackingStoragePool[]", "sms.version.version5", F_OPTIONAL)])
> CreateDataType("sms.storage.DatastorePair", "DatastorePair", "vmodl.DynamicData", "sms.version.version3", [("datastore1", "vim.Datastore", "sms.version.version3", 0), ("datastore2", "vim.Datastore", "sms.version.version3", 0)])
> CreateDataType("sms.storage.DrsMigrationCapabilityResult", "DrsMigrationCapabilityResult", "vmodl.DynamicData", "sms.version.version3", [("recommendedDatastorePair", "sms.storage.DatastorePair[]", "sms.version.version3", F_OPTIONAL), ("nonRecommendedDatastorePair", "sms.storage.DatastorePair[]", "sms.version.version3", F_OPTIONAL)])
> CreateEnumType("sms.storage.EntityType", "SmsEntityType", "sms.version.version11", ["StorageArrayEntity", "StorageProcessorEntity", "StoragePortEntity", "StorageLunEntity", "StorageFileSystemEntity", "StorageCapabilityEntity", "CapabilitySchemaEntity", "CapabilityProfileEntity", "DefaultProfileEntity", "ResourceAssociationEntity", "StorageContainerEntity", "StorageObjectEntity", "MessageCatalogEntity", "ProtocolEndpointEntity", "VirtualVolumeInfoEntity", "BackingStoragePoolEntity", "FaultDomainEntity", "ReplicationGroupEntity"])
> CreateDataType("sms.storage.FaultDomainProviderMapping", "FaultDomainProviderMapping", "vmodl.DynamicData", "sms.version.version11", [("activeProvider", "sms.provider.Provider", "sms.version.version11", 0), ("faultDomainId", "vim.vm.replication.FaultDomainId[]", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.storage.FileSystemInfo", "StorageFileSystemInfo", "vmodl.DynamicData", "sms.version.version2", [("fileServerName", "string", "sms.version.version2", 0), ("fileSystemPath", "string", "sms.version.version2", 0), ("ipAddress", "string", "sms.version.version2", F_OPTIONAL)])
> CreateDataType("sms.storage.LunHbaAssociation", "LunHbaAssociation", "vmodl.DynamicData", "sms.version.version2", [("canonicalName", "string", "sms.version.version2", 0), ("hba", "vim.host.HostBusAdapter[]", "sms.version.version2", 0)])
> CreateDataType("sms.storage.NameValuePair", "NameValuePair", "vmodl.DynamicData", "sms.version.version11", [("parameterName", "string", "sms.version.version11", 0), ("parameterValue", "string", "sms.version.version11", 0)])
> CreateDataType("sms.storage.StorageAlarm", "StorageAlarm", "vmodl.DynamicData", "sms.version.version11", [("alarmId", "long", "sms.version.version11", 0), ("alarmType", "string", "sms.version.version11", 0), ("containerId", "string", "sms.version.version11", F_OPTIONAL), ("objectId", "string", "sms.version.version11", F_OPTIONAL), ("objectType", "string", "sms.version.version11", 0), ("status", "string", "sms.version.version11", 0), ("alarmTimeStamp", "vmodl.DateTime", "sms.version.version11", 0), ("messageId", "string", "sms.version.version11", 0), ("parameterList", "sms.storage.NameValuePair[]", "sms.version.version11", F_OPTIONAL), ("alarmObject", "anyType", "sms.version.version11", F_OPTIONAL)])
> CreateDataType("sms.storage.StorageArray", "StorageArray", "vmodl.DynamicData", "sms.version.version2", [("name", "string", "sms.version.version2", 0), ("uuid", "string", "sms.version.version2", 0), ("vendorId", "string", "sms.version.version2", 0), ("modelId", "string", "sms.version.version2", 0), ("firmware", "string", "sms.version.version2", F_OPTIONAL), ("alternateName", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedBlockInterface", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedFileSystemInterface", "string[]", "sms.version.version2", F_OPTIONAL), ("supportedProfile", "string[]", "sms.version.version3", F_OPTIONAL), ("priority", "int", "sms.version.version4", F_OPTIONAL)])
> CreateEnumType("sms.storage.StorageArray.BlockDeviceInterface", "BlockDeviceInterface", "sms.version.version1", ["fc", "iscsi", "fcoe", "otherBlock"])
> CreateEnumType("sms.storage.StorageArray.FileSystemInterface", "FileSystemInterface", "sms.version.version1", ["nfs", "otherFileSystem"])
> CreateEnumType("sms.storage.StorageArray.VasaProfile", "VasaProfile", "sms.version.version3", ["blockDevice", "fileSystem", "capability", "policy", "object", "statistics", "storageDrsBlockDevice", "storageDrsFileSystem"])
> CreateDataType("sms.storage.StorageCapability", "StorageCapability", "vmodl.DynamicData", "sms.version.version2", [("uuid", "string", "sms.version.version2", 0), ("name", "string", "sms.version.version2", 0), ("description", "string", "sms.version.version2", 0)])
> CreateDataType("sms.storage.StorageContainer", "StorageContainer", "vmodl.DynamicData", "sms.version.version5", [("uuid", "string", "sms.version.version5", 0), ("name", "string", "sms.version.version5", 0), ("maxVvolSizeInMB", "long", "sms.version.version5", 0), ("providerId", 